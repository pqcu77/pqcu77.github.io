<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AI-Lab5</title>
    <link href="/2025/04/29/AI-lab5/"/>
    <url>/2025/04/29/AI-lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="理论内容回顾"><a href="#理论内容回顾" class="headerlink" title="理论内容回顾"></a>理论内容回顾</h1><h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><h3 id="重安装conda（虽然与pytorch没什么大关系）"><a href="#重安装conda（虽然与pytorch没什么大关系）" class="headerlink" title="重安装conda（虽然与pytorch没什么大关系）"></a>重安装conda（虽然与pytorch没什么大关系）</h3><p>由于我将ai实验移动到ubuntu里来做，所以我重新在这里安装一下conda。（先使用miniconda了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>安装完如果发现重启了终端也无法查找到 <code>conda --version</code> ，那么就输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 运行安装脚本（注意用 root 权限）</span><br>bash Miniconda3-latest-Linux-x86_64.sh<br><br><span class="hljs-comment"># 2. 安装过程中注意以下选项：</span><br><span class="hljs-comment">#    - 按回车阅读协议，输入 `yes` 同意。</span><br><span class="hljs-comment">#    - 安装路径默认是 `/root/miniconda3`（root 用户）或 `~/miniconda3`（普通用户），直接回车即可。</span><br><span class="hljs-comment">#    - 提示 `Do you wish the installer to initialize Miniconda3?` 时，必须输入 `yes`（否则需手动配置 PATH）。</span><br></code></pre></td></tr></table></figure><p>然后再重启终端，发现可以查看到版本号了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base) root@PQCU:~/2025AI# conda --version<br>conda 25.1.1<br></code></pre></td></tr></table></figure><p>配置一下清华镜像源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br>conda config --<span class="hljs-built_in">set</span> show_channel_urls <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h4 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h4><p><strong>1. 环境管理</strong></p><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda create --name myenv python=3.9</code></td><td>创建名为 <code>myenv</code> 的 Python 3.9 环境</td></tr><tr><td><code>conda activate myenv</code></td><td>激活 <code>myenv</code> 环境</td></tr><tr><td><code>conda deactivate</code></td><td>退出当前环境</td></tr><tr><td><code>conda env list</code></td><td>列出所有环境</td></tr><tr><td><code>conda remove --name myenv --all</code></td><td>删除 <code>myenv</code> 环境</td></tr><tr><td><code>conda env export &gt; environment.yml</code></td><td>导出当前环境配置到 YAML 文件</td></tr><tr><td><code>conda env create -f environment.yml</code></td><td>从 YAML 文件创建环境</td></tr></tbody></table><p><strong>2. 包管理</strong></p><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda install numpy</code></td><td>安装包（如 <code>numpy</code>）</td></tr><tr><td><code>conda install -c conda-forge package_name</code></td><td>从 <code>conda-forge</code> 渠道安装包</td></tr><tr><td><code>conda list</code></td><td>列出当前环境所有已安装包</td></tr><tr><td><code>conda search numpy</code></td><td>搜索包（查看可用版本）</td></tr><tr><td><code>conda update numpy</code></td><td>更新指定包</td></tr><tr><td><code>conda remove numpy</code></td><td>卸载包</td></tr><tr><td><code>conda update --all</code></td><td>更新所有包</td></tr></tbody></table><p><strong>3. Conda 自身管理</strong></p><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda --version</code></td><td>查看 Conda 版本</td></tr><tr><td><code>conda update conda</code></td><td>更新 Conda 到最新版本</td></tr><tr><td><code>conda clean --all</code></td><td>清理缓存（减少占用空间）</td></tr></tbody></table><ol start="4"><li><strong>查看&#x2F;修改配置</strong></li></ol><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda config --show</code></td><td>查看当前配置</td></tr><tr><td><code>conda config --remove-key channels</code></td><td>恢复默认镜像源</td></tr><tr><td><code>conda config --set auto_activate_base false</code></td><td>禁止自动激活 <code>base</code> 环境</td></tr></tbody></table><h3 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a>pytorch安装</h3><p>直接去官网<a href="https://pytorch.org/get-started/locally/">Start Locally | PyTorch官网</a>找到对应的版本号，然后复制命令安装即可。由于本人的电脑没有GPU，所有下载CPU版本。</p><p>linux+CPU：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu<br></code></pre></td></tr></table></figure><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>英文版：<br><a href="https://pytorch.org/docs/stable/index.html">PyTorch documentation — PyTorch 2.7 documentation</a><br>中文版：<br><a href="https://pytorch.ac.cn/docs/stable/index.html">PyTorch 文档 — PyTorch 2.7 文档 - PyTorch 深度学习库</a><br><a href="https://pytorch-cn.readthedocs.io/zh/latest/">主页 - PyTorch中文文档</a></p><h3 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h3><ul><li>pytorch的基本数据类型，在使用torch框架进行操作时，对象一般都是要求是tensor类型</li></ul><p>初始化tensor</p><ul><li><p>直接初始化<br><img src="/img/file-20250429151116933.png"><br><img src="/img/file-20250429151131189.png"></p></li><li><p>通过原始数据转化<br><img src="/img/file-20250429151256138.png"><br><img src="/img/file-20250429151235438.png"></p></li><li><p>通过numpy数据转化<br><img src="/img/file-20250429151441026.png"><br><img src="/img/file-20250429151456910.png"></p></li><li><p>也可以通过<code>torch.zeros()</code>，<code>torch.ones()</code>等创建指定大小的全0或全1张量<br><img src="/img/file-20250429152224887.png"><br><img src="/img/file-20250429152233048.png"></p></li><li><p>初始化未指定数据类型时，tensor会根据数据本身的类型自行判断</p></li></ul><p>梯度计算：</p><ul><li><code>requires_grad=True</code> –pytorch会追踪该张量的所有计算（自动微分），以便后续进行反向传播计算梯度</li></ul><p>维度变换：</p><ul><li><code>torch.view()</code>或者<code>torch.reshape()</code> 维度重置（但总数要一致），若根据已有维度可推算出剩下的维度，可使用 -1 替代<ul><li>用于<strong>改变张量的形状</strong>，但是总元素的数量必须保持不变。</li><li>可以使用 <code>-1</code> 自动计算某一维度的大小</li></ul></li></ul><table><thead><tr><th>方法</th><th>是否共享内存</th><th>是否适用于非连续内存</th><th>适用场景</th></tr></thead><tbody><tr><td><code>view()</code></td><td>✅ 是</td><td>❌ 只能在连续内存上使用</td><td>高效调整形状（不复制数据）</td></tr><tr><td><code>reshape()</code></td><td>✅ 是（如果可能）</td><td>✅ 可以处理非连续内存</td><td>更通用，但可能触发数据复制</td></tr></tbody></table><ul><li><code>torch.reshape()</code>也可以重置维度<ul><li><strong>压缩（删除）大小为 1 的维度</strong>。</li><li>如果不指定 <code>dim</code>，则<strong>删除所有大小为 1 的维度</strong>。</li><li>如果指定 <code>dim</code>，则<strong>只压缩该维度</strong>（<strong>该维度必须为 1</strong>，否则报错）。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># shape: [1, 3, 1, 2]</span><br><br><span class="hljs-comment"># 不指定 dim，删除所有大小为 1 的维度</span><br>x_squeeze = x.squeeze()  <span class="hljs-comment"># shape: [3, 2]</span><br><span class="hljs-built_in">print</span>(x_squeeze.shape)  <span class="hljs-comment"># torch.Size([3, 2])</span><br><br><span class="hljs-comment"># 指定 dim=2（第3个维度，从0开始计数）</span><br>x_squeeze_dim = x.squeeze(dim=<span class="hljs-number">2</span>)  <span class="hljs-comment"># shape: [1, 3, 2]</span><br><span class="hljs-built_in">print</span>(x_squeeze_dim.shape)  <span class="hljs-comment"># torch.Size([1, 3, 2])</span><br><br><span class="hljs-comment"># 如果 dim 不是 1，会报错</span><br>x.squeeze(dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 报错，因为 dim=1 的大小是 3，不是 1</span><br></code></pre></td></tr></table></figure><ul><li>torch.squeeze(dim) 若不指定维度，则会将tensor中为1的dim压缩，若指定只会压缩对应的维度</li><li>torch.unsqueeze(dim) 维度扩展<ul><li><strong>在指定位置插入一个大小为 1 的维度</strong>（与 <code>squeeze</code> 相反）。</li><li>常用于<strong>扩展维度</strong>，以适应某些操作（如矩阵乘法、卷积等）。</li></ul></li><li><code>torch.cat(List[tensor,tensor],dim)</code> 向量拼接，需要指定维度<ul><li>输入一个张量列表</li><li>dim指定沿哪个维度拼接</li><li>非拼接维度的形状必须相同，否则会报错</li><li>如果 <code>dim=0</code>（行拼接），则<strong>其他维度（如列数）必须相同</strong>。</li><li>如果 <code>dim=1</code>（列拼接），则<strong>行数必须相同</strong>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 创建两个张量</span><br>x = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])  <span class="hljs-comment"># shape: [2, 2]</span><br>y = torch.tensor([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])  <span class="hljs-comment"># shape: [2, 2]</span><br><br><span class="hljs-comment"># 沿第0维（行方向）拼接</span><br>z0 = torch.cat([x, y], dim=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(z0)<br><span class="hljs-comment"># tensor([[1, 2],</span><br><span class="hljs-comment">#         [3, 4],</span><br><span class="hljs-comment">#         [5, 6],</span><br><span class="hljs-comment">#         [7, 8]])  # shape: [4, 2]</span><br><br><span class="hljs-comment"># 沿第1维（列方向）拼接</span><br>z1 = torch.cat([x, y], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(z1)<br><span class="hljs-comment"># tensor([[1, 2, 5, 6],</span><br><span class="hljs-comment">#         [3, 4, 7, 8]])  # shape: [2, 4]</span><br></code></pre></td></tr></table></figure><h3 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h3><p>自定义神经网络类的基本框架：继承 nn.Module 神经网络基本类，该类实例化后输入数据将<strong>自动调用 forward 前向计算</strong></p><p>。有点没看懂。<br><img src="/img/file-20250429161016822.png"></p><p><img src="/img/file-20250429161107780.png"></p><h3 id="网络训练一般步骤"><a href="#网络训练一般步骤" class="headerlink" title="网络训练一般步骤"></a>网络训练一般步骤</h3><p>实例化网络 net &#x3D; Net() 后，<strong>定义网络优化器</strong></p><ul><li>optim &#x3D; nn.optim.Adam(net.parameters(), lr&#x3D;lr)<br>计算得到 Loss，</li><li>loss&#x3D;MSE(a,b)<br>在更新前，需清除上一步的梯度，即</li><li>optim.zero_grad()<br>然后 Loss 反向传播：</li><li>loss.backward()<br>最后优化器更新：</li><li>optim.step()</li></ul><h2 id="CNN网络训练实例"><a href="#CNN网络训练实例" class="headerlink" title="CNN网络训练实例"></a>CNN网络训练实例</h2><p>手写数字识别作为样例<br>1.读入训练集和测试集中的数字图片信息以及对图片预处理<br>2.用pytorch搭建神经网络（包括卷积和全连接神经网络）<br>3.将一个batch的训练集中的图片输入至神经网络，得到所有数字的预测分类概率（总共10个数字,0123456789）</p><p>4.根据真实标签和预测标签，利用交叉熵损失函数计算loss值，并进行梯度下降<br>5.根据测试集计算准确率，如果准确率没收敛，跳转回步骤3<br>6.画出loss、测试集准确率的曲线图<br>参考视频：<a href="https://www.bilibili.com/video/BV1Vx411j7kT?p=19">https://www.bilibili.com/video/BV1Vx411j7kT?p=19</a><br>参考代码：<a href="https://github.com/MorvanZhou/PyTorchTutorial/blob/master/tutorial%02contents/401_CNN.py">https://github.com/MorvanZhou/PyTorchTutorial/blob/master/tutorialcontents/401_CNN.py</a></p><h2 id="CNN卷积网络卷了什么？"><a href="#CNN卷积网络卷了什么？" class="headerlink" title="CNN卷积网络卷了什么？"></a>CNN卷积网络卷了什么？</h2><p>我们之前就知道图片的表示形式是一大堆数字（0-255），如果是灰色图数值代表的是灰度，而如果是彩色图记录的就是RGB颜色，使用三维张量或者三个矩阵来记录。</p><ul><li>每一个矩阵可以称为图片的一个channel，用宽高深来描述。</li></ul><p>传统的神经网络会导致物体如果处在同一个图片的不同位置，就可能会识别为不同物体，但是卷积神经网络可以捕捉图像中的局部特征而不受位置的影响。（不变性）</p><h3 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h3><p>在信号与系统课程中我们与卷积打了不少交道<br>连续：$F(x) &#x3D; \int_{-\infty}^{\infty} f(\tau) g(x - \tau) d\tau$</p><p>在卷积神经网络中，卷积操作是将一个<strong>可移动的小窗口</strong>（<strong>滤波器&#x2F;卷积核</strong>）与图像进行逐元素相乘然后相加的操作。滤波器相当于一组固定的权重。</p><p>例如：将一个 <code>6*6</code> 的网格滤波成 <code>4*4</code> 的网格，保留下来的是特征<br>这里的卷积核是一个 <code>3*3</code> 的矩阵，通过将黄色部分和卷积核进行卷积得到一个值填入到特征矩阵中，进行特征提取。<br><img src="/img/file-20250502112212143.png"></p><p><img src="/img/file-20250502112326957.png"><br>这个时候发现了边缘的特征丢失了<br>使用 <code>padding</code> 扩充方式，将 <code>6*6</code>的像素图扩充成 <code>8*8</code> 的像素图（用0填充）<br><img src="/img/file-20250502112502760.png"></p><p>因此在设置卷积神经网络时，我们需要关注这些参数</p><ul><li>步长stride：每次滑动的位置步长（也就是小窗口移动的距离）</li><li>卷积核的个数：决定输出的depth厚度</li><li>填充值zero-padding：在外围边缘用0填充（要使得总长能被步长整除）</li></ul><p>动图：<br><a href="https://i-blog.csdnimg.cn/blog_migrate/d0172774f7e42ae2f6310b63e59b4906.gif">https://i-blog.csdnimg.cn/blog_migrate/d0172774f7e42ae2f6310b63e59b4906.gif</a></p><p>卷积神经网络模型：<br><img src="/img/file-20250503095146360.png"><br>红色部分可以看做一个滤波器，多个滤波器叠加就成了卷积层</p><p>最大池化：（max pooling）<br>将图片特征进一步压缩，仅反映最突出的特点，也就是将图像切割成如图多个 <code>2*2</code> 的网格，取出每个小矩阵中最大的值。<br>池化后的数据保留了原始图片中最精华的特征<br><img src="/img/file-20250503095522607.png"></p><p>扁平化处理：<br><img src="/img/file-20250503095700734.png"><br>把池化后的数据进行扁平化处理：将两个 <code>3*3</code> 的像素图叠加转换为1维的数据条。<br>数据条作为输入，连接到全连接隐藏层，最终产生输出结果。（感觉做完转换后，得到的扁平化信息到最终输出结果就和MLP很类似了）</p><p><img src="/img/file-20250503095800527.png"></p><p>如果想进一步理解复杂的cnn模型：<a href="https://plantdraw2.samlab.cn/">CNN Explainer</a></p><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><h3 id="中药图片分类任务"><a href="#中药图片分类任务" class="headerlink" title="中药图片分类任务"></a>中药图片分类任务</h3><p>利用pytorch框架搭建神经网络实现中药图片分类，其中中药图片数据分为训练集 <code>train</code>和测试集 <code>test</code>，训练集仅用于网络训练阶段，测试集仅用于模型的性能测试阶段。训练集和测试集均包含五种不同类型的中药图片：<code>baihe</code>、<code>dangshen</code>、<code>gouqi</code>、<code>huaihua</code>、<code>jinyinhua</code>。请合理设计神经网络架构，利用训练集完成网络训练，统计网络模型的训练准确率和测试准确率，画出模型的训练过程的loss曲线、准确率曲线。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ol><li>最后提交的代码只需包含性能最好的实现方法和参数设置. 只需提交一个代码文件, 请不要提交其他文件.</li><li>本次作业可以使用 <code>pytorch</code>库、 <code>numpy</code>库、<code>matplotlib</code>库以及python标准库.</li><li>数据集可以在Github上下载。</li><li>模型的训练性能以及测试性能均作为本次作业的评分标准。</li><li>测试集不可用于模型训练。</li><li>不能使用开源的预训练模型进行训练。</li></ol><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>我们看到训练集和测试集都是彩色图，所以我们要采用三通道卷积的方式来表示。<br><img src="/img/file-20250503101420291.png"><br>也就是分别卷积后再相加得到结果。</p><p>n通道的卷积过程：<br><img src="/img/file-20250503101455202.png"><br>或<br><img src="/img/file-20250503101534982.png"><br>卷积层：</p><ul><li><p><strong><code>nn.Conv1d</code></strong></p><ul><li>输入：<code>(batch_size, channels, length)</code></li><li>处理<strong>一维序列数据</strong>（如时间序列、文本词向量）       </li><li>例：音频波形、传感器数据、自然语言处理中的词嵌入序列。</li></ul></li><li><p><strong><code>nn.Conv2d</code></strong>    </p><ul><li>输入：<code>(batch_size, channels, height, width)</code></li><li>处理<strong>二维网格数据</strong>（如图像）。        </li><li>例：RGB图像、二维频谱图。</li></ul></li><li><p><strong><code>nn.Conv3d</code></strong></p><ul><li>输入：<code>(batch_size, channels, depth, height, width)</code>     </li><li>处理<strong>三维体数据</strong>（如视频或医学扫描图像）。      </li><li>例：视频帧（时间+空间）、CT&#x2F;MRI扫描的3D体素数据。</li></ul></li><li><p><strong><code>Conv2d</code></strong>：</p><ul><li>卷积核沿<strong>2个方向（高度和宽度）滑动</strong>，输出二维特征图。    </li><li>卷积核尺寸：<code>(kernel_size, kernel_size)</code>（如<code>3x3</code>）。</li></ul></li></ul><table><thead><tr><th>卷积类型</th><th>适用场景示例</th></tr></thead><tbody><tr><td><code>Conv1d</code></td><td>文本分类（词序列）、语音识别（音频帧）、股票预测（时间序列）</td></tr><tr><td><code>Conv2d</code></td><td>图像分类、目标检测、风格迁移（2D图像处理）</td></tr><tr><td><code>Conv3d</code></td><td>视频动作识别、医学影像分析（3D体数据）</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>, dilation=<span class="hljs-number">1</span>, groups=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><ul><li><strong>in_channels</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a>) – 输入图像中的通道数</li><li><strong>out_channels</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a>) – 卷积产生的通道数</li><li><strong>kernel_size</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a>) – 卷积核的大小</li><li><strong>stride</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>可选的</em>) – 卷积的步长。默认值：1</li><li><strong>padding</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a><em>,</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>可选的</em>) – 输入四边添加的填充。默认值：0</li><li><strong>dilation</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>可选的</em>) – 内核元素之间的间距。默认值：1</li><li><strong>groups</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a><em>,</em> <em>可选的</em>) – 从输入通道到输出通道的组连接数。默认值：1</li><li><strong>bias</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#bool"><em>bool</em></a><em>,</em> <em>可选的</em>) – 如果为 <code>True</code>，则向输出添加一个可学习的偏置项。默认值：<code>True</code></li><li><strong>padding_mode</strong> (<a href="https://docs.pythonlang.cn/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>可选的</em>) – <code>&#39;zeros&#39;</code>, <code>&#39;reflect&#39;</code>, <code>&#39;replicate&#39;</code> 或 <code>&#39;circular&#39;</code>。默认值：<code>&#39;zeros&#39;</code></li></ul><p>池化层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.MaxPool2d(*kernel_size*, *stride=<span class="hljs-literal">None</span>*, *padding=<span class="hljs-number">0</span>*, *dilation=<span class="hljs-number">1</span>*, *return_indices=<span class="hljs-literal">False</span>*, *ceil_mode=<span class="hljs-literal">False</span>*)<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250503102731587.png"></p><p><img src="/img/file-20250503102916495.png"></p><p>进行测试后发现，不够稳定：<br><img src="/img/file-20250504112430590.png" alt="epoches&#x3D;15"></p><p><img src="/img/file-20250504112445890.png" alt="epoches&#x3D;30"></p><p><img src="/img/file-20250504112508914.png" alt="epoches&#x3D;100"></p><p><img src="/img/file-20250504112521791.png" alt="epoches&#x3D;500"><br><img src="/img/file-20250504112538716.png" alt="epoches&#x3D;1000"><br><img src="/img/file-20250504112551762.png" alt="epoches&#x3D;2000"><br>尝试添加归一化函数<code>nn.BatchNorm2d()</code>，并去掉了随机旋转和水平翻转（因为我观察到小规模测试集里的图片还是比较正的（））</p><ul><li>测试了一下50代，感觉效果一般<br><img src="/img/file-20250504113529656.png"></li></ul><p>又尝试在预处理数据部分添加了归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">transforms.Normalize(<br>            mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>]<br>        ),  <span class="hljs-comment"># 常用的参数</span><br></code></pre></td></tr></table></figure><p>发现在epoches&#x3D;50的情况下效果也好了很多，将进一步尝试更多代，寻找更加稳定的代数<br><img src="/img/file-20250504113749402.png" alt="epoches&#x3D;50"></p><p>资料：<br><a href="https://blog.csdn.net/AI_dataloads/article/details/133250229">【深度学习】一文搞懂卷积神经网络（CNN）的原理（超详细）_卷积神经网络原理-CSDN博客</a><br><a href="https://blog.csdn.net/m0_55697123/article/details/119464001">python标准库 —— os模块_python中os库的作用-CSDN博客</a><a href="https://pytorch.ac.cn/docs/stable/nn.html#convolution-layers">torch.nn — PyTorch 2.7 文档 - PyTorch 深度学习库</a></p><p><a href="https://zhuanlan.zhihu.com/p/163613814">python进度条库tqdm详解 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai新手赛部分题解</title>
    <link href="/2025/04/29/ai%E6%96%B0%E6%89%8B%E8%B5%9B%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/29/ai%E6%96%B0%E6%89%8B%E8%B5%9B%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>比赛结果：<br><img src="/img/file-20250429113148114.png"></p><p><img src="/img/d7c6ae3d320a570860ea2a249e091e3.jpg" alt="排行榜"></p><p><img src="/img/f5c32e6412ef17296b10162cf510e4d.jpg" alt="最后得分"></p><p><img src="/img/af1752655222fcb5c747d3799a11201.jpg" alt="奖品+奖状"></p><h1 id="NS-2025-00-须弥识花大赛-解题报告（Writeup）"><a href="#NS-2025-00-须弥识花大赛-解题报告（Writeup）" class="headerlink" title="NS-2025-00 须弥识花大赛 解题报告（Writeup）"></a>NS-2025-00 须弥识花大赛 解题报告（Writeup）</h1><h2 id="一、赛题理解与任务目标"><a href="#一、赛题理解与任务目标" class="headerlink" title="一、赛题理解与任务目标"></a>一、赛题理解与任务目标</h2><p>本次比赛模拟须弥地区的生态危机，任务目标是构建一个具备泛化能力的花卉识别 AI，能够在复杂环境下准确分类多种花卉种类。</p><p>从技术角度看，本题实质为一个 <strong>多类图像分类任务</strong>，即输入为一张图像，输出为其对应的花卉类别标签。该任务可归结为监督学习问题，挑战点在于：</p><ul><li>样本环境多变（雨天、晴天、被踩踏等）</li><li>类别较多且视觉相似度高</li><li>泛化能力要求高，需适应未知测试集</li></ul><h2 id="二、解题思路概述"><a href="#二、解题思路概述" class="headerlink" title="二、解题思路概述"></a>二、解题思路概述</h2><p>为应对复杂多变的测试图像环境，我们采用了如下整体策略：</p><ol><li><strong>数据增强 + 多模型集成</strong> 提升泛化能力；</li><li><strong>MixUp &#x2F; CutMix</strong> 等标签混合增强强化训练；</li><li><strong>使用预训练模型迁移学习</strong>，充分利用 ImageNet 语义特征；</li><li><strong>引入 Label Smoothing</strong> 缓解过拟合；</li><li><strong>测试时增强（TTA）</strong> 提高鲁棒性；</li><li><strong>早停机制</strong> 控制训练轮次防止过拟合。</li></ol><h2 id="三、模型设计与训练策略"><a href="#三、模型设计与训练策略" class="headerlink" title="三、模型设计与训练策略"></a>三、模型设计与训练策略</h2><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>我们构建了一个自定义的 <strong>多模型集成系统</strong>，结构如下：</p><table><thead><tr><th>序号</th><th>模型名称</th><th>预训练</th><th>修改输出层</th><th>Dropout</th></tr></thead><tbody><tr><td>1</td><td>ResNet50</td><td>✔️</td><td>Linear</td><td>0.5</td></tr><tr><td>2</td><td>EfficientNet-B0</td><td>✔️</td><td>Linear</td><td>0.3</td></tr><tr><td>3</td><td>MobileNetV3-Large</td><td>✔️</td><td>Linear</td><td>0.3</td></tr></tbody></table><blockquote><p>所有模型的输出通过“软投票”方式（概率平均）融合，提高整体鲁棒性。</p></blockquote><h3 id="数据增强策略"><a href="#数据增强策略" class="headerlink" title="数据增强策略"></a>数据增强策略</h3><ul><li><strong>训练集</strong>：使用多种图像变换组合（旋转、裁剪、亮度扰动、自动对比、灰度化、随机擦除）；</li><li><strong>标签增强</strong>：随机应用 MixUp（β&#x3D;0.2）或 CutMix（β&#x3D;1.0）进行样本合成；</li><li><strong>验证集&#x2F;测试集</strong>：保持中心裁剪 + 标准归一化，确保一致性。</li></ul><h3 id="损失函数与优化器"><a href="#损失函数与优化器" class="headerlink" title="损失函数与优化器"></a>损失函数与优化器</h3><ul><li>损失函数：使用 <strong>LabelSmoothingLoss</strong>（smoothing&#x3D;0.1）防止模型过拟合；</li><li>优化器：<strong>AdamW</strong> + <strong>OneCycleLR</strong> 学习率调度；</li><li>混合精度训练 + 梯度裁剪，提升效率并稳定训练过程。</li></ul><h3 id="训练控制机制"><a href="#训练控制机制" class="headerlink" title="训练控制机制"></a>训练控制机制</h3><ul><li>使用 <strong>早停机制</strong>（patience&#x3D;10）防止过拟合；</li><li>训练轮数：最多 30 epoch；</li><li>模型存储：保存最佳与最终模型权重，方便后续推理与对比。</li></ul><h2 id="四、模型预测与推理流程"><a href="#四、模型预测与推理流程" class="headerlink" title="四、模型预测与推理流程"></a>四、模型预测与推理流程</h2><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><p>我们定义了自动化加载 <code>model_info.json</code> + <code>*.pth</code> 权重的流程，自动判断使用集成 or 单模型结构。</p><h3 id="测试时增强（TTA）"><a href="#测试时增强（TTA）" class="headerlink" title="测试时增强（TTA）"></a>测试时增强（TTA）</h3><p>为了提高推理阶段的鲁棒性，对每张测试图像进行多种视图增强，具体包括：</p><ol><li>原始图像；</li><li>水平翻转；</li><li>垂直翻转；</li><li>尺寸裁剪；</li><li>亮度扰动。</li></ol><p>对上述增强图像进行推理后平均预测结果，提高模型的鲁棒性和准确性。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>最终输出为 <code>results.csv</code>，包含：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csv">file_name,label<br>123.jpg,7<br>...<br></code></pre></td></tr></table></figure><p>确保与比赛提交格式一致。</p><h2 id="五、性能评估与可视化"><a href="#五、性能评估与可视化" class="headerlink" title="五、性能评估与可视化"></a>五、性能评估与可视化</h2><p>训练阶段使用验证集进行模型性能评估，并生成：</p><ul><li>分类报告（classification_report.txt）；</li><li>混淆矩阵（confusion_matrix.png）；</li><li>训练曲线（training_history.png）；</li><li>预测可视化（model_predictions.png）。</li></ul><p>这些可视化图像有效支持模型诊断和调优。</p><h2 id="六、使用的工具与框架"><a href="#六、使用的工具与框架" class="headerlink" title="六、使用的工具与框架"></a>六、使用的工具与框架</h2><ul><li><strong>语言</strong>：Python 3.8+</li><li><strong>深度学习框架</strong>：PyTorch 1.13</li><li><strong>计算资源</strong>：NVIDIA GPU (CUDA 加速)</li><li><strong>辅助库</strong>：NumPy、Pandas、sklearn、Pillow、tqdm、seaborn、matplotlib、torchvision</li><li><strong>ai工具</strong>：copilot–claude3.7sonnet</li></ul><h2 id="七、总结与经验教训"><a href="#七、总结与经验教训" class="headerlink" title="七、总结与经验教训"></a>七、总结与经验教训</h2><ul><li>多模型融合是提升分类精度的重要手段；</li><li>数据增强和标签平滑有效提高泛化能力；</li><li>测试时增强进一步改善预测稳定性；</li><li>合理的训练控制策略（如早停和混合精度）提升了训练效率和最终性能。</li></ul><p>最终模型在验证集上表现稳定，预测准确率高，泛化能力强，能够较好适应测试集中复杂多变的花卉图像。效果良好，但达不到优秀，得分360。</p><h2 id="附录一：关键代码模块"><a href="#附录一：关键代码模块" class="headerlink" title="附录一：关键代码模块"></a>附录一：关键代码模块</h2><h3 id="模型构建（多模型集成）"><a href="#模型构建（多模型集成）" class="headerlink" title="模型构建（多模型集成）"></a>模型构建（多模型集成）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelEnsemble</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_classes, device, num_models=<span class="hljs-number">3</span>, model_types=<span class="hljs-literal">None</span>, use_pretrained=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-built_in">super</span>(ModelEnsemble, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.models = []<br>        <span class="hljs-variable language_">self</span>.device = device<br>        <span class="hljs-variable language_">self</span>.num_models = num_models<br>        ...<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_models):<br>            model_type = model_types[i % <span class="hljs-built_in">len</span>(model_types)]<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;resnet&#x27;</span> <span class="hljs-keyword">in</span> model_type:<br>                model = torchvision.models.resnet50(weights=pretrained_weights)<br>                num_ftrs = model.fc.in_features<br>                model.fc = nn.Sequential(nn.Dropout(<span class="hljs-number">0.5</span>), nn.Linear(num_ftrs, num_classes))<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;efficientnet&#x27;</span> <span class="hljs-keyword">in</span> model_type:<br>                model = torchvision.models.efficientnet_b0(weights=pretrained_weights)<br>                num_ftrs = model.classifier[<span class="hljs-number">1</span>].in_features<br>                model.classifier[<span class="hljs-number">1</span>] = nn.Sequential(nn.Dropout(<span class="hljs-number">0.3</span>), nn.Linear(num_ftrs, num_classes))<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;mobilenet&#x27;</span> <span class="hljs-keyword">in</span> model_type:<br>                model = torchvision.models.mobilenet_v3_large(weights=pretrained_weights)<br>                num_ftrs = model.classifier[<span class="hljs-number">3</span>].in_features<br>                model.classifier[<span class="hljs-number">3</span>] = nn.Sequential(nn.Dropout(<span class="hljs-number">0.3</span>), nn.Linear(num_ftrs, num_classes))<br>            <span class="hljs-variable language_">self</span>.models.append(model.to(device))<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        outputs = [model(x) <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.models]<br>        <span class="hljs-keyword">return</span> torch.mean(torch.stack(outputs), dim=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="标签混合增强（MixUp-CutMix）"><a href="#标签混合增强（MixUp-CutMix）" class="headerlink" title="标签混合增强（MixUp &amp; CutMix）"></a>标签混合增强（MixUp &amp; CutMix）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MixUp</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, alpha=<span class="hljs-number">0.2</span></span>): <span class="hljs-variable language_">self</span>.alpha = alpha<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, batch, targets</span>):<br>        lam = np.random.beta(<span class="hljs-variable language_">self</span>.alpha, <span class="hljs-variable language_">self</span>.alpha)<br>        index = torch.randperm(batch.size(<span class="hljs-number">0</span>)).to(batch.device)<br>        mixed_batch = lam * batch + (<span class="hljs-number">1</span> - lam) * batch[index]<br>        <span class="hljs-keyword">return</span> mixed_batch, targets, targets[index], lam<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CutMix</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, alpha=<span class="hljs-number">1.0</span></span>): <span class="hljs-variable language_">self</span>.alpha = alpha<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, batch, targets</span>):<br>        lam = np.random.beta(<span class="hljs-variable language_">self</span>.alpha, <span class="hljs-variable language_">self</span>.alpha)<br>        index = torch.randperm(batch.size(<span class="hljs-number">0</span>)).to(batch.device)<br>        bbx1, bby1, bbx2, bby2 = <span class="hljs-variable language_">self</span>._rand_bbox(batch.size(), lam)<br>        batch[:, :, bbx1:bbx2, bby1:bby2] = batch[index, :, bbx1:bbx2, bby1:bby2]<br>        lam = <span class="hljs-number">1</span> - ((bbx2 - bbx1) * (bby2 - bby1)) / (batch.size(-<span class="hljs-number">1</span>) * batch.size(-<span class="hljs-number">2</span>))<br>        <span class="hljs-keyword">return</span> batch, targets, targets[index], lam<br></code></pre></td></tr></table></figure><hr><h3 id="标签平滑损失函数"><a href="#标签平滑损失函数" class="headerlink" title="标签平滑损失函数"></a>标签平滑损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LabelSmoothingLoss</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, classes, smoothing=<span class="hljs-number">0.1</span></span>):<br>        <span class="hljs-built_in">super</span>(LabelSmoothingLoss, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.confidence = <span class="hljs-number">1.0</span> - smoothing<br>        <span class="hljs-variable language_">self</span>.smoothing = smoothing<br>        <span class="hljs-variable language_">self</span>.cls = classes<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, pred, target</span>):<br>        pred = pred.log_softmax(dim=-<span class="hljs-number">1</span>)<br>        true_dist = torch.zeros_like(pred)<br>        true_dist.fill_(<span class="hljs-variable language_">self</span>.smoothing / (<span class="hljs-variable language_">self</span>.cls - <span class="hljs-number">1</span>))<br>        true_dist.scatter_(<span class="hljs-number">1</span>, target.unsqueeze(<span class="hljs-number">1</span>), <span class="hljs-variable language_">self</span>.confidence)<br>        <span class="hljs-keyword">return</span> torch.mean(torch.<span class="hljs-built_in">sum</span>(-true_dist * pred, dim=-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><hr><h3 id="测试时增强（TTA）-1"><a href="#测试时增强（TTA）-1" class="headerlink" title="测试时增强（TTA）"></a>测试时增强（TTA）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_time_augmentation</span>(<span class="hljs-params">model, image, transform, device, num_augmentations=<span class="hljs-number">5</span></span>):<br>    model.<span class="hljs-built_in">eval</span>()<br>    predictions = []<br><br>    <span class="hljs-comment"># 原图预测</span><br>    image_tensor = transform(image).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(image_tensor))<br><br>    <span class="hljs-comment"># 水平翻转</span><br>    h_tensor = transform(transforms.functional.hflip(image)).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(h_tensor))<br><br>    <span class="hljs-comment"># 垂直翻转</span><br>    v_tensor = transform(transforms.functional.vflip(image)).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(v_tensor))<br><br>    <span class="hljs-comment"># 中心裁剪+亮度扰动</span><br>    jitter_transform = transforms.Compose([<br>        transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>),<br>        transform<br>    ])<br>    jitter_tensor = jitter_transform(image).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(jitter_tensor))<br><br>    <span class="hljs-comment"># 综合平均</span><br>    <span class="hljs-keyword">return</span> torch.mean(torch.stack(predictions), dim=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="NS-2025-07-LLM-to-BTs–Writeup"><a href="#NS-2025-07-LLM-to-BTs–Writeup" class="headerlink" title="NS-2025-07 LLM to BTs–Writeup"></a>NS-2025-07 LLM to BTs–Writeup</h1><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>本题要求实现一个将英文自然语言指令自动转换为行为树(Behavior Tree)结构化XML的系统。系统需要将用户文本指令转换为符合BehaviorTree.CPP库和Groot可视化工具要求的XML，并且以规定格式输出，包含119个使用CDATA包装的item元素。系统需要正确理解指令中的执行逻辑，并构建相应的行为树结构。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>针对不使用大语言模型的环境限制，我实现了一个基于规则和模式匹配的SimpleBehaviorTreeGenerator类。主要解题思路包括：</p><h3 id="1-数据分析与样例学习"><a href="#1-数据分析与样例学习" class="headerlink" title="1. 数据分析与样例学习"></a>1. 数据分析与样例学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_training_examples</span>(<span class="hljs-params">self, input_file, output_file, max_examples=<span class="hljs-number">20</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;加载训练示例用于参考&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        inputs = json.load(f)<br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        outputs = json.load(f)<br>        <br>    <span class="hljs-comment"># 选择示例（简单起见，取前N个）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(inputs[:max_examples], outputs[:max_examples]))<br></code></pre></td></tr></table></figure><p>通过载入训练样例，系统可以参考已有的指令-行为树对应关系，提高生成质量。为了节省内存，我只载入了前20个样例作为参考。</p><h3 id="2-基于相似度的模式匹配"><a href="#2-基于相似度的模式匹配" class="headerlink" title="2. 基于相似度的模式匹配"></a>2. 基于相似度的模式匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_similar_example</span>(<span class="hljs-params">self, instruction</span>):<br>    <span class="hljs-comment"># 提取指令中的关键词</span><br>    keywords = <span class="hljs-variable language_">self</span>.extract_keywords(instruction)<br>    <br>    best_match = <span class="hljs-literal">None</span><br>    best_score = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> ex_input, ex_output <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.train_examples:<br>        <span class="hljs-comment"># 计算关键词匹配度</span><br>        ex_keywords = <span class="hljs-variable language_">self</span>.extract_keywords(ex_input)<br>        common_keywords = <span class="hljs-built_in">set</span>(keywords) &amp; <span class="hljs-built_in">set</span>(ex_keywords)<br>        score = <span class="hljs-built_in">len</span>(common_keywords) / <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(keywords), <span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-keyword">if</span> score &gt; best_score <span class="hljs-keyword">and</span> score &gt; <span class="hljs-number">0.2</span>:  <span class="hljs-comment"># 至少20%的关键词匹配</span><br>            best_score = score<br>            best_match = (ex_input, ex_output)<br>    <br>    <span class="hljs-keyword">return</span> best_match<br></code></pre></td></tr></table></figure><p>系统会尝试在训练样例中找到与输入指令相似的例子，通过关键词匹配计算相似度，当相似度超过20%时，可以借鉴其行为树结构。</p><h3 id="3-规则化语义解析"><a href="#3-规则化语义解析" class="headerlink" title="3. 规则化语义解析"></a>3. 规则化语义解析</h3><p>为了从文本中提取动作和条件，我实现了多个关键函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_actions</span>(<span class="hljs-params">self, text</span>):<br>    <span class="hljs-comment"># 基于常见动词的简单提取</span><br>    action_list = []<br>    <br>    <span class="hljs-comment"># 常见动作动词</span><br>    action_verbs = [<span class="hljs-string">&quot;打开&quot;</span>, <span class="hljs-string">&quot;关闭&quot;</span>, <span class="hljs-string">&quot;移动&quot;</span>, <span class="hljs-string">&quot;走向&quot;</span>, <span class="hljs-string">&quot;前进&quot;</span>, <span class="hljs-string">&quot;后退&quot;</span>, <span class="hljs-string">&quot;转向&quot;</span>, <span class="hljs-string">&quot;拿起&quot;</span>, <span class="hljs-string">&quot;放下&quot;</span>,<br>                    <span class="hljs-string">&quot;检查&quot;</span>, <span class="hljs-string">&quot;观察&quot;</span>, <span class="hljs-string">&quot;寻找&quot;</span>, <span class="hljs-string">&quot;等待&quot;</span>, <span class="hljs-string">&quot;计算&quot;</span>, <span class="hljs-string">&quot;进入&quot;</span>, <span class="hljs-string">&quot;离开&quot;</span>, <span class="hljs-string">&quot;拿&quot;</span>, <span class="hljs-string">&quot;取&quot;</span>, <br>                    <span class="hljs-string">&quot;放置&quot;</span>, <span class="hljs-string">&quot;推&quot;</span>, <span class="hljs-string">&quot;拉&quot;</span>, <span class="hljs-string">&quot;跳&quot;</span>, <span class="hljs-string">&quot;握住&quot;</span>, <span class="hljs-string">&quot;松开&quot;</span>, <span class="hljs-string">&quot;启动&quot;</span>, <span class="hljs-string">&quot;停止&quot;</span>, <span class="hljs-string">&quot;跟随&quot;</span>,<br>                    <span class="hljs-string">&quot;测量&quot;</span>, <span class="hljs-string">&quot;抓取&quot;</span>, <span class="hljs-string">&quot;识别&quot;</span>, <span class="hljs-string">&quot;使用&quot;</span>, <span class="hljs-string">&quot;保存&quot;</span>, <span class="hljs-string">&quot;下载&quot;</span>, <span class="hljs-string">&quot;上传&quot;</span>, <span class="hljs-string">&quot;执行&quot;</span>, <span class="hljs-string">&quot;完成&quot;</span>]<br>    <br>    <span class="hljs-comment"># 分割文本</span><br>    parts = re.split(<span class="hljs-string">r&#x27;[,，。、；;]&#x27;</span>, text)<br>    <br>    <span class="hljs-comment"># 检查每个部分是否包含动作</span><br>    <span class="hljs-keyword">for</span> part <span class="hljs-keyword">in</span> parts:<br>        <span class="hljs-comment"># 省略实现细节...</span><br>        <br>    <span class="hljs-keyword">return</span> action_list<br></code></pre></td></tr></table></figure><p>虽然代码中包含了中文动词列表，但考虑到实际测试集全是英文，我在实际部署前对代码做了修改，补充了英文动词列表，如”move”、”go”、”turn”、”pick”等。</p><h3 id="4-控制结构判断"><a href="#4-控制结构判断" class="headerlink" title="4. 控制结构判断"></a>4. 控制结构判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">determine_control_structure</span>(<span class="hljs-params">self, text</span>):<br>    <span class="hljs-comment"># 默认使用顺序执行</span><br>    structure = <span class="hljs-string">&quot;Sequence&quot;</span><br>    <br>    <span class="hljs-comment"># 检查是否存在选择逻辑</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(keyword <span class="hljs-keyword">in</span> text <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;或者&quot;</span>, <span class="hljs-string">&quot;否则&quot;</span>, <span class="hljs-string">&quot;要么&quot;</span>, <span class="hljs-string">&quot;如果不&quot;</span>, <span class="hljs-string">&quot;失败后&quot;</span>, <span class="hljs-string">&quot;选择&quot;</span>]):<br>        structure = <span class="hljs-string">&quot;Fallback&quot;</span><br>    <br>    <span class="hljs-comment"># 检查是否存在并行逻辑</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(keyword <span class="hljs-keyword">in</span> text <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;同时&quot;</span>, <span class="hljs-string">&quot;并行&quot;</span>, <span class="hljs-string">&quot;一起&quot;</span>, <span class="hljs-string">&quot;并且&quot;</span>, <span class="hljs-string">&quot;一边&quot;</span>, <span class="hljs-string">&quot;同步&quot;</span>]):<br>        structure = <span class="hljs-string">&quot;Parallel&quot;</span><br>    <br>    <span class="hljs-comment"># 检查是否需要反应式</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(keyword <span class="hljs-keyword">in</span> text <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;持续检查&quot;</span>, <span class="hljs-string">&quot;保持&quot;</span>, <span class="hljs-string">&quot;反复&quot;</span>, <span class="hljs-string">&quot;一直&quot;</span>, <span class="hljs-string">&quot;直到&quot;</span>, <span class="hljs-string">&quot;监控&quot;</span>]):<br>        <span class="hljs-keyword">if</span> structure == <span class="hljs-string">&quot;Sequence&quot;</span>:<br>            structure = <span class="hljs-string">&quot;ReactiveSequence&quot;</span><br>        <span class="hljs-keyword">elif</span> structure == <span class="hljs-string">&quot;Fallback&quot;</span>:<br>            structure = <span class="hljs-string">&quot;ReactiveFallback&quot;</span><br>    <br>    <span class="hljs-keyword">return</span> structure<br></code></pre></td></tr></table></figure><p>同样，在实际部署前，我将关键词判断逻辑修改为英文版本，增加了”or”、”else”、”parallel”、”simultaneously”、”continuous”等关键词。</p><h3 id="5-XML树构建与验证"><a href="#5-XML树构建与验证" class="headerlink" title="5. XML树构建与验证"></a>5. XML树构建与验证</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_xml_tree</span>(<span class="hljs-params">self, actions, conditions, control_structure</span>):<br>    xml = <span class="hljs-string">f&#x27;&lt;root BTCPP_format=&quot;4&quot;&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">f&#x27;  &lt;BehaviorTree ID=&quot;MainTree&quot;&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">f&#x27;    &lt;<span class="hljs-subst">&#123;control_structure&#125;</span> name=&quot;Root<span class="hljs-subst">&#123;control_structure&#125;</span>&quot;&gt;\n&#x27;</span><br>    <br>    <span class="hljs-comment"># 添加条件节点</span><br>    <span class="hljs-keyword">for</span> condition <span class="hljs-keyword">in</span> conditions:<br>        xml += <span class="hljs-string">f&#x27;      &lt;Condition ID=&quot;<span class="hljs-subst">&#123;condition[<span class="hljs-string">&quot;ID&quot;</span>]&#125;</span>&quot; /&gt;\n&#x27;</span><br>    <br>    <span class="hljs-comment"># 添加动作节点</span><br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions:<br>        xml += <span class="hljs-string">f&#x27;      &lt;Action ID=&quot;<span class="hljs-subst">&#123;action[<span class="hljs-string">&quot;ID&quot;</span>]&#125;</span>&quot; /&gt;\n&#x27;</span><br>    <br>    xml += <span class="hljs-string">f&#x27;    &lt;/<span class="hljs-subst">&#123;control_structure&#125;</span>&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">f&#x27;  &lt;/BehaviorTree&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">&#x27;&lt;/root&gt;&#x27;</span><br>    <br>    <span class="hljs-keyword">return</span> xml<br></code></pre></td></tr></table></figure><p>这个函数构建了符合BehaviorTree.CPP格式的XML结构，通过validate_xml函数进行检查确保结构合法。</p><h3 id="6-CDATA标签处理"><a href="#6-CDATA标签处理" class="headerlink" title="6. CDATA标签处理"></a>6. CDATA标签处理</h3><p>最初遇到的主要技术困难是ElementTree库不直接支持CDATA标签。解决方案是使用minidom库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提取所有item节点并手动添加CDATA</span><br>item_nodes = items_node.getElementsByTagName(<span class="hljs-string">&quot;item&quot;</span>)<br><br><span class="hljs-keyword">for</span> item_node <span class="hljs-keyword">in</span> item_nodes:<br>    <span class="hljs-comment"># 获取文本内容</span><br>    text_content = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> item_node.childNodes:<br>        <span class="hljs-keyword">if</span> child.nodeType == minidom.Node.TEXT_NODE:<br>            text_content += child.data<br>    <br>    <span class="hljs-comment"># 清除所有子节点</span><br>    <span class="hljs-keyword">while</span> item_node.hasChildNodes():<br>        item_node.removeChild(item_node.firstChild)<br>    <br>    <span class="hljs-comment"># 创建新的CDATA节点</span><br>    cdata = reparsed.createCDATASection(text_content)<br>    item_node.appendChild(cdata)<br></code></pre></td></tr></table></figure><p>这段代码解决了将XML内容正确包装在CDATA标签中的问题，确保输出符合要求格式。</p><h2 id="实现中的关键技术难点与解决方案"><a href="#实现中的关键技术难点与解决方案" class="headerlink" title="实现中的关键技术难点与解决方案"></a>实现中的关键技术难点与解决方案</h2><h3 id="1-CDATA节点处理"><a href="#1-CDATA节点处理" class="headerlink" title="1. CDATA节点处理"></a>1. CDATA节点处理</h3><p><strong>问题</strong>: ElementTree库不直接支持创建CDATA节点，导致初始实现时出错。</p><p><strong>解决方案</strong>: 使用minidom库替代处理CDATA部分，通过createCDATASection方法创建CDATA节点，并手动替换原有文本节点。</p><h3 id="2-英文自然语言理解"><a href="#2-英文自然语言理解" class="headerlink" title="2. 英文自然语言理解"></a>2. 英文自然语言理解</h3><p><strong>问题</strong>: 代码初始设计时主要考虑了中文关键词，不适合全英文测试集。</p><p><strong>解决方案</strong>: 在实际部署前，修改了关键词列表，添加了英文动作动词和条件关键词，并调整了相关的正则表达式和文本处理逻辑。</p><h3 id="3-输出格式标准化"><a href="#3-输出格式标准化" class="headerlink" title="3. 输出格式标准化"></a>3. 输出格式标准化</h3><p><strong>问题</strong>: 需要确保生成119个item元素，即使测试输入可能少于这个数量。</p><p><strong>解决方案</strong>: 在process_test_set方法中强制处理119个项目，对于超出测试集范围的项目使用空字符串作为内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 确保处理119个项目</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">120</span>):<br>    <span class="hljs-comment"># 如果索引超出测试输入范围，使用空XML</span><br>    <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(test_inputs):<br>        instruction = test_inputs[i-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 生成行为树</span><br>        xml_output = <span class="hljs-variable language_">self</span>.generate_behavior_tree(instruction)<br>    <span class="hljs-keyword">else</span>:<br>        logger.info(<span class="hljs-string">f&quot;No instruction for item <span class="hljs-subst">&#123;i&#125;</span>, using empty XML&quot;</span>)<br>        xml_output = <span class="hljs-string">&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># 创建item元素...</span><br></code></pre></td></tr></table></figure><h2 id="使用的工具与依赖"><a href="#使用的工具与依赖" class="headerlink" title="使用的工具与依赖"></a>使用的工具与依赖</h2><ol><li><p><strong>Python 3.8+</strong>: 主要开发语言</p></li><li><p><strong>Standard Library</strong>:</p><ul><li>xml.etree.ElementTree: XML树操作</li><li>xml.dom.minidom: CDATA处理与XML格式化</li><li>re: 正则表达式用于文本分析</li><li>json: 读取训练和测试数据</li><li>logging: 日志记录和调试</li><li>argparse: 命令行参数解析</li><li>datetime: 性能监测</li></ul></li><li><p>ai工具：claude 3.7sonnet</p></li></ol><h2 id="关键算法分析"><a href="#关键算法分析" class="headerlink" title="关键算法分析"></a>关键算法分析</h2><h3 id="1-相似度计算算法"><a href="#1-相似度计算算法" class="headerlink" title="1. 相似度计算算法"></a>1. 相似度计算算法</h3><p>使用集合交集计算关键词匹配度，算法复杂度为O(len(keywords))，通过设置阈值0.2确保只使用足够相似的样例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">common_keywords = <span class="hljs-built_in">set</span>(keywords) &amp; <span class="hljs-built_in">set</span>(ex_keywords)<br>score = <span class="hljs-built_in">len</span>(common_keywords) / <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(keywords), <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="2-动作提取算法"><a href="#2-动作提取算法" class="headerlink" title="2. 动作提取算法"></a>2. 动作提取算法</h3><p>通过文本分割和动词匹配，识别可能的动作，复杂度为O(n*m)，其中n是文本片段数，m是动词列表长度。</p><h3 id="3-控制结构判断算法"><a href="#3-控制结构判断算法" class="headerlink" title="3. 控制结构判断算法"></a>3. 控制结构判断算法</h3><p>通过关键词匹配确定最合适的控制结构，采用优先级判断的方式处理多种可能性。</p><h2 id="实验结果与性能"><a href="#实验结果与性能" class="headerlink" title="实验结果与性能"></a>实验结果与性能</h2><p>在我的测试环境中，系统能够在几秒内处理完119个指令，转换效率较高。通过日志记录，分析了成功率和常见失败模式，不断调整关键词列表和规则逻辑，提高了整体处理质量。</p><p>由于没有使用大语言模型，系统在处理复杂语义和隐含逻辑时存在局限性，但对于结构化明确的指令有良好表现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我实现的SimpleBehaviorTreeGenerator系统通过<strong>规则匹配和模式识别</strong>，成功实现了英文自然语言指令到行为树XML的自动转换。系统不依赖大型语言模型，通过简单有效的文本处理技术和结构生成规则，提供了合理的转换质量。特别是通过样例学习和相似度匹配，结合精心设计的规则库，系统能够处理多种常见指令模式，生成符合BehaviorTree.CPP标准的行为树结构。</p><p>虽然相比大型语言模型，规则化方法在语义理解的深度上存在局限，但在计算资源受限的环境中，这种方法提供了一个高效且实用的解决方案。通过将CDATA处理、XML验证等关键技术融入系统，确保了输出格式的规范性和有效性。</p><h1 id="NS-2025-08-我搭的靶场-题解"><a href="#NS-2025-08-我搭的靶场-题解" class="headerlink" title="NS-2025-08 我搭的靶场 题解"></a>NS-2025-08 我搭的靶场 题解</h1><h2 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h2><p>本题要求我们设计一个二维障碍场景，用于测试强化学习无人机智能体 Alpha Pilot 的路径规划能力。我们需要布置起点、终点和最多30个圆形障碍物，目标是让智能体尽可能失败（高失败率、长路径），同时保证场景理论上可解。</p><p>关键约束条件：</p><ul><li>场地大小：50m × 50m</li><li>起点和终点距离至少20m</li><li>障碍物半径1m，障碍物间距≥3m</li><li>起点&#x2F;终点与障碍物距离≥2.5m</li><li>无人机半径0.5m，最大速度2m&#x2F;s</li></ul><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-分析智能体弱点"><a href="#1-分析智能体弱点" class="headerlink" title="1. 分析智能体弱点"></a>1. 分析智能体弱点</h3><p>通过研究<code>agent.py</code>代码，可以发现Alpha Pilot智能体有以下潜在弱点：</p><ul><li>使用Q-learning算法，可能对复杂环境泛化能力有限</li><li>感知范围有限（约15m）</li><li>在障碍物附近有<strong>负奖励</strong>，可能导致”<strong>畏惧</strong>“靠近障碍物</li><li>可能有<strong>方向偏好</strong>（如倾向于向右或向上移动）</li></ul><h3 id="2-设计策略性障碍布局"><a href="#2-设计策略性障碍布局" class="headerlink" title="2. 设计策略性障碍布局"></a>2. 设计策略性障碍布局</h3><p>基于上述分析，我们设计了几种针对性的障碍布局策略：</p><h4 id="a-误导性路径"><a href="#a-误导性路径" class="headerlink" title="a) 误导性路径"></a>a) 误导性路径</h4><ul><li>在起点和终点之间创建看似合理但实际是死胡同的路径</li><li>利用无人机对特定方向的偏好设置陷阱</li></ul><h4 id="b-感知边界障碍"><a href="#b-感知边界障碍" class="headerlink" title="b) 感知边界障碍"></a>b) 感知边界障碍</h4><ul><li>在无人机感知范围边界（约15m）布置障碍物</li><li>使无人机难以提前规划路径，容易陷入局部最优</li></ul><h4 id="c-狭窄通道"><a href="#c-狭窄通道" class="headerlink" title="c) 狭窄通道"></a>c) 狭窄通道</h4><ul><li>设计宽度刚好略大于无人机通过能力的通道（约3.5m）</li><li>利用无人机对靠近障碍物的负奖励，使其犹豫不决</li></ul><h4 id="d-迷宫结构"><a href="#d-迷宫结构" class="headerlink" title="d) 迷宫结构"></a>d) 迷宫结构</h4><ul><li>创建复杂的迷宫式布局</li><li>增加路径规划的复杂度，容易使智能体迷失方向</li></ul><h3 id="3-遗传算法优化"><a href="#3-遗传算法优化" class="headerlink" title="3. 遗传算法优化"></a>3. 遗传算法优化</h3><p>使用遗传算法自动优化环境设计：</p><ol><li><strong>初始化种群</strong>：随机生成多个满足约束的环境</li><li><strong>评估适应度</strong>：通过test_scoring.py评估每个环境的失败率和平均步数</li><li><strong>选择精英</strong>：保留表现最好的环境</li><li><strong>交叉变异</strong>：组合优秀环境的特征并引入随机变化</li><li><strong>迭代优化</strong>：重复上述过程直到收敛</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们通过编写一个随机生成合理有效路障地图并测试失败率的程序来自我迭代搜索出最佳路障地图，主要类<code>EnvironmentOptimizer</code>实现了上述思路：</p><ol><li><p><strong>环境生成</strong>：</p><ul><li><code>generate_random_environment</code>：创建随机但有效的基础环境</li><li>四种策略方法创建针对性障碍物</li></ul></li><li><p><strong>评估函数</strong>：</p><ul><li>调用<code>test_scoring.py</code>获取失败率和平均步数</li><li>计算综合得分（失败率×300 + min(平均步数&#x2F;50000, 0.9)×100）</li></ul></li><li><p><strong>遗传算法</strong>：</p><ul><li>种群初始化、选择、交叉、变异</li><li>保留精英个体确保不退化</li></ul></li><li><p><strong>约束检查</strong>：</p><ul><li>确保所有几何约束得到满足</li><li>验证环境可解性</li></ul></li></ol><h2 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h2><p>经过多代进化，算法能够找到使智能体高失败率的环境特征：</p><ul><li>在关键路径点设置”陷阱”区域</li><li>利用狭窄通道增加决策难度</li><li>在感知边界布置障碍物限制信息获取</li><li>保持理论可解性但实际很难通过</li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li><p>运行<code>python solution.py</code>开始优化过程</p></li><li><p>程序会自动保存最佳环境到<code>results.json</code></p></li><li><p>可使用<code>test_env.py</code>可视化结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python test_env.py results.json --test-agent<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>test_scoring.py</code>来进行评分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python test_scoring.py results.json <br></code></pre></td></tr></table></figure><ul><li>我们本地测试是可以实现让agent十次都失败，但是最终提交结果没有拿到400分满分，可能还是稍微有些许漏洞或者应该多提交几次（hh。（最终得分是：399.95）</li></ul></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过分析智能体弱点并针对性设计障碍布局，结合遗传算法自动优化，我们能够创建出理论上可解但实际上极具挑战性的测试环境。这种方法不仅适用于本题，也可推广到其他智能体测试场景的设计中。</p><p>最佳环境通常具有以下特征：</p><ul><li>起点和终点位于对角线位置（最大化距离）</li><li>25-30个精心布置的障碍物</li><li>结合多种策略的复合障碍布局</li><li>在关键路径点设置决策难点</li></ul><h2 id="使用工具与环境"><a href="#使用工具与环境" class="headerlink" title="使用工具与环境"></a>使用工具与环境</h2><ul><li>开发语言：Python 3.8</li><li>框架库：numpy，matplotlib（可视化）</li><li>环境配置：CUDA 12.1，Ubuntu 22.04</li><li>ai工具：ChatGPT-4o</li></ul><h2 id="关键代码展示"><a href="#关键代码展示" class="headerlink" title="关键代码展示"></a>关键代码展示</h2><ul><li><p>展示4个策略：</p><h4 id="误导性路径"><a href="#误导性路径" class="headerlink" title="误导性路径"></a>误导性路径</h4><ul><li>在起点和终点之间创建看似合理但实际是死胡同的路径</li><li>利用无人机对特定方向的偏好设置陷阱</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_misleading_path</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;创建一个误导性的路径，利用无人机向右和向上的偏好&quot;&quot;&quot;</span><br>        obstacles = []<br>        <br>        <span class="hljs-comment"># 计算从起点到终点的直线方向</span><br>        dx = end[<span class="hljs-number">0</span>] - start[<span class="hljs-number">0</span>]<br>        dy = end[<span class="hljs-number">1</span>] - start[<span class="hljs-number">1</span>]<br>        <br>        <span class="hljs-comment"># 创建一个看似通向目标但实际是误导的路径</span><br>        mislead_x = start[<span class="hljs-number">0</span>] + dx * <span class="hljs-number">0.6</span><br>        mislead_y = start[<span class="hljs-number">1</span>] + dy * <span class="hljs-number">0.6</span><br>        <br>        <span class="hljs-comment"># 在误导点周围创建障碍物包围圈</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            angle = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * math.pi)<br>            radius = random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br>            x = mislead_x + radius * math.cos(angle)<br>            y = mislead_y + radius * math.sin(angle)<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>        <br>        <span class="hljs-comment"># 创建一个向右上方的诱饵路径（利用代理对向右和向上的偏好）</span><br>        bait_points = []<br>        bait_length = <span class="hljs-built_in">min</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">int</span>(<span class="hljs-variable language_">self</span>.point_distance(start, end) / <span class="hljs-number">3</span>))<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, bait_length + <span class="hljs-number">1</span>):<br>            bait_x = start[<span class="hljs-number">0</span>] + i * <span class="hljs-number">1.5</span><br>            bait_y = start[<span class="hljs-number">1</span>] + i * <span class="hljs-number">1.5</span><br>            bait_points.append([bait_x, bait_y])<br>        <br>        <span class="hljs-comment"># 在诱饵路径末端设置障碍物陷阱</span><br>        <span class="hljs-keyword">if</span> bait_points:<br>            end_point = bait_points[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>                angle = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * math.pi)<br>                radius = random.uniform(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)<br>                x = end_point[<span class="hljs-number">0</span>] + radius * math.cos(angle)<br>                y = end_point[<span class="hljs-number">1</span>] + radius * math.sin(angle)<br>                <br>                <span class="hljs-comment"># 确保在场地范围内</span><br>                x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>                y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>                <br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles):<br>                    obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>        <br>        <span class="hljs-keyword">return</span> obstacles<br>        <br></code></pre></td></tr></table></figure><h4 id="感知边界障碍"><a href="#感知边界障碍" class="headerlink" title="感知边界障碍"></a>感知边界障碍</h4><ul><li>在无人机感知范围边界（约15m）布置障碍物</li><li>使无人机难以提前规划路径，容易陷入局部最优</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_narrow_passages</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建狭窄通道，利用无人机在障碍物3米范围内的负奖励&quot;&quot;&quot;</span><br>    obstacles = []<br>    <br>    <span class="hljs-comment"># 计算从起点到终点的方向</span><br>    dx = end[<span class="hljs-number">0</span>] - start[<span class="hljs-number">0</span>]<br>    dy = end[<span class="hljs-number">1</span>] - start[<span class="hljs-number">1</span>]<br>    distance = math.sqrt(dx**<span class="hljs-number">2</span> + dy**<span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-comment"># 将方向单位化</span><br>    <span class="hljs-keyword">if</span> distance &gt; <span class="hljs-number">0</span>:<br>        dx /= distance<br>        dy /= distance<br>    <br>    <span class="hljs-comment"># 计算垂直于路径方向的向量</span><br>    perp_dx = -dy<br>    perp_dy = dx<br>    <br>    <span class="hljs-comment"># 在路径上创建多个狭窄通道</span><br>    num_passages = <span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">int</span>(distance / <span class="hljs-number">10</span>))<br>    passage_width = <span class="hljs-number">3.5</span>  <span class="hljs-comment"># 略大于障碍物直径+无人机直径</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_passages):<br>        <span class="hljs-comment"># 计算通道中心点</span><br>        t = (i + <span class="hljs-number">1</span>) / (num_passages + <span class="hljs-number">1</span>)<br>        center_x = start[<span class="hljs-number">0</span>] + t * dx * distance<br>        center_y = start[<span class="hljs-number">1</span>] + t * dy * distance<br>        <br>        <span class="hljs-comment"># 在通道两侧创建障碍物</span><br>        <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> [-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]:<br>            offset = passage_width / <span class="hljs-number">2</span> + <span class="hljs-variable language_">self</span>.obstacle_radius<br>            x = center_x + side * perp_dx * offset<br>            y = center_y + side * perp_dy * offset<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>                <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>                <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-keyword">return</span> obstacles<br></code></pre></td></tr></table></figure><h4 id="狭窄通道"><a href="#狭窄通道" class="headerlink" title="狭窄通道"></a>狭窄通道</h4><ul><li>设计宽度刚好略大于无人机通过能力的通道（约3.5m）</li><li>利用无人机对靠近障碍物的负奖励，使其犹豫不决</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_narrow_passages</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建狭窄通道，利用无人机在障碍物3米范围内的负奖励&quot;&quot;&quot;</span><br>    obstacles = []<br>    <br>    <span class="hljs-comment"># 计算从起点到终点的方向</span><br>    dx = end[<span class="hljs-number">0</span>] - start[<span class="hljs-number">0</span>]<br>    dy = end[<span class="hljs-number">1</span>] - start[<span class="hljs-number">1</span>]<br>    distance = math.sqrt(dx**<span class="hljs-number">2</span> + dy**<span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-comment"># 将方向单位化</span><br>    <span class="hljs-keyword">if</span> distance &gt; <span class="hljs-number">0</span>:<br>        dx /= distance<br>        dy /= distance<br>    <br>    <span class="hljs-comment"># 计算垂直于路径方向的向量</span><br>    perp_dx = -dy<br>    perp_dy = dx<br>    <br>    <span class="hljs-comment"># 在路径上创建多个狭窄通道</span><br>    num_passages = <span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">int</span>(distance / <span class="hljs-number">10</span>))<br>    passage_width = <span class="hljs-number">3.5</span>  <span class="hljs-comment"># 略大于障碍物直径+无人机直径</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_passages):<br>        <span class="hljs-comment"># 计算通道中心点</span><br>        t = (i + <span class="hljs-number">1</span>) / (num_passages + <span class="hljs-number">1</span>)<br>        center_x = start[<span class="hljs-number">0</span>] + t * dx * distance<br>        center_y = start[<span class="hljs-number">1</span>] + t * dy * distance<br>        <br>        <span class="hljs-comment"># 在通道两侧创建障碍物</span><br>        <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> [-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]:<br>            offset = passage_width / <span class="hljs-number">2</span> + <span class="hljs-variable language_">self</span>.obstacle_radius<br>            x = center_x + side * perp_dx * offset<br>            y = center_y + side * perp_dy * offset<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>                <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>                <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-keyword">return</span> obstacles<br></code></pre></td></tr></table></figure><h4 id="迷宫结构"><a href="#迷宫结构" class="headerlink" title="迷宫结构"></a>迷宫结构</h4><ul><li>创建复杂的迷宫式布局</li><li>增加路径规划的复杂度，容易使智能体迷失方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_maze_structure</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建迷宫结构，让无人机容易迷失方向&quot;&quot;&quot;</span><br>    obstacles = []<br>    <br>    <span class="hljs-comment"># 在起点和终点之间创建迷宫结构</span><br>    mid_x = (start[<span class="hljs-number">0</span>] + end[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span><br>    mid_y = (start[<span class="hljs-number">1</span>] + end[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span><br>    <br>    <span class="hljs-comment"># 创建迷宫的中心区域</span><br>    maze_radius = <span class="hljs-built_in">min</span>(<span class="hljs-number">15</span>, <span class="hljs-variable language_">self</span>.point_distance(start, end) / <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment"># 创建迷宫的几条&quot;墙&quot;</span><br>    <span class="hljs-keyword">for</span> wall_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        wall_angle = wall_idx * <span class="hljs-number">2</span> * math.pi / <span class="hljs-number">3</span><br>        wall_length = maze_radius * <span class="hljs-number">0.8</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            t = (i + <span class="hljs-number">1</span>) / <span class="hljs-number">4</span><br>            x = mid_x + t * wall_length * math.cos(wall_angle)<br>            y = mid_y + t * wall_length * math.sin(wall_angle)<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>                <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>                <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-comment"># 创建一些随机的迷宫元素</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        angle = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * math.pi)<br>        radius = random.uniform(maze_radius * <span class="hljs-number">0.3</span>, maze_radius)<br>        x = mid_x + radius * math.cos(angle)<br>        y = mid_y + radius * math.sin(angle)<br>        <br>        <span class="hljs-comment"># 确保在场地范围内</span><br>        x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>        y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>            <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>            <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>            obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-keyword">return</span> obstacles<br></code></pre></td></tr></table></figure><h1 id="NS-2025-11-接管厨房客厅的那一天-Writeup"><a href="#NS-2025-11-接管厨房客厅的那一天-Writeup" class="headerlink" title="NS-2025-11 接管厨房客厅的那一天 Writeup"></a>NS-2025-11 接管厨房客厅的那一天 Writeup</h1><h2 id="一、任务背景与目标"><a href="#一、任务背景与目标" class="headerlink" title="一、任务背景与目标"></a>一、任务背景与目标</h2><p>本次“NS-2025-11 家庭智能协作挑战”要求参赛者基于多模态输入（图像 + 自然语言）构建智能体，使其控制机械臂完成一系列具有挑战性的家庭任务。这些任务具有不同的动态特征与动作要求，包括：</p><ul><li>堆叠积木（stack_blocks）</li><li>放置杯子（place_cups）</li><li>把钱放入保险箱（put_money_in_safe）</li><li>拧入灯泡（light_bulb_in）</li><li>将物品放入抽屉（put_item_in_drawer）</li></ul><p>智能体需对序列输入做出连续动作预测：三维位置（XYZ）、旋转（四元数）、抓取信号（是否夹取）。挑战评估模型对任务目标完成度、轨迹质量与精度的适应能力。</p><hr><h2 id="二、系统架构与模型设计"><a href="#二、系统架构与模型设计" class="headerlink" title="二、系统架构与模型设计"></a>二、系统架构与模型设计</h2><p>为统一处理所有任务，我们设计了统一结构的策略网络 <code>TaskModel</code>，其整体结构分为以下三个部分：</p><h3 id="2-1-编码器：ActionDecoder-encoder"><a href="#2-1-编码器：ActionDecoder-encoder" class="headerlink" title="2.1 编码器：ActionDecoder.encoder"></a>2.1 编码器：<code>ActionDecoder.encoder</code></h3><p>输入为 <code>[B, T, D]</code> 的观测向量序列（图像 + 语言的融合特征），经过两层全连接网络映射到维度为 <code>embed_dim=128</code> 的特征表示，并通过 <code>ReLU</code> 激活增强非线性表达能力。</p><h3 id="2-2-时序建模模块：TemporalBlock"><a href="#2-2-时序建模模块：TemporalBlock" class="headerlink" title="2.2 时序建模模块：TemporalBlock"></a>2.2 时序建模模块：<code>TemporalBlock</code></h3><p>采用标准的 Transformer 子结构（多头注意力 + 残差 LayerNorm + 前馈网络），能够建模动作序列中时间步间的依赖关系与长期轨迹规律：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MultiheadAttention -&gt; LayerNorm -&gt; MLP -&gt; LayerNorm<br></code></pre></td></tr></table></figure><p>该模块允许模型识别出不同时间步之间的操作规律，如“插入-旋转-释放”等时序动作序列。</p><h3 id="2-3-动作解码头"><a href="#2-3-动作解码头" class="headerlink" title="2.3 动作解码头"></a>2.3 动作解码头</h3><ul><li><code>head_pos</code>: 输出每一步的三维位置（XYZ）</li><li><code>head_rot</code>: 输出归一化四元数，表示旋转角度</li><li><code>head_grip</code>: 输出抓取信号，通过 <code>sigmoid</code> 激活</li></ul><p>最终模型输出维度为 <code>action_dim = 3 + 4 + 1 = 8</code>。</p><hr><h2 id="三、任务感知的损失函数设计"><a href="#三、任务感知的损失函数设计" class="headerlink" title="三、任务感知的损失函数设计"></a>三、任务感知的损失函数设计</h2><p>我们在 <code>TaskModel.compute_loss()</code> 中为不同任务设计了特定的损失加权策略，从而提高模型在各类任务中的表现力与泛化性。</p><h3 id="通用损失构成："><a href="#通用损失构成：" class="headerlink" title="通用损失构成："></a>通用损失构成：</h3><ul><li><code>loss_pos</code>: 所有时间步的 MSE（位置）</li><li><code>loss_rot</code>: 所有时间步的 Cosine 相似度损失（四元数）</li><li><code>loss_grip</code>: 所有时间步的 BCE（抓取信号）</li></ul><h3 id="任务特化策略如下："><a href="#任务特化策略如下：" class="headerlink" title="任务特化策略如下："></a>任务特化策略如下：</h3><table><thead><tr><th>任务名称</th><th>调整策略</th></tr></thead><tbody><tr><td>stack_blocks</td><td>强调<strong>最后一步的位置稳定性</strong>与<strong>旋转精度</strong>，将最后一帧位置误差加入损失，并将旋转损失权重翻倍。</td></tr><tr><td>place_cups</td><td>增加轨迹差值损失项，鼓励轨迹对齐；同时强调<strong>最后时刻的旋转一致性</strong>，增强杯口方向控制。</td></tr><tr><td>put_money_in_safe</td><td>加强末帧抓取状态与位置精度的监督，确保插入时精度与夹持控制。</td></tr><tr><td>light_bulb_in</td><td>提高位置与旋转损失权重，适配对姿态和插入精度的高要求；抓取控制也更为关键。</td></tr><tr><td>put_item_in_drawer</td><td>默认使用 <code>put_money_in_safe</code> 相似策略，注重轨迹尾部插入点与释放状态的联合优化。</td></tr></tbody></table><hr><h2 id="四、训练与实现细节"><a href="#四、训练与实现细节" class="headerlink" title="四、训练与实现细节"></a>四、训练与实现细节</h2><table><thead><tr><th>参数</th><th>配置</th></tr></thead><tbody><tr><td>Batch Size</td><td>32</td></tr><tr><td>Epochs</td><td>30</td></tr><tr><td>Optimizer</td><td>Adam</td></tr><tr><td>Learning Rate</td><td>1e-4</td></tr><tr><td>Scheduler</td><td>Cosine Annealing</td></tr><tr><td>Sequence Length</td><td>10</td></tr><tr><td>Input Dim</td><td>64（图像+语言特征）</td></tr><tr><td>Embed Dim</td><td>128</td></tr></tbody></table><p>代码实现基于 PyTorch 框架，支持多任务训练与微调。每个任务模型独立训练并评估。</p><hr><h2 id="五、实验结果与分析"><a href="#五、实验结果与分析" class="headerlink" title="五、实验结果与分析"></a>五、实验结果与分析</h2><p>在官方验证平台上的评测结果如下（分数越高表示性能越优）：</p><table><thead><tr><th>任务名称</th><th>得分</th></tr></thead><tbody><tr><td>put_money_in_safe</td><td>292.48</td></tr><tr><td>stack_blocks</td><td>219.12</td></tr><tr><td>light_bulb_in</td><td>284.34</td></tr><tr><td>put_item_in_drawer</td><td>320.00</td></tr><tr><td>place_cups</td><td>260.35</td></tr></tbody></table><p>该结果表明我们的方法在多任务适配性与精度控制方面具有良好的表现，尤其是在插入与抓取精度要求高的任务中（如 drawer, light bulb）。</p><hr><h2 id="六、使用工具与环境"><a href="#六、使用工具与环境" class="headerlink" title="六、使用工具与环境"></a>六、使用工具与环境</h2><ul><li>开发语言：Python 3.10</li><li>框架库：PyTorch 2.1.0、NumPy、WandB（日志）、Matplotlib（可视化）</li><li>环境配置：CUDA 12.1，Ubuntu 22.04</li><li>ai工具：ChatGPT-4o</li></ul><hr><h2 id="七、挑战与展望"><a href="#七、挑战与展望" class="headerlink" title="七、挑战与展望"></a>七、挑战与展望</h2><p>我们观察到如下挑战与优化方向：</p><ul><li><strong>多任务共享结构</strong>：虽然当前模型能适应多任务，但可能存在参数干扰问题。未来考虑引入任务提示向量（Task Prompt）进行条件控制。</li><li><strong>语言与图像融合方式</strong>：当前仅使用预融合输入，未来可尝试引入 Cross-Attention 机制实现更强的模态融合。</li><li><strong>动作输出结构优化</strong>：不同任务在输出精度要求差异大，可设计更细粒度的输出头或使用分层结构优化不同粒度的预测项。针对不同任务的特性进一步优化。</li></ul><hr><h2 id="八、-部分代码展示"><a href="#八、-部分代码展示" class="headerlink" title="八、 部分代码展示"></a>八、 部分代码展示</h2><p>关键代码：</p><h3 id="1-模型主干设计（BasePolicy）"><a href="#1-模型主干设计（BasePolicy）" class="headerlink" title="1. 模型主干设计（BasePolicy）"></a>1. 模型主干设计（BasePolicy）</h3><p>这是所有任务共享的基本网络结构，使用了 <code>ResNet18</code> 提取视觉特征，并用 <code>TransformerEncoder</code> 编码语言。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePolicy</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        resnet = resnet18(pretrained=<span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.vision_encoder = nn.Sequential(*<span class="hljs-built_in">list</span>(resnet.children())[:-<span class="hljs-number">1</span>])<br>        encoder_layer = nn.TransformerEncoderLayer(d_model=<span class="hljs-number">512</span>, nhead=<span class="hljs-number">8</span>)<br>        <span class="hljs-variable language_">self</span>.lang_encoder = nn.TransformerEncoder(encoder_layer, num_layers=<span class="hljs-number">2</span>)<br>        <span class="hljs-variable language_">self</span>.cross_modal = nn.MultiheadAttention(embed_dim=<span class="hljs-number">512</span>, num_heads=<span class="hljs-number">8</span>, batch_first=<span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.fc_out = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">256</span>), nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">128</span>), nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">7</span>)<br>        )<br>        <span class="hljs-variable language_">self</span>.grip_cls = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>), nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">2</span>)<br>        )<br><br></code></pre></td></tr></table></figure><h3 id="2-跨模态编码（视觉-语言）"><a href="#2-跨模态编码（视觉-语言）" class="headerlink" title="2. 跨模态编码（视觉 + 语言）"></a>2. <strong>跨模态编码（视觉 + 语言）</strong></h3><p>视觉特征和语言特征交叉融合，通过 Multi-Head Attention 得到联合特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode_inputs</span>(<span class="hljs-params">self, obs, instr</span>):<br>    B, C_view, Two, C, H, W = obs.shape<br>    obs = obs.view(B * C_view * Two, C, H, W)<br>    vision_feat = <span class="hljs-variable language_">self</span>.vision_encoder(obs).view(B, C_view * Two, -<span class="hljs-number">1</span>).mean(dim=<span class="hljs-number">1</span>)<br>    instr = instr.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    lang_feat_seq = <span class="hljs-variable language_">self</span>.lang_encoder(instr).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    lang_feat_att, _ = <span class="hljs-variable language_">self</span>.cross_modal(vision_feat.unsqueeze(<span class="hljs-number">1</span>), lang_feat_seq, lang_feat_seq)<br>    <span class="hljs-keyword">return</span> vision_feat, lang_feat_att.squeeze(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="3-loss函数"><a href="#3-loss函数" class="headerlink" title="3. loss函数"></a>3. loss函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_loss</span>(<span class="hljs-params">pred, target, task=<span class="hljs-literal">None</span>, epoch=<span class="hljs-number">0</span></span>):<br>    pos_loss = F.mse_loss(pred[:, :<span class="hljs-number">3</span>], target[:, :<span class="hljs-number">3</span>])<br>    rot_weight = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>, epoch / <span class="hljs-number">20.0</span>)<br>    rot_loss = F.smooth_l1_loss(pred[:, <span class="hljs-number">3</span>:<span class="hljs-number">7</span>], target[:, <span class="hljs-number">3</span>:<span class="hljs-number">7</span>]) * rot_weight<br>    grip_target = target[:, <span class="hljs-number">7</span>:].long().squeeze(<span class="hljs-number">1</span>)<br>    grip_loss = F.cross_entropy(torch.cat([<span class="hljs-number">1</span> - pred[:, <span class="hljs-number">7</span>:], pred[:, <span class="hljs-number">7</span>:]], dim=<span class="hljs-number">1</span>), grip_target)<br><br>    <span class="hljs-keyword">if</span> task == <span class="hljs-string">&#x27;stack_blocks&#x27;</span>:<br>        rot_loss *= <span class="hljs-number">2.0</span><br>    <span class="hljs-keyword">elif</span> task == <span class="hljs-string">&#x27;put_money_in_safe&#x27;</span>:<br>        pos_loss *= <span class="hljs-number">1.5</span><br>    <span class="hljs-keyword">elif</span> task == <span class="hljs-string">&#x27;light_bulb_in&#x27;</span>:<br>        pos_loss *= <span class="hljs-number">1.3</span><br>        grip_loss *= <span class="hljs-number">1.2</span><br><br>    <span class="hljs-keyword">return</span> pos_loss + rot_loss + <span class="hljs-number">0.1</span> * grip_loss<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4月碎碎念</title>
    <link href="/2025/04/29/4%E6%9C%88%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2025/04/29/4%E6%9C%88%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>如此无聊的土豆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无聊的东西</tag>
      
      <tag>如此无聊的土豆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab4.2</title>
    <link href="/2025/04/21/AI-Lab4-2/"/>
    <url>/2025/04/21/AI-Lab4-2/</url>
    
    <content type="html"><![CDATA[<h1 id="人工神经网络介绍"><a href="#人工神经网络介绍" class="headerlink" title="人工神经网络介绍"></a>人工神经网络介绍</h1><h2 id="单层感知机"><a href="#单层感知机" class="headerlink" title="单层感知机"></a>单层感知机</h2><ul><li>由于M-P神经元模型参数需要事先设定好，为了能够自适应学习出所需要的参数，研究人员就提出了<strong>单层感知机(Perceptron)</strong></li><li>感知机的基本公式为：<strong>y(𝑥)&#x3D;𝑠𝑖𝑔𝑛(𝑤𝑥+𝑏)</strong></li><li>sign为符号函数，当自变量为<strong>正数</strong>时取值为1，否则取值为0</li></ul><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><ul><li>包含三个层次：一个<strong>输入层</strong>，一个或多个中间层(也叫<strong>隐藏层</strong>，hidden layer) 和一个<strong>输出层</strong></li><li>输入层与输出层的节点数是固定的，中间层则可以自由指定</li><li>MLP通常还会引入<strong>偏置单元b</strong></li></ul><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><ul><li>常见：sigmoid、Relu、tanh<br><img src="/img/file-20250421163950262.png"></li><li>sigmoid可以用于<strong>计算概率</strong></li><li>ReLU函数的拟合效果可能更好一点</li><li>tanh函数</li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><ul><li>作用：衡量网络表现是否良好，并为之后的网络参数优化提供指导<br><img src="/img/file-20250421164225769.png"></li></ul><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><ul><li>梯度定义：梯度是一个向量，表示某一函数在该点出的方向导数沿着该方向取得最大值。</li><li>梯度下降的一般公式为：<code>𝜃=𝜃−𝜂∇𝜃𝐿(𝜃)</code>，其中，𝜂是<strong>学习率</strong>，∇𝜃是对𝜃的梯度，𝜃是参数<ul><li>学习率太小学习地很慢</li><li>学习率太大效果不太好，可能错过最小值，无法收敛</li></ul></li></ul><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="2-1：购房预测分类任务"><a href="#2-1：购房预测分类任务" class="headerlink" title="2.1：购房预测分类任务"></a>2.1：购房预测分类任务</h2><ul><li>利用感知机算法在给定数据集完成购房预测训练</li><li>要求：<ul><li>选择<strong>合适的损失函数</strong>，利用<strong>训练集</strong>完成网络训练，<strong>画出数据可视化图、loss曲线图</strong>。（可以任意拿两个特征、三个出来画，全部都要画出来）</li><li>单层感知机示例：<br>  <img src="/img/file-20250421164713292.png"></li></ul></li></ul><p>&#x3D;&gt;感知机算法</p><h4 id="房价预测任务"><a href="#房价预测任务" class="headerlink" title="房价预测任务"></a>房价预测任务</h4><p><code>data.csv</code>数据集包含五个属性，共10000条数据，其中 <code>longitude</code>和 <code>latitude</code>表示房子经纬度，<code>housing_age</code>表示<strong>房子年龄</strong>，<code>homeowner_income</code>表示<strong>房主的收入</strong>（单位：十万元）， <code>house_price</code>表示<strong>房子的价格</strong>。请根据数据集 <code>data.csv</code>中四个属性 <code>longitude</code>、<code>latitude</code>、<code>housing_age</code>、<code>homeowner_income</code>，利用<strong>感知机算法</strong>预测房价 <code>house_price</code>，并画出<strong>数据可视化图、loss曲线图</strong>。</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol><li>最后提交的代码只需包含性能最好的实现方法和参数设置. 只需提交一个代码文件, 请不要提交其他文件.</li><li>本次作业可以使用 <code>numpy</code>库、<code>matplotlib</code>库以及python标准库.</li><li>数据集可以在Github上下载。</li></ol><h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h3><h4 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h4><h5 id="1-1-数据处理"><a href="#1-1-数据处理" class="headerlink" title="1.1 数据处理"></a>1.1 数据处理</h5><ul><li>加载数据集、数据预处理（标准化&#x2F;归一化）</li><li>划分训练集和测试集（8:2）</li></ul><p>&#x3D;&gt;利用 loadtxt函数读取csv文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">np.loadtxt(filepath,delimiter,usecols,unpack)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">参数：</span><br><span class="hljs-string">filepath:加载文件路径  </span><br><span class="hljs-string">delimiter:加载文件分隔符  (csv一般以&#x27;,&#x27;进行分隔)</span><br><span class="hljs-string">usecols:加载数据文件中列索引（标签）</span><br><span class="hljs-string">unpack:当加载多列数据时是否需要将数据列进行解耦赋值给不同的变量 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="1-2-感知机模型构建"><a href="#1-2-感知机模型构建" class="headerlink" title="1.2 感知机模型构建"></a>1.2 感知机模型构建</h5><ul><li>定义感知机模型结构（<code>__init__</code>，参数包括：学习率，迭代次数，loss数组)</li><li>实现前向传播算法</li><li>实现反向传播与权重更新</li></ul><h5 id="1-3-模型训练与评估"><a href="#1-3-模型训练与评估" class="headerlink" title="1.3 模型训练与评估"></a>1.3 模型训练与评估</h5><ul><li>设定超参数（学习率、迭代次数等）</li><li>训练模型并记录loss</li><li>在测试集上评估模型性能</li></ul><h5 id="1-4-可视化结果"><a href="#1-4-可视化结果" class="headerlink" title="1.4 可视化结果"></a>1.4 可视化结果</h5><ul><li>数据分布可视化</li><li>loss曲线绘制</li></ul><h2 id="知识补给："><a href="#知识补给：" class="headerlink" title="知识补给："></a>知识补给：</h2><h3 id="感知机概述："><a href="#感知机概述：" class="headerlink" title="感知机概述："></a>感知机概述：</h3><ul><li>感知机是二分类的线性分类模型，属于监督学习算法（提供label进行训练）</li><li>为求得超平面，感知机导入了基于误分类的损失函数，利用<strong>梯度下降法</strong>对损失函数进行最优化求解。</li><li>如果训练数据集是线性可分的，则感知机一定能求得分离超平面。如果是非线性可分的数据，则无法获得超平面。</li></ul><h3 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h3><p>感知机模型：$f(x)&#x3D;sign(w⋅x+b)$</p><ul><li>sign()是符号函数</li><li>其中的一个超平面是$wx+b&#x3D;0$</li></ul><h3 id="感知机损失函数（loss）"><a href="#感知机损失函数（loss）" class="headerlink" title="感知机损失函数（loss）"></a>感知机损失函数（loss）</h3><p>损失函数的一个自然选择是<strong>误分类点的总数</strong>，但是这样的函数不是连续可导函数，不易优化。因此感知机采用的损失函数是<strong>误分类点到超平面的总距离</strong>。</p><p>对于误分类样本 $(x_i, y_i)$（满足 $y_i(w \cdot x_i + b) \leq 0$），损失函数为<strong>误分类点到超平面的距离的相反数</strong>：</p><p>$$<br>L(w,b) &#x3D; -\sum_{x_i \in M} y_i(w \cdot x_i + b)<br>$$</p><p>其中 $M$ 是误分类样本集合。</p><h4 id="距离公式推导"><a href="#距离公式推导" class="headerlink" title="距离公式推导"></a>距离公式推导</h4><p>误分类点到超平面的几何距离：$||w||$是w的$L_2$范数</p><p>$$<br>\text{Distance} &#x3D; \frac{|w \cdot x_i + b|}{|w|_2}<br>$$</p><p>因误分类时 $y_i(w \cdot x_i + b) &lt; 0$，可简化为：</p><p>$$<br>\text{Distance} &#x3D; -\frac{y_i(w \cdot x_i + b)}{|w|_2}<br>$$</p><h4 id="梯度下降更新规则"><a href="#梯度下降更新规则" class="headerlink" title="梯度下降更新规则"></a>梯度下降更新规则</h4><p>参数更新公式（$\eta$ 为学习率）：</p><p>$$<br>\begin{aligned}<br>w &amp;\leftarrow w + \eta y_i x_i \<br>b &amp;\leftarrow b + \eta y_i<br>\end{aligned}<br>$$</p><p>梯度计算：</p><p>$$<br>\begin{aligned}<br>\nabla_w L &amp;&#x3D; -y_i x_i \<br>\nabla_b L &amp;&#x3D; -y_i<br>\end{aligned}<br>$$</p><h4 id="收敛性定理（Novikoff）"><a href="#收敛性定理（Novikoff）" class="headerlink" title="收敛性定理（Novikoff）"></a>收敛性定理（Novikoff）</h4><p>对于线性可分数据集，感知机保证在有限步 $k$ 内收敛：</p><p>$$<br>k \leq \left( \frac{R}{\gamma} \right)^2<br>$$</p><p>其中：</p><ul><li>$R &#x3D; \max |x_i|$ 是输入特征的最大模长</li><li>$\gamma$ 是分离超平面的间隔（margin）</li></ul><h4 id="多层感知机："><a href="#多层感知机：" class="headerlink" title="多层感知机："></a>多层感知机：</h4><p><img src="/img/file-20250421164856817.png"></p><ul><li>要手写权重、偏置、梯度下降率</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex_learning</title>
    <link href="/2025/04/17/LaTex-learning/"/>
    <url>/2025/04/17/LaTex-learning/</url>
    
    <content type="html"><![CDATA[<p>参考资料链接：<br><a href="https://texdoc.org/serve/texlive-zh-cn.pdf/0">TEX Live指南2025</a><br><a href="https://oi-wiki.org/tools/latex/">LaTeX 入门 - OI Wiki</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>[!NOTE]<br>本文是在windows下的安装记录+vscode配置使用</p></blockquote><p>通过官网进行安装，下载 <code>install-tl-windows.exe</code> ，跟着指令继续做即可</p><p>安装好后，需要将bin加入环境变量，此处我是加入 <code>E:\software\texLive2\texlive\2025\bin\windows</code> 到环境变量</p><p>查看版本看是否安装好了：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">tex <span class="hljs-comment">--version</span><br>latex <span class="hljs-comment">--version</span><br>xelatex <span class="hljs-comment">--version</span><br>pdflatex <span class="hljs-comment">--version</span><br><span class="hljs-keyword">context</span> <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>输出版本号则成功</p><h1 id="与vscode打通"><a href="#与vscode打通" class="headerlink" title="与vscode打通"></a>与vscode打通</h1><ul><li>安装Latex Workshop</li><li>配置setting.json</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs prolog"> <span class="hljs-string">&quot;latex-workshop.latex.tools&quot;</span>: [<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;args&quot;</span>: [<br><br>            <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br><br>            <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br><br>            <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;args&quot;</span>: [<br><br>            <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br><br>            <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br><br>            <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>        <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>        <span class="hljs-string">&quot;args&quot;</span>: [<br><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br><br>        ]<br><br>    &#125;<br><br>],<br><br>  <br><br><span class="hljs-string">&quot;latex-workshop.latex.recipes&quot;</span>: [<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span><br><br>        ],<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xe-&gt;bib-&gt;xe-&gt;xe&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdf-&gt;bib-&gt;pdf-&gt;pdf&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><br><br>        ]<br><br>    &#125;<br><br>],<br></code></pre></td></tr></table></figure><p>测试：</p><ul><li>新建一个 <code>.tex</code> 文件</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-meta">% !TEX program = xelatex  % 强制使用 XeLaTeX 编译（部分编辑器需要）</span><br><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125; <span class="hljs-comment">% 自动处理中文（推荐）</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>你好，LaTeX！<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>构建项目即可查看预览：<br><img src="/img/file-20250417172301672.png"></p><h1 id="使用笔记"><a href="#使用笔记" class="headerlink" title="使用笔记"></a>使用笔记</h1><h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[a4paper, 12pt]&#123;article&#125; <span class="hljs-keyword">\begin</span>&#123;document&#125; A sentence of text. <span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><ul><li><code>\documentclass</code> 命令必须出现在每个LaTeX文档开头。花括号内的文本指定了文档的类型。<ul><li><strong>article</strong> 文档类型适合<strong>较短的文章</strong>，比如期刊文章和短篇报告。其他文档类型包括 <strong>report</strong>（适用于更长的多章节的文档，比如博士生论文），<strong>proc</strong>（会议论文集），<strong>book</strong> 和 <strong>beamer</strong>。</li><li>方括号内的文本指定了一些<strong>选项</strong>——示例中它设置纸张大小为 A4，主要文字大小为 12pt。</li></ul></li><li><code>\begin&#123;document&#125;</code> 和 <code>\end&#123;document&#125;</code> 命令将你的文本内容包裹起来。<ul><li><code>\begin&#123;document&#125;</code> 之前的视为前导命令</li></ul></li></ul><h3 id="文档标题"><a href="#文档标题" class="headerlink" title="文档标题"></a>文档标题</h3><p><code>\maketitle</code> 命令可以给文档<strong>创建标题</strong>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\title&#123;My</span> First Document&#125; <br><span class="hljs-string">\author&#123;My</span> Name&#125; <br><span class="hljs-string">\date&#123;\today&#125;</span> <br><span class="hljs-string">\maketitle</span><br></code></pre></td></tr></table></figure><ul><li>放置在<code>\begin&#123;document&#125;</code>之后</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-meta">% !TEX program = xelatex  % 强制使用 XeLaTeX 编译（部分编辑器需要）</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125; <span class="hljs-comment">% 自动处理中文（推荐）</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\title</span>&#123;My First Document&#125;<br><span class="hljs-keyword">\author</span>&#123;PQCU&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><span class="hljs-keyword">\maketitle</span><br>你好，LaTeX！<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250417174047528.png"></p><blockquote><p>[!NOTE]</p><ul><li><strong>article</strong> 文档的正文会紧跟着标题之后在同一页上排版。<strong>report</strong> 会将标题置为单独的一页。</li></ul></blockquote><h3 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h3><ul><li><code>\section&#123;...&#125;</code></li><li><code>\subsection&#123;...&#125;</code></li><li><code>\subsubsection&#123;...&#125;</code></li><li><code>\paragraph&#123;...&#125;</code></li><li><code>\subparagraph&#123;...&#125; 花括号内的文本表示**章节的标题** 对于 **report** 和 **book** 类型的文档还支持 </code>\chapter{…}&#96; 的命令。</li></ul><p>使用展示：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-meta">% !TEX program = xelatex  % 强制使用 XeLaTeX 编译（部分编辑器需要）</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125; <span class="hljs-comment">% 自动处理中文（推荐）</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\title</span>&#123;My First Document&#125; <br><span class="hljs-keyword">\author</span>&#123;PQCU&#125; <br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125; <br><span class="hljs-keyword">\maketitle</span><br><span class="hljs-keyword">\section</span>&#123;Introduction&#125;<br>  This is the introduction.<br><br>  <span class="hljs-keyword">\section</span>&#123;Methods&#125;<br><br>  <span class="hljs-keyword">\subsection</span>&#123;Stage 1&#125;<br>  The first part of the methods.<br>  <span class="hljs-keyword">\subsubsection</span>&#123;wow&#125;<br><br>  <span class="hljs-keyword">\subsection</span>&#123;Stage 2&#125;<br>  The second part of the methods.<br><br>  <span class="hljs-keyword">\section</span>&#123;Results&#125;<br>  Here are my results.<br>  <span class="hljs-keyword">\paragraph</span>&#123;hhh1&#125;<br>  <span class="hljs-keyword">\subparagraph</span>&#123;hhh&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>渲染结果：<br><img src="/img/file-20250417174832497.png"></p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Latex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab3</title>
    <link href="/2025/04/14/AI-lab4/"/>
    <url>/2025/04/14/AI-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><ul><li>训练集有标签y</li><li>目标是找到能区分正负样本的决策边界，据此拟合一个假设函数</li><li>分类问题</li></ul><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><ul><li>训练集的数据不带有标签y</li><li>需要根据样本间的相似性对样本集进行聚类，试图使类内差距最小化，类间差距最大化</li><li>聚类问题<ul><li>k-means，密度聚类，层次聚类等</li></ul></li></ul><h2 id="K聚类"><a href="#K聚类" class="headerlink" title="K聚类"></a>K聚类</h2><p>算法概述：</p><ul><li>K-means算法是一种无监督学习方法。</li><li>使用一个没有标签的数据集，然后将数据聚类成不同的组。</li><li>通过迭代将数据点分配到K个簇中，使得每个数据点与其所属簇的中心(质心)之间的<strong>距离平方和最小化</strong>。</li></ul><p>距离度量：</p><ul><li>闵可夫斯基距离（Minkowski distance）<ul><li>p&#x3D;2–欧式距离</li><li>p&#x3D;1–曼哈顿距离</li><li>切比雪夫距离<img src="/img/file-20250414171426341.png"></li></ul></li></ul><p>算法流程：</p><ol><li>选择K个点作为初始质心。（初始化簇质心为任意点）</li><li>将每个点指派到最近的质心， 形成K个簇。（遍历所有数据点，计算所有质心与数据点的距离，根据距离选择簇）</li><li>对于上一步聚类的结果， 对所有簇计算平均距离， 得出该簇的新的聚类中心（新的质心）。</li><li>重复上述两步&#x2F;直到迭代结束：质心不发生变化。<br><img src="/img/file-20250414171640499.png"></li></ol><p>优点</p><ul><li>原理简单，实现容易，收敛速度快</li><li>聚类效果较优</li><li>算法的可解释度比较强</li><li>主要需要调参的参数仅仅时簇数K</li></ul><p>缺点<br>◼ 需要预先指定簇的数量<br>◼ 无法区分高度重叠的数据<br>◼ 欧几里得距离限制了能处理的数据变量类型<br>◼ 随机选择质心并不能带来理想的结果<br>◼ 无法处理异常值和噪声数据<br>◼ 不适用于非线性数据<br>◼ 对特征尺度敏感<br>◼ 如果遇到非常大的数据集，计算机可能会崩溃</p><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><p>聚类任务</p><ul><li>在给定数据集上，设计合适的k以及距离度量函数，利用k-means算法完成数据的聚类</li><li>要求：<ul><li>尝试分别在前200条、前1000条、前10000条数据完成聚类。</li><li>画出聚类后的数据可视化图。</li></ul></li></ul><h2 id="聚类个数K和初始聚类中心的选取"><a href="#聚类个数K和初始聚类中心的选取" class="headerlink" title="聚类个数K和初始聚类中心的选取"></a>聚类个数K和初始聚类中心的选取</h2><ul><li>合适的k值怎么选取？&#x3D;&gt;手肘法</li><li>聚类的目标是使得<strong>每个样本点到距离其最近的聚类中心的总误差平方和（也即聚类的代价函数–SSE）尽可能小</strong><br>$$<br>SSE&#x3D;\sum\limits_{i&#x3D;1}\limits^k\sum\limits_{x\in{C_i}}|d(x,C_i)|^2</li></ul><p>$$<br>SSE的大小表示聚类结果的好坏，k为簇的个数<br>$d(x,C_i)$表示的是欧拉距离公式</p><p><img src="/img/file-20250414185257096.png"></p><p>方法二：Gap Statistics方法（自动）<br>$Gap(K)&#x3D;E(logD_k)-logD_k$<br>$D_k$为损失函数，$E(logD_k)$是期望。<br>这个数值通常通过蒙特卡洛模拟产生，我们在样本里所在的区域中按照均匀分布随机产生和原始样本数一样多的随机样本，并对这个随机样本做 K-Means，从而得到一个$D_k$ 。如此往复多次，通常 20 次，我们可以得到 20 个$logD_k$  。对这 20 个数值求平均值，就得到了$E(logD_k)$ ​ 的近似值。最终可以计算 Gap Statisitc。而 Gap statistic 取得最大值所对应的 K 就是最佳的 K。</p><p>初始聚类中心：</p><ul><li>对初始聚类中心的位置敏感</li><li>优化方式：<ul><li>最大距离法（课上学过）<ul><li>先选取数据集中距离最大的两个点作为初始聚类中心</li><li>将剩余数据对象进行分配，更新聚类中心</li><li>继续寻找与聚类中心距离最远的点作为下一个中心点</li></ul></li></ul></li></ul><h1 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h1><p><a href="https://zhuanlan.zhihu.com/p/619739126">最常用的聚类算法——K-Means原理详解和实操应用(R&amp;Python) - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some Resources</title>
    <link href="/2025/04/14/Some%20Resources/"/>
    <url>/2025/04/14/Some%20Resources/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.latexlive.com/help#d12">在线LaTeX公式编辑器-帮助文档</a></p>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eBPF-Chap3</title>
    <link href="/2025/04/10/eBPF-chap3/"/>
    <url>/2025/04/10/eBPF-chap3/</url>
    
    <content type="html"><![CDATA[<h1 id="eBPF程序结构"><a href="#eBPF程序结构" class="headerlink" title="eBPF程序结构"></a>eBPF程序结构</h1><p>本章展示了eBPF程序从源代码到执行的整个过程中经历的各个阶段<br><img src="/img/file-20250410211708647.png"></p><ul><li>eBPF程序是一组eBPF字节码指令，可以直接使用eBPF字节码编写，但是一般来说使用高级语言编写会更轻松</li></ul><h2 id="eBPF-虚拟机"><a href="#eBPF-虚拟机" class="headerlink" title="eBPF 虚拟机"></a>eBPF 虚拟机</h2><ul><li>计算机软件实现</li><li>以eBPF字节码（由一组指令组成）指令的形式接受程序，这些指令必须转换为在CPU上运行的本地机器指令。</li></ul><h3 id="eBPF寄存器"><a href="#eBPF寄存器" class="headerlink" title="eBPF寄存器"></a>eBPF寄存器</h3><ul><li>使用10个通用寄存器（0-9）</li><li>寄存器10用作栈指针</li><li>eBPF程序的<strong>上下文参数</strong>在开始执行之前加载到<strong>寄存器1</strong>中，<strong>函数的返回值</strong>存储在<strong>寄存器0</strong>中</li><li>eBPF调用函数之前，参数放到<strong>寄存器1-5</strong>中（传递参数）</li></ul><h3 id="eBPF指令"><a href="#eBPF指令" class="headerlink" title="eBPF指令"></a>eBPF指令</h3><p>eBPF指令的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>__u8 code; <span class="hljs-comment">/* opcode */</span><br>__u8 dst_reg:<span class="hljs-number">4</span>; <span class="hljs-comment">/* dest register */</span><br>__u8 src_reg:<span class="hljs-number">4</span>; <span class="hljs-comment">/* source register */</span><br>__s16 off; <span class="hljs-comment">/* signed offset */</span><br>__s32 imm; <span class="hljs-comment">/* signed immediate constant */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>如果一条指令长度超过了8byte，则可以使用宽指令编码（wide instruction encoding）</li><li>操作码类别：<ul><li>将值写入寄存器（立即数或从内存中读取的值或从其他寄存器中读取的值）</li><li>存储寄存器中的值到内存中</li><li>进行数值计算</li><li>跳转到其他指令（满足一定条件时）</li></ul></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="example1："><a href="#example1：" class="headerlink" title="example1："></a>example1：</h3><p>当网络数据包到达时触发它并写入一行跟踪</p><p><strong>XDP 的返回值</strong><br>在 XDP 程序中，返回值决定了数据包的处理方式，常用的返回值包括：</p><ul><li><strong><code>XDP_DROP</code></strong>: 丢弃数据包。</li><li><strong><code>XDP_PASS</code></strong>: 将数据包传递给内核网络栈进行正常处理。</li><li><strong><code>XDP_TX</code></strong>: 数据包直接回送到接收的网卡（即本地发送）。</li><li><strong><code>XDP_REDIRECT</code></strong>: 将数据包重定向到另一个网络接口或用户空间。</li></ul><p>程序解释：<br><code>SEC(&quot;edp&quot;)</code> 声明这是一个XDP程序，运行在网络驱动处理的阶段<br><code>bpf_printk()</code> 用于向内核日志打印调试信息</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>可以使用clang来编译<br>makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TARGETS = hello hello-func<br><br><span class="hljs-section">all: <span class="hljs-variable">$(TARGETS)</span></span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br><br><span class="hljs-variable">$(TARGETS)</span>: %: %.bpf.o<br><br><span class="hljs-section">%.bpf.o: %.bpf.c</span><br><br>    clang \<br>        -target bpf \<br>        -I/usr/<span class="hljs-keyword">include</span>/<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -m)</span>-linux-gnu \<br>        -g \<br>        -O2 -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">clean:</span><br>    - rm *.bpf.o<br>    - rm -f /sys/fs/bpf/hello<br>    - rm -f /sys/fs/bpf/hello-func<br></code></pre></td></tr></table></figure><h4 id="检查eBPF对象文件"><a href="#检查eBPF对象文件" class="headerlink" title="检查eBPF对象文件"></a>检查eBPF对象文件</h4><p><code>file hello.bpf.o</code> 命令可以用于查看文件的内容</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@PQCU</span><span class="hljs-symbol">:~/eBPF/learning-ebpf/chapter3</span><span class="hljs-comment"># file hello.bpf.o</span><br><span class="hljs-symbol">hello.bpf.o:</span> <span class="hljs-title class_">ELF</span> <span class="hljs-number">64</span>-bit <span class="hljs-title class_">LSB</span> relocatable, eBPF, version <span class="hljs-number">1</span> (<span class="hljs-title class_">SYSV</span>), <span class="hljs-keyword">with</span> debug_info, <span class="hljs-keyword">not</span> stripped<br></code></pre></td></tr></table></figure><p>表明它是一个ELF文件，包含eBPF代码，适用于64bit架构</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs tap">root@PQCU:~/eBPF/learning-ebpf/chapter3<span class="hljs-comment"># llvm-objdump -S hello.bpf.o</span><br><br>hello.bpf.o:    file format elf64-bpf<br><br>Disassembly of section xdp:<br><br>0000000000000000 &lt;hello&gt;:<br>; int hello(struct xdp_md *ctx) &#123;<br>       0:       b7<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>r1 = 0<br>;     bpf_printk(&quot;Hello World %d&quot;, counter);<br>       1:      <span class="hljs-number"> 73 </span>1a fe ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u8 *)(r10 - 2) = r1<br>       2:       b7<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>25<span class="hljs-number"> 64 </span>00<span class="hljs-number"> 00 </span>r1 = 25637<br>       3:       6b 1a fc ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u16 *)(r10 - 4) = r1<br>       4:       b7<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>72 6c<span class="hljs-number"> 64 </span>20 r1 = 543452274<br>       5:      <span class="hljs-number"> 63 </span>1a f8 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u32 *)(r10 - 8) = r1<br>       6:      <span class="hljs-number"> 18 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 48 </span>65 6c 6c<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 6f<span class="hljs-number"> 20 </span>57 6f r1 =<span class="hljs-number"> 8022916924116329800 </span>ll<br>       8:       7b 1a f0 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u64 *)(r10 - 16) = r1<br>       9:      <span class="hljs-number"> 18 </span>06<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r6 =<span class="hljs-number"> 0 </span>ll<br>      11:      <span class="hljs-number"> 61 </span>63<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r3 = *(u32 *)(r6 + 0)<br>      12:       bf a1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r1 = r10<br>      13:      <span class="hljs-number"> 07 </span>01<span class="hljs-number"> 00 </span>00 f0 ff ff ff r1 += -16<br>;     bpf_printk(&quot;Hello World %d&quot;, counter);<br>      14:       b7<span class="hljs-number"> 02 </span>00<span class="hljs-number"> 00 </span>0f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>r2 = 15<br>      15:      <span class="hljs-number"> 85 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 06 </span>00<span class="hljs-number"> 00 </span>00 call 6<br>;     counter++;<br>      16:      <span class="hljs-number"> 61 </span>61<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r1 = *(u32 *)(r6 + 0)<br>      17:      <span class="hljs-number"> 07 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00 r1 += 1<br>      18:      <span class="hljs-number"> 63 </span>16<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u32 *)(r6 + 0) = r1<br>;     return XDP_PASS;<br>      19:       b7<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>r0 = 2<br>      20:      <span class="hljs-number"> 95 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 exit<br></code></pre></td></tr></table></figure><ul><li>llvm-objdump用于显示目标文件或可执行文件信息；可以显示文件头信息、符号表、反汇编代码等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS</category>
      
      <category>eBPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS</tag>
      
      <tag>eBPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab4</title>
    <link href="/2025/04/02/OS-Lab4/"/>
    <url>/2025/04/02/OS-Lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lab4：中断"><a href="#OS-Lab4：中断" class="headerlink" title="OS_Lab4：中断"></a>OS_Lab4：中断</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul><li>DDL：<strong>2024年4月20号 24:00</strong></li><li>提交的内容：将<strong>4个assignment的代码</strong>和<strong>实验报告</strong>放到<strong>压缩包</strong>中，命名为“<strong>lab4-学号-姓名</strong>”，并交到课程并交到课程邮箱 <a href="https://gitee.com/link?target=mailto:os_sysu_lab@163.com">os_sysu_lab@163.com</a><br>  将实验报告的pdf提交至 <a href="https://gitee.com/link?target=http://inbox.weiyun.com/NOKI03hf">http://inbox.weiyun.com/NOKI03hf</a></li><li><strong>Example材料的代码放置在<code>src</code>目录下</strong>。</li></ul><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本章会学习：</p><ul><li>C代码变成C程序的过程。</li><li>C&#x2F;C++项目的组织方法。</li><li>makefile的使用。</li><li>C和汇编混合编程。</li><li>保护模式中断处理机制。</li><li>8259A可编程中断处理部件。</li><li>时钟中断的处理。</li></ul><p>通过本章的学习，同学们将掌握<strong>使用C语言来编写内核</strong>的方法，<strong>理解保护模式的中断处理机制和处理时钟中断</strong>，为后面的二级分页机制和多线程&#x2F;进程打下基础。</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p><a href="https://www.cnblogs.com/linzworld/p/13690620.html">C语言-从代码到程序的过程理解 - 亥码 - 博客园</a></p><h2 id="C代码变成C程序的过程"><a href="#C代码变成C程序的过程" class="headerlink" title="C代码变成C程序的过程"></a>C代码变成C程序的过程</h2><p><img src="/img/file-20250402143442814.png"></p><ol><li>预处理：输入源程序并保存(.C文件)。<ul><li>处理源代码中以“#”开头的预编译指令</li><li>删掉注释行</li><li>.i文件中不包含任何宏定义和注释行</li></ul></li><li>将源文件转换成汇编代码（.s文件）的过程<ul><li>词法分析 -&gt; 语法分析 -&gt; 语义分析及相关的优化-&gt; 中间代码生成 -&gt; 目标代码生成（汇编文件.s）</li></ul></li><li>汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码（.o文件）。</li><li>将多个目标文件链接生成可执行文件( .EXE文件（windows）,.out文件（Linux）)。</li></ol><p>gcc指令生成中间过程文件：<br><code>gcc [选项] 要编译的文件 [选项] [目标文件]</code><br>or<br><code>gcc [option] filename [option] [objectfile]</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <span class="hljs-comment">//直接生成可执行文件main.out</span><br>gcc hello<span class="hljs-selector-class">.c</span> -o hello <br>gcc -E <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.i</span> <span class="hljs-comment">//生成预处理后的代码（还是文本文件）</span><br>gcc -S <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.s</span> <span class="hljs-comment">//汇编代码</span><br>gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.o</span> <span class="hljs-comment">//目标代码</span><br></code></pre></td></tr></table></figure><h3 id="example0"><a href="#example0" class="headerlink" title="example0"></a>example0</h3><p><strong>使用gcc跑一下程序</strong><br><img src="/img/file-20250402144450731.png"><br>or（可以不列举.h，因为.c文件中已经#include了，在.c&#x3D;&gt;.i阶段会将.h文件内容展开插入到）<br><img src="/img/file-20250402144559227.png"></p><ul><li>在.h中编写函数声明，不要在.h中实现函数，如果.h被多次引用可能会导致出现<strong>函数重定义</strong>问题</li><li>编译时要把所有.c和.cpp文件都加上去编译</li></ul><p><strong>查看各个步骤</strong></p><ul><li>预处理生成.i文件：<br>  <code>gcc -E main.c -o main</code></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 0 <span class="hljs-string">&quot;main.c&quot;</span></span><br><span class="hljs-meta"># 0 <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="hljs-meta"># 0 <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="hljs-meta"># 1 <span class="hljs-string">&quot;/usr/include/stdc-predef.h&quot;</span> 1 3 4</span><br><span class="hljs-meta"># 0 <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span> 2</span><br><span class="hljs-meta"># 1 <span class="hljs-string">&quot;main.c&quot;</span></span><br><span class="hljs-meta"># 1 <span class="hljs-string">&quot;print.h&quot;</span> 1  </span><br>  <br><br>void print_something()<span class="hljs-comment">;</span><br><span class="hljs-meta"># 2 <span class="hljs-string">&quot;main.c&quot;</span> 2</span><br><br><span class="hljs-built_in">int</span> main() &#123;<br><br>    print_something()<span class="hljs-comment">;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译生成汇编文件<br>  <code>gcc -S main.c -o main.s -masm=intel</code><br>  这里 <code>-masm=intel</code> 指示生成intel风格的汇编代码，否则默认AT&amp;T风格代码</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.file</span><span class="hljs-string">&quot;main.c&quot;</span><br><span class="hljs-meta">.intel_syntax</span> noprefix<br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.globl</span>main<br><span class="hljs-meta">.type</span>main, @function<br><span class="hljs-symbol">main:</span><br><span class="hljs-symbol">.LFB0:</span><br><span class="hljs-meta">.cfi_startproc</span><br>endbr64<br><span class="hljs-keyword">push</span><span class="hljs-built_in">rbp</span><br><span class="hljs-meta">.cfi_def_cfa_offset</span> <span class="hljs-number">16</span><br><span class="hljs-meta">.cfi_offset</span> <span class="hljs-number">6</span>, -<span class="hljs-number">16</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-meta">.cfi_def_cfa_register</span> <span class="hljs-number">6</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">call</span>print_something@PLT<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">pop</span><span class="hljs-built_in">rbp</span><br><span class="hljs-meta">.cfi_def_cfa</span> <span class="hljs-number">7</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">ret</span><br><span class="hljs-meta">.cfi_endproc</span><br><span class="hljs-symbol">.LFE0:</span><br><span class="hljs-meta">.size</span>main, .-main<br><span class="hljs-meta">.ident</span><span class="hljs-string">&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span><br><span class="hljs-meta">.section</span>.note<span class="hljs-number">.</span>GNU-stack,<span class="hljs-string">&quot;&quot;</span>,@progbits<br><span class="hljs-meta">.section</span>.note<span class="hljs-number">.</span>gnu<span class="hljs-number">.</span>property,<span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-meta">.long</span>1f - 0f<br><span class="hljs-meta">.long</span>4f - 1f<br><span class="hljs-meta">.long</span><span class="hljs-number">5</span><br><span class="hljs-number">0</span>:<br><span class="hljs-meta">.string</span><span class="hljs-string">&quot;GNU&quot;</span><br><span class="hljs-number">1</span>:<br><span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-meta">.long</span><span class="hljs-number">0xc0000002</span><br><span class="hljs-meta">.long</span>3f - 2f<br><span class="hljs-number">2</span>:<br><span class="hljs-meta">.long</span><span class="hljs-number">0x3</span><br><span class="hljs-number">3</span>:<br><span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span>:<br></code></pre></td></tr></table></figure><ul><li>重定位<br>  <code>gcc main.c print.c -o main.o</code><ul><li>在linux下，可重定位文件的格式是<strong>ELF</strong>文件格式，其包含了ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）等信息。</li></ul></li><li><strong>gcc是编译工具集合，在进行这些操作时会自动调用as、ld等</strong></li></ul><h2 id="Makefile（OS-Lab3中也有相关内容）"><a href="#Makefile（OS-Lab3中也有相关内容）" class="headerlink" title="Makefile（OS_Lab3中也有相关内容）"></a>Makefile（OS_Lab3中也有相关内容）</h2><p><img src="/img/file-20250402151015905.png"><br><img src="/img/file-20250402151025502.png"></p><h2 id="C-C-和汇编混合编程"><a href="#C-C-和汇编混合编程" class="headerlink" title="C&#x2F;C++和汇编混合编程"></a>C&#x2F;C++和汇编混合编程</h2><ul><li>在C&#x2F;C++代码中使用汇编代码实现的函数。</li><li>在汇编代码中使用C&#x2F;C++中的函数。</li></ul><p>混合编程是必要的，例如在bootloader初始化后，<strong>我们需要跳转到C&#x2F;C++编写的函数中执行</strong>；又如我们需要在C&#x2F;C++中调用使用汇编代码读取硬盘的函数。</p><ul><li>使用汇编函数（使用汇编函数实现的函数）来代替内联汇编</li></ul><p>&#x3D;&gt;汇编代码和C代码最终都会转换成可执行代码</p><ul><li>如果要在汇编代码中使用c函数，只需要在汇编代码中<strong>声明这个函数来自外部</strong>（在链接阶段才会使用到函数实现）</li><li>同理，要在c中使用汇编函数也只需要声明用到的函数来自外部即可<br>&#x3D;&gt;how？</li><li><strong>汇编代码</strong>：<br>使用来自C的函数：<br>声明：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">extern</span> function_from_C<br></code></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span> function_from_C<br></code></pre></td></tr></table></figure><p>使用来自CPP的函数：</p><ul><li>需要在C++代码的函数定义前加上<code>extern &quot;C&quot;</code></li><li>因为C++支持函数重载，为了区别同名的重载函数，C++在编译时会进行名字修饰。也就是说，<code>function_from_CPP</code>编译后的标号不再是<code>function_from_CPP</code>，而是要<strong>带上额外的信息</strong>。而&#x3D;&#x3D;C代码编译后的标号还是原来的函数名&#x3D;&#x3D;。</li><li>extern “C” 目的是告诉编译器按C代码规则编译，不加名字修饰。<br>在C++代码中声明：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">functionFromCpp</span>()</span>;<br></code></pre></td></tr></table></figure><p>在汇编代码中声明：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">extern</span> function_from_CPP<br></code></pre></td></tr></table></figure><ul><li>C&#x2F;CPP：<br>要先在汇编代码中奖函数声明为 <code>global</code>。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">global</span> function_from_asm<br></code></pre></td></tr></table></figure><p>C&#x2F;C++中声明其来自外部：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function_from_asm</span>()</span>;<br></code></pre></td></tr></table></figure><p>在C++中需要声明为 <code>extern &quot;C&quot;</code> </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function_from_asm</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="如果函数带返回值和参数"><a href="#如果函数带返回值和参数" class="headerlink" title="如果函数带返回值和参数"></a>如果函数带返回值和参数</h3><ul><li>如果函数有<strong>参数</strong>，那么参数&#x3D;&#x3D;<strong>从右向左&#x3D;&#x3D;依次入栈</strong>。</li><li>如果函数<strong>有返回值</strong>，返回值放在<strong>eax</strong>中。</li><li>放置于栈的参数一般使用<strong>ebp</strong>来获取。<br><strong>特别注意，汇编函数并没有函数参数和返回值的概念，因此汇编函数也被称为过程，不过是一段指令序列而已。</strong></li></ul><h3 id="Example1-混合编程"><a href="#Example1-混合编程" class="headerlink" title="Example1 混合编程"></a>Example1 混合编程</h3><ul><li>在文件<code>c_func.c</code>中定义C函数<code>function_from_C</code>。</li><li>在文件<code>cpp_func.cpp</code>中定义C++函数<code>function_from_CPP</code>。</li><li>在文件<code>asm_func.asm</code>中定义汇编函数<code>function_from_asm</code>，在<code>function_from_asm</code>中调用<code>function_from_C</code>和<code>function_from_CPP</code>。</li><li>在文件<code>main.cpp</code>中调用汇编函数<code>function_from_asm</code>。</li></ul><p>指令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o c_func<span class="hljs-selector-class">.o</span> -m32 -c c_func<span class="hljs-selector-class">.c</span><br>g++ -o cpp_func<span class="hljs-selector-class">.o</span> -m32 -c cpp_func<span class="hljs-selector-class">.cpp</span> <br>g++ -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -m32 -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>nasm -o asm_utils<span class="hljs-selector-class">.o</span> -f elf32 asm_utils<span class="hljs-selector-class">.asm</span><br>g++ -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.out</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> c_func<span class="hljs-selector-class">.o</span> cpp_func<span class="hljs-selector-class">.o</span> asm_utils<span class="hljs-selector-class">.o</span> -m32<br></code></pre></td></tr></table></figure><p><code>-f elf32</code>指定了nasm编译生成的文件格式是<code>ELF32</code>文件格式<br><img src="/img/file-20250402154026967.png"></p><h3 id="Example2：内核加载"><a href="#Example2：内核加载" class="headerlink" title="Example2：内核加载"></a>Example2：内核加载</h3><p>项目结构：</p><ul><li><code>project/build</code>。存放Makefile，make之后生成的中间文件如<code>.o</code>，<code>.bin</code>等会放置在这里，目的是防止这些文件混在代码文件中。</li><li><code>project/include</code>。存放<code>.h</code>等函数定义和常量定义的头文件等。</li><li><code>project/run</code>。存放gdb配置文件，硬盘映像<code>.img</code>文件等。</li><li><code>project/src</code>。存放<code>.c</code>，<code>.cpp</code>等函数实现的文件。</li></ul><p>不需要在.cpp文件中写出.h的具体地址，只需要在编译时指出include和.cpp文件的地址就行了。<br>编译指令中使用<code>-I</code>参数指明<strong>头文件的位置</strong>即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ -o hello -<span class="hljs-selector-tag">I</span>../include ../<span class="hljs-attribute">src</span>/hello<span class="hljs-selector-class">.cpp</span><br></code></pre></td></tr></table></figure><p>mbr &#x3D;&gt; bootloader &#x3D;&gt; kernel<br>进入内核后，定义内核起始点<br>src&#x2F;boot&#x2F;entry.asm：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">extern setup_kernel<br><span class="hljs-symbol">enter_kernel:</span><br>    <span class="hljs-keyword">jmp</span> setup_kernel<br></code></pre></td></tr></table></figure><p>在链接阶段巧妙地将<code>entry.asm</code>的代码放在内核代码的最开始部分，使得bootloader在执行跳转之后，转到的就是内核代码的起始指令，执行 <code>jmp setup_kernel</code> 。然后就跳转到了C++编写的函数<code>setup_kernel</code>，即可以使用c++来写内核了。</p><p>运行代码：<br>way1：不使用makefile</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd build<br><span class="hljs-comment"># 编译mbr和bootloader</span><br>nasm -o mbr.bin -f bin -I<span class="hljs-built_in">..</span>/include/ <span class="hljs-built_in">..</span>/src/boot/mbr.asm<br>nasm -o bootloader.bin -f bin -I<span class="hljs-built_in">..</span>/include/ <span class="hljs-built_in">..</span>/src/boot/bootloader.asm<br><span class="hljs-comment"># `-I`参数指定了头文件路径，`-f`指定了生成的文件格式是二进制的文件。</span><br><br><span class="hljs-comment"># 编译内核的代码，将所有的代码都统一编译成可重定位文件，然后再链接成一个可执行文件</span><br><span class="hljs-comment"># 编译 entry.asm和asm_utils.asm</span><br>nasm -o entry.obj -f elf32 <span class="hljs-built_in">..</span>/src/boot/entry.asm<br>nasm -o asm_utils.o -f elf32 <span class="hljs-built_in">..</span>/src/utils/asm_utils.asm<br><br><span class="hljs-comment"># 编译setup.cpp</span><br>g++ -g -Wall <span class="hljs-attribute">-march</span>=i386 -m32 -nostdlib -fno-builtin -ffreestanding -fno-pic -I<span class="hljs-built_in">..</span>/include -c <span class="hljs-built_in">..</span>/src/kernel/setup.cpp<br><br><span class="hljs-comment"># 链接生成可重定位文件：kernel.bin和kernel.o（只包含代码的文件和可执行文件）</span><br><br>ld -o kernel.o -melf_i386 -N entry.obj setup.o asm_utils.o -e enter_kernel -Ttext 0x00020000<br>ld -o kernel.bin -melf_i386 -N entry.obj setup.o asm_utils.o -e enter_kernel -Ttext 0x00020000 --oformat binary<br><br><span class="hljs-comment"># 最后将mbr.bin bootloader.bin kernel.bin写入硬盘</span><br><br>dd <span class="hljs-attribute">if</span>=mbr.bin <span class="hljs-attribute">of</span>=../run/hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1 <span class="hljs-attribute">seek</span>=0 <span class="hljs-attribute">conv</span>=notrunc<br>dd <span class="hljs-attribute">if</span>=bootloader.bin <span class="hljs-attribute">of</span>=../run/hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=5 <span class="hljs-attribute">seek</span>=1 <span class="hljs-attribute">conv</span>=notrunc<br>dd <span class="hljs-attribute">if</span>=kernel.bin <span class="hljs-attribute">of</span>=../run/hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=200 <span class="hljs-attribute">seek</span>=6 <span class="hljs-attribute">conv</span>=notrunc<br><br><span class="hljs-comment"># 在run目录下启动</span><br><br>qemu-system-i386 -hda <span class="hljs-built_in">..</span>/run/hd.img -serial <span class="hljs-literal">null</span> -parallel stdio -no-reboot<br><br></code></pre></td></tr></table></figure><p>way2：使用makefile</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">cd build<br><span class="hljs-built_in">make</span><br><span class="hljs-built_in">make</span> <span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><p><img src="/img/file-20250402165250552.png"></p><p><strong>一些解释：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">g++ -g -Wall -march<span class="hljs-operator">=</span><span class="hljs-type">i386</span> -m<span class="hljs-number">32</span> -nostdlib -fno-<span class="hljs-keyword">builtin</span> -ffreestanding -fno-pic -I../include -<span class="hljs-keyword">c</span> ../src/kernel/setup.cpp<br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><code>-O0</code>告诉编译器<strong>不开启编译优化</strong>。（如果要开启有几种可以选择，O1,O2,O3…</li><li><code>-Wall</code>告诉编译器<strong>显示所有编译器警告信息</strong></li><li><code>-march=i386</code>告诉编译器生成i386处理器下的<code>.o</code>文件格式。</li><li><code>-m32</code>告诉编译器生成<strong>32位</strong>的二进制文件。</li><li><code>-nostdlib -fno-builtin -ffreestanding -fno-pic</code>是告诉编译器不要包含C的任何标准库。</li><li><code>-g</code>表示向生成的文件中加入debug信息供gdb使用。</li><li><code>-I</code>指定了代码需要的头文件的目录。</li><li><code>-c</code>表示生成可重定位文件。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld -o kernel<span class="hljs-selector-class">.o</span> -melf_i386 -N entry<span class="hljs-selector-class">.obj</span> setup<span class="hljs-selector-class">.o</span> asm_utils<span class="hljs-selector-class">.o</span> -e enter_kernel -Ttext <span class="hljs-number">0</span>x00020000<br><br>ld -o kernel<span class="hljs-selector-class">.bin</span> -melf_i386 -N entry<span class="hljs-selector-class">.obj</span> setup<span class="hljs-selector-class">.o</span> asm_utils<span class="hljs-selector-class">.o</span> -e enter_kernel -Ttext <span class="hljs-number">0</span>x00020000 <span class="hljs-attr">--oformat</span> binary<br></code></pre></td></tr></table></figure><ul><li><code>-m</code>参数指定<strong>模拟器为i386</strong>。</li><li><code>-N</code>参数告诉链接器<strong>不要进行页对齐</strong>。</li><li><code>-Ttext</code>指定标号的起始地址。</li><li><code>-e</code>参数<strong>指定程序进入点</strong>。</li><li><code>--oformat</code>指定<strong>输出文件格式</strong>。<blockquote><p>[!NOTE]<br>为什么要生成两个文件呢？注意到上面两条指令差别仅在于是否有<code>-oformat binary</code>。实际上，<code>kernel.o</code>也是<code>ELF32</code>格式的，其不仅包含代码和数据，还包含<code>debug</code>信息和<code>elf</code>文件信息等。特别地，<code>kernel.o</code>开头并不是内核进入点，而是<code>ELF</code>的文件头，因此我们需要解析ELF文件才能找到真正的内核进入点。</p></blockquote></li></ul><p>&#x3D;&gt;为了简便，我们只希望链接生成的文件只有内核的代码，不包含其他信息。</p><blockquote><p>[!NOTE]<br>输出的二进制文件的机器指令顺序和<strong>链接时给出的文件顺序</strong>相同<br>所以要注意把entry.o放到最前面</p></blockquote><h2 id="保护模式下的中断"><a href="#保护模式下的中断" class="headerlink" title="保护模式下的中断"></a>保护模式下的中断</h2><p>中断：在外设产生请求时，通过一种信号告诉CPU应该暂停当前状态，转向处理外设请求，处理完之后再恢复到原先暂停的状态继续运行。<br>中断：</p><ul><li>外部中断（硬件产生，硬中断）<ul><li>屏蔽中断–INTR引脚产生</li><li>不可屏蔽中断–NMI引脚产生</li></ul></li><li>内部中断（软件产生，在程序中使用int指令调用，软中断）</li></ul><p>保护模式下的中断向量号：</p><table><thead><tr><th>向量号</th><th>助记符</th><th>说明</th><th>类型</th><th>错误号</th><th>产生源</th></tr></thead><tbody><tr><td>0</td><td>#DE</td><td>除出错</td><td>故障</td><td>无</td><td>DIV或IDIV指令</td></tr><tr><td>1</td><td>#DB</td><td>调试</td><td>故障&#x2F;陷阱</td><td>无</td><td>任何代码或数据引用，或是INT 1指令</td></tr><tr><td>2</td><td>–</td><td>NMI中断</td><td>中断</td><td>无</td><td>非屏蔽外部中断</td></tr><tr><td>3</td><td>#BP</td><td>断点</td><td>陷阱</td><td>无</td><td>INT 3指令</td></tr><tr><td>4</td><td>#OF</td><td>溢出</td><td>陷阱</td><td>无</td><td>INTO指令</td></tr><tr><td>5</td><td>#BR</td><td>边界范围超出</td><td>故障</td><td>无</td><td>BOUND指令</td></tr><tr><td>6</td><td>#UD</td><td>无效操作码（未定义操作码）</td><td>故障</td><td>无</td><td>UD2指令或保留的操作码。（Pentium Pro中加入的新指令）</td></tr><tr><td>7</td><td>#NM</td><td>设备不存在（无数学协处理器）</td><td>故障</td><td>无</td><td>浮点或WAIT&#x2F;FWAIT指令</td></tr><tr><td>8</td><td>#DF</td><td>双重错误</td><td>异常终止</td><td>有（0）</td><td>任何可产生异常、NMI或INTR的指令</td></tr><tr><td>9</td><td>–</td><td>协处理器段超越（保留）</td><td>故障</td><td>无</td><td>浮点指令（386以后的CPU不产生该异常）</td></tr><tr><td>10</td><td>#TS</td><td>无效的任务状态段TSS</td><td>故障</td><td>有</td><td>任务交换或访问TSS</td></tr><tr><td>11</td><td>#NP</td><td>段不存在</td><td>故障</td><td>有</td><td>加载段寄存器或访问系统段</td></tr><tr><td>12</td><td>#SS</td><td>堆栈段错误</td><td>故障</td><td>有</td><td>堆栈操作和SS寄存器加载</td></tr><tr><td>13</td><td>#GP</td><td>一般保护错误</td><td>故障</td><td>有</td><td>任何内存引用和其他保护检查</td></tr><tr><td>14</td><td>#PF</td><td>页面错误</td><td>故障</td><td>有</td><td>任何内存引用</td></tr><tr><td>15</td><td>–</td><td>（Intel保留，请勿使用）</td><td></td><td>无</td><td></td></tr><tr><td>16</td><td>#MF</td><td>x87 FPU浮点错误（数学错误）</td><td>故障</td><td>无</td><td>x87 FPU浮点或WAIT&#x2F;FWAIT指令</td></tr><tr><td>17</td><td>#AC</td><td>对起检查</td><td>故障</td><td>有（0）</td><td>对内存中任何数据的引用</td></tr><tr><td>18</td><td>#MC</td><td>机器检查</td><td>异常终止</td><td>无</td><td>错误码（若有）和产生源与CPU类型有关（奔腾处理器引进）</td></tr><tr><td>19</td><td>#XF</td><td>SIMD浮点异常</td><td>故障</td><td>无</td><td>SSE和SSE2浮点指令（PIII处理器引进）</td></tr><tr><td>20-31</td><td>–</td><td>（Intel保留，请勿使用）</td><td></td><td></td><td></td></tr><tr><td>32-255</td><td>–</td><td>用户定义（非保留）中断</td><td>中断</td><td></td><td>外部中断或者INT n指令</td></tr></tbody></table><h3 id="中断处理机制"><a href="#中断处理机制" class="headerlink" title="中断处理机制"></a>中断处理机制</h3><p>保护模式下中断处理程序处理过程：</p><ul><li>中断前的准备。</li><li>CPU 检查是否有<strong>中断信号</strong>。</li><li>CPU根据<strong>中断向量号</strong>到IDT中取得处理这个向量的<strong>中断描述符</strong>。</li><li>CPU根据中断描述符中的段选择符到 GDT 中找到相应的段描述符。</li><li>CPU 根据特权级的判断设定即将运行程序的栈地址。</li><li>CPU保护现场。</li><li>CPU跳转到中断服务程序的第一条指令开始处执行。</li><li>中断服务程序运行。</li><li>中断服务程序处理完成，使用iret返回。</li></ul><h4 id="中断前的准备"><a href="#中断前的准备" class="headerlink" title="中断前的准备"></a>中断前的准备</h4><ul><li><p>为了标识中断处理程序的位置，保护模式使用了中断描述符（64位）。<br><img src="/img/file-20250402171903443.png"></p></li><li><p>段选择子：中断程序所在段的选择子。</p></li><li><p>偏移量：中断程序的代码在中断程序所在段的偏移位置。</p></li><li><p>P位：段存在位。 0表示不存在，1表示存在。</p></li><li><p>DPL：特权级描述。 0-3 共4级特权，特权级从0到3依次降低。</p></li><li><p>D位： D&#x3D;1表示32位代码，D&#x3D;0表示16位代码。</p></li><li><p>保留位：保留不使用。</p></li></ul><p>中断描述符的结合被称为中断描述符表IDT，并存放在IDTR中。<br><img src="/img/file-20250402172029124.png"><br>中断描述符最多有2^16&#x2F;2^3&#x3D;2^13<br>但CPU只能处理前256个中断，所以我们只会往IDT中放入256个中断描述符。<br>类似地，我们使用<strong>lidt指令</strong>对IDTR赋值<br><img src="/img/file-20250402172325228.png" alt="使用lgdt为GDTR赋值"></p><h4 id="CPU检查是否有中断信号"><a href="#CPU检查是否有中断信号" class="headerlink" title="CPU检查是否有中断信号"></a>CPU检查是否有中断信号</h4><ul><li>除了主动调用中断之外，CPU<strong>每执行完一条指令</strong>之后，就回去中断控制器8259A中检查是否有中断请求。</li><li>若有中断请求，在相应的时钟脉冲到来时，CPU就会<strong>从总线上读取中断向量号</strong>。</li><li>根据中断向量号到IDT中取得对应的<strong>中断描述符</strong>（中断的向量号就是中断描述符在IDT的序号）</li><li>CPU根据中断描述符中的<strong>段选择符</strong>到<strong>GDT</strong>中找到相应的段描述符</li><li>CPU 根据特权级的判断设定即将运行程序的栈地址</li><li>CPU保护现场<ul><li>依次将EFLAGS，CS，EIP中的内容压栈（特权级不变时）</li><li>从用户态切换到内核态后，CPU会依次将SS，ESP，EFLAGS、CS、EIP压栈（特权级改变时）</li></ul></li><li>CPU跳转到中断服务程序的第一条指令开始处执行</li><li>中断服务程序运行</li><li><strong>中断服务程序处理完成，使用iret返回。</strong> <ul><li>在特权级不发生变化的情况下，iret会将之前压入栈的EFLAGS，CS，EIP的值送入对应的寄存器，然后便实现了中断返回。若特权级发生变化，CPU还会更新SS和ESP。</li></ul></li></ul><h3 id="Example3"><a href="#Example3" class="headerlink" title="Example3"></a>Example3</h3><p>&#x3D;&gt;what to do：初始化IDT的256个中断</p><ul><li>这256个中断的中断处理程序均是向栈中压入<code>0xdeadbeef</code>后做死循环。<br>我们要做的事情只有三件。</li><li>确定IDT的地址。</li><li>定义中断默认处理函数。</li><li>初始化256个中断描述符。</li></ul><h4 id="中断管理器"><a href="#中断管理器" class="headerlink" title="中断管理器"></a>中断管理器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INTERRUPT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERRUPT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;os_type.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptManager</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    <span class="hljs-comment">// IDT起始地址</span><br>    uint32 *IDT;<br>    <br>public:<br>    InterruptManager();<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 设置中断描述符</span><br>    <span class="hljs-comment">// index   第index个描述符，index=0, 1, ..., 255</span><br>    <span class="hljs-comment">// address 中断处理程序的起始地址</span><br>    <span class="hljs-comment">// DPL     中断描述符的特权级</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setInterruptDescriptor</span><span class="hljs-params">(uint32 index, uint32 address, byte DPL)</span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h5 id="初始化IDT-initialize"><a href="#初始化IDT-initialize" class="headerlink" title="初始化IDT: initialize()"></a>初始化IDT: <code>initialize()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::initialize</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 初始化IDT</span><br>    IDT = (uint32 *)IDT_START_ADDRESS;<br>    asm_lidt(IDT_START_ADDRESS, <span class="hljs-number">256</span> * <span class="hljs-number">8</span> - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i)<br>    &#123;<br>        setInterruptDescriptor(i, (uint32)asm_interrupt_empty_handler, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置IDT地址，然后初始化256个中断描述符（每个8字节）</p><ul><li>IDT_START_ADDRESS&#x3D;…</li><li>CPU&#x3D;&gt;IDTR&#x3D;&gt;IDT<ul><li>CPU先到IDTR寻找IDT的地址</li><li>根据中断向量号在IDT找到对应的中断描述符</li><li>跳转到对应的函数</li></ul></li><li>此处确定IDTR的32位基地址为0x8880，表界限为2047（8 * 256 - 1）</li><li><code>lidt [tag]</code><ul><li>将以tag为起始地址的48字节放入到寄存器IDTR中</li><li>C语言中初始化IDT的方法：在汇编代码中实现函数 <code>asm_lidt</code> 用于将IDT信息放入到IDTR中</li></ul></li></ul><h5 id="定义中断描述符"><a href="#定义中断描述符" class="headerlink" title="定义中断描述符"></a>定义中断描述符</h5><p>中断描述符中有几个值是定值：</p><ul><li>P&#x3D;1表示存在。</li><li>D&#x3D;1表示32位代码。</li><li>DPL&#x3D;0表示特权级0.</li><li>代码段选择子等于bootloader中的代码段选择子，也就是寻址4GB空间的代码段选择子。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置中断描述符</span><br><span class="hljs-comment">// index   第index个描述符，index=0, 1, ..., 255</span><br><span class="hljs-comment">// address 中断处理程序的起始地址</span><br><span class="hljs-comment">// DPL     中断描述符的特权级</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::setInterruptDescriptor</span><span class="hljs-params">(uint32 index, uint32 address, byte DPL)</span><br>&#123;<br>    IDT[index * <span class="hljs-number">2</span>] = (CODE_SELECTOR &lt;&lt; <span class="hljs-number">16</span>) | (address &amp; <span class="hljs-number">0xffff</span>);<br>    IDT[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = (address &amp; <span class="hljs-number">0xffff0000</span>) | (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">15</span>) | (DPL &lt;&lt; <span class="hljs-number">13</span>) | (<span class="hljs-number">0xe</span> &lt;&lt; <span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>IDT是起始地址指针</li></ul><h5 id="中断默认处理函数"><a href="#中断默认处理函数" class="headerlink" title="中断默认处理函数"></a>中断默认处理函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">ASM_UNHANDLED_INTERRUPT_INFO db &#x27;Unhandled interrupt happened, halt...&#x27;<br>                             db 0<br><br>; void asm_unhandled_interrupt()<br>asm_unhandled_interrupt:<br>    cli ;关中断<br>    mov esi, ASM_UNHANDLED_INTERRUPT_INFO ;提示字符串<br>    xor ebx, ebx<br>    mov ah, 0x03<br>.output_information:<br>    cmp byte[esi], 0<br>    je .end<br>    mov al, byte[esi]<br>    mov word[gs:bx], ax<br>    inc esi<br>    add ebx, 2<br>    jmp .output_information<br>.end:<br>    jmp $<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250405172317304.png"></p><p><img src="/img/file-20250405172728632.png"></p><h2 id="8259A-芯片（可编程中断控制器）"><a href="#8259A-芯片（可编程中断控制器）" class="headerlink" title="8259A 芯片（可编程中断控制器）"></a>8259A 芯片（可编程中断控制器）</h2><blockquote><p>[!NOTE]<br>硬中断和软中断指示调用方式不同，而中断的初始化和中断描述符的设置方式是完全相同的</p></blockquote><p>计算机需要知道这些中断请求的中断向量号和优先级，可以通过8259A芯片解决（用代码来修改其处理优先级、屏蔽某个中断等）</p><h3 id="8259A的初始化"><a href="#8259A的初始化" class="headerlink" title="8259A的初始化"></a>8259A的初始化</h3><p>初始化过程是<strong>依次通过向8259A的特定端口发送4个ICW</strong>，ICW1~ICW4（初始化命令字，Initialization Command Words）来完成的。</p><blockquote><p>[!NOTE]<br>四个ICW必须严格按照顺序依次发送</p></blockquote><h4 id="ICW结构"><a href="#ICW结构" class="headerlink" title="ICW结构"></a>ICW结构</h4><h5 id="ICW1：发送到0x20端口（主片）和0xA0端口（从片）"><a href="#ICW1：发送到0x20端口（主片）和0xA0端口（从片）" class="headerlink" title="ICW1：发送到0x20端口（主片）和0xA0端口（从片）"></a>ICW1：发送到0x20端口（主片）和0xA0端口（从片）</h5><p><img src="/img/file-20250405173725507.png"></p><ul><li><p>I位：若<strong>置1</strong>，表示<strong>ICW4会被发送</strong>。置0表示ICW4不会被发送。我们会发送ICW4，所以I位置1。</p></li><li><p>C位：若<strong>置0</strong>，表示8259A工作在&#x3D;&#x3D;级联&#x3D;&#x3D;环境下。8259A的主片和从片我们都会使用到，所以C位置0。</p></li><li><p>M位：指出中断请求的<strong>电平触发模式</strong>，在PC机中，M位应当被置0，表示采用“<strong>边沿触发模式</strong>”。</p></li></ul><h5 id="ICW2：发送到0x21（主片）和0xA1（从片）端口"><a href="#ICW2：发送到0x21（主片）和0xA1（从片）端口" class="headerlink" title="ICW2：发送到0x21（主片）和0xA1（从片）端口"></a>ICW2：发送到0x21（主片）和0xA1（从片）端口</h5><p><img src="/img/file-20250405173905771.png"></p><p>对于主片和从片，ICW2都是用来表示当&#x3D;&#x3D;IRQ0&#x3D;&#x3D;的中断发生时，8259A会向CPU提供的中断向量号。</p><p>此后，IRQ0，IRQ1，…，IRQ7的<strong>中断号</strong>为ICW2，ICW2+1，ICW2+2，…，ICW2+7。</p><p>&#x3D;&#x3D;ICW2的低3位必须是0&#x3D;&#x3D;</p><h5 id="ICW3：发送到0x21（主片）和0xA1（从片）端口"><a href="#ICW3：发送到0x21（主片）和0xA1（从片）端口" class="headerlink" title="ICW3：发送到0x21（主片）和0xA1（从片）端口"></a>ICW3：发送到0x21（主片）和0xA1（从片）端口</h5><ul><li>ICW3只有在级联工作时才会被发送，主要用来建立两处PIC之间的连接，对于主片和从片，其结构是不一样的</li><li>主片：<br><img src="/img/file-20250405174025929.png"><br>上面的相应位被置1，则相应的IRQ线就被用作于与从片相连，若置0则表示被连接到外围设备。</li></ul><p>从片被连接到主片的IRQ2位，所以主片只有第2位被置1&#x3D;&gt;主片<strong>ICW3&#x3D;0x04</strong></p><ul><li>从片：<br><img src="/img/file-20250405174118941.png"><br>IRQ指出是主片的哪一个IRQ连接到了从片，这里，从片的<strong>ICW3&#x3D;0x02</strong>，即IRQ&#x3D;0x02，其他位置均为0。</li></ul><h5 id="ICW4：发送到0x21（主片）和0xA1（从片）端口"><a href="#ICW4：发送到0x21（主片）和0xA1（从片）端口" class="headerlink" title="ICW4：发送到0x21（主片）和0xA1（从片）端口"></a>ICW4：发送到0x21（主片）和0xA1（从片）端口</h5><p><img src="/img/file-20250405174414639.png"></p><ul><li><p>EOI位：若置1表示<strong>自动结束</strong>，在PC位上这位需要被清零，详细原因在后面再提到。</p></li><li><p>80x86位：置1表示PC工作在80x86架构下，因此我们置1。</p></li></ul><blockquote><p>[!NOTE]<br>ICW1,ICW3,ICW4的值已经固定，可变的只有ICW2</p></blockquote><h3 id="8259A的工作流程"><a href="#8259A的工作流程" class="headerlink" title="8259A的工作流程"></a>8259A的工作流程</h3><p>（无需掌握）</p><blockquote><p>[!NOTE]<br><strong>对于8259A芯片产生的中断，我们需要手动在中断返回前向8259A发送EOI消息。如果没有发送EOI消息，那么此后的中断便不会被响应</strong></p></blockquote><p>发送EOI消息的示例代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;发送OCW2字</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>, <span class="hljs-built_in">al</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>, <span class="hljs-built_in">al</span><br></code></pre></td></tr></table></figure><ul><li>8259A的中断处理函数末尾必须加上这段代码，否则中断不会被响应</li></ul><h3 id="优先级、中断屏蔽字和EOI消息的动态改变"><a href="#优先级、中断屏蔽字和EOI消息的动态改变" class="headerlink" title="优先级、中断屏蔽字和EOI消息的动态改变"></a>优先级、中断屏蔽字和EOI消息的动态改变</h3><p><strong>初始化</strong>8259A后，可以在任何时优先级、中断屏蔽字和EOI消息的动态改变候<strong>发送OCW</strong>（Operation Command Words）字来实现</p><p>OCW有三个：OCW1，OCW2，OCW3</p><ul><li><p>OCW1：中断屏蔽，发送到0x21（主片）或0xA1（从片）端口<br><img src="/img/file-20250409142738523.png"><br>位置1表示<strong>屏蔽相应的IRQ请求</strong>。<br>在初始化8259A的代码末尾，将0xFF发送到0x21和0xA1端口。这是因为我们还没建立起处理8259A芯片的中断处理函数，所以暂时屏蔽主片和从片的所有中断。</p></li><li><p>OCW2：一般用于<strong>发送EOI消息</strong>，发送到0x20（主片）或0xA0（从片）端口。<br><img src="/img/file-20250409142845513.png"><br>EOI消息是发送<code>0x20</code>，即<strong>只有EOI位是1</strong>，<strong>其他位置为0</strong>。</p></li><li><p>OCW3：用于<u>设置下一个读端口动作将要读取的IRR或ISR</u>，我们不需要使用。</p></li></ul><h3 id="中断程序编写思路"><a href="#中断程序编写思路" class="headerlink" title="中断程序编写思路"></a>中断程序编写思路</h3><ul><li><strong>保护现场</strong>。保存寄存器中的内容（压栈）</li><li><strong>中断处理</strong>。执行中断处理程序</li><li><strong>恢复现场</strong>。处理完中断后恢复之前放在栈中的寄存器内容，然后执行 <code>iret</code> 返回。执行 <code>iret</code>前，如果有错误码，则需要将错误码弹出栈；如果是8259A芯片产生的中断，则需要在中断返回前发送EOI消息。<ul><li>注意，8259A芯片产生的中断不会错误码。事实上，只有中断向量号1-19的部分中断才会产生错误码。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">interrupt_handler_example:</span><br><span class="hljs-keyword">pushad</span><br>... <span class="hljs-comment">; 中断处理程序</span><br><span class="hljs-keyword">popad</span><br><br><span class="hljs-comment">; 非必须</span><br><br><span class="hljs-comment">; 1 弹出错误码，没有则不可以加入</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span><br><br><span class="hljs-comment">; 2 对于8259A芯片产生的中断，最后需要发送EOI消息，若不是则不可以加入</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>, <span class="hljs-built_in">al</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>, <span class="hljs-built_in">al</span><br><br><span class="hljs-keyword">iret</span> <span class="hljs-comment">;中断返回</span><br></code></pre></td></tr></table></figure><h3 id="Example4-8259A编程"><a href="#Example4-8259A编程" class="headerlink" title="Example4 8259A编程"></a>Example4 8259A编程</h3><p><img src="/img/file-20250409144538936.png"></p><ul><li>初始化8259A芯片：</li></ul><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">void</span> InterruptManager::initialize<span class="hljs-number">8259</span>A()<br>&#123;<br>    <span class="hljs-comment">// ICW 1</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">20</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span>);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">0</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span>);<br>    <span class="hljs-comment">// ICW 2</span><br>    IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_M</span>ASTER = <span class="hljs-number">0</span>x<span class="hljs-number">20</span>;<br>    IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_</span>SLAVE = <span class="hljs-number">0</span>x<span class="hljs-number">28</span>;<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_M</span>ASTER);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_</span>SLAVE);<br>    <span class="hljs-comment">// ICW 3</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, <span class="hljs-number">4</span>);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// ICW 4</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, <span class="hljs-number">1</span>);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// OCW 1 屏蔽主片所有中断，但主片的IRQ2需要开启</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, <span class="hljs-number">0</span>xfb);<br>    <span class="hljs-comment">// OCW 1 屏蔽从片所有中断</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, <span class="hljs-number">0</span>xff);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化8259A芯片的过程是通过设置一系列的ICW字来完成的。由于我们并未建立处理8259A中断的任何函数，因此在初始化的最后，我们需要屏蔽主片和从片的所有中断。</p><ul><li><code>asm_out_port</code> 是对 <code>out</code> 指令的封装</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_out_port:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">2</span>] <span class="hljs-comment">; port</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">3</span>] <span class="hljs-comment">; value</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>    <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><ul><li><code>asm_in_port</code> 是对 <code>in</code> 指令的封装</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; void asm_in_port(uint16 port, uint8 *value)</span><br><span class="hljs-symbol">asm_in_port:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span><br><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">2</span>] <span class="hljs-comment">; port</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">3</span>] <span class="hljs-comment">; *value</span><br><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">ebx</span>], <span class="hljs-built_in">al</span><br><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><ul><li>处理时钟中断：主片的IRQ0中断<ul><li>8253芯片能以一定频率来产生时钟中断。当产生了时钟中断后，信号会被8259A截获，从而产生IRQ0中断。处理时钟中断：<ul><li>编写中断处理函数</li><li>设置主片IRQ0中断对应的中断描述符</li><li>开启时钟中断</li><li>开中断</li></ul></li></ul></li></ul><p>&#x3D;&gt;编写中断处理函数：<br>不再使用放置字符到显存地址的方式来显示字符，而是去封装一个函数来处理屏幕输出的类 <code>STDIO</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STDIO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDIO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;os_type.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">STDIO</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    uint8 *screen;<br><br>public:<br>    STDIO();<br>    <span class="hljs-comment">// 初始化函数</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 打印字符c，颜色color到位置(x,y)</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(uint x, uint y, uint8 c, uint8 color)</span>;<br>    <span class="hljs-comment">// 打印字符c，颜色color到光标位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(uint8 c, uint8 color)</span>;<br>    <span class="hljs-comment">// 打印字符c，颜色默认到光标位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(uint8 c)</span>;<br>    <span class="hljs-comment">// 移动光标到一维位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">moveCursor</span><span class="hljs-params">(uint position)</span>;<br>    <span class="hljs-comment">// 移动光标到二维位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">moveCursor</span><span class="hljs-params">(uint x, uint y)</span>;<br>    <span class="hljs-comment">// 获取光标位置</span><br>    uint <span class="hljs-title function_">getCursor</span><span class="hljs-params">()</span>;<br><br>public:<br>    <span class="hljs-comment">// 滚屏</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">rollUp</span><span class="hljs-params">()</span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>处理光标位置<ul><li>与光标读写相关的端口： <code>0x3d4</code> 和 <code>0x3d5</code></li><li>需要向端口<code>0x3d4</code>写入数据，表明处理的是高8位（0x0e）还是低8位(0x0f)</li><li>从<code>0x3d5</code>读取数据可以读取到光标的位置，如果要改变光标的位置，将新位置写入&#96;0x3d5<br>  移动光标：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">STDIO::moveCursor</span><span class="hljs-params">(uint position)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">80</span> * <span class="hljs-number">25</span>) <span class="hljs-comment">//判断是否溢出</span><br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    uint8 temp;<br><br>    <span class="hljs-comment">// 处理高8位</span><br>    temp = (position &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;<br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0e</span>);<br>    asm_out_port(<span class="hljs-number">0x3d5</span>, temp);<span class="hljs-comment">//out--写入</span><br><br>    <span class="hljs-comment">// 处理低8位</span><br>    temp = position &amp; <span class="hljs-number">0xff</span>;<br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0f</span>);<br>    asm_out_port(<span class="hljs-number">0x3d5</span>, temp);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取光标：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">uint <span class="hljs-title function_">STDIO::getCursor</span><span class="hljs-params">()</span><br>&#123;<br>    uint pos;<br>    uint8 temp;<br><br>    pos = <span class="hljs-number">0</span>;<br>    temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 处理高8位</span><br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0e</span>);<br>    asm_in_port(<span class="hljs-number">0x3d5</span>, &amp;temp);<span class="hljs-comment">//in--读取</span><br>    pos = ((uint)temp) &lt;&lt; <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">// 处理低8位</span><br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0f</span>);<br>    asm_in_port(<span class="hljs-number">0x3d5</span>, &amp;temp);<br>    pos = pos | ((uint)temp);<br><br>    <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>中断处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 中断处理函数</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">void</span> <span class="hljs-title function_">c_time_interrupt_handler</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 清空屏幕</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80</span>; ++i)<br>    &#123;<br>        stdio.print(<span class="hljs-number">0</span>, i, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0x07</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出中断发生的次数</span><br>    ++times;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;interrupt happend: &quot;</span>;<br>    <span class="hljs-type">char</span> number[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> temp = times;<br><br>    <span class="hljs-comment">// 将数字转换为字符串表示</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i ) &#123;<br>        <span class="hljs-keyword">if</span>(temp) &#123;<br>            number[i] = temp % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            number[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        temp /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动光标到(0,0)输出字符</span><br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; ++i ) &#123;<br>        stdio.print(str[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出中断发生的次数</span><br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">9</span>; i &gt; <span class="hljs-number">0</span>; --i ) &#123;<br>        stdio.print(number[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面这个函数还不完全是一个中断处理函数，因为我们进入中断后需要保护现场，离开中断需要恢复现场</strong>。这里，现场指的是寄存器的内容。但是，C语言并未提供相关指令。最重要的是，中断的返回需要使用<code>iret</code>指令，而C语言的任何函数编译出来的返回语句都是<code>ret</code>。因此，我们<strong>只能在汇编代码中完成保护现场、恢复现场和中断返回</strong></p><p>中断发生后 &#x3D;&gt; CPU跳转到汇编实现的代码 &#x3D;&gt; 使用汇编代码保存寄存器的内容 &#x3D;&gt; 保护现场后，调用 <code>call</code> 指令来跳转到C语言编写的中断函数主题 &#x3D;&gt; C语言函数返回后 &#x3D;&gt; 返回到 <code>call</code> 指令的下一条汇编代码 &#x3D;&gt; 汇报代码中恢复保存的寄存器内容 &#x3D;&gt; <code>iret</code>返回</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_time_interrupt_handler:</span><br>    <span class="hljs-keyword">pushad</span><br>    <br>    <span class="hljs-keyword">nop</span> <span class="hljs-comment">; 否则断点打不上去</span><br>    <span class="hljs-comment">; 发送EOI消息，否则下一次中断不发生</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>, <span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>, <span class="hljs-built_in">al</span><br>    <br>    <span class="hljs-keyword">call</span> c_time_interrupt_handler<br><br>    <span class="hljs-keyword">popad</span><br>    <span class="hljs-keyword">iret</span><br></code></pre></td></tr></table></figure><ul><li><p><code>pushad</code>指令是将<code>EAX</code>,<code>ECX</code>,<code>EDX</code>,<code>EBX</code>,<code>ESP</code>,<code>EBP</code>,<code>ESI</code>,<code>EDI</code>依次入栈，<code>popad</code>则相反</p></li><li><p>对于8259A芯片产生的中断，我们需要在中断返回前发送EOI消息。否则，8259A不会产生下一次中断。</p></li><li><p>设置中断描述符</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::setTimeInterrupt</span><span class="hljs-params">(<span class="hljs-type">void</span> *handler)</span><br>&#123;<br>    setInterruptDescriptor(IRQ0_8259A_MASTER, (uint32)handler, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>封装开启和关闭时钟中断的函数<ul><li>读取OCW1可以得知中断开启情况</li><li>要修改中断开启情况：先读取再写入对应的OCW1</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::enableTimeInterrupt</span><span class="hljs-params">()</span><br>&#123;<br>    uint8 value;<br>    <span class="hljs-comment">// 读入主片OCW</span><br>    asm_in_port(<span class="hljs-number">0x21</span>, &amp;value);<br>    <span class="hljs-comment">// 开启主片时钟中断，置0开启</span><br>    value = value &amp; <span class="hljs-number">0xfe</span>;<br>    asm_out_port(<span class="hljs-number">0x21</span>, value);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::disableTimeInterrupt</span><span class="hljs-params">()</span><br>&#123;<br>    uint8 value;<br>    asm_in_port(<span class="hljs-number">0x21</span>, &amp;value);<br>    <span class="hljs-comment">// 关闭时钟中断，置1关闭</span><br>    value = value | <span class="hljs-number">0x01</span>;<br>    asm_out_port(<span class="hljs-number">0x21</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><h3 id="Assignment-1-混合编程的基本思路"><a href="#Assignment-1-混合编程的基本思路" class="headerlink" title="Assignment 1 混合编程的基本思路"></a>Assignment 1 混合编程的基本思路</h3><p>复现Example 1，结合具体的代码说明C代码调用汇编函数的语法和汇编代码调用C函数的语法。例如，结合代码说明<code>global</code>、<code>extern</code>关键字的作用，为什么C++的函数前需要加上<code>extern &quot;C&quot;</code>等， 结果截图并说说你是怎么做的。同时，学习make的使用，并用make来构建Example 1，结果截图并说说你是怎么做的。</p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><h3 id="Assignment-2-使用C-C-来编写内核"><a href="#Assignment-2-使用C-C-来编写内核" class="headerlink" title="Assignment 2 使用C&#x2F;C++来编写内核"></a>Assignment 2 使用C&#x2F;C++来编写内核</h3><p>复现Example 2，在进入<code>setup_kernel</code>函数后，将输出 Hello World 改为输出你的学号，结果截图并说说你是怎么做的。</p><h3 id="Assignment-3-中断的处理"><a href="#Assignment-3-中断的处理" class="headerlink" title="Assignment 3 中断的处理"></a>Assignment 3 中断的处理</h3><p>复现Example 3，你可以更改Example中默认的中断处理函数为你编写的函数，然后触发之，结果截图并说说你是怎么做的。</p><h3 id="Assignment-4-时钟中断"><a href="#Assignment-4-时钟中断" class="headerlink" title="Assignment 4 时钟中断"></a>Assignment 4 时钟中断</h3><p>复现Example 4，仿照Example中使用C语言来实现时钟中断的例子，利用C&#x2F;C++、 InterruptManager、STDIO和你自己封装的类来实现你的时钟中断处理过程，结果截图并说说你是怎么做的。注意，不可以使用纯汇编的方式来实现。(例如，通过时钟中断，你可以在屏幕的第一行实现一个跑马灯。跑马灯显示自己学号和英文名，即类似于LED屏幕显示的效果。)</p><ul><li>只需要修改<code>c_time_interrupt_handler()</code>这个函数</li><li>在原本的基础上简单修改就好了<ul><li>stdio中有几种不同的print函数，使用可以自定义color的那个，产生跑马灯效果</li><li>把名字、学号放在第一行（设置光标位置即可实现）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">uint8 color = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">void</span> <span class="hljs-title function_">c_time_interrupt_handler</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 清空屏幕</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80</span>; ++i) &#123;<br>        stdio.print(<span class="hljs-number">0</span>, i, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0x07</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出中断发生的次数</span><br>    ++times;<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;LQT 23336139&quot;</span>;  <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> str_len = <span class="hljs-number">13</span>;  <span class="hljs-comment">// 实际显示长度</span><br>    <span class="hljs-type">char</span> number[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>&#125;; <br>    <br>    <span class="hljs-comment">// 正确转换数字为字符串</span><br>    <span class="hljs-type">int</span> temp = times;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        number[i++] = temp % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        temp /= <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">while</span>(temp &amp;&amp; i &lt; <span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-comment">// 第一行输出</span><br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str_len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= cnt &amp;&amp; i &lt; cnt + <span class="hljs-number">3</span> &amp;&amp; cnt + <span class="hljs-number">2</span> &lt; str_len) &#123;<br>            stdio.print(str[i], ++color % <span class="hljs-number">16</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stdio.print(str[i]);<br>        &#125;<br>    &#125;<br>    <br>    cnt = (cnt + <span class="hljs-number">1</span>) % (str_len - <span class="hljs-number">2</span>);  <span class="hljs-comment">// 限制cnt范围</span><br>    <br>    <span class="hljs-comment">// 第二行输出</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;interrupt happend: &quot;</span>;<br>    stdio.moveCursor(<span class="hljs-number">80</span>);  <span class="hljs-comment">// 第二行开始</span><br>    <br>    <span class="hljs-comment">// 输出前缀字符串</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str1[i]; i++) &#123;<br>        stdio.print(str1[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 逆序输出数字(从最高位开始)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        stdio.print(number[j]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab5_updated</title>
    <link href="/2025/04/02/OS-Lab5-updated/"/>
    <url>/2025/04/02/OS-Lab5-updated/</url>
    
    <content type="html"><![CDATA[<h1 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本次实验会学习C语言的可变参数机制的实现方法，然后实现一个简单的printf函数，通过printf()和gdb来帮助debug；同时会实现内核线程（定义PCB；实现基于时钟中断的RR算法）。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul><li>DDL：2024.5.4 24:00</li><li>提交的内容：将<strong>3+1（选做）个assignment的代码</strong>和<strong>实验报告</strong>放到<strong>压缩包</strong>中，命名为“<strong>lab5-学号-姓名</strong>”，并交到课程邮箱 <a href="https://gitee.com/link?target=mailto:os_sysu_lab@163.com">os_sysu_lab@163.com</a></li><li>将实验报告的pdf提交至 <a href="https://gitee.com/link?target=http://inbox.weiyun.com/3CiJFwEn">http://inbox.weiyun.com/3CiJFwEn</a></li><li><strong>材料的Example的代码放置在 <code>src</code>目录下</strong>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/clover-toeic/p/3736748.html">可变参数函数详解 - clover_toeic - 博客园</a></p><h2 id="printf的实现"><a href="#printf的实现" class="headerlink" title="printf的实现"></a>printf的实现</h2><p>printf()可以使用任意数量的参数来调用，这类函数称为<strong>可变参数函数</strong></p><h3 id="C语言的可变参数机制"><a href="#C语言的可变参数机制" class="headerlink" title="C语言的可变参数机制"></a>C语言的可变参数机制</h3><p>C语言允许我们使用定义可变参数函数，此时函数参数列表分为两部分：固定参数（如int，char* )+可变参数(用 <code>...</code>来表示)<br>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> _Format, ...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>可变参数函数，参数列表中至少要有一个固定参数</li><li>可变参数列表必须放在形参列表最后</li></ul><p>为了<strong>引用可变参数列表中的参数</strong>，我们需要用到 <code>&lt;stdarg.h&gt;</code>头文件定义的一个变量类型 <code>va_list</code>和三个宏 <code>va_start</code>，<code>va_arg</code>，<code>va_end</code>，这三个宏用于获取可变参数列表中的参数，用法如下。</p><table><thead><tr><th>宏</th><th>用法说明</th></tr></thead><tbody><tr><td><code>va_list</code></td><td>定义一个<strong>指向可变参数列表的指针</strong>。</td></tr><tr><td><code>void va_start(va_list ap, last_arg)</code></td><td><strong>初始化可变参数列表指针</strong> <code>ap</code>，使其指向可变参数列表的<strong>起始位置</strong>，即函数的固定参数列表的最后一个参数 <code>last_arg</code>的后面第一个参数。<strong>（使用固定参数的最后一个参数来初始化可变参数指针）</strong></td></tr><tr><td><code>type va_arg(va_list ap, type)</code></td><td>以类型 <code>type</code>返回可变参数，并使 <code>ap</code>指向<strong>下一个参数</strong>。</td></tr><tr><td><code>void va_end(va_list ap)</code></td><td>清零 <code>ap</code>。</td></tr></tbody></table><ul><li>可变参数必须<strong>从头到尾</strong>逐个访问。如果你在访问了几个可变参数之后想半途中止，这是可以的，但是，如果你想一开始就访问参数列表中间的参数，那是不行的(可以把想访问的中间参数之前的参数读取但是不使用，曲线救国)。</li><li>这些宏是无法直接判断实际实际存在参数的数量。</li><li>这些宏无法判断每个参数的类型，所以在使用 <code>va_arg</code>的时候一定要指定正确的类型。</li><li>如果在 <code>va_arg</code>中指定了错误的类型，那么将会影响到后面的参数的读取。</li><li>第一个参数也未必要是可变参数个数，例如 <code>printf</code>的第一个参数就是字符串指针。</li></ul><p>无论参数数量有多少，这些参数都被统一地按函数调用给出的顺序放到了栈上，只不过使用可变参数的函数并不知道这些栈上的参数具体含义&#x3D;&gt;才需要使用 <code>va_arg</code>来指定参数的类型<br>$可变参数列表的起始地址&#x3D;固定参数列表的最后一个参数的地址+这个参数的大小$<br>初始化了 <code>parameter</code>后，我们就使用 <code>parameter</code>和 <code>va_arg</code>来引用可变参数。<br>从本质上来说，<code>parameter</code>就是指向函数调用栈的一个指针，类似 <code>esp</code>、<code>ebp</code>，<code>va_arg</code>按照指定的类型来返回 <code>parameter</code>指向的内容。注意，在 <code>va_arg</code>返回后，<code>parameter</code>会指向下一个参数，无需我们手动调整。</p><h3 id="src：2"><a href="#src：2" class="headerlink" title="src：2"></a>src：2</h3><p>定义的几个宏</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">_INTSIZEOF</span>(n) ((sizeof(n) + <span class="hljs-built_in">sizeof</span>(int) - <span class="hljs-number">1</span>) &amp; ~(sizeof(int) - <span class="hljs-number">1</span>))<br><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">va_start</span>(ap, v) (ap = (va_list)&amp;v + <span class="hljs-built_in">_INTSIZEOF</span>(v))<br><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">va_arg</span>(ap, type) (*(type *)((ap += _INTSIZEOF(type)) - <span class="hljs-built_in">_INTSIZEOF</span>(type)))<br><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">va_end</span>(ap) (ap = (va_list)<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>作用：<br><code>_INTSIZEOF</code> 宏：对齐宏，将给定类型的大小向上舍入为sizeof(int)的倍数。（push和pop是32位的，所以都像4字节对齐）</p><ul><li><code>sizeof(n) + sizeof(int) - 1</code> 确保我们有足够的字节</li><li><code>&amp; ~(sizeof(int) - 1)</code> 通过屏蔽掉低位来确保适当的对齐</li></ul><p><code>va_start</code> 宏：初始化va_list使其指向第一个可变参数</p><ul><li><code>&amp;v</code> 是最后一个命名参数的地址</li><li><code>_INTSIZEOF(v)</code> 计算需要跳过多少字节才能到达第一个可变参数</li><li>结果指针指向可变参数列表的开头</li></ul><p><code>va_arg</code> 宏：获取下一个参数</p><ul><li>它将指针前进适当对齐的请求类型大小：<code>ap += _INTSIZEOF(type)</code></li><li>然后再回调相同的大小：<code>- _INTSIZEOF(type)</code></li><li>将结果地址转换为请求类型的指针：<code>(type *)</code></li><li>解引用该指针以获取值：<code>*(type *)</code></li></ul><p><code>va_end</code>宏：将va_list指针设置为NULL来清理，标记可变参数的结束</p><h3 id="Example1-实现printf"><a href="#Example1-实现printf" class="headerlink" title="Example1  实现printf"></a>Example1  实现printf</h3><ul><li>定义：<code>int printf(const char *const fmt,...);</code><ul><li>首先找到fmt中形如 <code>%c,%d,%x,%s</code>对应的参数，然后用这些参数具体的值来替换，得到新的格式化输出字符串（fmt的解析）</li><li>最后printf将这个新的格式化输出字符即可。</li></ul></li></ul><blockquote><p>[!NOTE]<br>实际上，我们会定义一个缓冲区，然后对fmt进行逐字符地解析，将结果逐字符的放到缓冲区中。放入一个字符后，我们会检查缓冲区，如果缓冲区已满，则将其输出，然后清空缓冲区，否则不做处理。</p></blockquote><ul><li>我们还需要实现：<ul><li>一个能输出字符串的函数</li><li>这个函数要能正确处理换行（光标移动到下一行开始）</li><li>光标超过了屏幕表示范围需要滚屏</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">STDIO::print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> str)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; str[i]; ++i)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (str[i])<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>            uint row;<br>            row = getCursor() / <span class="hljs-number">80</span>;<br>            <span class="hljs-keyword">if</span> (row == <span class="hljs-number">24</span>)<br>            &#123;<br>                rollUp();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ++row;<br>            &#125;<br>            moveCursor(row * <span class="hljs-number">80</span>);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            print(str[i]);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%d</td><td>按十进制整数输出</td></tr><tr><td>%c</td><td>输出一个字符</td></tr><tr><td>%s</td><td>输出一个字符串</td></tr><tr><td>%x</td><td>按16进制输出</td></tr><tr><td>printf()</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> fmt, ...)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_LEN = <span class="hljs-number">32</span>;<br><br>    <span class="hljs-type">char</span> buffer[BUF_LEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span> number[<span class="hljs-number">33</span>];<br><br>    <span class="hljs-type">int</span> idx, counter;<br>    va_list ap;<br><br>    va_start(ap, fmt);<br>    idx = <span class="hljs-number">0</span>;<br>    counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; fmt[i]; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fmt[i] != <span class="hljs-string">&#x27;%&#x27;</span>)<br>        &#123;<br>            counter += printf_add_to_buffer(buffer, fmt[i], idx, BUF_LEN);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            i++;<br>            <span class="hljs-keyword">if</span> (fmt[i] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">switch</span> (fmt[i])<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>                counter += printf_add_to_buffer(buffer, fmt[i], idx, BUF_LEN);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>                counter += printf_add_to_buffer(buffer, va_arg(ap, <span class="hljs-type">int</span>), idx, BUF_LEN);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>                buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                idx = <span class="hljs-number">0</span>;<br>                counter += stdio.print(buffer);<br>                counter += stdio.print(va_arg(ap, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *));<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br>                <span class="hljs-type">int</span> temp = va_arg(ap, <span class="hljs-type">int</span>);<br><br>                <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> &amp;&amp; fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span>)<br>                &#123;<br>                    counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;-&#x27;</span>, idx, BUF_LEN);<br>                    temp = -temp;<br>                &#125;<br><br>                temp = itos(number, temp, (fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span> ? <span class="hljs-number">10</span> : <span class="hljs-number">16</span>));<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = temp - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)<br>                &#123;<br>                    counter += printf_add_to_buffer(buffer, number[j], idx, BUF_LEN);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    counter += stdio.print(buffer);<br><br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加到缓冲区函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf_add_to_buffer</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">char</span> c, <span class="hljs-type">int</span> &amp;idx, <span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_LEN)</span><br>&#123;<br>    <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br>    buffer[idx] = c;<br>    ++idx;<br><br>    <span class="hljs-keyword">if</span> (idx == BUF_LEN)<br>    &#123;<br>        buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        counter = stdio.print(buffer);<br>        idx = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250417193048263.png"></p><h2 id="内核线程-1"><a href="#内核线程-1" class="headerlink" title="内核线程"></a>内核线程</h2><ul><li>程序、进程、线程</li></ul><h3 id="用户线程和内核线程"><a href="#用户线程和内核线程" class="headerlink" title="用户线程和内核线程"></a>用户线程和内核线程</h3><ul><li>用户线程：线程只由用户进程实现，os察觉不到（无线程机制）&#x3D;&gt;一旦挂起，整个进程挂起</li><li>内核线程：让进程更多地占用CPU资源，某一线程阻塞了也只会阻塞这个线程，不会影响其他线程</li></ul><h3 id="线程的描述"><a href="#线程的描述" class="headerlink" title="线程的描述"></a>线程的描述</h3><ul><li>五个状态（创建态、运行态、就绪态、阻塞态、终止态）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ProgramStatus</span></span><br><span class="hljs-class">&#123;</span><br>    CREATED,<br>    RUNNING,<br>    READY,<br>    BLOCKED,<br>    DEAD<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>PCB数据结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> *<span class="hljs-built_in">stack</span>;                      <span class="hljs-comment">// 栈指针，用于调度时保存esp</span><br>    <span class="hljs-type">char</span> name[MAX_PROGRAM_NAME + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 线程名</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ProgramStatus</span> <span class="hljs-title">status</span>;</span>       <span class="hljs-comment">// 线程的状态</span><br>    <span class="hljs-type">int</span> priority;                    <span class="hljs-comment">// 线程优先级</span><br>    <span class="hljs-type">int</span> pid;                         <span class="hljs-comment">// 线程pid</span><br>    <span class="hljs-type">int</span> ticks;                       <span class="hljs-comment">// 线程时间片总时间</span><br>    <span class="hljs-type">int</span> ticksPassedBy;               <span class="hljs-comment">// 线程已执行时间</span><br>    ListItem tagInGeneralList;       <span class="hljs-comment">// 线程队列标识</span><br>    ListItem tagInAllList;           <span class="hljs-comment">// 线程队列标识</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>stack：各个线程虽然共享内核空间，但是又有自己的栈，这个栈保存在PCB中；<ul><li>每个PCB会被分配一个页，上面的数据结构PCB只是这个页的低地址部分，栈指针从这个页的结束为止向下递减。（所以栈的空间是有限的，过多会覆盖PCB的信息）<br>  <img src="/img/file-20250428190629787.png"></li></ul></li><li><code>ticks</code>是线程剩余的执行次数。在时间片调度算法中，每发生中断一次记为一个<code>tick</code>，当<code>ticks=0</code>时，线程会被换下处理器，然后将其他线程换上处理器执行。</li><li><code>ticksPassedBy</code>是线程总共执行的<code>tick</code>的次数。</li><li><code>tagInGeneralList</code>和<code>tagInAllList</code>是线程在线程队列中的标识，用于在线程队列中找到线程的PCB。</li></ul><h3 id="PCB的分配"><a href="#PCB的分配" class="headerlink" title="PCB的分配"></a>PCB的分配</h3><ul><li>大小4096个字节（一个页）–目前手动预留–后面实现了内存分页、页内存管理，就是由页内存管理来实现）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// PCB的大小，4KB。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PCB_SIZE = <span class="hljs-number">4096</span>;         <br><span class="hljs-comment">// 存放PCB的数组，预留了MAX_PROGRAM_AMOUNT个PCB的大小空间。</span><br><span class="hljs-type">char</span> PCB_SET[PCB_SIZE * MAX_PROGRAM_AMOUNT]; <br><span class="hljs-comment">// PCB的分配状态，true表示已经分配，false表示未分配。</span><br><span class="hljs-type">bool</span> PCB_SET_STATUS[MAX_PROGRAM_AMOUNT];     <br></code></pre></td></tr></table></figure><ul><li>在<code>ProgramManager</code>中声明两个管理PCB所在的内存空间函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 分配一个PCB</span><br>PCB *<span class="hljs-title function_">allocatePCB</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 归还一个PCB</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">releasePCB</span><span class="hljs-params">(PCB *program)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>allocatePCB</code>会去检查<code>PCB_SET</code>中每一个PCB的状态，如果找到一个<strong>未被分配的PCB</strong>，则返回这个PCB的起始地址。若未找到，则返回nullptr。</li><li>PCB_SET中的PCB是连续存放的，对于第i个PCB，起始地址即为<code>i*PCB_SIZE</code></li><li><code>releasePCB</code>接受一个PCB指针<code>program</code>，然后计算出<code>program</code>指向的PCB在<code>PCB_SET</code>中的位置，然后将<code>PCB_SET_STATUS</code>中的对应位置设置<code>false</code>即可。</li></ul><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><ul><li>加入两个List成员，<code>allPrograms</code> （所有状态的线程、进程的队列）和<code>readyProframs</code>（处于就绪态的线程、进程的队列）</li><li>创建线程<ul><li>线程实际上执行的是<strong>某个函数的代码</strong>。（规定线程只能执行返回值为void，参数为 <code>void*</code> 的函数<br>  用于创建线程的函数：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个线程并放入就绪队列</span><br><span class="hljs-comment">// function：线程执行的函数</span><br><span class="hljs-comment">// parameter：指向函数的参数的指针</span><br><span class="hljs-comment">// name：线程的名称</span><br><span class="hljs-comment">// priority：线程的优先级</span><br><span class="hljs-comment">// 成功，返回pid；失败，返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">executeThread</span><span class="hljs-params">(ThreadFunction function, <span class="hljs-type">void</span> *parameter, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> priority)</span>;<br></code></pre></td></tr></table></figure><p>具体实现的注解：<br><img src="/img/file-20250429104258940.png"></p><ul><li>4个为0的值是要放到ebp，ebx，edi，esi中的。</li><li><code>thread-&gt;stack[4]</code>是线程执行的函数的起始地址。</li><li><code>thread-&gt;stack[5]</code>是线程的返回地址，所有的线程执行完毕后都会返回到这个地址。</li><li><code>thread-&gt;stack[6]</code>是线程的参数的地址。</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>在ProgramManager中加入成员running，用来<u>记录当前处理机上执行的线程的PCB</u></p><ul><li>本次实验用的方法是RR（时间片轮转算法）</li><li>线程切换：<ul><li>由于线程的所有信息都在线程栈中，只要我们切换线程栈就能实现线程的切换，<strong>线程栈的切换就是将线程的栈指针放到esp中</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">asm_switch_thread:<br>    push ebp<br>    push ebx<br>    push edi<br>    push esi<br><br>    mov eax, [esp + 5 * 4]<br>    mov [eax], esp ; 保存当前栈指针到PCB中，以便日后恢复<br><br>    mov eax, [esp + 6 * 4]<br>    mov esp, [eax] ; 此时栈已经从cur栈切换到next栈<br><br>    pop esi<br>    pop edi<br>    pop ebx<br>    pop ebp<br><br>    sti<br>    ret<br></code></pre></td></tr></table></figure><p>第2-5行，我们保存寄存器<code>ebp</code>，<code>ebx</code>，<code>edi</code>，<code>esi</code>。（C语言规则决定的，要求被调函数主动为主调函数保存这四个寄存器的值）<br>第7-8行，我们保存esp的值到线程的<code>PCB::statck</code>中，用做下次恢复。注意到<code>PCB::stack</code>在<code>PCB</code>的偏移地址是0。第7行代码是首先将<code>cur-&gt;stack</code>的地址放到<code>eax</code>中，第8行向<code>[eax]</code>中写入<code>esp</code>的值，也就是向<code>cur-&gt;stack</code>中写入esp。<br><img src="/img/file-20250429111214591.png"><br>第10-11行，我们将<code>next-&gt;stack</code>的值写入到esp中，从而完成线程栈的切换。<br><img src="/img/file-20250429111249331.png"><br>最后使用pop语句将四个0放入寄存器中。</p><h2 id="Example2-第一个线程"><a href="#Example2-第一个线程" class="headerlink" title="Example2 第一个线程"></a>Example2 第一个线程</h2><p>例子内容：创建第一个线程，并输出”hello world”，pid和线程的名字。</p><ul><li>第一个线程不可以返回</li><li>创建第一个线程：由于当前系统中没有线程，因此无法通过在时钟中断调度的方式将第一个线程换上处理器执行。而是要<strong>找出第一个线程的PCB</strong>，然后手动执行类似 <code>schedule</code> 的过程，最后执行 <code>asm_switch_thread</code> 会强制将第一个线程换上处理器执行。<br>这一部分是找到第一个线程的PCB，手动设置第一个线程为运行状态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">ListItem *item = programManager.readyPrograms.front();  <span class="hljs-comment">// 获取就绪队列的第一个线程</span><br>PCB *firstThread = ListItem2PCB(item, tagInGeneralList); <span class="hljs-comment">// 转换为 PCB 结构</span><br>firstThread-&gt;status = RUNNING;  <span class="hljs-comment">// 标记为运行状态</span><br>programManager.readyPrograms.pop_front();  <span class="hljs-comment">// 从就绪队列移除</span><br>programManager.running = firstThread;      <span class="hljs-comment">// 设为当前运行线程</span><br></code></pre></td></tr></table></figure><p>然后再使用线程切换程序，切换到第一个线程。作用是：</p><ul><li>保存当前的上下文</li><li>加载第一个线程的上下文</li><li>跳转到 <code>first_thread</code> 执行<br>运行结果：<br><img src="/img/file-20250430144301726.png"></li></ul><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><h2 id="Assignment1-printf的实现"><a href="#Assignment1-printf的实现" class="headerlink" title="Assignment1 printf的实现"></a>Assignment1 printf的实现</h2><p>学习可变参数机制，然后实现printf，你可以在材料中的printf上进行改进，或者从头开始实现自己的printf函数。结果截图并说说你是怎么做的。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul><li>我决定对材料中的printf进行改进，即添加一些新的格式化输出方式。</li><li>修改fmt解析过程，添加进新的格式化输出方式</li><li>得到新的格式化输出字符串之后，将这个字符串打印<br>PS:</li><li>实际上，我们会定义一个缓冲区，然后对fmt进行逐字符地解析，将结果逐字符的放到缓冲区中。放入一个字符后，我们会检查缓冲区，如果缓冲区已满，则将其输出，然后清空缓冲区，否则不做处理。</li></ul><p>材料中定义了一个print函数，作用是正确处理字符串中的换行符，暂时无需修改。</p><p>我要做的是修改printf函数实现，加入新的</p><ul><li>原本有的：<code>%d</code>，<code>%c</code>，<code>%s</code>，<code>%x</code>，<code>%%</code></li><li>加入：<code>%f</code>，<code>%o</code>，（还可能加入左右对齐）</li></ul><p>再次观察一下原本的printf函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_LEN = <span class="hljs-number">32</span>;       <span class="hljs-comment">// 缓冲区大小（32字节）</span><br><span class="hljs-type">char</span> buffer[BUF_LEN + <span class="hljs-number">1</span>];      <span class="hljs-comment">// 临时缓冲区（存放待输出的字符）</span><br><span class="hljs-type">char</span> number[<span class="hljs-number">33</span>];               <span class="hljs-comment">// 数字转换缓冲区（存放整数转字符串的结果）</span><br><span class="hljs-type">int</span> idx, counter;              <span class="hljs-comment">// idx: buffer 的当前写入位置，counter: 已输出的字符总数</span><br>va_list ap;                    <span class="hljs-comment">// 可变参数列表</span><br></code></pre></td></tr></table></figure><p>初始化可变参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">va_start(ap, fmt);  <span class="hljs-comment">// 初始化 ap，使其指向第一个可变参数</span><br>idx = <span class="hljs-number">0</span>;            <span class="hljs-comment">// buffer 初始为空</span><br>counter = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 输出字符数初始为 0</span><br></code></pre></td></tr></table></figure><p>遍历格式化字符串 <code>fmt</code> 直至遇到 <code>\0</code></p><ul><li>一些判断<br>普通字符：存入 <code>buffer</code><br>这里的 <code>printf_add_to_buffer</code> 函数用于：</li></ul><ol><li>将字符 <code>fmt[i]</code> 写入 <code>buffer[idx]</code></li><li>如果 <code>buffer</code> 满了，先调用 <code>stdio.print(buffer)</code> 刷新缓冲区</li><li>返回 <code>1</code> （表示成功写入一个字符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fmt[i] != <span class="hljs-string">&#x27;%&#x27;</span>)<br>&#123;<br>    counter += printf_add_to_buffer(buffer, fmt[i], idx, BUF_LEN);<br>&#125;<br></code></pre></td></tr></table></figure><p>格式化占位符：检查下一个字符，决定如何处理</p><ol><li>如果%是最后一个字符，直接结束</li><li>根据几种不同情况来进行处理</li></ol><p>输出%的情况：</p><ul><li><code>%%</code>的情况：将%加入到buffer中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>    counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;%&#x27;</span>, idx, BUF_LEN);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>C语言中当函数使用可变参数时，某些类型的参数会自动提升为更大的类型，以确保参数的传递一致性</p></blockquote><table><thead><tr><th>原始类型</th><th>提升后的类型</th></tr></thead><tbody><tr><td><code>char</code></td><td><code>int</code></td></tr><tr><td><code>short</code></td><td><code>int</code></td></tr><tr><td><code>float</code></td><td><code>double</code></td></tr></tbody></table><ul><li>%c的情况：从可变参数列表取出一个字符<br>所以这里从可变参数列表中提取的是一个 <code>int</code> （即使我们传入的是char）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>    counter += printf_add_to_buffer(buffer, va_arg(ap, <span class="hljs-type">int</span>), idx, BUF_LEN);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><ul><li>%s的情况：先刷新buffer，然后直接用stdio.print输出参数字符串，避免拷贝到buffer</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>    buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;          <span class="hljs-comment">// 先终止当前 buffer</span><br>    idx = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 重置 buffer 指针</span><br>    counter += stdio.print(buffer);  <span class="hljs-comment">// 输出 buffer 中的内容</span><br>    counter += stdio.print(va_arg(ap, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *));  <span class="hljs-comment">// 直接输出参数字符串</span><br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><ul><li>%d和%x的情况：<br>先从参数列表中取出一个整数，然后进行处理<br>如果是一个负数，需要手动处理（%d）<br>然后将整数转换为字符串，逆序写入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br>    <span class="hljs-type">int</span> temp = va_arg(ap, <span class="hljs-type">int</span>);  <span class="hljs-comment">// 取出一个整数</span><br>    <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> &amp;&amp; fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span>)  <span class="hljs-comment">// 处理负数（仅十进制）</span><br>    &#123;<br>        counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;-&#x27;</span>, idx, BUF_LEN);<br>        temp = -temp;  <span class="hljs-comment">// 转为正数</span><br>    &#125;<br>    temp = itos(number, temp, (fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span> ? <span class="hljs-number">10</span> : <span class="hljs-number">16</span>));  <span class="hljs-comment">// 整数转字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = temp - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)  <span class="hljs-comment">// 逆序写入 buffer（因为 itos 返回的是反向字符串）</span><br>    &#123;<br>        counter += printf_add_to_buffer(buffer, number[j], idx, BUF_LEN);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>加入%f和%o：<br>实现方法：<br>八进制添加方法比较简单，直接参照十进制和十六进制即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<span class="hljs-comment">//八进制</span><br>    temp = va_arg(ap, <span class="hljs-type">int</span>); <span class="hljs-comment">// Declare temp here</span><br>    <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> &amp;&amp; fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span>)<br>    &#123;<br>        counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;-&#x27;</span>, idx, BUF_LEN);<br>        temp = -temp;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fmt[i]==<span class="hljs-string">&#x27;d&#x27;</span>)&#123;<br>        itos(number, temp,<span class="hljs-number">10</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fmt[i]==<span class="hljs-string">&#x27;x&#x27;</span>)&#123;<br>        itos(number, temp, <span class="hljs-number">16</span> );<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        itos(number, temp, <span class="hljs-number">8</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; number[j]; ++j)<br>    &#123;<br>        counter += printf_add_to_buffer(buffer, number[j], idx, BUF_LEN);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>浮点数输出稍微麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-comment">//浮点数</span><br>   tmp = va_arg(ap, <span class="hljs-type">double</span>); <span class="hljs-comment">//进制扩展</span><br>   <span class="hljs-type">char</span> float_str[<span class="hljs-number">64</span>];<br>   ftos(float_str, tmp, <span class="hljs-number">4</span>); <br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; float_str[j]; ++j)<br>   &#123;<br>       counter += printf_add_to_buffer(buffer, float_str[j], idx, BUF_LEN);<br>   &#125;<br>   <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>其他的部分和输出整数类似，但是需要重新写ftos函数，用于将浮点数转换为字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ftos</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">double</span> value, <span class="hljs-type">int</span> precision = <span class="hljs-number">6</span>)</span> &#123;<br>    <span class="hljs-type">char</span> *ptr = buf;<br><br>    <span class="hljs-comment">// 处理负数</span><br>    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>        *ptr++ = <span class="hljs-string">&#x27;-&#x27;</span>;<br>        value = -value;<br>    &#125;<br><br>    <span class="hljs-comment">// 提取整数部分</span><br>    <span class="hljs-type">int</span> integer = (<span class="hljs-type">int</span>)value;<br>    value -= integer;  <span class="hljs-comment">// 剩余小数部分</span><br><br>    <span class="hljs-comment">// 整数部分转字符串（逆序）</span><br>    <span class="hljs-type">char</span> int_str[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        int_str[i++] = <span class="hljs-string">&#x27;0&#x27;</span> + (integer % <span class="hljs-number">10</span>);<br>        integer /= <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">while</span> (integer &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 逆序写入整数部分</span><br>    <span class="hljs-keyword">while</span> (--i &gt;= <span class="hljs-number">0</span>) &#123;<br>        *ptr++ = int_str[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 添加小数点</span><br>    *ptr++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br><br>    <span class="hljs-comment">// 处理小数部分</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; precision; ++j) &#123;<br>        value *= <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> digit = (<span class="hljs-type">int</span>)value;<br>        *ptr++ = <span class="hljs-string">&#x27;0&#x27;</span> + digit;<br>        value -= digit;<br>    &#125;<br><br>    *ptr = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 终止字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：<br><img src="/img/file-20250430160236085.png"></p><h2 id="Assignment-2-线程的实现"><a href="#Assignment-2-线程的实现" class="headerlink" title="Assignment 2 线程的实现"></a>Assignment 2 线程的实现</h2><p>自行设计PCB，可以添加更多的属性，如优先级等，然后根据你的PCB来实现线程，演示执行结果。</p><p>实现过程：<br>我为PCB添加了<strong>优先级</strong>属性，修改了代码中的线程程序，打印出了优先级。但是由于我们还没有实现按照优先级进行抢占等调度方式，只实现了RR，所以并不会发生优先级抢占。<br><img src="/img/file-20250501194749870.png"><br><img src="/img/file-20250505223636947.png"></p><h2 id="Assignment-3-线程调度切换的秘密"><a href="#Assignment-3-线程调度切换的秘密" class="headerlink" title="Assignment 3 线程调度切换的秘密"></a>Assignment 3 线程调度切换的秘密</h2><p>操作系统的线程能够<strong>并发执行</strong>的秘密在于我们<u>需要中断线程的执行，保存当前线程的状态，然后调度下一个线程上处理机，最后使被调度上处理机的线程从之前被中断点处恢复执行</u>。现在，同学们可以亲手揭开这个秘密。</p><p>编写若干个线程函数，使用gdb跟踪<code>c_time_interrupt_handler</code>、<code>asm_switch_thread</code>等函数，观察线程切换前后栈、寄存器、PC等变化，结合gdb、材料中“线程的调度”的内容来跟踪并说明下面两个过程。</p><ul><li>一个新创建的线程是<strong>如何被调度</strong>然后<strong>开始执行</strong>的。</li><li>一个正在执行的线程是<strong>如何被中断然后被换下</strong>处理器的，以及<strong>换上处理机后又是如何从被中断点开始执行的</strong>。</li></ul><p>通过上面这个练习，同学们应该能够进一步理解操作系统是如何实现线程的并发执行的。</p><p>实现方法：<br>首先我在调度函数（ <code>schedule()</code>）中加入了打印信息：</p><p><img src="/img/file-20250501201034941.png"></p><p>开启gdb模式：<br>先追踪setup_kernel()函数</p><ul><li>先修改一下gdbinit添加断点</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">target remote:<span class="hljs-number">1234</span><br><span class="hljs-function"><span class="hljs-title">file</span></span> ../build/kernel.o<br><span class="hljs-keyword">set</span> disassembly-flavor <span class="hljs-comment">intel</span><br>b <span class="hljs-comment">setup_kernel</span><br>c<br></code></pre></td></tr></table></figure><p>再打开gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make debug<br></code></pre></td></tr></table></figure><p>启动界面如图所示：<br><img src="/img/file-20250501201808114.png"><br>已经加载好符号表，并跳转到即将进入setup_kernel()</p><p>一直到切换线程之前都没有输出，因为并没有调用调度函数。<br><img src="/img/file-20250501202011141.png"><br>但再向前一步就有输出了<br><img src="/img/file-20250501202044113.png"><br>现在发现pid&#x3D;0的进程无法退出（根），而third_thread程序中是死循环，所以会一直在pid&#x3D;0和pid&#x3D;2之间一直切换</p><p>再跟踪c_time_interrupt_handler()<br><img src="/img/file-20250501203827173.png"><br>可以看到启动后屏幕上打印了线程1的执行情况，说明现在进入了中断</p><p>在schedule()函数中我们设置了时间片为<code>优先级*10</code>，在创建线程时我们设置优先级均为1，所以时间片就为10了。所以要十次才会轮换<br><img src="/img/file-20250501210736317.png"><br>又过10次：<br><img src="/img/file-20250501210801326.png"><br>又过10次：<br><img src="/img/file-20250501210820361.png"></p><p>ps：<br><img src="/img/file-20250501205216649.png"></p><p>总的来说：</p><ul><li>线程并发执行的核心原理是通过快速、时分复用地切换CPU的使用权，给用户造成一种“所有线程同时运行的错觉”</li><li>新线程被选中是因为next指针指向了新创建线程的PCB</li><li>进入 asm_switch_thread 时，cur指向当前运行的线程，next指向新创建的线程，同时保存了cur线程的上下文。单步执行或者continue之后，PC会跳转到新线程的入口函数的第一条指令，然后开始执行。</li><li>中断的发生、切换与恢复<ul><li>触发中断后会进入到 <code>c_time_interrupt_handler</code>中</li><li>其中会处理tick计数、判断时间片是否用完等</li></ul></li><li>线程切换会使用到asm_switch_thread函数，最后ret恢复执行，再次调度回去。</li></ul><h2 id="（必做与选做）Assignment-4-调度算法的实现"><a href="#（必做与选做）Assignment-4-调度算法的实现" class="headerlink" title="（必做与选做）Assignment 4 调度算法的实现"></a>（必做与选做）Assignment 4 调度算法的实现</h2><p>在材料中，我们已经学习了如何使用时间片轮转算法来实现线程调度。但线程调度算法不止一种，例如</p><ul><li>先来先服务。</li><li>最短作业（进程）优先。</li><li>响应比最高者优先算法。</li><li>优先级调度算法。</li><li>多级反馈队列调度算法。</li></ul><p>此外，我们的调度算法还可以是抢占式的。</p><p>现在，同学们需要将线程调度算法修改为上面提到的算法或者是同学们自己设计的算法。然后，同学们需要自行编写测试样例来呈现你的算法实现的正确性和基本逻辑。最后，将结果截图并说说你是怎么做的。<strong>（先来先服务为必做，其他为选做）</strong></p><p>参考资料：<a href="https://gitee.com/link?target=https://zhuanlan.zhihu.com/p/97071815">https://zhuanlan.zhihu.com/p/97071815</a></p><p>Tips：</p><ul><li>先来先服务最简单。</li><li>有些调度算法的实现<strong>可能需要</strong>用到中断。</li></ul><p>提示：你可能需要改动的地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">lab5/src/<span class="hljs-number">4</span>/include/program.h<br><br><span class="hljs-comment">// 执行线程调度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 你自己的线程调度算法的声明</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">your_schedule</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">lab5/src/<span class="hljs-number">4</span>/src/kernel/program.cpp<br><br><span class="hljs-comment">// 你自己的线程调度算法的具体实现</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ProgramManager::your_schedule</span><span class="hljs-params">()</span>&#123;<br>...<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">program_exit</span><span class="hljs-params">()</span><br>&#123;<br>    PCB *thread = programManager.running;<br>    thread-&gt;status = ProgramStatus::DEAD;<br><br>    <span class="hljs-keyword">if</span> (thread-&gt;pid)<br>    &#123;<br>        <span class="hljs-comment">// 修改你想要调用的线程调度算法</span><br>        programManager.your_schedule();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        interruptManager.disableInterrupt();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;halt\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">lab5/src/<span class="hljs-number">4</span>/src/kernel/setup.cpp<br><br><span class="hljs-comment">// 你可以自由添加线程与修改打印信息</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">third_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 你可以添加多个线程</span><br><span class="hljs-comment">// 创建第一个线程</span><br><span class="hljs-type">int</span> pid = programManager.executeThread(first_thread, nullptr, <span class="hljs-string">&quot;first thread&quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can not execute thread\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br><span class="hljs-comment">// 再加入一个线程</span><br><span class="hljs-type">int</span> pid2 = programManager.executeThread(second_thread, nullptr, <span class="hljs-string">&quot;second_thread&quot;</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (pid2 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can not execute thread\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br></code></pre></td></tr></table></figure><p>FIFO算法：<br>按照任务进入队列的顺序，依次调用，执行完一个任务再执行下一个任务，只有当任务结束后才会发生切换。</p><p>SJF算法：<br>按照任务的耗时长短进行调度，优先调度耗时短的任务，这个算法有个前提，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。另外，这个时间是指任务剩余还需要的执行时间，举例，一个耗时1小时的任务还剩10秒执行完成，这个时候若再来一个耗时1分钟的任务，调度仍然还是继续执行完那个耗时1小时的任务，因为他剩余的时间是10秒，比1分钟短，所以此算法又叫最短剩余时间任务有限算法（SRTJ），能够解决FIFO算法中短耗时任务等待前面耗时长任务的窘境。</p><p>先实现先进先出算法：<br>由于是执行完一个任务就执行下一个任务，即在任务结束才发生切换，不需要使用中断函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ProgramManager::FIFO_schedule</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">bool</span> status = interruptManager.getInterruptStatus();<br>    interruptManager.disableInterrupt();<br>    <br>    <span class="hljs-keyword">if</span>(readyPrograms.size() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;All thread has been finished.\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br><br>    <span class="hljs-comment">//只需要判断进程是否结束，结束就释放掉</span><br>    <span class="hljs-keyword">if</span> (running-&gt;status == ProgramStatus::DEAD)<br>    &#123;<br>        releasePCB(running);<br>    &#125;<br><br>    ListItem *item = readyPrograms.front();<br>    PCB *next = ListItem2PCB(item, tagInGeneralList);<br>    PCB *cur = running;<br>    next-&gt;status = ProgramStatus::RUNNING;<br>    running = next;<br>    readyPrograms.pop_front();<br><br>    asm_switch_thread(cur, next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d is finished, and pid %d is loaded and start to run.\n&quot;</span>, cur-&gt;pid, next-&gt;pid);<br><br>    <br>    interruptManager.setInterruptStatus(status);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">third_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    programManager.FIFO_schedule();<br>    <span class="hljs-comment">// while (1)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">second_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    programManager.FIFO_schedule();<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">first_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-comment">// 第1个线程不可以返回</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    <span class="hljs-keyword">if</span> (!programManager.running-&gt;pid)<br>    &#123;<br>        programManager.executeThread(second_thread, nullptr, <span class="hljs-string">&quot;second thread&quot;</span>, <span class="hljs-number">2</span>);<br>        programManager.executeThread(third_thread, nullptr, <span class="hljs-string">&quot;third thread&quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    programManager.FIFO_schedule();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250501214258828.png"></p><p>（非抢占）优先级调度算法：<br>主要就是每次执行完一个线程之后，运行下一个线程是从队列中取出优先级最高的线程来执行。<br>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ProgramManager::priority_schedule</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">bool</span> status = interruptManager.getInterruptStatus();<br>    interruptManager.disableInterrupt();<br><br>    <span class="hljs-keyword">if</span> (readyPrograms.size() == <span class="hljs-number">0</span>)<br>    &#123;<br>        interruptManager.setInterruptStatus(status);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前运行的进程仍然是运行状态，将其放回就绪队列</span><br>    <span class="hljs-keyword">if</span> (running-&gt;status == ProgramStatus::RUNNING)<br>    &#123;<br>        running-&gt;status = ProgramStatus::READY;<br>        <span class="hljs-comment">// running-&gt;ticks = running-&gt;priority * 10;</span><br>        readyPrograms.push_back(&amp;(running-&gt;tagInGeneralList));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (running-&gt;status == ProgramStatus::DEAD)<br>    &#123;<br>        releasePCB(running);<br>    &#125;<br><br><br>    <span class="hljs-comment">// 找到优先级最高的进程</span><br>    ListItem *highestPriorityItem = readyPrograms.front();<br>    PCB *highestPriorityPCB = ListItem2PCB(highestPriorityItem, tagInGeneralList);<br>    <br>    <span class="hljs-comment">// 遍历就绪队列找到优先级最高的进程</span><br>    ListItem *item = readyPrograms.front();<br>    <span class="hljs-keyword">while</span> (item != nullptr)<br>    &#123;<br>        PCB *pcb = ListItem2PCB(item, tagInGeneralList);<br>        <span class="hljs-keyword">if</span> (pcb-&gt;priority &gt; highestPriorityPCB-&gt;priority)<br>        &#123;<br>            highestPriorityPCB = pcb;<br>            highestPriorityItem = item;<br>        &#125;<br>        item = item-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 从就绪队列中移除将要运行的进程</span><br>    readyPrograms.erase(highestPriorityItem);<br><br>    PCB *cur = running;<br>    running = highestPriorityPCB;<br>    running-&gt;status = ProgramStatus::RUNNING;<br><br>    asm_switch_thread(cur, running);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d is switched out, and pid %d with priority %d is loaded and start to run.\n&quot;</span>, <br>           cur-&gt;pid, running-&gt;pid, running-&gt;priority);<br><br>    interruptManager.setInterruptStatus(status);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修改一下线程，让输出可以显示出优先级的作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">third_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;priority: %d--pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;priority, programManager.running-&gt;pid, programManager.running-&gt;name);<br><br>    programManager.priority_schedule();<br><br>    <span class="hljs-comment">// while (1)</span><br><br>    <span class="hljs-comment">// &#123;</span><br><br>    <span class="hljs-comment">// &#125;</span><br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">second_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;priority: %d--pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;priority, programManager.running-&gt;pid, programManager.running-&gt;name);<br><br>    programManager.priority_schedule();<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">first_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br><br>&#123;<br><br>    <span class="hljs-comment">// 第1个线程不可以返回</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;priority: %d--pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;priority, programManager.running-&gt;pid, programManager.running-&gt;name);<br><br>    <span class="hljs-keyword">if</span> (!programManager.running-&gt;pid)<br><br>    &#123;<br><br>        programManager.executeThread(second_thread, nullptr, <span class="hljs-string">&quot;second thread&quot;</span>, <span class="hljs-number">2</span>);<br><br>        programManager.executeThread(third_thread, nullptr, <span class="hljs-string">&quot;third thread&quot;</span>, <span class="hljs-number">3</span>);<br><br>    &#125;<br><br>    programManager.priority_schedule();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现结果：<br><img src="/img/file-20250505222954149.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu22.04安装bcc</title>
    <link href="/2025/03/29/ubuntu22-04%E5%AE%89%E8%A3%85bcc/"/>
    <url>/2025/03/29/ubuntu22-04%E5%AE%89%E8%A3%85bcc/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_39678161/article/details/137339963">WSL2安装BCC_bcc wsl-CSDN博客</a></p><p>遇到问题：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">LD vmlinux BTFIDS vmlinux FAILED: <span class="hljs-built_in">load</span> BTF <span class="hljs-built_in">from</span> vmlinux: No such <span class="hljs-built_in">file</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">directory</span> make: *** [Makefile:<span class="hljs-number">1226</span>: vmlinux] Error <span class="hljs-number">255</span> make: *** Deleting <span class="hljs-built_in">file</span> <span class="hljs-string">&#x27;vmlinux&#x27;</span><br></code></pre></td></tr></table></figure><p>尝试方法：</p><ul><li>在”scripts\pahole-flags.sh”文件下添加</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;pahole_ver&#125;</span>&quot;</span> -ge <span class="hljs-string">&quot;124&quot;</span> ]; <span class="hljs-attribute">then</span><br>       <span class="hljs-comment"># see PAHOLE_HAS_LANG_EXCLUDE</span><br>       extra_paholeopt=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;extra_paholeopt&#125;</span> --skip_encoding_btf_enum64&quot;</span><br>fi<br></code></pre></td></tr></table></figure><p>失败</p><ul><li><p>再次开始发现是因为在设置.config的时候不知道为什么出现了问题，然后make的时候出现[n&#x2F;y&#x2F;m]的选择也选择错误。最后再来一次正确设置就没问题了。</p></li><li><p>每次重启后需要重新编译内核，但是又出现了问题<br><img src="/img/f6ad7575dc6c73ae8e91fd7dd66e66f.png"><br>查询后发现是wsl内存设置太小的问题，找到.wslconfig，修改为：</p></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[wsl2]</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">8</span>GB   <span class="hljs-comment"># 设置内存上限为8GB</span><br><span class="hljs-attr">swap</span>=<span class="hljs-number">4</span>GB     <span class="hljs-comment"># 交换空间4GB</span><br><span class="hljs-attr">kernelCommandLine</span>=sysctl.vm.overcommit_memory=<span class="hljs-number">1</span><br><span class="hljs-attr">processors</span>=<span class="hljs-number">4</span> <span class="hljs-comment"># 可选：分配4个CPU核心</span><br></code></pre></td></tr></table></figure><p>每次开始前：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">KERNELRELEASE</span>=$(uname -r)<br>make <span class="hljs-attribute">KERNELRELEASE</span>=<span class="hljs-variable">$KERNELRELEASE</span> -j 4<br>make <span class="hljs-attribute">KERNELRELEASE</span>=<span class="hljs-variable">$KERNELRELEASE</span> modules -j 4<br>sudo make <span class="hljs-attribute">KERNELRELEASE</span>=<span class="hljs-variable">$KERNELRELEASE</span> modules_install<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>eBPF_learning</title>
    <link href="/2025/03/28/eBPF-learning/"/>
    <url>/2025/03/28/eBPF-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter1-Introduction"><a href="#Chapter1-Introduction" class="headerlink" title="Chapter1 Introduction"></a>Chapter1 Introduction</h1><h2 id="什么是eBPF"><a href="#什么是eBPF" class="headerlink" title="什么是eBPF"></a>什么是eBPF</h2><ul><li><p>eBPF可以在特权上下文中（如kernel）运行&#x3D;&#x3D;沙盒&#x3D;&#x3D;程序。用于<strong>安全有效地扩展内核的功能</strong>，而无需通过更改内核源代码或加载内核模块的方式来实现。<br><img src="/img/Pasted%20image%2020250328231557.png"></p></li><li><p>eBPF从根本上改变了这个方式，通过允许<strong>在操作系统中运行沙盒程序</strong>的方式，应用程序开发人员可以<strong>运行eBPF程序</strong>，以便在运行时向操作系统<strong>添加额外的功能</strong>。然后在<strong>JIT编译器</strong>和<strong>验证引擎</strong>的帮助下，操作系统确保它像本地编译的程序一样具备安全性和执行效率</p></li><li><p>eBPF最初代表了<strong>伯克利包过滤器 (Berkeley Packet Filter)</strong>，但现在能做的更多了，缩写不再有意义。最初的eBPF有时候被称为cBPF（经典BPF）。</p></li></ul><h2 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h2><h2 id="resources："><a href="#resources：" class="headerlink" title="resources："></a>resources：</h2><p><a href="https://docs.cilium.io/en/stable/reference-guides/bpf/index.html">BPF 和 XDP 参考指南 — Cilium 1.17.2 文档</a><br><a href="https://ebpf.io/zh-hans/what-is-ebpf/#%E4%BB%80%E4%B9%88%E6%98%AF-ebpf-">什么是 eBPF ? An Introduction and Deep Dive into the eBPF Technology</a>（中文版）</p><h2 id="钩子概览"><a href="#钩子概览" class="headerlink" title="钩子概览"></a>钩子概览</h2><p>eBPF 程序是<strong>事件驱动</strong>的，当内核或应用程序<em>通过某个钩子点</em>时运行。<strong>预定义的钩子</strong>包括系统调用、函数入口&#x2F;退出、内核跟踪点、网络事件等。<br><img src="/img/Pasted%20image%2020250328234202.png"><br>如果预定义的钩子不能满足特定需求，则可以<strong>创建内核探针</strong>（kprobe）或<strong>用户探针</strong>（uprobe），以便在内核或用户应用程序的<strong>几乎任何位置附加 eBPF 程序</strong>。<br><img src="/img/Pasted%20image%2020250328234616.png"></p><p>eBPF的核心钩子位置：<br>eBPF程序通常通过以下的内核钩子注入并执行：</p><ul><li><strong>Kprobes&#x2F;Uprobes</strong>：动态跟踪内核或用户空间函数调用</li><li><strong>Tracepoints</strong>：静态内核事件跟踪点（如系统调用、调度事件）</li><li><strong>TC（Traffic Control）</strong>：在<strong>网络流量控制层</strong>处理数据包</li><li><strong>Socket Filters</strong>：过滤或监控套接字数据</li></ul><h2 id="如何编写eBPF程序"><a href="#如何编写eBPF程序" class="headerlink" title="如何编写eBPF程序"></a>如何编写eBPF程序</h2><p>使用<strong>cilium、bcc或bpftrace</strong>这样子的项目间接使用，这些项目提供了 eBPF 之上的抽象，不需要直接编写程序，而是提供了指定基于意图的来定义实现的能力，然后用 eBPF 实现。</p><h2 id="加载器和校验架构"><a href="#加载器和校验架构" class="headerlink" title="加载器和校验架构"></a>加载器和校验架构</h2><p>确定所需的钩子后，可以使用 <strong>bpf 系统调用</strong>将 eBPF 程序加载到 Linux 内核中。这通常是使用一个可用的 eBPF 库来完成的。<br><img src="/img/go.webp"></p><p>当层序被加载到Linux内核中时，它在被附加到所请求的钩子上之前要经过两个步骤：</p><ul><li>验证：验证步骤用来确保eBPF程序可以安全运行<ul><li>加载eBPF程序的进程&#x3D;&#x3D;必须要所需的能力（特权）&#x3D;&#x3D;，<u>除非启用非特权eBPF</u>，否则只有特权进程可以加载eBPF程序</li><li>eBPF程序不会崩溃或者对系统造成损害</li><li>eBPF程序一定会运行至结束</li></ul></li><li>JIT编译<ul><li>JIT (Just-in-Time) 编译步骤<u>将程序的通用字节码转换为机器特定的指令集</u>，用以<strong>优化程序的执行速</strong>度。这使得 eBPF 程序可以像本地编译的内核代码或作为内核模块加载的代码一样高效地运行。</li></ul></li></ul><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>eBPF 程序的其中一个重要方面是<strong>共享和存储</strong>所收集的信息和状态的能力。<br>为此，eBPF 程序可以利用 eBPF maps 的概念来存储和检索各种数据结构中的数据。eBPF maps 既可以<strong>从 eBPF 程序访问</strong>，也可以通过<strong>系统调用</strong>从<strong>用户空间中的应用程序访问</strong>。<br><img src="/img/file-20250329153804831.png"></p><h2 id="Helper调用"><a href="#Helper调用" class="headerlink" title="Helper调用"></a>Helper调用</h2><p>eBPF 程序不直接调用内核函数。这样做会将 eBPF 程序绑定到特定的内核版本，会使程序的兼容性复杂化。而对应地，eBPF 程序改为调用 helper 函数达到效果，这是内核提供的通用且稳定的 API。</p><p><a href="https://ebpf.io/static/6e18b76323d8520107fab90c033edaf4/01295/helper.png"><img src="https://ebpf.io/static/6e18b76323d8520107fab90c033edaf4/b14d5/helper.png" alt="Helper"></a></p><p>可用的 helper 调用集也在不断发展迭代中。一些 helper 调用的示例:</p><ul><li>生成随机数</li><li>获取当前时间日期</li><li>eBPF map 访问</li><li>获取进程 &#x2F; cgroup 上下文</li><li>操作网络数据包及其转发逻辑</li></ul><h2 id="尾调用和函数调用"><a href="#尾调用和函数调用" class="headerlink" title="尾调用和函数调用"></a>尾调用和函数调用</h2><p>eBPF 程序可以通过尾调用和函数调用的概念来组合。函数调用允许在 eBPF 程序内部完成定义和调用函数。尾调用可以调用和执行另一个 eBPF 程序并替换执行上下文，类似于 execve() 系统调用对常规进程的操作方式。<br><img src="/img/file-20250329153901010.png"></p><h1 id="Chapter-2：简单运行Hello-World"><a href="#Chapter-2：简单运行Hello-World" class="headerlink" title="Chapter 2：简单运行Hello World"></a>Chapter 2：简单运行Hello World</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>code：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/python3</span><br>from bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;</span>Hello World!<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span><br><br>b = BPF(text=program)<br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br>b.trace_print()<br></code></pre></td></tr></table></figure><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 给予执行权限</span><br><span class="hljs-built_in">chmod</span> +x ~/ebpf-programs/hello.py<br><br><span class="hljs-comment"># 2. 使用sudo运行（eBPF需要root权限）</span><br><span class="hljs-built_in">sudo</span> ~/ebpf-programs/hello.py<br><br><span class="hljs-comment"># 或者</span><br><span class="hljs-built_in">sudo</span> python3 ~/ebpf-programs/hello.py<br></code></pre></td></tr></table></figure><h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><p>这段代码由两部分组成：运行在内核中的<strong>eBPF程序</strong>（被””” “””包住的部分)本身，以及<strong>将eBPF程序加载到内核并读取其生成的跟踪的用户空间代码</strong></p><p>hello.py是用户空间，hello()是运行在内核中的eBPF程序。<br><img src="/img/file-20250405102033975.png"></p><blockquote><p>[!NOTE]<br>整个代码是用python写的，但是eBPF程序本身是用C写的</p></blockquote><ul><li>辅助函数bpf_trace_printk()：可以用来编写消息&#x2F;打印信息；辅助函数是eBPF程序可以调用与系统交互的函数</li><li>跟踪输出：bpf_trace_printk()总是将输出发送到相同的预定义的伪文件位置：&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace_pipe。但如果有多个eBPF程序会导致混乱（都保存到同样的地方）&#x3D;&gt;引入BPF Maps</li></ul><blockquote><p>[!NOTE]<br>eBPF需要在root下运行（需要特权），如果不在root下则需要使用sudo</p></blockquote><ul><li>eBPF程序可以动态改变系统的行为，一旦负载到事件上就可以由效果-</li></ul><h2 id="BPF-Maps"><a href="#BPF-Maps" class="headerlink" title="BPF Maps"></a>BPF Maps</h2><ul><li>map是一种可以<strong>在用户空间访问</strong>的数据结构</li><li>maps可以用来在<strong>多个eBPF程序</strong>中共享数据，或者在<strong>用户空间</strong>应用程序和<strong>运行的eBPF代码</strong>之间通信<ul><li>用户空间写入配置信息到eBPF程序，以便检索</li><li>由一个eBPF程序存储状态以便后续由另一个程序检索</li><li>eBPF程序将结果或metrics写入map，以便用户空间应用呈现&#x2F;检索结果</li></ul></li></ul><h3 id="Hash-Table-Map"><a href="#Hash-Table-Map" class="headerlink" title="Hash Table Map"></a>Hash Table Map</h3><p>C程序部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">BPF_HASH(counter_table);<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctx)</span> &#123;<br>   u64 uid;<br>   u64 counter = <span class="hljs-number">0</span>;<br>   u64 *p;<br><br>   uid = bpf_get_current_uid_gid() &amp; <span class="hljs-number">0xFFFFFFFF</span>;<br>   p = counter_table.lookup(&amp;uid); <span class="hljs-comment">//查找map中是否存在对应的uid</span><br>   <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>      counter = *p;<span class="hljs-comment">//存在则取出对应的值cnt，不存在的话counter=0没有影响</span><br>   &#125;<br>   counter++;<span class="hljs-comment">//调用+1</span><br>   counter_table.update(&amp;uid, &amp;counter);<span class="hljs-comment">//更新对应的调用次数</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>BPF_HASH()</code>是bcc用于定义hash table的宏</li><li><code>bpf_get_current_uid_gid()</code>是一个辅助函数，用于获得触发k探针事件的进程ID（保存到了64位的低32位中，高32位保留给group ID（但是这部分被masked out了））</li><li><code>lookup(&amp;uid)</code> 在哈希表中查找具有与用户ID相匹配的键的条目，并返回一个指向对应值的指针</li></ul><p>bcc framework部分和前面helloworld基本相同，读取信息部分需要修改为从哈希表中读取<br>code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3  </span><br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_HASH(counter_table);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">   u64 uid;</span><br><span class="hljs-string">   u64 counter = 0;</span><br><span class="hljs-string">   u64 *p;</span><br><span class="hljs-string"></span><br><span class="hljs-string">   uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;</span><br><span class="hljs-string">   p = counter_table.lookup(&amp;uid);</span><br><span class="hljs-string">   if (p != 0) &#123;</span><br><span class="hljs-string">      counter = *p;</span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string">   counter++;</span><br><span class="hljs-string">   counter_table.update(&amp;uid, &amp;counter);</span><br><span class="hljs-string">   return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program)<br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-comment"># Attach to a tracepoint that gets hit for all syscalls </span><br><span class="hljs-comment"># b.attach_raw_tracepoint(tp=&quot;sys_enter&quot;, fn_name=&quot;hello&quot;)</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    sleep(<span class="hljs-number">2</span>)<br>    s = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> b[<span class="hljs-string">&quot;counter_table&quot;</span>].items():<br>        s += <span class="hljs-string">f&quot;ID <span class="hljs-subst">&#123;k.value&#125;</span>: <span class="hljs-subst">&#123;v.value&#125;</span>\t&quot;</span><br>    <span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>运行结果:<br><img src="/img/file-20250405121158545.png"><br>在调用ls时，只会增加一个count，而运行sudo ls时由于会执行sudo和ls，会增加两个count</p><h3 id="Perf-and-Ring-Buffer-Maps"><a href="#Perf-and-Ring-Buffer-Maps" class="headerlink" title="Perf and Ring Buffer Maps"></a>Perf and Ring Buffer Maps</h3><ul><li>允许以我们选择的结构将数据写入到perf环缓冲区映射中</li><li>环缓冲区可以看做是逻辑组织在环中的内存，由单独的写、读指针。任意长度的数据被写入指针的任何位置，<strong>长度信息包含在该数据的头</strong>中。对于读取操作，从读取指针所在的任何位置读取数据，使用头来确定要读取多少数据<br><img src="/img/file-20250405113648981.png"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3  </span><br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_PERF_OUTPUT(output); </span><br><span class="hljs-string"> </span><br><span class="hljs-string">struct data_t &#123;     </span><br><span class="hljs-string">   int pid;</span><br><span class="hljs-string">   int uid;</span><br><span class="hljs-string">   char command[16];</span><br><span class="hljs-string">   char message[12];</span><br><span class="hljs-string">&#125;;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">   struct data_t data = &#123;&#125;; </span><br><span class="hljs-string">   char message[12] = &quot;Hello World&quot;;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">   data.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span><br><span class="hljs-string">   data.uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;</span><br><span class="hljs-string">   </span><br><span class="hljs-string">   bpf_get_current_comm(&amp;data.command, sizeof(data.command));</span><br><span class="hljs-string">   bpf_probe_read_kernel(&amp;data.message, sizeof(data.message), message); </span><br><span class="hljs-string"> </span><br><span class="hljs-string">   output.perf_submit(ctx, &amp;data, sizeof(data)); </span><br><span class="hljs-string"> </span><br><span class="hljs-string">   return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program) <br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_event</span>(<span class="hljs-params">cpu, data, size</span>):  <br>   data = b[<span class="hljs-string">&quot;output&quot;</span>].event(data)<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;data.pid&#125;</span> <span class="hljs-subst">&#123;data.uid&#125;</span> <span class="hljs-subst">&#123;data.command.decode()&#125;</span> <span class="hljs-subst">&#123;data.message.decode()&#125;</span>&quot;</span>)<br> <br>b[<span class="hljs-string">&quot;output&quot;</span>].open_perf_buffer(print_event) <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <br>   b.perf_buffer_poll()<br></code></pre></td></tr></table></figure><ul><li><code>BPF_PERF_OUTPUT</code>用于创建一个map（从内核传递消息到用户空间–map output）</li><li><code>bpf_get_current_pid_tgid()</code>：获取触发词eBPF程序的进程ID</li><li><code>bpf_get_current_comm()</code>：用于获取在创建execve系统共享的进程中运行的可执行文件；这是一个字符串，传递参数方法不太一样（要传递地址和长度）</li></ul><p><img src="/img/file-20250405123905949.png"><br><img src="/img/file-20250405123948939.png"></p><h3 id="Tail-Calls"><a href="#Tail-Calls" class="headerlink" title="Tail Calls"></a>Tail Calls</h3><ul><li>尾调用可以调用并执行另一个eBPF程序，并替换执行上下文，且不会返回原始位置</li><li><code>long bpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index)</code><ul><li>ctx允许将上下文从调用的eBPF程序传递给被调用者。</li><li>prog_array_map是一种BPF_MAP_TYPE_PROG_ARRAY类型的eBPF映射，它包含一组标识eBPF程序的文件描述符。</li><li>index指示应该调用哪一组eBPF程序<br>  BCC framework下可以这样简化使用：<code>prog_array_map.call(ctx, index)</code></li></ul></li></ul><p>code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3  </span><br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><span class="hljs-keyword">import</span> ctypes <span class="hljs-keyword">as</span> ct<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_PROG_ARRAY(syscall, 500);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(struct bpf_raw_tracepoint_args *ctx) &#123;</span><br><span class="hljs-string">    int opcode = ctx-&gt;args[1];</span><br><span class="hljs-string">    syscall.call(ctx, opcode);</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Another syscall: %d&quot;, opcode);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_exec(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Executing a program&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_timer(struct bpf_raw_tracepoint_args *ctx) &#123;</span><br><span class="hljs-string">    int opcode = ctx-&gt;args[1];</span><br><span class="hljs-string">    switch (opcode) &#123;</span><br><span class="hljs-string">        case 222:</span><br><span class="hljs-string">            bpf_trace_printk(&quot;Creating a timer&quot;);</span><br><span class="hljs-string">            break;</span><br><span class="hljs-string">        case 226:</span><br><span class="hljs-string">            bpf_trace_printk(&quot;Deleting a timer&quot;);</span><br><span class="hljs-string">            break;</span><br><span class="hljs-string">        default:</span><br><span class="hljs-string">            bpf_trace_printk(&quot;Some other timer operation&quot;);</span><br><span class="hljs-string">            break;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int ignore_opcode(void *ctx) &#123;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program)<br>b.attach_raw_tracepoint(tp=<span class="hljs-string">&quot;sys_enter&quot;</span>, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br>ignore_fn = b.load_func(<span class="hljs-string">&quot;ignore_opcode&quot;</span>, BPF.RAW_TRACEPOINT)<br>exec_fn = b.load_func(<span class="hljs-string">&quot;hello_exec&quot;</span>, BPF.RAW_TRACEPOINT)<br>timer_fn = b.load_func(<span class="hljs-string">&quot;hello_timer&quot;</span>, BPF.RAW_TRACEPOINT)<br><br>prog_array = b.get_table(<span class="hljs-string">&quot;syscall&quot;</span>)<br><br><span class="hljs-comment"># Ignore all syscalls initially</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prog_array)):<br>    prog_array[ct.c_int(i)] = ct.c_int(ignore_fn.fd)<br><br><span class="hljs-comment"># Only enable few syscalls which are of the interest</span><br>prog_array[ct.c_int(<span class="hljs-number">59</span>)] = ct.c_int(exec_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">222</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">223</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">224</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">225</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">226</span>)] = ct.c_int(timer_fn.fd)<br><br>b.trace_print()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab3</title>
    <link href="/2025/03/24/AI-lab3/"/>
    <url>/2025/03/24/AI-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="AI-Lab3–搜索算法"><a href="#AI-Lab3–搜索算法" class="headerlink" title="AI-Lab3–搜索算法"></a>AI-Lab3–搜索算法</h1><h2 id="任务List"><a href="#任务List" class="headerlink" title="任务List"></a>任务List</h2><ol><li>利用盲目搜索解决迷宫问题（无需提交）</li><li>利用启发式搜索解决15-Puzzle问题</li><li>利用博弈树搜索实现象棋AI（无需提交）</li><li>利用遗传算法求解TSP问题</li></ol><h2 id="任务1：利用盲目搜索解决迷宫问题"><a href="#任务1：利用盲目搜索解决迷宫问题" class="headerlink" title="任务1：利用盲目搜索解决迷宫问题"></a>任务1：利用盲目搜索解决迷宫问题</h2><p>尝试利用DFS、BFS、深度受限算法、迭代加深算法、双向搜索算法解决迷宫问题:</p><ul><li>S表示起点;</li><li>E表示终点;</li><li>1表示墙;</li><li>0是可通行。<br>迷宫样例图：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">111111111111111111111111111111111111</span><br><span class="hljs-number">1000000000000000000000000000000000</span><span class="hljs-built_in">S1</span><br><span class="hljs-number">101111111111111111111111101111111101</span><br><span class="hljs-number">101100010001000000111111100011000001</span><br><span class="hljs-number">101101010101011110111111111011011111</span><br><span class="hljs-number">101101010101000000000000011011000001</span><br><span class="hljs-number">101101010101010111100111000011111101</span><br><span class="hljs-number">101001010100010000110111111110000001</span><br><span class="hljs-number">101101010111111110110000000011011111</span><br><span class="hljs-number">101101000110000000111111111011000001</span><br><span class="hljs-number">100001111110111111100000011011111101</span><br><span class="hljs-number">111111000000100000001111011010000001</span><br><span class="hljs-number">100000011111101111101000011011011111</span><br><span class="hljs-number">101111110000001000000011111011000001</span><br><span class="hljs-number">100000000111111011111111111011001101</span><br><span class="hljs-number">111111111100000000000000000011111101</span><br><span class="hljs-number">1</span>E0000000001111111111111111000000001<br><span class="hljs-number">111111111111111111111111111111111111</span><br></code></pre></td></tr></table></figure><h2 id="任务2：利用启发式搜索解决15-Puzzle问题"><a href="#任务2：利用启发式搜索解决15-Puzzle问题" class="headerlink" title="任务2：利用启发式搜索解决15-Puzzle问题"></a>任务2：利用启发式搜索解决15-Puzzle问题</h2><p>尝试使用<code>A*</code>与<code>IDA*</code>算法解决15-Puzzle问题，启发式函数可以自己选取，最好多尝试几种不同的启发式函数</p><p><img src="/img/image-20250324172954172.png" alt="样例_15puzzle"></p><p>利用A*算法和IDA*算法解决15-Puzzle问题, 可自定义启发式函数. Puzzle问题的输入数据类型为二维嵌套list, 空位置用 <code>0</code>表示. 输出的解数据类型为 <code>list</code>, 是移动数字方块的次序.</p><p>若选择A*算法, 则函数名为 <code>A_star</code>; 若选择IDA*算法, 则函数名为 <code>IDA_star</code>.</p><p>例子: 输入</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">puzzle = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3,4]</span>,<span class="hljs-comment">[5,6,7,8]</span>,<span class="hljs-comment">[9,10,11,12]</span>,<span class="hljs-comment">[0,13,14,15]</span>]</span><br></code></pre></td></tr></table></figure><p>则调用 <code>A_star(puzzle)</code>或 <code>IDA_star(puzzle)</code>后输出解</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[13,14,15]</span><br></code></pre></td></tr></table></figure><p>相关知识：<br><code>A*</code>算法的必要知识点：<br>&#x3D;&#x3D;算法描述&#x3D;&#x3D;：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">* 初始化open_set和close_set；<br>* 将起点加入open_set中，并设置优先级为0（优先级最高）；<br>* 如果open_set不为空，则从open_set中选取优先级最高的节点n：<br>    * 如果节点n为终点，则：<br>        * 从终点开始逐步追踪parent节点，一直达到起点；<br>        * 返回找到的结果路径，算法结束；<br>    * 如果节点n不是终点，则：<br>        * 将节点n从open_set中删除，并加入close_set中；<br>        * 遍历节点n所有的邻近节点：<br>            * 如果邻近节点m在close_set中，则：<br>                * 跳过，选取下一个邻近节点<br>            * 如果邻近节点m也不在open_set中，则：<br>                * 设置节点m的parent为节点n<br>                * 计算节点m的优先级<br>                * 将节点m加入open_set中<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;启发式函数：&#x3D;&#x3D; <code>f(n)=g(n)+h(n)</code></p><ul><li>f(n)是节点n的<strong>综合</strong>优先级。（每次选择会选择总和优先级最高，也就是<strong>f(n)值最小</strong>的节点&#x3D;&gt;维护一个优先队列）</li><li>g(n)是节点n距离<strong>起点</strong>的代价</li><li>h(n)是节点n距离<strong>终点</strong>的预估代价</li></ul><p>&#x3D;&gt;启发函数的选取：（网格形式的图）</p><ul><li>曼哈顿距离–适用于只允许&#x3D;&#x3D;上下左右&#x3D;&#x3D;四个方向移动  √ （同时加上线性冲突判断）</li><li>对角距离–适用于允许朝八个方向移动</li><li>欧几里得距离–适用于允许朝任何方向移动</li></ul><p>&#x3D;&gt;计算曼哈顿距离的函数：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">def heuristic(node):<br>dx=<span class="hljs-built_in">abs</span>(node.<span class="hljs-variable language_">x</span>-goal.<span class="hljs-variable language_">x</span>)<br>dy=<span class="hljs-built_in">abs</span>(node.<span class="hljs-variable language_">y</span>-goal.<span class="hljs-variable language_">y</span>)<br><span class="hljs-keyword">return</span> cost*(dx+dy)<br></code></pre></td></tr></table></figure><p><code>IDA*</code>算法：<br><code>IDA*</code>算法是在DFS的基础上，添加启发信息的启发式搜索算法。（IDA * 为采用了<strong>迭代加深算法的 A * 算法</strong>。）<br>优点：（相对于A*)</p><ul><li>不需要判重、不需要排序，利于深度剪枝</li><li><strong>空间需求减少</strong>：每个深度下实际上是一个深度优先搜索，不过有深度限制，使用DFS可以减小空间消耗<br>缺点：<br>重复搜索：当深度变大后每次都要从头搜索（不记忆-节省内存）</li></ul><p>&#x3D;&#x3D;算法描述&#x3D;&#x3D;：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1、开始时，计算起点所有邻居结点的估价函数，选取估价函数最小的结点作为下一个访问结点。(?)<br><br>2、重复步骤一，在递归过程中，若当前结点的估价函数大于阈值bound，则返回当前结点的估价得分。<br><br>3、若当前结点是目标结点，则得到最优解，返回路径。<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250330115435358.png"></p><p>算法思路：</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources:"></a>Resources:</h3><p><a href="https://zhuanlan.zhihu.com/p/54510444">路径规划之 A* 算法 - 知乎</a><br><a href="https://witchpuff.github.io/posts/astar/#2-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA">Solving 15-Puzzle with A* and IDA* | CyberWitch</a></p><p><img src="/img/file-20250329203607439.png" alt="1"><br><img src="/img/file-20250329203936669.png" alt="2"><br><img src="/img/file-20250331220621299.png" alt="3"></p><h2 id="任务3：利用博弈树搜索实现象棋AI"><a href="#任务3：利用博弈树搜索实现象棋AI" class="headerlink" title="任务3：利用博弈树搜索实现象棋AI"></a>任务3：利用博弈树搜索实现象棋AI</h2><p>编写一个中国象棋博弈程序，要求用alpha-beta剪枝算法，可以实现两个AI对弈。</p><ul><li>一方由人类点击或者AI算法控制。</li><li>一方由内置规则AI控制。</li><li>算法支持红黑双方互换</li></ul><h2 id="任务4：利用遗传算法求解TSP问题利用遗传算法求解-TSP-问题"><a href="#任务4：利用遗传算法求解TSP问题利用遗传算法求解-TSP-问题" class="headerlink" title="任务4：利用遗传算法求解TSP问题利用遗传算法求解 TSP 问题"></a>任务4：利用遗传算法求解TSP问题利用遗传算法求解 TSP 问题</h2><ul><li>在National Traveling Salesman Problems（uwaterloo.ca)（<a href="https://www.math.uwaterloo.ca/tsp/world/countries.html%EF%BC%89">https://www.math.uwaterloo.ca/tsp/world/countries.html）</a> 中任选两个TSP问题的数据集。</li><li>建议：<ul><li><p>对于规模较大的TSP问题, 遗传算法可能需要运行几分钟甚至几个小时的时间才能得到一个比较好的结果. 因此建议先用城市数较小的数据集测试算法正确与否, 再用城市数较大的数据集来评估算法性能。</p></li><li><p>由于遗传算法是基于随机搜索的算法, 只运行一次算法的结果并不能反映算法的性能. 为了更好地分析遗传算法的性能, 应该以不同的初始随机种子或用不同的参数(例如种群数量, 变异概率等)多次运行算法, 这些需要在实验报告中呈现.</p></li></ul></li></ul><p>resources：<br><a href="https://zhuanlan.zhihu.com/p/623494344">初识Numpy数组，看这一篇就够了！ - 知乎</a></p><h3 id="更加详细的要求："><a href="#更加详细的要求：" class="headerlink" title="更加详细的要求："></a>更加详细的要求：</h3><p>为了方便批改作业, 我们统一用类 <code>GeneticAlgTSP</code>来编写遗传算法的各个模块, 并分析算法性能. 该类需包含以下方法:</p><ul><li>构造函数 <code>__init__()</code>, 输入为TSP数据集文件名 <code>filename</code>, 数据类型 <code>str</code>. 例如 <code>&quot;dj38.tsp&quot;</code>是Djibouti的38个城市坐标数据文件; <code>&quot;ch71009.tsp&quot;</code>是China的71009个城市坐标数据文件. 我们需要在构造函数中读取该文件中的数据, 存储到类成员 <code>self.cities</code>中(数据类型自定, 建议存储为 <code>numpy</code>数组). 同时在构造函数中初始化种群, 存储到类成员 <code>self.population</code>中(数据类型自定).</li><li>求解方法 <code>iterate()</code>, 输入为算法迭代的轮数 <code>num_iterations</code>, 数据类型 <code>int</code>. 该方法是基于当前种群 <code>self.population</code>进行迭代(不是从头开始), 返回迭代后种群中的一个较优解, 数据类型 <code>list</code>, 格式为1-n个城市编号的排列. 例如, 对于n&#x3D;5的TSP问题, 迭代后返回的较优解形如 <code>[1,3,4,5,2]</code>, 表示当前较好的游览城市次序为1-3-4-5-2-1.</li></ul><p>可以在类中编写其他方法以方便编写并分析遗传算法的性能. 请在代码注释或实验报告中说明每个方法&#x2F;模块的功能.</p><h3 id="steps："><a href="#steps：" class="headerlink" title="steps："></a>steps：</h3><ul><li>读取文件，提取出城市维度和城市坐标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_tsp</span>(<span class="hljs-params">filename</span>):<br><br>    nodes=[]<br><br>    dimension=<span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file:<br><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br><br>            <span class="hljs-keyword">if</span> line.strip().startswith(<span class="hljs-string">&#x27;DIMENSION&#x27;</span>):<br><br>                <span class="hljs-comment">#获取维度信息</span><br><br>                dimension=line.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>].strip()<br><br>            <span class="hljs-comment">#节点信息获取</span><br><br>            <span class="hljs-keyword">if</span> line.strip().startswith(<span class="hljs-string">&#x27;NODE_COORD_SECTION&#x27;</span>):<br><br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br><br>            line = line.strip()<br><br>            <span class="hljs-keyword">if</span> line==<span class="hljs-string">&#x27;EOF&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> line:<br><br>                <span class="hljs-keyword">break</span>  <span class="hljs-comment">#结束</span><br><br>            parts=line.split()<br><br>            <span class="hljs-comment">#去掉开头编号，生成元组</span><br><br>            nodes.append((<span class="hljs-built_in">float</span>(parts[<span class="hljs-number">1</span>]),<span class="hljs-built_in">float</span>(parts[<span class="hljs-number">2</span>])))<br><br>    location=np.array(nodes)<br><br>    <span class="hljs-keyword">return</span> dimension,location<br></code></pre></td></tr></table></figure><ul><li>初始化种族：在城市数较少时使用<strong>随机数</strong>生成法，中等城市数可以考虑部分贪婪（？，大体量城市再考虑其他</li></ul><h2 id="相关资料：NumPy随机排列：使用numpy-random-permutation实现数组元素的随机重排-极客教程"><a href="#相关资料：NumPy随机排列：使用numpy-random-permutation实现数组元素的随机重排-极客教程" class="headerlink" title="相关资料：NumPy随机排列：使用numpy.random.permutation实现数组元素的随机重排|极客教程"></a>相关资料：<a href="https://geek-docs.com/numpy/numpy-ask-answer/numpy-random-permutation_z1.html">NumPy随机排列：使用numpy.random.permutation实现数组元素的随机重排|极客教程</a></h2><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol><li>数据集来源于网站<a href="https://www.math.uwaterloo.ca/tsp/world/countries.html">National Traveling Salesman Problems (uwaterloo.ca)</a>. 可浏览该网站参考相关国家的TSP问题的解. 可以自选1-2个数据集来测试算法性能, 并在实验报告中说明.</li><li>TSP问题上遗传算法的具体实现(解的表示, 染色体交叉操作等)不一定局限于课件上的方式, 也许存在比课件效果更好的具体实现方法.</li><li>由于遗传算法是基于随机搜索的算法, 只运行一次算法的结果并不能反映算法的性能. 为了更好地分析遗传算法的性能, 应该以不同的初始随机种子或用不同的参数(例如种群数量, 变异概率等)多次运行算法, 这些需要在实验报告中呈现.</li><li>最后提交的代码只需包含性能最好的实现方法和参数设置. 只需提交一个代码文件, 请不要提交其他文件.</li><li>对于规模较大的TSP问题, 遗传算法可能需要运行几分钟甚至几个小时的时间才能得到一个比较好的结果. 因此建议先用城市数较小的数据集测试算法正确与否, 再用城市数较大的数据集来评估算法性能.</li><li>本次作业可以使用 <code>numpy</code>库以及python标准库. 有余力的同学可用 <code>matplotlib</code>库对遗传算法的结果进行可视化处理与分析, 并在实验报告中呈现.</li></ol><h2 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h2><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>模拟退火算法SA来源于固体退火原理，是一种基于<strong>概率</strong>的算法。<br>模拟退火算法从某一较高初温出发，伴随温度参数的不断下降，&#x3D;&#x3D;结合概率突跳特性在解空间中随机寻找目标函数的全局最优解&#x3D;&#x3D;，<strong>即在局部最优解能</strong>概率性地跳出<strong>并</strong>最终趋于全局最优。</p><blockquote><p>[!NOTE]<br>算法思想为：先从一个<strong>较高的初始温度</strong>出发，逐渐降低温度，直到温度降低到满足热平衡条件为止。在每个温度下，进行<strong>n轮搜索</strong>，每轮搜索时对旧解添加随机扰动生成新解，并按一定规则接受新解。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模拟退火算法包含两个部分即&#x3D;&#x3D;Metropolis算法&#x3D;&#x3D;和&#x3D;&#x3D;退火过程&#x3D;&#x3D;，分别对应内循环和外循环。</p><ul><li><strong>外循环就是退火过程</strong>，将固体达到较高的温度（初始温度T（0）），然后按照降温系数alpha使温度按照一定的比例下降，当达到<strong>终止温度Tf</strong>时，冷却结束，即退火过程结束。<blockquote><p>[!NOTE]</p><ul><li><p>外层循环控制温度由高向低变化</p></li><li><p>内层循环中温度固定，对旧解添加随机扰动得到新解，并按一定规则接受新解。迭代次数成为马尔可夫链长度</p></li></ul></blockquote></li><li><strong>Metropolis算法是内循环</strong>，即<u>在每次温度下，迭代L次，寻找在该温度下能量的最小值</u>（即最优解）。</li></ul><h3 id="算法优点"><a href="#算法优点" class="headerlink" title="算法优点"></a>算法优点</h3><p><strong>不管函数形式多复杂，模拟退火算法更有可能找到全局最优解。</strong></p><p>过程图：</p><p><img src="/img/file-20250331170514223.png"></p><p>伪代码：<br><img src="/img/file-20250331170528207.png"><br><img src="/img/file-20250331170610602.png"></p><p>resources：<br><a href="https://zhuanlan.zhihu.com/p/382426984">模拟退火算法超详细教程 - 知乎</a></p><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><blockquote><p>[!NOTE]<br>遗传算法是受自然进化理论启发的一系列搜索算法。</p></blockquote><p>达尔文进化论的原理概括总结如下：</p><ol><li>&#x3D;&#x3D;变异&#x3D;&#x3D;：种群中单个样本的特征(性状，属性)可能会有所不同，这导致了样本彼此之间有一定程度的差异</li><li>&#x3D;&#x3D;遗传&#x3D;&#x3D;：某些特征可以遗传给其后代。导致后代与双亲样本具有一定程度的相似性</li><li>&#x3D;&#x3D;选择&#x3D;&#x3D;：种群通常在给定的环境中争夺资源。更适应环境的个体在生存方面更具优势，因此会产生更多的后代</li></ol><p>进化算法：</p><ol><li>选择</li><li>交叉（或重组）</li><li>变异</li></ol><p><strong>达尔文进化论&lt;&#x3D;&gt;遗传算法</strong>的对应概念</p><ul><li>遗传算法试图找问题的最优解</li></ul><table><thead><tr><th>达尔文进化论</th><th>遗传算法</th></tr></thead><tbody><tr><td>保留种群的个体性状</td><td>保留了针对给定问题的<strong>候选解集合</strong></td></tr><tr><td><strong>适者生存</strong>并更有可能遗传优良特性</td><td>候选解经过<strong>迭代评估</strong>，越优的解越有可能将特征传递给下一代候选解集合</td></tr></tbody></table><p>算法的基本思想：<br>在求解问题时从多个解开始，然后通过一定的法则进行逐步迭代以产生新的解</p><p>遗传算法的过程：</p><ul><li>开始时，种群随机初始化，并计算每个个体的适应度函数，初代产生</li><li>如果不满足优化准则，开始产生新一代计算</li><li>为了产生下一代，按照适应度选择个体，父代进行基因重组而产生子代</li><li>子代有几率变异，子代的适应度被重新计算</li><li>循环直到满足优化准则</li></ul><p>伪代码：<br><img src="/img/file-20250331172623564.png"></p><p><img src="/img/9a1dfe9d663af4eb0c6989344df3c6f.jpg"></p><p>resources：<br><a href="https://zhuanlan.zhihu.com/p/436453994">遗传算法 (Genetic Algorithm, GA) 详解与实现 - 知乎</a></p><h2 id="旅行商问题–解的表示"><a href="#旅行商问题–解的表示" class="headerlink" title="旅行商问题–解的表示"></a>旅行商问题–解的表示</h2><p><img src="/img/file-20250331173623765.png"><br><img src="/img/file-20250331173701655.png"><br><img src="/img/file-20250331173729854.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML_Notes</title>
    <link href="/2025/03/16/HTML-Notes/"/>
    <url>/2025/03/16/HTML-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-入门"><a href="#HTML-入门" class="headerlink" title="HTML 入门"></a>HTML 入门</h1><p>Resources：</p><p><a href="https://wangdoc.com/html/intro">HTML 语言简介 - HTML 教程 - 网道</a></p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=tag_meta_name">W3School TIY Editor</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HTML是网页使用的语言，定义了网页的结构和内容，是一种标签语言。浏览器访问网站相当于从服务器下载HTML代码，然后渲染出网页。</p><p>浏览器的网页开发，涉及三种技术：<strong>HTML、CSS 和 JavaScript</strong>。HTML 语言定义网页的<strong>结构和内容</strong>，CSS 样式表定义<strong>网页的样式</strong>，JavaScript 语言定义网页与用户的互动行为（<strong>交互</strong>）。</p><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打开就会看到Hello World</p><h2 id="网页的基本概念"><a href="#网页的基本概念" class="headerlink" title="网页的基本概念"></a>网页的基本概念</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote><p>作为一门标签语言，学习HTML就是学习各种标签的用法</p></blockquote><p>标签大多是<strong>成对</strong>出现的，比如<code>&lt;title&gt;</code>和<code>&lt;/title&gt;</code>，前者为开始标签，后者为结束标签；单独使用的标签：如<code>&lt;meta&gt;</code>标签，用于提示浏览器，做一些特别处理，并不需要使用到标签之间的内容。</p><p>标签用于指示浏览器如何处理这段代码，如何渲染</p><p>标签可以嵌套，但要正确嵌套，闭合顺序和括号是类似的，不能跨层嵌套</p><ul><li>正确：<code>&lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt;</code></li></ul><p>HTML标签名对<strong>大小写不敏感</strong>，习惯上使用小写，同时HTML语言<strong>忽略缩进与换行</strong>。</p><ul><li>下面三种情况都是一样的：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br>  网页标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页<br>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>浏览器渲染网页时，会把 HTML 源码解析成一个标签树，每个标签都是树的一个节点，这种节点就称为网页元素。比如<code>&lt;p&gt;</code>标签对应网页的<code>p</code>元素</p><p>嵌套的标签构成了网页元素的层级关系。</p><h4 id="块集元素、行内元素"><a href="#块集元素、行内元素" class="headerlink" title="块集元素、行内元素"></a>块集元素、行内元素</h4><p>块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据 100% 的宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>p</code>元素是会计元素，所以浏览器会将内容分成两行显示</p><p>行内元素默认与其他元素在同一行，<strong>不产生换行</strong>。比如，<code>span</code>就是行内元素，通常用来为某些文字指定<strong>特别的样式</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>span</code>元素是行内元素，因此浏览器会<strong>将两行内容放在一行显示</strong></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是标签的额外信息，使用<strong>空格与标签名</strong>和其他属性分隔</p><p>属性可以用<code>=</code>指定属性值，比如 <code>&lt;img src=&quot;demo.jpg&quot; width=&quot;500&quot;&gt;</code>；属性值一般放在双引号里面，这不是必须的，但推荐使用</p><p>属性名对大小写不敏感</p><h2 id="网页的基本标签"><a href="#网页的基本标签" class="headerlink" title="网页的基本标签"></a>网页的基本标签</h2><p>基本结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="&lt;!doctype&gt;"></a>&lt;!doctype&gt;</h3><p>网页的第一个标签通常是&lt;!doctype&gt;，表示<strong>文档类型</strong>，告诉浏览器如何解析网页。</p><p>一般来说，只要像下面这样，简单声明<code>doctype</code>为<code>html</code>即可。浏览器就会按照 HTML 5 的规则处理网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;html&gt;"></a><code>&lt;html&gt;</code></h3><p>这个标签是网页的<strong>顶层容器</strong>，即标签树结构的<strong>顶层节点</strong>，也称为<strong>根元素</strong>，其他元素都是它的子元素。<strong>一个网页只能有一个 <code>html</code>标签</strong></p><p>该标签的 <code>lang</code> 属性表示网页内容<strong>默认的语言</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;head&gt;"></a><code>&lt;head&gt;</code></h3><p><code>&lt;head&gt;</code>标签是一个容器标签，用于放置网页的<strong>元信息</strong>。它的内容不会出现在网页上，而是<u>为网页渲染提供额外信息</u>。</p><ul><li>在爬虫时我们也需要使用到head，将自己伪装成真实的浏览器</li></ul><p><code>&lt;head&gt;</code>是<code>&lt;html&gt;</code>的第一个子元素。如果网页不包含<code>&lt;head&gt;</code>，浏览器会自动创建一个。</p><p><code>&lt;head&gt;</code>的<strong>子元素</strong>一般有下面七个，后文会一一介绍。</p><ul><li><code>&lt;meta&gt;</code>：设置网页的<strong>元数据</strong>。</li><li><code>&lt;link&gt;</code>：连接<strong>外部样式表</strong>。</li><li><code>&lt;title&gt;</code>：设置<strong>网页标题</strong>。</li><li><code>&lt;style&gt;</code>：放置<strong>内嵌的样式表</strong>。</li><li><code>&lt;script&gt;</code>：引入脚本。</li><li><code>&lt;noscript&gt;</code>：浏览器不支持脚本时，所要显示的内容。</li><li><code>&lt;base&gt;</code>：设置网页内部相对 URL 的计算基准。</li></ul><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h3><p><code>&lt;meta&gt;</code>标签用于设置或说明网页的元数据，必须放在<code>&lt;head&gt;</code>里面。一个<code>&lt;meta&gt;</code>标签就是一项元数据，网页可以有多个<code>&lt;meta&gt;</code>。</p><p>不管什么样的网页，一般都可以放置下面两个 <code>&lt;meta&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Page Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一个<code>&lt;meta&gt;</code>标签表示网页采用 UTF-8 格式编码，第二个<code>&lt;meta&gt;</code>标签表示<strong>网页在手机端可以自动缩放</strong>。</p><h4 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h4><p><strong>（1）charset 属性</strong>：</p><ul><li>用来指定网页的编码方式，防止乱码</li></ul><p><strong>（2）name 属性，content 属性</strong>：</p><ul><li><code>name</code>属性表示元数据的名字， <code>content</code>属性表示元数据的值；合在一起使用可以为网页指定一项元数据</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML 语言入门&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML,教程&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">application-name</td><td align="left">规定页面代表的 Web 应用程序的名称。</td></tr><tr><td align="left">author</td><td align="left">规定文档作者的姓名。例如：<meta name="author" content="YK Investment"></td></tr><tr><td align="left">description</td><td align="left">规定页面的描述。搜索引擎可以选择此描述来显示搜索结果。例如：<meta name="description" content="免费的 Web 教程"></td></tr><tr><td align="left">generator</td><td align="left">规定用于生成文档的软件包之一（不用于手写页面）。例如：<meta name="generator" content="FrontPage 4.0"></td></tr><tr><td align="left">keywords</td><td align="left">规定与页面相关的关键字列表，以逗号分隔。告知搜索引擎关于页面的内容。**提示：**请始终规定关键字（搜索引擎需要对页面进行分类）。例如：<meta name="keywords" content="HTML, meta tag, tag reference"></td></tr><tr><td align="left">viewport</td><td align="left">控制视口（网页的用户可见区域）。</td></tr></tbody></table><p><strong>（3）http-equiv 属性，content 属性</strong>：</p><p><code>&lt;meta&gt;</code>标签的http-equiv属性用来<strong>补充 HTTP 回应的头信息字段</strong>，如果服务器发回的HTTP回应缺少某个字段，就可以用它来补充。</p><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;title&gt;"></a><code>&lt;title&gt;</code></h3><p><code>&lt;title&gt;</code>标签用于<strong>指定网页的标题</strong>，会<u>显示在浏览器窗口的标题栏</u>。</p><p><code>&lt;title&gt;</code>标签内部不能嵌套标签，只能放置<strong>无格式的纯文本</strong></p><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h3><p><code>&lt;body&gt;</code>标签是一个容器标签，用于放置网页的<strong>主体内容</strong>；浏览器显示的页面内容，都放置在它的内部</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="空格和换行"><a href="#空格和换行" class="headerlink" title="空格和换行"></a>空格和换行</h2><p>HTML 语言有自己的空格处理规则。<strong>标签内容的头部和尾部的空格</strong>，一律忽略不计。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>  hello world   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&gt;这个只会显示成 <code>hello world</code>而非 <code>  hello world   </code></p><p>标签内容里面的<strong>多个连续空格</strong>（包含制表符<code>\t</code>），会被浏览器<strong>合并成一个</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello      world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&gt;只会显示成 <code>hello world</code>而非 <code>hello      world</code></p><p>还会将文本中的<strong>换行符 <code>\n</code>和回车符 <code>\t</code>替换成空格</strong>，如果文本之间有多个换行，会替换成空格，然后多个空格会合并为一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<br><br><br><br>world<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&gt;只会显示成 <code>hello world</code></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，注释可以是多行的。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  &lt;p&gt;这是一个注释&lt;/p&gt;</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><h1 id="URL简介"><a href="#URL简介" class="headerlink" title="URL简介"></a>URL简介</h1><p>URL 是“统一资源定位符”（Uniform Resource Locator）的首字母缩写，中文是“网址”</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>浏览器请求服务器资源的方法，如HTTPS协议</p><p>HTTPS是HTTP的<strong>加密版本</strong>，每个协议的格式不同，https后面会加 <code>://</code>，但邮件协议<code>mailto</code>的协议后面只有一个冒号，eg：<code>mailto:foo@example.com</code></p><h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><p>主机host是<strong>资源所在的网站名或服务器的名字</strong>，又称为<strong>域名</strong>。</p><p>有些主机没有域名，只有ip地址–局域网常常出现</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>同一个域名下面可能同时包含多个网站，他们通过<strong>端口port</strong>区分</p><p>HTTP 协议的<u>默认端口是80</u>，如果省略了这个参数，服务器就会返回80端口的网站。</p><p>端口紧跟在域名后面，两者之间使用冒号分隔，比如<code>www.example.com:80</code></p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>路径（path）是资源在网站的位置。</p><p>比如<code>https://pqcu77.github.io/index.html</code>指向了博客路径下的index.html文件。现在由于服务器可能模拟这些位置，所以路径只是虚拟位置</p><p>路径可能只包含目录，不包含文件名，在不同的服务器设置下，服务器可能会默认跳转到该目录下的文件中。</p><h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><p>查询参数是提供给服务器的额外信息，参数位置是在路径后面，两者之间使用 <code>? </code>分隔，查询参数可以有一组或者多组，每组参数都是键值对的形式，键值对之间用等号<code>=</code>连接，多组参数之间使用<code>&amp;</code>连接</p><p>如：<code>?key1=value1&amp;key2=value2</code></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>锚点是网页内部的定位点，使用<code>#</code>加上锚点名称，放在网址的最后。例子：<code>https://pqcu77.github.io/2025/03/06/cs50-ai-Machine-Learning/#Project</code></p><p>浏览器加载页面以后，会自动滚动到锚点所在的位置，锚点名称通过网页元素<code>id</code>属性命名</p><p><img src="/img/image-20250316164425053.png" alt="image-20250316164425053"></p><p>图中你可以看到有多个id属性</p><h2 id="URL字符"><a href="#URL字符" class="headerlink" title="URL字符"></a>URL字符</h2><p>URL 的各个组成部分，只能使用以下这些字符。</p><ul><li>26个英语字母（包括大写和小写）</li><li>10个阿拉伯数字</li><li>连词号（<code>-</code>）</li><li>句点（<code>.</code>）</li><li>下划线（<code>_</code>）</li></ul><p>还有18个字符属于URL的保留字符，只能在给定的位置出现。比如查询参数的<code>?</code></p><p>如果要使用他们，需要使用转义字符，对应方式是：<u>在这些字符的十六进制ASCII码前面加上百分号%</u>。</p><ul><li><p><code>!</code>：%21</p></li><li><p><code>#</code>：%23</p></li><li><p><code>$</code>：%24</p></li><li><p><code>&amp;</code>：%26</p></li><li><p><code>&#39;</code>：%27</p></li><li><p><code>(</code>：%28</p></li><li><p><code>)</code>：%29</p></li><li><p><code>*</code>：%2A</p></li><li><p><code>+</code>：%2B</p></li><li><p><code>,</code>：%2C</p></li><li><p><code>/</code>：%2F</p></li><li><p><code>:</code>：%3A</p></li><li><p><code>;</code>：%3B</p></li><li><p><code>=</code>：%3D</p></li><li><p><code>?</code>：%3F</p></li><li><p><code>@</code>：%40</p></li><li><p><code>[</code>：%5B</p></li><li><p><code>]</code>：%5D</p></li><li><p>空格的转义形式是 <code>%20</code></p></li></ul><p>既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 URL 里面，比如<code>www.example.com/中国.html</code>，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 UTF-8 编码，每两位算作一组，然后每组头部添加百分号（<code>%</code>）。</p><h2 id="绝对URL和相对URL"><a href="#绝对URL和相对URL" class="headerlink" title="绝对URL和相对URL"></a>绝对URL和相对URL</h2><p>绝对URL：带有资源的完整信息，包含协议、主机、路径等部分</p><p>相对URL：不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。</p><p>URL 还可以使用两个特殊简写，表示特定位置。</p><ul><li><code>.</code>：表示当前目录，比如<code>./a.html</code>（当前目录下的<code>a.html</code>文件）</li><li><code>..</code>：表示上级目录，比如<code>../a.html</code>（上级目录下的<code>a.html</code>文件）</li></ul><h2 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;base&gt;标签"></a><code>&lt;base&gt;</code>标签</h2><p>指定网页内部的所有相对URL的计算基准，整张网页只能有一个<code>&lt;base&gt;</code>标签</p><h1 id="网页元素的属性"><a href="#网页元素的属性" class="headerlink" title="网页元素的属性"></a>网页元素的属性</h1><p>网页元素的属性（attribute）可以定制元素的行为，不同的属性会导致元素有不同的行为。</p><p>属性名也对大小写不敏感</p><h3 id="全局属性：所有元素都可以使用"><a href="#全局属性：所有元素都可以使用" class="headerlink" title="全局属性：所有元素都可以使用"></a>全局属性：所有元素都可以使用</h3><ul><li>但有些属性对某些元素可能不产生意义</li></ul><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul><li>id属性是元素在网页内的<strong>唯一标识符</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验四</title>
    <link href="/2025/03/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
    <url>/2025/03/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="conda指令"><a href="#conda指令" class="headerlink" title="conda指令"></a>conda指令</h1><ul><li>创建python虚拟环境<br><code>conda create -n py36 python=3.6.5</code></li><li>进入某个python虚拟环境<br><code>conda activate xxx</code></li><li>在虚拟环境中安装<br><code>conda install numpy</code>或<code>pip install numpy</code></li></ul><p><a href="https://blog.csdn.net/menc15/article/details/71477949">Anaconda环境管理-CSDN博客</a></p><h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><ol><li><p>实验目的<br>（1）深入理解和掌握<strong>离散时间非周期信号的傅里叶变换</strong>及计算方法；<br>（2）熟悉离散时间傅里叶变换的性质；<br>（3）理解离散时间 LTI 系统的频域分析原理和方法，掌握离散时间 LTI 系统的频率响应求解方法，并能编程绘制相应的幅频、相频响应曲线。</p></li><li><p>实验原理<br><img src="/img/file-20250413093659825.png"></p></li></ol><p>python提供的 <code>scipy.signal.freqz()</code>函数可以近似求解离散时间傅里叶变换。<br>无穷级数求和：SymPy符号函数求和方法： <code>sum()</code> <code>summation()</code> <code>gosper_sum()</code>等函数都可以用于级数求和操作。<br>SymPy符号函数积分的方法：<code>integrate()</code><br>通过numpy库和scipy库可以产生<strong>基本的信号</strong>，如阶跃信号、指数信号、脉冲信号等等，其中<strong>scipy.signal可用于计算信号的卷积</strong><br><a href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal">Signal processing (scipy.signal) — SciPy v1.15.2 Manual</a></p><ol start="3"><li><p>性质<br><img src="/img/file-20250413105048333.png"><br><img src="/img/file-20250413105117697.png"><br><img src="/img/file-20250413105354392.png"></p></li><li><p>实验任务<br>（1）编程计算双边指数衰减信号$𝑥[𝑛] &#x3D; e^{−2|𝑛|}$的离散时间傅里叶变换，并验证其时域内插，即<br>$$<br>\begin{cases}<br> \begin{split}<br> x[n&#x2F;k],n为k的整数倍\<br> 0, 其他n<br> \end{split}<br>\end{cases}<br>$$<br>的离散时间傅里叶变换，取𝑘 &#x3D; 3。请分别绘制$𝑥[𝑛]$和$𝑥_{k}[𝑛]$的幅频曲线和相频曲线。<br><img src="/img/file-20250414105151886.png"></p></li></ol><p><img src="/img/file-20250414113453654.png"><br>（2）考虑差分方程$𝑦[𝑛] − 𝑎𝑦[𝑛 − 1] &#x3D; 𝑥[𝑛]$，其中|𝑎| &lt; 1。取𝑎 &#x3D;0.2，编程求解该方程所描述系统的频率响应，并：<br>（a）画出系统的幅频和相频特性曲线；<br>（b）求解系统的单位脉冲响应并绘制出图形</p><p><img src="/img/file-20250414112640663.png"><br><img src="/img/file-20250414112651331.png"></p><p>（3）设离散时间双边指数衰减信号$𝑥[𝑛] &#x3D; e^{−2|𝑛|}, 𝑦[𝑛] &#x3D; 𝑥[𝑛] ∗ 𝑥[𝑛]$，请<br>（a）编程用卷积性质求解$𝑌(e^{j𝜔})$与$𝑦[𝑛]$，并绘制$𝑥[𝑛]$、$|𝑌(e^{j𝜔})|$和$𝑦[𝑛]$的图像；<br>（b）编程用时域卷积求解$𝑦[𝑛]$，绘制$𝑦[𝑛]$的图像，并与（a）的结果比较</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab3</title>
    <link href="/2025/03/12/OS-lab3/"/>
    <url>/2025/03/12/OS-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lab3：从实模式到保护模式"><a href="#OS-Lab3：从实模式到保护模式" class="headerlink" title="OS_Lab3：从实模式到保护模式"></a>OS_Lab3：从实模式到保护模式</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li><p>DDL：2025.4.6</p></li><li><p>提交内容：2+1个任务的代码和实验报告 传课程邮箱<a href="https://gitee.com/link?target=mailto:os_sysu_lab@163.com">os_sysu_lab@163.com</a>+实验报告pdf–提交到<a href="https://inbox.weiyun.com/NuWl0loN">腾讯微云</a></p></li><li><p><strong>材料的Example的代码放置在<code>src</code>目录下</strong>。</p></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习如何从16位的实模式跳转到32位的保护模式，然后在平坦模式下运行32位系统。同时学习如何使用I&#x2F;O端口和硬件交互，为后面保护模式编程打下基础</p><h2 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h2><h3 id="突破512字节的限制"><a href="#突破512字节的限制" class="headerlink" title="突破512字节的限制"></a>突破512字节的限制</h3><p>​我们在之前学到了计算机在启动的最后只会自动加载MBR（512字节）到内存中运行，然而这个空间是很小的，所以在实际应用中，MBR只负责定义了一些基本信息，如磁盘大小、扇区大小等。</p><p>​在运行操作系统前，需要将操作系统内核程序从外存加载到内存中，但这个空间大小无疑是较大的，因而在系统内核加载前，我们的MBR不再是输出“hello world”，而是<strong>将一段程序从外存加载到内存</strong>（大小无512Bytes限制）。这段程序（称为<strong>bootloader</strong>）在内存足够的前提下可以尽量大一点–可以实现：从实模式跳转到保护模式、加载操作系统内核等。</p><p>​无论是MBR还是bootloader，其最开始都是存放在<strong>磁盘</strong>（外存）上的。而MBR和bootloader只有被加载到内存中才可以被执行，除了MBR外，计算机是不会去外存找程序执行的。<strong>MBR</strong>是在计算机启动时被计算机<strong>自动加载到0x7C00处</strong>执行。此后，计算机的任何行为都由我们的程序来控制。也就是说，<u>我们需要自己从外存中加载程序到内存中运行。</u>–学习如何读写硬盘！</p><h3 id="LBA方式读写硬盘"><a href="#LBA方式读写硬盘" class="headerlink" title="LBA方式读写硬盘"></a>LBA方式读写硬盘</h3><h4 id="读写I-O端口"><a href="#读写I-O端口" class="headerlink" title="读写I&#x2F;O端口"></a>读写I&#x2F;O端口</h4><ul><li>硬盘属于外设，<u>CPU和外设的交换</u>通过<strong>I&#x2F;O端口</strong>进行。</li><li>I&#x2F;O端口是一些<strong>寄存器</strong>，位于I&#x2F;O接口电路中。当需要进行数据交换时，我们先将命令和数据放入到指定的I&#x2F;O端口中，等待外设处理完后再从指定的端口取出处理结果。指定的端口也可以获取外设的状态。</li></ul><blockquote><p>（指定–数据交换的I&#x2F;O端口已经被预先规定好了）</p></blockquote><ul><li><p>和寄存器编址很相似，每一个端口在I&#x2F;O电路中都会被<strong>统一编址</strong>。</p><ul><li><p>主硬盘分配的端口地址是0x1f0<del>0x1f7，从硬盘分配的端口地址是0x170</del>0x177</p></li><li><p>由于端口是独立编址的，因此我们<strong>无法使用mov指令来对端口赋值</strong>，可以使用in（读），out（写）指令。</p></li><li><p>值得注意的是：<strong>in指令的源操作数只能是立即数或dx，目的操作数只能是ax和al；out指令的源操作数只能是al或ax，目的操作数只能是立即数或dx</strong></p></li><li><p>例子：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; in指令</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x21</span> <span class="hljs-comment">; 表示从0x21端口读取一字节数据到al</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0x21</span> <span class="hljs-comment">; 表示从端口地址0x21读取1字节数据到al，从端口地址0x22读取1字节到ah</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0x379</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span>  <span class="hljs-comment">; 从端口0x379读取1字节到al</span><br><br><span class="hljs-comment">; out指令</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x21</span>, <span class="hljs-built_in">al</span> <span class="hljs-comment">; 将al的值写入0x21端口</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x21</span>, <span class="hljs-built_in">ax</span> <span class="hljs-comment">; 将ax的值写入端口地址0x21开始的连续两个字节</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x378</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">ax</span>  <span class="hljs-comment">; 将ah和al分别写入端口0x379和0x378</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="读写硬盘"><a href="#读写硬盘" class="headerlink" title="读写硬盘"></a>读写硬盘</h4><ul><li>硬盘的读写是以块为单位的，块在硬盘中也被称为扇区，一般的扇区大小是512字节。</li><li>LBA的全称是Logical Block Addressing, <strong>逻辑块寻址模式</strong>。</li><li>硬盘的物理结构包括<strong>磁头、扇区和柱面</strong>（CHS），通过CHS就可以定位磁盘上的数据–在访问硬盘时手动指定磁头、磁道和柱面。</li></ul><p><img src="/img/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84.png" alt="硬盘内部示意图"></p><ul><li>另一种方法：LBA模式。此模式下磁盘的地址空间被划分一个个的逻辑块，访问时<u>只需要指定对应磁盘地址对应的逻辑块</u>即可。</li></ul><blockquote><p>在实模式下，还有利用BIOS中断来读取硬盘的方式，称为CHS模式。需要手动将逻辑扇区号转化为磁盘对应的磁头、磁道和柱面，比较麻烦。这里不使用BIOS中断的原因是因为BIOS中断是16位程序，在保护模式下无法使用。有兴趣的同学可以自行探索“<strong>通过BIOS中断读取硬盘</strong>”</p></blockquote><p>使用LBA读取硬盘的方式：</p><ul><li><p>设置<strong>起始的逻辑扇区号</strong>。由于扇区的读写是连续的，因此只要给出第一个扇区的编号就好了。此处使用的是LBA28（28表示使用28位来表示逻辑扇区的编号）的方式来读取硬盘–但IO端口一次只能读取8位，所以要分<strong>四段</strong>写入端口。</p><ul><li>逻辑扇区的0<del>7位被写入0x1F3端口，8</del>15位被写入0x1F4端口，16~23位被写入0x1F5端口，最后4位被写入0x1F6端口的低4位。</li></ul><table><thead><tr><th align="left">端口地址</th><th align="left">数据位范围</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0x1F3</td><td align="left">0~7</td><td align="left">逻辑扇区号的低 8 位</td></tr><tr><td align="left">0x1F4</td><td align="left">8~15</td><td align="left">逻辑扇区号的中间 8 位</td></tr><tr><td align="left">0x1F5</td><td align="left">16~23</td><td align="left">逻辑扇区号的高 8 位</td></tr><tr><td align="left">0x1F6</td><td align="left">24~27</td><td align="left">逻辑扇区号的最高 4 位</td></tr></tbody></table><ul><li>0x1F6的8个位表示如下</li></ul></li></ul><p><img src="/img/0x1f6%E7%AB%AF%E5%8F%A3.png" alt="0x1f6端口"></p><ul><li><p>将要读取的扇区数量写入0x1F2端口。<strong>8位端口</strong>，每次最多只能读写255个扇区</p></li><li><p>向0x1F7端口写入0x20，请求硬盘读。</p></li><li><p>等待其他读写操作完成。</p></li></ul><p><img src="/img/0x1f7.png" alt="0x1f7"></p><ul><li>若在第四步中检测到其他操作已经完成，那么我们就可以正式从硬盘中读取数据。</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_read_hard_disk:</span>                           <br><span class="hljs-comment">; 从硬盘读取一个逻辑扇区</span><br><br><span class="hljs-comment">; 参数列表</span><br><span class="hljs-comment">; ax=逻辑扇区号0~15位</span><br><span class="hljs-comment">; cx=逻辑扇区号16~28位</span><br><span class="hljs-comment">; ds:bx=读取出的数据放入地址</span><br><br><span class="hljs-comment">; 返回值</span><br><span class="hljs-comment">; bx=bx+512</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f3</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>    <span class="hljs-comment">; LBA地址7~0</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; 0x1f4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">ah</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>    <span class="hljs-comment">; LBA地址15~8</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">cx</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; 0x1f5</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>    <span class="hljs-comment">; LBA地址23~16</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; 0x1f6</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">ah</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0xe0</span>   <span class="hljs-comment">; LBA地址27~24</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f2</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>   <span class="hljs-comment">; 读取1个扇区</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f7</span>    <span class="hljs-comment">; 0x1f7</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span>     <span class="hljs-comment">;读命令</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">al</span><br><br>    <span class="hljs-comment">; 等待处理其他操作</span><br><span class="hljs-symbol">  .waits:</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; dx = 0x1f7</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x88</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x08</span><br>    <span class="hljs-keyword">jnz</span> .waits                         <br>    <br><br>    <span class="hljs-comment">; 读取512字节到地址ds:bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">256</span>   <span class="hljs-comment">; 每次读取一个字，2个字节，因此读取256次即可          </span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f0</span><br><span class="hljs-symbol">  .readw:</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">loop</span> .readw<br>      <br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>保护模式，是一种在80286系列之后，基于x86架构的CPU操作模式。在80286及以后，保护模式的引入使得内存地址改为32位，程序至少可以访问到2^32&#x3D;4G的内存空间</p><p>保护模式与实模式相比，主要有两个差别。</p><ul><li>保护模式提供了<strong>段间的保护机制</strong>，防止程序间胡乱访问地址带来的问题。</li><li>保护模式访问的<strong>内存空间变大</strong>，32位地址线最大支持4G内存空间。</li></ul><h4 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h4><p><u>在保护模式下，所有的程序都会运行在自己的段中，一旦程序错误地访问其他段的地址空间，那么CPU就会产生异常来阻止程序访问。</u>可以简单地理解为保护模式保护的是段地址空间，阻止程序越界访问。</p><p>CPU需要知道当前运行中程序的段地址空间信息，然后才能执行地址保护。段地址空间信息是通过<strong>段描述符</strong>(segment descriptor)来给出的，包含了<strong>段基地址</strong>(段的起始地址)、<strong>段界限</strong>(段的长度)等，共计64字节</p><p><img src="/img/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="段描述符"></p><ul><li><strong>段基地址</strong>。段基地址共32位，是<strong>段的起始地址</strong>，被拆分成三部分放置。</li><li><strong>G位</strong>。G表示<strong>粒度</strong>， G&#x3D;0表示段界限以<strong>字节</strong>为单位， G&#x3D;1表示段界限以<strong>4KB</strong>为单位。</li><li><strong>D&#x2F;B位</strong>。D&#x2F;B位是<u>默认操作数的大小或默认堆栈指针的大小</u>，在保护模式下，该位置为1，表示32位。</li><li><strong>L位</strong>。L位是 <strong>64 位代码段标志</strong>，由于这里我们使用的是32位的代码，所以L置0。</li><li><strong>AVL</strong>。AVL位是保留位。</li><li><strong>段界限</strong>。段界限表示段的偏移地址范围，我们在后面详细讨论这个问题。</li><li><strong>P位</strong>。P位是段存在位， P&#x3D;1表示段存在， P&#x3D;0表示段不存在。</li><li><strong>DPL</strong>。DPL指明访问该段必须有的最低优先级，优先级从0-3依次降低，即0拥有最高优先级，3拥有最低优先级。</li><li><strong>S位</strong>。S位是描述符类型。S&#x3D;0表示该段是系统段，S&#x3D;1表示该段位代码段或数据段。</li><li><strong>TYPE</strong>。TYPE指示代码段或数据段的类型，如下所示。</li></ul><table><thead><tr><th>第11位(X)</th><th>第10位(E)</th><th>第9位(W)</th><th>第8位(A)</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>*</td><td>只读，向上扩展</td></tr><tr><td>0</td><td>0</td><td>1</td><td>*</td><td>读写，向上扩展</td></tr><tr><td>0</td><td>1</td><td>0</td><td>*</td><td>只读，向下扩展</td></tr><tr><td>0</td><td>1</td><td>1</td><td>*</td><td>读写，向下扩展</td></tr><tr><td>1</td><td>0</td><td>0</td><td>*</td><td>只执行，非一致代码段</td></tr><tr><td>1</td><td>0</td><td>1</td><td>*</td><td>执行、可读，非一致代码段</td></tr><tr><td>1</td><td>1</td><td>0</td><td>*</td><td>只执行，一致代码段</td></tr><tr><td>1</td><td>1</td><td>1</td><td>*</td><td>执行、可读、一致代码段</td></tr></tbody></table><p>A位表示是否被使用过，A&#x3D;1表示使用，A&#x3D;0表示未被使用，由<strong>CPU</strong>负责设置，我们不需要去管</p><p><strong>向上</strong>扩展和<strong>向下</strong>扩展指的是<strong>段的线性基地址</strong>和<strong>段的线性尾地址</strong>的大小关系</p><p>保护模式的寻址过程：线性地址&#x3D;base+offset</p><p>保护模式下，我们在指令中给出的都是偏移地址，偏移地址和段线性基地址相加后得到线性地址，线性地址通过<strong>地址变换部件MMU</strong>后得到实际的物理地址。<br>$$<br>物理地址&#x3D;f(线性地址)<br>$$<br>但在此时我们并未开启分页机制，所以是恒等变换x&#x3D;f(x) –&gt;线性地址</p><p>对于一个向上扩展的段，如代码段和数据段，段界限给出的是最大的偏移量，寻址时满足下面的条件。<br>$$<br>0\le offset +length\le(段界限+1)*粒度<br>$$<br>对于一个向下扩展的段，如栈段，段界限给出的是最小的偏移量，寻址时满足如下条件。<br>$$<br>(段界限+1)*粒度\le offset-length\le\text{0xFFFFFFFF}<br>$$</p><p>在保护模式，所有<strong>段描述符</strong>都会被<strong>集中放置</strong>，这个集中放置的区域被称为<strong>全局描述符表</strong>（GDT）。</p><p>保护模式的内存地址扩展到32位，所以可以使用32位的寄存器。保护模式下<strong>段寄存器</strong>仍在使用，但保存的不再是段地址，而是<strong>段选择子</strong>（GDT的索引），用于指示给CPU寻址时使用的是哪个段。</p><p><img src="/img/image-20250320143535634.png" alt="image-20250320143535634"></p><ul><li>第15-3位是<strong>段描述符的索引</strong>，表示选择子指向的段描述符是段描述符表中的第几个，编号从 0 开始。</li><li>第2位用来<strong>指示描述符表</strong>，0表示描述符表是 GDT。</li><li>第1-0位是<strong>请求特权级</strong>，特权级编号为 0-3，权限依次降低，<strong>0权限最高</strong>。</li></ul><p>保护模式下的寻址：段地址+偏移地址–&gt;表示为 <strong>选择子:偏移地址</strong></p><p>每个段寄存器都会有一个64位的不可见的部分，这部分被称为描述符高速缓存器。<em>当我们将选择子送入段寄存器时，CPU会自动从描述符表中加载对应的段描述符到描述符高速缓存器中。此后，当需要使用段寄存器时，CPU会直接从描述符高速缓存器中取出相应的内容，无需重新在描述符表中查找对应的段描述符。</em></p><p>CPU向下兼容，Intel 80286以后的CPU首先进入实模式，然后通过切换机制再进入到保护模式。也就是说在BIOS加电启动后，需要在实模式下的<strong>MBR</strong>中<u>编写16位进入保护模式的代码</u>，然后再跳转到保护模式，执行接下来的32位代码。</p><p>steps:</p><ul><li><p><strong>准备GDT，用lgdt指令加载GDTR信息</strong>。</p></li><li><p><strong>打开第21根地址线</strong>。</p><ul><li><p>实模式下，第21根地址线的值恒为0，使得当访问越界超过1MB时，自然溢出使得地址的值仍然小于1MB（取模）</p></li><li><p>所以要进入保护模式，需要打开第21根地址线–开关位于南桥芯片的端口A20，使用in、out指令可以对主板端口进行<strong>读写</strong>操作</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span> <span class="hljs-comment">;南桥芯片内的端口</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span> <span class="hljs-comment">;打开A20</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>开启cr0的保护模式标志位</strong>。</p><ul><li><p>真正的开关–CR0（32bit寄存器）包含了一系列用户控制CPU操作模式和运行的标志位</p></li><li><p><strong>第0位是保护模式的开关位</strong>–PE位–PE位置1，CPU进入保护模式</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cli</span> <span class="hljs-comment">;保护模式下中断机制尚未建立，应禁止中断</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span> <span class="hljs-comment">;设置PE位为1</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>远跳转，进入保护模式</strong>。</p></li></ul><p>GDT的起始位置和大小由我们来确定，保存在寄存器<strong>GDTR</strong>中，GDTR：</p><p><img src="/img/image-20250320144218557.png" alt="image-20250320144218557"></p><p>全集描述符表边界–GDT的边界–段界限边界</p><p>$$<br>段描述符最大数量&#x3D;\frac{2^{16}}{8}&#x3D;8192<br>$$<br>每个段描述符是64bit（8字节）</p><h2 id="Example1：-bootloader的加载"><a href="#Example1：-bootloader的加载" class="headerlink" title="Example1： bootloader的加载"></a>Example1： bootloader的加载</h2><p>内存地址安排：bootloader被安排在MBR之后，预留了<strong>5个扇区</strong>的空间</p><table><thead><tr><th>name</th><th>start</th><th>length</th><th>end</th></tr></thead><tbody><tr><td>MBR</td><td>0x7c00</td><td>0x200(512B)</td><td>0x7e00</td></tr><tr><td>bootloader</td><td>0x7e00</td><td>0xa00(512B *** 5**)</td><td>0x8800</td></tr></tbody></table><p>运行步骤：</p><ul><li><p>编译bootloader后写入到<strong>硬盘起始编号为1</strong>的扇区，共有五个扇区。</p><ul><li>编译：<code>nasm -f bin bootloader.asm -o bootloader.bin</code></li><li>加载：<code>dd if=bootloader.bin of=hd.img bs=512 count=5 seek=1 conv=notrunc</code></li></ul></li><li><p>mbr也要重新编译并写入硬盘其实编号为0的扇区</p><ul><li>编译：<code>nasm -f bin mbr.asm -o mbr.bin</code></li><li>加载：<code>dd if=mbr.bin of=hd.img bs=512 count=1 seek=0 conv=notrunc</code></li></ul><p>回顾一下对应的参数设置：<img src="/img/image-20250320164325744.png" alt="image-20250320164325744"></p></li><li><p>运行 <code>qemu-system-i386 -hda hd2.img -serial null -parallel stdio</code></p></li></ul><p>运行结果：</p><p><img src="/img/image-20250320163929392.png" alt="image-20250320163929392"></p><h2 id="Example2：进入保护模式"><a href="#Example2：进入保护模式" class="headerlink" title="Example2：进入保护模式"></a>Example2：进入保护模式</h2><p>在进入保护模式之前，我们先对我们的内存地址进行规划。</p><table><thead><tr><th>Name</th><th>Start</th><th>Length</th><th>End</th></tr></thead><tbody><tr><td>MBR</td><td>0x7c00</td><td>0x200(512B)</td><td>0x7e00</td></tr><tr><td>bootloader</td><td>0x7e00</td><td>0xa00(512B * 5)</td><td>0x8800</td></tr><tr><td>GDT</td><td>0x8800</td><td>0x80(8B * 16)</td><td>0x8880</td></tr></tbody></table><ul><li>MBR自动加载到0x7c00</li><li>bootloader在MBR中显式加载到0x7e00</li><li>GDT显示加载到0x8800</li></ul><p><code>equ</code>是汇编伪指令，e.g：编译器会在编译时将 <code>LOADER_SECTOR_COUNT</code>出现的地方替换为5 （类似与宏</p><blockquote><p>在操作系统内核设计的过程中，内存规划是一件令人苦恼的事情。从上面的例子可以看到，bootloader紧跟在MBR后面，GDT紧跟在bootloader后面，看起来非常紧凑。但是，只要其中一个发生变化，那么可能我们又要重新规划内存。也就是说，没有一种内存规划方案是完美的。</p></blockquote><p>在bootloader中跳转到保护模式：</p><ul><li>定义段描述符（代码段描述符、数据段描述符、栈段描述符和视频段描述符）</li></ul><p>平坦模式：让代码段描述符、数据段描述符和栈段描述符中的<strong>段线性基地址为0</strong> &#x3D;&gt;偏移地址和线性地址完全相同</p><blockquote><p>段的存在是为了让CPU执行段保护，放置程序越界访问；</p><p>后续实验中会采用二级分页机制，此时页保护页可以组织程序越界访问 &#x3D;》无需分段了</p></blockquote><p>视频段描述符是<strong>显存所在的内存区域</strong>的段描述符。注意，<strong>GDT的第0个描述符必须是全0的描述符</strong>。接着，在GDT中依次放入0描述符，数据段描述符、堆栈段描述符、显存段描述符和代码段描述符</p><p>运行结果：</p><p><img src="/img/image-20250320171528591.png" alt="image-20250320171528591"></p><p>如何在gdb中使用info registers查看寄存器</p><ul><li>要记得在qemu启动时加入 <code>-s -S</code> 参数: <code>qemu-system-i386 -hda hd.img -serial null -parallel stdio -s -S</code></li><li>再启动gdb，并且连接端口 <code>target remote:1234</code></li><li>在输入 <code>info registers</code>可以查看</li></ul><p><img src="/img/image-20250320172738614.png" alt="image-20250320172738614"></p><ul><li>执行程序之后，发现寄存器发生了很大的变化</li></ul><p><img src="/img/image-20250320172319147.png" alt="image-20250320172319147"></p><p>ps：</p><table><thead><tr><th>gdb指令</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>break *adress或b *address</td><td>在地址adress处设置断点。</td><td>break *0x7c00 b *0x7c00</td></tr><tr><td>break symbol或b symbol</td><td>在符号symbol处设置断点，例如symbol一般是函数名。</td><td>break setup_kernel b setup_kernel</td></tr><tr><td>break filename:line_number</td><td>在文件filename处的第line_numer行设置断点</td><td>b mbr.asm:12</td></tr><tr><td>add-symbol-file filename address</td><td>加载符号表filename到地址address处</td><td>add-symbol-file mbr.symbol 0x7c00</td></tr><tr><td>x&#x2F;FMT address</td><td>address是内存地址，FMT格式是重复的单元个数+格式+大小。 重复的单元个数是一个数字，表示我们希望查看多少个单元。正数表示从address向后查看。负数表示从address向前查看。 格式是一个字符，可以是o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string)。 大小是一个字符，可以是b(byte, 1 byte), h(halfword, 2 byte), w(word, 4 byte), g(giant, 8 bytes)。</td><td>x&#x2F;5xw 0x8032 x&#x2F;10i 0x7c00</td></tr><tr><td>continue或c</td><td>继续执行正在调试的程序到断点处暂停。</td><td></td></tr><tr><td>step或s</td><td>执行一条C语句，如果遇到函数调用语句，则会进入函数体中。</td><td></td></tr><tr><td>next或n</td><td>执行一条C语句，函数调用语句不会进入函数体，把函数当成一条语句执行。</td><td></td></tr><tr><td>stepi或si</td><td>执行一条汇编语句，如果遇到函数调用语句，则会进入函数体中。</td><td></td></tr><tr><td>nexti或ni</td><td>执行一条汇编语句，函数调用语句不会进入函数体，把函数当成一条语句执行。</td><td></td></tr><tr><td>info registers</td><td>查看所有寄存器的值</td><td></td></tr><tr><td>layout layout_name</td><td>layout_name包含src，asm，split，regs。 src显示源代码窗口和命令窗口，asm显示汇编代码窗口和命令窗口，split显示源代码窗口、汇编代码窗口和命令窗口，regs显示寄存器窗口。</td><td>layout split</td></tr><tr><td>focus layout_window</td><td>转换当前窗口到layout窗口，layout_window包含src，asm，regs，cmd。任何时刻gdb的当前窗口只有一个，并且使用方向键的效果只会在当前窗口处显示。</td><td>focus cmd</td></tr><tr><td>file symbol_file</td><td>加载符号表，为gdb提供debug信息。</td><td>file ..&#x2F;build&#x2F;kernel.o</td></tr><tr><td>set disassembly-flavor intel</td><td>设置汇编代码格式为intel风格</td><td></td></tr><tr><td>set architecture name</td><td>设置指令对应的CPU架构，name包含i8086(16位)，i386(32位)</td><td>set architecture i386</td></tr></tbody></table><h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务 1"></a>任务 1</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>复现Example 1，说说你是怎么做的并提供结果截图，也可以参考Ucore、Xv6等系统源码，实现自己的LBA方式的磁盘访问。</p><p>提示：部分需要的文件存放在<code>src/example-1</code>下，请根据需要将其放置于自己创建的lab3文件夹下。</p><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>在Example1中，我们使用了LBA28的方式来读取硬盘。此时，我们只要给出逻辑扇区号即可，但需要手动去读取I&#x2F;O端口。然而，BIOS提供了实模式下读取硬盘的中断，其不需要关心具体的I&#x2F;O端口，只需要给出逻辑扇区号对应的磁头（Heads）、扇区（Sectors）和柱面（Cylinder）即可，又被称为CHS模式。现在，同学们需要&#x3D;&#x3D;将LBA28读取硬盘的方式换成CHS读取&#x3D;&#x3D;，同时给出逻辑扇区号向CHS的转换公式。最后说说你是怎么做的并提供结果截图。</p><p>勘误：《于渊：一个操作系统的实现2》P183-184给的是读取软盘的计算公式，而我们读取的是硬盘，因此不适用。参考资料变更如下。</p><ul><li><a href="https://gitee.com/link?target=https://blog.csdn.net/G_Spider/article/details/6906184">LBA向CHS模式的转换</a></li><li><a href="https://gitee.com/link?target=https://blog.csdn.net/brainkick/article/details/7583727">int 13h中断</a></li></ul><p>其中，关键参数如下。</p><table><thead><tr><th>参数</th><th>数值</th></tr></thead><tbody><tr><td>驱动器号（DL寄存器）</td><td>80h</td></tr><tr><td>每磁道扇区数</td><td><strong>63</strong></td></tr><tr><td>每柱面磁头数（每柱面总的磁道数）</td><td>18</td></tr></tbody></table><h3 id="LBA向CHS模式转换："><a href="#LBA向CHS模式转换：" class="headerlink" title="LBA向CHS模式转换："></a>LBA向CHS模式转换：</h3><ul><li>LBA值需要通过运算间接的粗cylinder、head、sector这三个变量的值</li></ul><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><strong>cylinder</strong>：磁盘的<strong>柱面</strong></li><li><strong>head</strong>：磁盘的<strong>磁头</strong>，每张磁片有两个磁头</li><li><strong>sector</strong>：磁盘<strong>扇区</strong>，这里指物理扇区，编号从 <strong>1 - 63</strong>，每条 track 的最大 sector 数 63</li><li><strong>SPT</strong>（sector_per_track）：每磁道上的 sector 数</li><li><strong>HPC</strong>（head_per_cylinder）：每个 cylinder 的 head 数量，这个数量应该是<strong>磁片数 * 2</strong></li></ul><h4 id="LBA寻址"><a href="#LBA寻址" class="headerlink" title="LBA寻址"></a>LBA寻址</h4><p>LBA的扇区从0开始计算。<br>&#x3D;&#x3D;LBA &#x3D; (cylinder * HPC + head) * SPT + sector - 1&#x3D;&#x3D;</p><ul><li>先计算track的数量，再加上物理扇区（从1开始编号），转换为LBA扇区需要-1</li><li>track 的数量计算方式为：<code>cylinder * HPC（head_per_cylinder）+ head</code></li></ul><h4 id="LBA2CHS"><a href="#LBA2CHS" class="headerlink" title="LBA2CHS"></a>LBA2CHS</h4><ol><li>计算cylinder：<code>cylinder=LBA/(SPT*HPC)</code><ul><li><code>SPT*HPC</code>这部分计算的是每个cylinder有多少个扇区</li><li>然后再计算在磁盘内需要多少个柱面表达</li></ul></li><li>计算head：<code>head=(LBA/SPT)%HPC</code><ul><li>在求出磁盘柱面的情况下，我们需要求得磁盘的磁头</li><li><code>LBA/SPT</code>这步在计算磁盘内有多少head</li><li>然后再计算出在一个柱面中的磁头编号</li></ul></li><li>计算sector：sector&#x3D;LBA%SPT+1<ul><li><code>LBA % SPT</code> 这步计算可以得出逻辑的扇区号</li><li>然后由于物理的扇区是从1开始的，所以要<code>+1</code></li></ul></li></ol><p>Resources：<br><a href="https://blog.csdn.net/haiross/article/details/38661051">代码实现之磁盘的 LBA 寻址转换为 CHS 寻址_lba和cly-CSDN博客</a><br><a href="https://www.cnblogs.com/mlzrq/p/10223053.html">读取磁盘：CHS方式 - 猛练自然强 - 博客园</a></p><p>实现过程：<br>直接使用int 13h中断模式中的ah&#x3D;02h功能（读扇区）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">功能<span class="hljs-number">02H</span>： <br>功能描述：读扇区 <br>入口参数：<span class="hljs-number">AH</span>＝<span class="hljs-number">02H</span> <br><span class="hljs-built_in">AL</span>＝扇区数 <br><span class="hljs-number">CH</span>＝柱面 <br><span class="hljs-built_in">CL</span>＝扇区 <br><span class="hljs-number">DH</span>＝磁头 <br><span class="hljs-built_in">DL</span>＝驱动器，<span class="hljs-number">00H</span>~<span class="hljs-number">7FH</span>：软盘；<span class="hljs-number">80H</span>~<span class="hljs-number">0FFH</span>：硬盘 <br><span class="hljs-symbol">ES:</span><span class="hljs-built_in">BX</span>＝缓冲区的地址 <br>出口参数：CF＝<span class="hljs-number">0</span>——操作成功，<span class="hljs-number">AH</span>＝<span class="hljs-number">00H</span>，<span class="hljs-built_in">AL</span>＝传输的扇区数，否则，<span class="hljs-number">AH</span>＝状态代码，参见功能号<span class="hljs-number">01H</span>中的说明<br></code></pre></td></tr></table></figure><p>关键参数参考：</p><table><thead><tr><th>参数</th><th>数值</th></tr></thead><tbody><tr><td>驱动器号（DL寄存器）</td><td>80h</td></tr><tr><td>每磁道扇区数</td><td><strong>63</strong></td></tr><tr><td>每柱面磁头数（每柱面总的磁道数）</td><td>18</td></tr><tr><td>扇区号（通过LBA地址+1得到物理地址CSH）</td><td>2</td></tr><tr><td>柱面号</td><td>0</td></tr><tr><td>缓冲区地址(bootloader加载地址)</td><td>0x7e00</td></tr></tbody></table><p>代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_read_hard_disk:</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x02</span> <span class="hljs-comment">;设置模式</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1</span> <span class="hljs-comment">;读取扇区数</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">0x80</span> <span class="hljs-comment">;磁头</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0x7e00</span> <span class="hljs-comment">;缓冲区地址</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;柱面号</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span> <span class="hljs-comment">;扇区号？</span><br><br>  <span class="hljs-keyword">int</span> <span class="hljs-number">13h</span><br></code></pre></td></tr></table></figure><p>结果截图：</p><p><img src="/img/image-20250324213555322.png" alt="image-20250324213555322"></p><h2 id="任务-2"><a href="#任务-2" class="headerlink" title="任务 2"></a>任务 2</h2><p>复现Example 2，使用gdb或其他debug工具在进入保护模式的4个重要步骤上<strong>设置断点</strong>，并结合代码、寄存器的内容等来分析这4个步骤，最后附上结果截图。gdb的使用可以参考appendix的“debug with gdb and qemu”部份。</p><p>提示：部分需要的文件存放在<code>src/example-2</code>下，请根据需要将其放置于自己创建的lab3文件夹下。</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>可以直接make run；<br>结果截图参见上面的Example2部分。<br><img src="/img/image-20250320171528591.png" alt="image-20250320171528591"></p><h3 id="GDB调试方法"><a href="#GDB调试方法" class="headerlink" title="GDB调试方法"></a>GDB调试方法</h3><p>resources：<br><a href="https://gitee.com/kpyang5/sysu-2025-spring-operating-system/blob/main/appendix/debug_with_gdb_and_qemu/README.md#%E5%AE%89%E8%A3%85215%E7%89%88%E6%9C%AC%E7%9A%84nasm">appendix&#x2F;debug_with_gdb_and_qemu&#x2F;README.md · young&#x2F;sysu-2025-spring-operating-system - 码云 - 开源中国</a><br><a href="https://blog.csdn.net/qq_51753728/article/details/142262405">Makefile(超详细一文读懂)-CSDN博客</a></p><p>回顾之前简单的调试：</p><ul><li>在qemu启动的前提下，打开一个新的终端，并输入gdb进入gdb调试</li><li>在gdb下，连接已经启动的qemu进行调试： <code>target remote:1234</code></li><li>设置断点：<code>break func</code></li><li>输入<code>c</code>（continue）运行</li></ul><h4 id="生成符号表"><a href="#生成符号表" class="headerlink" title="生成符号表"></a>生成符号表</h4><ul><li>可以使用gdb在debug过程中查看源代码&#x3D;&gt;提供相关的信息&#x3D;&gt;符号表（ELF格式）</li><li>制作符号表：<ul><li>先编译汇编代码生成可重定向文件（ELF文件）</li><li>使用这个可重定向文件生成可执行文件和bin格式文件</li></ul></li></ul><p>以example-2为例：</p><ul><li>删除<code>*.asm</code>中的<code>org</code>语句，后续会在链接的过程中指定他们代码和数据的起始地址</li><li>编译mbr.asm生成.o文件 。<code>-g</code>参数是为了加上debug信息</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nasm -o mbr<span class="hljs-selector-class">.o</span> -<span class="hljs-selector-tag">g</span> -f elf32 mbr<span class="hljs-selector-class">.asm</span> <br></code></pre></td></tr></table></figure><ul><li>为<code>mbr.o</code>文件指定起始地址为<code>0x7c00</code>，分别链接生成可执行文件<code>mbr.symbol</code>和<code>mbr.bin</code></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld -o mbr<span class="hljs-selector-class">.symbol</span> -melf_i386 -N mbr<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7c00<br>ld -o mbr<span class="hljs-selector-class">.bin</span> -melf_i386 -N mbr<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7c00 <span class="hljs-attr">--oformat</span> binary<br></code></pre></td></tr></table></figure><ul><li>对bootloader.asm重复同样的工作</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nasm -o bootloader<span class="hljs-selector-class">.o</span> -<span class="hljs-selector-tag">g</span> -f elf32 bootloader<span class="hljs-selector-class">.asm</span> <br>ld -o bootloader<span class="hljs-selector-class">.symbol</span> -melf_i386 -N bootloader<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7e00<br>ld -o bootloader<span class="hljs-selector-class">.bin</span> -melf_i386 -N bootloader<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7e00 <span class="hljs-attr">--oformat</span> binary<br></code></pre></td></tr></table></figure><ul><li>将mbr.bin和bootloader.bin都载入磁盘</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=mbr.bin <span class="hljs-attribute">of</span>=hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1 <span class="hljs-attribute">seek</span>=0 <span class="hljs-attribute">conv</span>=notrunc<br>dd <span class="hljs-attribute">if</span>=bootloader.bin <span class="hljs-attribute">of</span>=hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=5 <span class="hljs-attribute">seek</span>=1 <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure><p>执行完这些之后会发现生成了这些文件：</p><p><img src="/img/image-20250325085117185.png" alt="image-20250325085117185"></p><p>设置断点：</p><p>在mbr的第一条指令处设置断点</p><p><img src="/img/image-20250325085326131.png" alt="image-20250325085326131"></p><p>打开显示源代码的窗口：</p><p><img src="/img/image-20250325085405878.png" alt="image-20250325085405878"></p><p>加载MBR对应的符号表，可以在src窗口看到我们的源代码</p><p>&#x3D;&#x3D;B+表示断点，白色窗口表示下一条要执行的指令&#x3D;&#x3D;</p><p><img src="/img/image-20250325085657137.png" alt="image-20250325085657137"></p><p>窗口之间跳转：<br>注意，我们现在有两个窗口，一个是输入命令的cmd窗口，一个是显示源代码的src窗口。而方向键的效果只会在当前窗口起作用，并且当前窗口只有一个。在src窗口下，<strong>上下键的作用是上下滚动代码</strong>，<strong>在cmd窗口下，上键的作用是找到之前执行的命令</strong>。如果想要在两个窗口之前切换，可以使用<code>focus</code>命令，例如切换当前窗口到cmd窗口。</p><p><img src="/img/image-20250325090100161.png" alt="image-20250325090100161"></p><p><img src="/img/image-20250325090218168.png" alt="image-20250325090218168"></p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="进入保护模式的四个步骤"><a href="#进入保护模式的四个步骤" class="headerlink" title="进入保护模式的四个步骤"></a>进入保护模式的四个步骤</h4><ul><li><strong>准备GDT，用lgdt指令加载GDTR信息</strong>。</li><li><strong>打开第21根地址线</strong>。</li><li><strong>开启cr0的保护模式标志位</strong>。</li><li><strong>远跳转，进入保护模式</strong>。</li></ul><h4 id="更加详细的基本调试思路"><a href="#更加详细的基本调试思路" class="headerlink" title="更加详细的基本调试思路"></a>更加详细的基本调试思路</h4><ol><li><strong>qemu启动</strong>。我们先在一个Terminal下启动qemu，注意，qemu运行的参数需要加上<code>-s -S</code>参数，且在gdb启动之前不能关闭qemu。</li><li><strong>gdb启动</strong>。在另一个Terminal下启动gdb并<strong>连接</strong>上第1步启动的qemu。（如target remote:1234)</li><li><strong>加载符号表</strong>。&#x3D;&#x3D;符号表&#x3D;&#x3D;会为gdb提供源代码和标识符等debug信息。</li><li><strong>设置断点</strong>。gdb运行到我们设置的断点处会暂停，我们会在我们感兴趣的代码地址处设置断点，断点一般是我们认为bug出现的地方。</li><li><strong>运行至断点处</strong>。使用命令跳过其他我们不感兴趣的代码，使代码一直执行到我们设置的断点处暂停。</li><li><strong>查看寄存器或特定地址的值</strong>。我们可以在gdb暂停的地方查看寄存器或特定地址的值，并根据输出来判断前面执行的代码是否出现bug。</li><li><strong>单步调试跟踪</strong>。gdb在断点处暂停后，我们可以一条一条语句地执行来跟踪程序的运行逻辑，gdb每执行条语句就会暂停。</li><li><strong>重复3、4、5、6一直到bug解决</strong>。这个过程可能需要反复执行，但不一定是按照{3,4,5,6}{3,4,5,6}的顺序，可以是{3,4,6,5,6,6,6,5,3,4,5}{3,4,6,5,6,6,6,5,3,4,5}。</li></ol><h4 id="实验断点设置："><a href="#实验断点设置：" class="headerlink" title="实验断点设置："></a>实验断点设置：</h4><p>在mbr的初始地址设置断点：</p><p><img src="/img/image-20250325102422602.png" alt="image-20250325102422602"></p><p>键入<code>c</code>之后，成功初始化</p><p><img src="/img/image-20250325102509957.png" alt="image-20250325102509957"></p><p>然后打开源代码窗口，并加载MBR对应的符号表</p><p><img src="/img/image-20250325102602634.png" alt="image-20250325102602634"></p><p>然后为bootloader设置断点，对应情况如下：</p><ul><li>这里<strong>断点位置的查找</strong>（偏移量的计算）使用了<code>nasm -f bin -l bootloader.lst bootloader.asm</code>命令，可以生成一个对应的<strong>列表文件</strong>，会显示&#x3D;&#x3D;每条指令的偏移量&#x3D;&#x3D;</li><li>另一种方法是使用反汇编（objdump）–输出结果会呈现在终端中<code>objdump -D -b binary -m i386 -M intel bootloader.bin</code></li></ul><p><img src="/img/image-20250325102052040.png" alt="image-20250325102052040"></p><ul><li>到达第一个起始点：</li></ul><p><img src="/img/image-20250325103125494.png" alt="image-20250325103125494"></p><p>此时的寄存器内容：</p><p><img src="/img/image-20250325103155996.png" alt="image-20250325103155996"></p><p><img src="/img/image-20250325103217047.png" alt="image-20250325103217047"></p><p><img src="/img/image-20250325103229067.png" alt="image-20250325103229067"><br>栈顶指针指向0x7c00，下一条执行的指令</p><ul><li>到达第二个断点–初始设置GDTR之前</li></ul><p><img src="/img/image-20250325103308463.png" alt="image-20250325103308463"></p><p>寄存器内容：</p><p><img src="/img/image-20250325103324172.png" alt="image-20250325103324172"></p><p><img src="/img/image-20250325103341062.png" alt="image-20250325103341062"></p><p><img src="/img/image-20250325103354840.png" alt="image-20250325103354840"></p><ul><li>第三个断点–GDTR设置后，打开第21根地址线之前<br><img src="/img/file-20250330212542533.png"></li></ul><p><img src="/img/image-20250325103450079.png" alt="image-20250325103450079"></p><p>寄存器内容：</p><p><img src="/img/image-20250325103511283.png" alt="image-20250325103511283"></p><p><img src="/img/image-20250325103521281.png" alt="image-20250325103521281"></p><p><img src="/img/image-20250325103529256.png" alt="image-20250325103529256"></p><ul><li>第四个断点–打开第21根地址线之后，设置保护模式PE位之前</li></ul><p><img src="/img/image-20250325103605882.png" alt="image-20250325103605882"></p><p><img src="/img/image-20250325103620227.png" alt="image-20250325103620227"></p><p><img src="/img/image-20250325103627936.png" alt="image-20250325103627936"></p><ul><li>第五个断点–设置PE位之后，进入保护模式之前</li></ul><p><img src="/img/image-20250325103649298.png" alt="image-20250325103649298"></p><p>寄存器内容：</p><p><img src="/img/image-20250325103703503.png" alt="image-20250325103703503"></p><p><img src="/img/image-20250325103719845.png" alt="image-20250325103719845"></p><h6 id="可以看到这里cr0位改变了，成功设置"><a href="#可以看到这里cr0位改变了，成功设置" class="headerlink" title="可以看到这里cr0位改变了，成功设置"></a>可以看到这里cr0位改变了，成功设置</h6><p>进入保护模式前：</p><p><img src="/img/image-20250325103805259.png" alt="image-20250325103805259"></p><ul><li>执行到最后（进入保护模式）</li></ul><p>可以看到<strong>多呈现了一行输出</strong>–成功进入保护模式</p><p><img src="/img/image-20250325103857556.png" alt="image-20250325103857556"></p><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><h5 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h5><p><code>Makefile</code> 是 <code>make</code> 命令所读取的配置文件，包含了构建项目的规则。其主要作用是<strong>检查项目文件的依赖关系</strong>，<strong>自动执行必要的命令</strong>，从而<strong>更新目标文件</strong>。一般来说，Makefile 主要包括以下三部分内容：</p><ul><li>目标：需要生成的文件，例如可执行文件。</li><li>依赖：生成目标所依赖的文件或目标。</li><li>命令：构建目标时需要执行的命令。</li></ul><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target</span>:dependencies<br><span class="hljs-keyword">command</span><br></code></pre></td></tr></table></figure><ul><li><strong>target</strong>：目标文件，可以是一个目标文件或一个动作名称（例如：<code>all</code>, <code>clean</code>）。</li><li><strong>dependencies</strong>：生成目标所依赖的文件或其他目标。</li><li><strong>command</strong>：构建目标的命令，必须以 <code>Tab</code> 键开头。</li></ul><p>变量的使用：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">VarName</span><span class="hljs-operator">=</span>var<br></code></pre></td></tr></table></figure><p>使用的时候：<code>$(VarName)</code><br>例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">CC = g++<br>CFLAGS = -Wall -<span class="hljs-selector-tag">g</span><br> <br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>    $(CC) $(CFLAGS) -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span>.o<br></code></pre></td></tr></table></figure><p>常用的内置变量：</p><ul><li><code>$@</code>：表示<strong>目标文件</strong>。</li><li><code>$^</code>：表示<strong>所有的依赖文件</strong>。</li><li><code>$&lt;</code>：表示<strong>第一个依赖文件</strong>。</li></ul><p>伪目标：一种&#x3D;&#x3D;命令名称&#x3D;&#x3D;<br>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm -f *.o main<br></code></pre></td></tr></table></figure><p><strong>方式一：Makefile+直接编译链接（不推荐）</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app:add<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> multi<span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc add<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> multi<span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o app<br></code></pre></td></tr></table></figure><p><strong>方式二：Makefile+编译+链接</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app:add<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span><br>gcc add<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -o app<br> <br>add<span class="hljs-selector-class">.o</span>:add<span class="hljs-selector-class">.c</span><br>gcc -c add<span class="hljs-selector-class">.c</span> -o add<span class="hljs-selector-class">.o</span><br> <br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span>:<span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span><br>gcc -c <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span><br> <br>multi<span class="hljs-selector-class">.o</span>:multi<span class="hljs-selector-class">.c</span><br>gcc -c multi<span class="hljs-selector-class">.c</span> -o multi<span class="hljs-selector-class">.o</span><br> <br>sub<span class="hljs-selector-class">.o</span>:sub<span class="hljs-selector-class">.c</span><br>gcc -c sub<span class="hljs-selector-class">.c</span> -o sub<span class="hljs-selector-class">.o</span><br> <br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>:<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span>.o<br></code></pre></td></tr></table></figure><p><strong>方式三：Makefile+变量</strong><br>知识点：<br>自定义变量：</p><ul><li>变量名&#x3D;变量值，如var&#x3D;hello<br>预定义变量：</li><li>AR : 归档维护程序的名称，默认值为 ar</li><li>CC : C 编译器的名称，默认值为 cc</li><li>CXX : C++ 编译器的名称，默认值为 g++</li><li>$@ : 目标的完整名称</li><li>$&lt; : 第一个依赖文件的名称</li><li>$^: 所有的依赖文件<br>例子：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src=add.o div.o multi.o sub.o main.o<br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(src)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">add.o:add.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">div.o:div.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">multi.o:multi.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">sub.o:sub.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">main.o:main.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p><strong>方式四：Makefile+模式匹配</strong><br><strong>方法五：Makefile + 函数</strong></p><h5 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h5><ul><li><code>make</code>或<code>make run</code>。使用qemu启动<code>hd.img</code>，在此命令执行前应该执行<code>make build</code>。</li><li><code>make debug</code>。启动qemu并开启gdb调试。</li><li><code>make build</code>。编译代码并写入<code>hd.img</code>。</li><li><code>make clean</code>。清除当前文件夹下以<code>.bin</code>结尾的文件。（也可以自己设置，比如.o结尾，.exe结尾的文件等等）</li></ul><p>gdb的命令也可以预先写到文件中，在启动gdb后会自动加载执行<br>比如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">target remote:1234<br>set disassembly-flavor intel<span class="hljs-built_in"></span><br><span class="hljs-built_in">add-symbol-file </span>mbr.symbol 0x7c00<span class="hljs-built_in"></span><br><span class="hljs-built_in">add-symbol-file </span>bootloader.symbol 0x7c00<br></code></pre></td></tr></table></figure><h2 id="任务-3（选做）"><a href="#任务-3（选做）" class="headerlink" title="任务 3（选做）"></a>任务 3（选做）</h2><p>改造“Lab2-Assignment 4”为32位代码，即在保护模式后执行自定义的汇编程序。</p><p>resources：<br><a href="https://blog.csdn.net/abc123lzf/article/details/109289567">x86保护模式——全局描述符表GDT详解_gdt全局描述符表 作用-CSDN博客</a></p><h3 id="GDT介绍"><a href="#GDT介绍" class="headerlink" title="GDT介绍"></a>GDT介绍</h3><p>GDT全称：全局描述符表<br>GDT的数据结构是一个描述符数组，每个描述符8个字节，可以存放在内存当中任意位置</p><p><strong>实模式</strong>下的初始化代码，主要完成三件事：</p><ol><li>初始化段描述符</li><li>初始化GDT的基址，并存放到GDTR寄存器</li><li><strong>切换到保护模式</strong>（打开A20地址线，将CR0寄存器第0位设置为1），并跳转到负责打印字符串的代码段。</li></ol><p>现在为止学到的：<br>从MBR加载bootloader，bootloader理论上是没有字节限制的，可以占据多个扇区，并完成很多功能，然后再将控制权交给操作系统<br>运行MBR是16位实模式，运行bootloader时通过执行对应的一组指令切换到32位保护模式，才开始加载内核进入内存，并且<strong>开始执行用户程序</strong>（本task要学习实现的）。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>参照原本的bootloader代码，<br>示例代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;# 初始设置和显示信息 #</span><br><span class="hljs-meta">%include</span> <span class="hljs-string">&quot;boot.inc&quot;</span><br><span class="hljs-comment">;org 0x7e00 这里注释掉，因为会通过命令行设置起到同样作用的命令</span><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span> <span class="hljs-comment">;显存地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x03</span> <span class="hljs-comment">;青色</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, bootloader_tag_end - bootloader_tag <span class="hljs-comment">;计算要打印的字符串长度</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ebx</span> <span class="hljs-comment">;置0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, bootloader_tag <span class="hljs-comment">;将字符串移动到寄存器内（指针）</span><br><span class="hljs-symbol">output_bootloader_tag:</span> <span class="hljs-comment">;循环输出</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span>[<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">loop</span> output_bootloader_tag<br><span class="hljs-comment">;# 初始设置和显示信息 #</span><br><br><span class="hljs-comment">;# 局描述符表GDT设置 #</span><br><span class="hljs-comment">;空描述符--GDT的第一个条目必须为空</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x00</span>],<span class="hljs-number">0x00</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x04</span>],<span class="hljs-number">0x00</span>  <br><br><span class="hljs-comment">;创建描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x08</span>],<span class="hljs-number">0x0000ffff</span>    <span class="hljs-comment">; 基地址为0，段界限为0xFFFFF</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x0c</span>],<span class="hljs-number">0x00cf9200</span>    <span class="hljs-comment">; 粒度为4KB，存储器段描述符 </span><br><br><span class="hljs-comment">;建立保护模式下的堆栈段描述符      </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x10</span>],<span class="hljs-number">0x00000000</span>    <span class="hljs-comment">; 基地址为0x00000000，界限0x0 </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x14</span>],<span class="hljs-number">0x00409600</span>    <span class="hljs-comment">; 粒度为1个字节</span><br><br><span class="hljs-comment">;建立保护模式下的显存描述符   </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x18</span>],<span class="hljs-number">0x80007fff</span>    <span class="hljs-comment">; 基地址为0x000B8000，界限0x07FFF </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x1c</span>],<span class="hljs-number">0x0040920b</span>    <span class="hljs-comment">; 粒度为字节</span><br><br><span class="hljs-comment">;创建保护模式下平坦模式代码段描述符</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x20</span>],<span class="hljs-number">0x0000ffff</span>    <span class="hljs-comment">; 基地址为0，段界限为0xFFFFF</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x24</span>],<span class="hljs-number">0x00cf9800</span>    <span class="hljs-comment">; 粒度为4kb，代码段描述符 </span><br><br><span class="hljs-comment">;# 局描述符表GDT设置 #</span><br><br><span class="hljs-comment">;#加载GDTR并准备切换到保护模式#</span><br><span class="hljs-comment">;准备GDTR B+ 1</span><br><span class="hljs-comment">;初始化描述符表寄存器GDTR</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [pgdt], <span class="hljs-number">39</span>      <span class="hljs-comment">;描述符表的界限   </span><br><span class="hljs-keyword">lgdt</span> [pgdt] <span class="hljs-comment">;加载GDTR寄存器，告诉CPU GDT的位置和大小</span><br><span class="hljs-comment">;打开第21根地址线，B+ 2      </span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span>                         <span class="hljs-comment">;南桥芯片内的端口 </span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span>                        <span class="hljs-comment">;打开A20</span><br><span class="hljs-comment">;设置保护模式标志位 B+ 3</span><br><span class="hljs-keyword">cli</span>                                <span class="hljs-comment">;禁用中断，中断机制尚未工作</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span>                        <span class="hljs-comment">;设置PE位</span><br><span class="hljs-comment">;#加载GDTR并准备切换到保护模式#   </span><br><br><span class="hljs-comment">;以下进入保护模式 B+ 4</span><br><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> CODE_SELECTOR:protect_mode_begin <span class="hljs-comment">;远跳转，同时清空CPU流水线并加载CS寄存器为代码段选择子</span><br><br><span class="hljs-comment">;16位的描述符选择子：32位偏移</span><br><span class="hljs-comment">;清流水线并串行化处理器</span><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]           <br><span class="hljs-symbol">protect_mode_begin:</span>    <span class="hljs-comment">;进入保护模式                          </span><br><span class="hljs-comment">;保护模式下的初始化</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, DATA_SELECTOR                     <span class="hljs-comment">;加载数据段(0..4GB)选择子</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, STACK_SELECTOR<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, VIDEO_SELECTOR<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-comment">;保护模式必须通过GDT描述符来访问内存，不能直接使用段地址</span><br><span class="hljs-comment">;32位模式下使用32位寄存器(eax)而不是16位(ax)</span><br><span class="hljs-comment">;显存访问需要通过专门的显存段描述符</span><br><span class="hljs-comment">;这里开始执行自己的程序--所以我们只需要修改这部分就好了，同时要保证这部分是32位的</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, protect_mode_tag_end - protect_mode_tag<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">80</span> * <span class="hljs-number">2</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, protect_mode_tag<br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x3</span><br><span class="hljs-symbol">output_protect_mode_tag:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span>[<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">ebx</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">loop</span> output_protect_mode_tag<br><span class="hljs-comment">;=======up======|same|======up===========</span><br><span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">; 死循环</span><br><br><span class="hljs-comment">;数据定义</span><br>pgdt <span class="hljs-built_in">dw</span> <span class="hljs-number">0</span><br>     <span class="hljs-built_in">dd</span> GDT_START_ADDRESS<br><br>bootloader_tag <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;run bootloader&#x27;</span><br><span class="hljs-symbol">bootloader_tag_end:</span><br><br>protect_mode_tag <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;enter protect mode&#x27;</span><br><span class="hljs-symbol">protect_mode_tag_end:</span><br></code></pre></td></tr></table></figure><p>my_program：前面的部分和上面基本完全一样，下面只展示我的程序部分</p><ol><li>初始化弹射字符变量–存储在内存中（<strong>保护模式下更倾向于使用内存变量而不是寄存器存储状态</strong>）</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [row], <span class="hljs-number">2</span>        <span class="hljs-comment">; 初始行位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [col], <span class="hljs-number">0</span>        <span class="hljs-comment">; 初始列位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [row_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 行方向增量 (1=向下)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [col_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 列方向增量 (1=向右)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [char_color], <span class="hljs-number">0x0A</span>  <span class="hljs-comment">; 字符颜色 (亮绿色)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [char_value], <span class="hljs-string">&#x27;0&#x27;</span>   <span class="hljs-comment">; 显示字符</span><br></code></pre></td></tr></table></figure><p>使用：<code>mov &lt;mem&gt;, &lt;con&gt;</code>，将常数存储到&#x3D;&#x3D;内存地址row&#x3D;&#x3D;处，并通过<code>byte</code>指定操作数大小为1字节。<br>2. 边界检查</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bounce_loop:</span><br><span class="hljs-keyword"></span>    <span class="hljs-comment">; 检查上下边界</span><br>    mov al, [row]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_up </span>      <span class="hljs-comment">; 如果行 &lt;= 0，需要向下反弹</span><br>    cmp al, <span class="hljs-number">24</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_down </span>    <span class="hljs-comment">; 如果行 &gt;= 24，需要向上反弹</span><br>    <br>    <span class="hljs-comment">; 检查左右边界</span><br>    mov al, [col]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_right </span>   <span class="hljs-comment">; 如果列 &lt;= 0，需要向右反弹</span><br>    cmp al, <span class="hljs-number">79</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_left </span>    <span class="hljs-comment">; 如果列 &gt;= 79，需要向左反弹</span><br>    <br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display </span>        <span class="hljs-comment">; 通过所有边界检查，显示字符</span><br></code></pre></td></tr></table></figure><p>这里将模板内存地址中存储的值取出到寄存器内，再进行比较。其余的内容差不多。<br>3. 显存位置计算</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">movzx</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">byte</span> [row]    <span class="hljs-comment">; 获取当前行</span><br><span class="hljs-keyword">imul</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">80</span>             <span class="hljs-comment">; ebx = row * 80</span><br><span class="hljs-keyword">movzx</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">byte</span> [col]    <span class="hljs-comment">; 获取当前列</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ecx</span>             <span class="hljs-comment">; ebx = row * 80 + col</span><br><span class="hljs-keyword">shl</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">1</span>               <span class="hljs-comment">; ebx = 2 * (row * 80 + col)</span><br></code></pre></td></tr></table></figure><p>使用32位寄存器代替原本的16位寄存器。<br>4. 显存写入<br>区别是32位一次可以写入两个字节，所以我们分别对ah和al进行赋值之后，一起存储到gs中</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, [char_color]     <span class="hljs-comment">; 设置字符颜色</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [char_value]     <span class="hljs-comment">; 设置字符值</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">ebx</span>], <span class="hljs-built_in">ax</span>    <span class="hljs-comment">; 写入显存</span><br></code></pre></td></tr></table></figure><ol start="5"><li>位置更新<br>内存上的值要进行计算，需要提取到寄存器之后再计算。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [row]<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>, [row_dir]        <span class="hljs-comment">; 根据行方向增量更新行</span><br><span class="hljs-keyword">mov</span> [row], <span class="hljs-built_in">al</span><br>    <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [col]<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>, [col_dir]        <span class="hljs-comment">; 根据列方向增量更新列</span><br><span class="hljs-keyword">mov</span> [col], <span class="hljs-built_in">al</span><br>    <br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> [char_color]    <span class="hljs-comment">; 改变颜色</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> [char_value]    <span class="hljs-comment">; 改变字符</span><br></code></pre></td></tr></table></figure><ol start="5"><li>延时实现<br>旧的代码中我使用的是bios int15h中断功能，但是这是实模式专属的，在保护模式无法使用。因此要切换成<strong>循环计数</strong>（纯软件延时）的方式（之前在实模式尝试过这种方式，但是延时效果比较差，应该是空间不够大）</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">mov ecx, <span class="hljs-number">2000000</span>         <span class="hljs-comment">; 延时计数器</span><br><span class="hljs-symbol">delay_loop:</span><br>    <span class="hljs-keyword">nop </span>                     <span class="hljs-comment">; 空操作</span><br>    loop delay_loop          <span class="hljs-comment">; 循环直到ecx为0</span><br></code></pre></td></tr></table></figure><p>整个程序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">; =========== 弹射字符动画 (32-bit) ===========</span><br><br><span class="hljs-comment">; 初始化弹射字符变量--存储在内存中</span><br>mov <span class="hljs-keyword">byte </span>[row], <span class="hljs-number">2</span>        <span class="hljs-comment">; 初始行位置</span><br>mov <span class="hljs-keyword">byte </span>[col], <span class="hljs-number">0</span>        <span class="hljs-comment">; 初始列位置</span><br>mov <span class="hljs-keyword">byte </span>[row_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 行方向增量 (1=向下)</span><br>mov <span class="hljs-keyword">byte </span>[col_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 列方向增量 (1=向右)</span><br>mov <span class="hljs-keyword">byte </span>[char_color], <span class="hljs-number">0x0A</span>  <span class="hljs-comment">; 字符颜色 (亮绿色)</span><br>mov <span class="hljs-keyword">byte </span>[char_value], <span class="hljs-string">&#x27;0&#x27;</span>   <span class="hljs-comment">; 显示字符</span><br><br><span class="hljs-comment">; 主弹射循环</span><br><span class="hljs-keyword">bounce_loop:</span><br><span class="hljs-keyword"></span>    <span class="hljs-comment">; 检查上下边界</span><br>    mov al, [row]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_up </span>      <span class="hljs-comment">; 如果行 &lt;= 0，需要向下反弹</span><br>    cmp al, <span class="hljs-number">24</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_down </span>    <span class="hljs-comment">; 如果行 &gt;= 24，需要向上反弹</span><br>    <br>    <span class="hljs-comment">; 检查左右边界</span><br>    mov al, [col]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_right </span>   <span class="hljs-comment">; 如果列 &lt;= 0，需要向右反弹</span><br>    cmp al, <span class="hljs-number">79</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_left </span>    <span class="hljs-comment">; 如果列 &gt;= 79，需要向左反弹</span><br>    <br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display </span>        <span class="hljs-comment">; 通过所有边界检查，显示字符</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_up:</span><br>    mov <span class="hljs-keyword">byte </span>[row_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 将行方向改为向下(正)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_down:</span><br>    mov <span class="hljs-keyword">byte </span>[row_dir], -<span class="hljs-number">1</span>   <span class="hljs-comment">; 将行方向改为向上(负)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_right:</span><br>    mov <span class="hljs-keyword">byte </span>[col_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 将列方向改为向右(正)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_left:</span><br>    mov <span class="hljs-keyword">byte </span>[col_dir], -<span class="hljs-number">1</span>   <span class="hljs-comment">; 将列方向改为向左(负)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">display:</span><br>    <span class="hljs-comment">; 计算显存位置</span><br>    <span class="hljs-keyword">movzx </span>ebx, <span class="hljs-keyword">byte </span>[row]    <span class="hljs-comment">; 获取当前行</span><br>    imul ebx, <span class="hljs-number">80</span>             <span class="hljs-comment">; ebx = row * 80</span><br>    <span class="hljs-keyword">movzx </span>ecx, <span class="hljs-keyword">byte </span>[col]    <span class="hljs-comment">; 获取当前列</span><br>    <span class="hljs-keyword">add </span>ebx, ecx             <span class="hljs-comment">; ebx = row * 80 + col</span><br>    <span class="hljs-keyword">shl </span>ebx, <span class="hljs-number">1</span>               <span class="hljs-comment">; ebx = 2 * (row * 80 + col)</span><br>    <br>    <span class="hljs-comment">; 显示字符</span><br>    mov ah, [char_color]     <span class="hljs-comment">; 设置字符颜色</span><br>    mov al, [char_value]     <span class="hljs-comment">; 设置字符值</span><br>    mov word [gs:ebx], ax    <span class="hljs-comment">; 写入显存</span><br>    <br>    <span class="hljs-comment">; 更新位置</span><br>    mov al, [row]<br>    <span class="hljs-keyword">add </span>al, [row_dir]        <span class="hljs-comment">; 根据行方向增量更新行</span><br>    mov [row], al<br>    <br>    mov al, [col]<br>    <span class="hljs-keyword">add </span>al, [col_dir]        <span class="hljs-comment">; 根据列方向增量更新列</span><br>    mov [col], al<br>    <br>    <span class="hljs-comment">; 更新字符外观</span><br>    inc <span class="hljs-keyword">byte </span>[char_color]    <span class="hljs-comment">; 改变颜色</span><br>    inc <span class="hljs-keyword">byte </span>[char_value]    <span class="hljs-comment">; 改变字符</span><br>    cmp <span class="hljs-keyword">byte </span>[char_value], <span class="hljs-string">&#x27;9&#x27;</span>+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">jne </span><span class="hljs-keyword">add_delay</span><br><span class="hljs-keyword"></span>    mov <span class="hljs-keyword">byte </span>[char_value], <span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-comment">; 如果超过&#x27;9&#x27;，重置为&#x27;0&#x27;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">add_delay:</span><br>    <span class="hljs-comment">; 保护模式下的延时循环</span><br>    mov ecx, <span class="hljs-number">2000000</span>         <span class="hljs-comment">; 延时计数器</span><br><span class="hljs-symbol">delay_loop:</span><br>    <span class="hljs-keyword">nop </span>                     <span class="hljs-comment">; 空操作</span><br>    loop delay_loop          <span class="hljs-comment">; 循环直到ecx为0</span><br>    <br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">bounce_loop </span>         <span class="hljs-comment">; 继续主循环</span><br><br><span class="hljs-comment">; 保护模式下存储变量的数据区</span><br>row         db <span class="hljs-number">0</span>  <span class="hljs-comment">; 当前行位置</span><br>col         db <span class="hljs-number">0</span>  <span class="hljs-comment">; 当前列位置</span><br>row_dir     db <span class="hljs-number">0</span>  <span class="hljs-comment">; 行方向</span><br>col_dir     db <span class="hljs-number">0</span>  <span class="hljs-comment">; 列方向</span><br>char_color  db <span class="hljs-number">0</span>  <span class="hljs-comment">; 字符颜色</span><br>char_value  db <span class="hljs-number">0</span>  <span class="hljs-comment">; 字符值</span><br><br>protect_mode_tag db <span class="hljs-string">&#x27;enter protect mode&#x27;</span><br><span class="hljs-symbol">protect_mode_tag_end:</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab2</title>
    <link href="/2025/03/11/AI-lab2/"/>
    <url>/2025/03/11/AI-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>常量：任何类型的实体</p></li><li><p>变量：x,y未知量</p></li><li><p>项：谓词、变量的参数项，由递归定义</p><ul><li>变量是项（可以看成是0元函数）</li><li>t1，t2，t3……tn是项，f是n元函数，则f(t1,t2,,,,tn)也是项</li><li>一阶逻辑中<strong>谓词不是项</strong>，即不能作为函数&#x2F;谓词的参数，也就是不存在f(P(x))这种复合方式，但是二阶逻辑中是可以的</li></ul></li><li><p>谓词：谓词是对其参数的</p><ul><li>零元谓词：退化为命题</li><li>单元谓词：只有一个参数，表示参数具备某种属性</li><li>多元谓词：多个参数，表示参数之间的关系</li></ul></li><li><p>事实：谓词中变量实例化后得到的事实</p></li><li><p>规则：公式，通过递归定义</p></li><li><p>可满足性：对该可满足性问题，只要能找到一组赋值，使得这个公式成立，这个公式就是可满足的</p></li><li><p>逻辑蕴含和逻辑推论</p><ul><li>逻辑蕴含S |&#x3D; α指对于<strong>任意变量赋值</strong>，如果S正确，则α也正确</li><li>逻辑推论S |- α指<strong>存在一条推理路径</strong>，从S出发，推导证明α</li></ul></li><li><p>一阶逻辑中谓词不是项，即不能作为函数&#x2F;谓词的参数，也就是不存在f(P(x))这种复合方式，但是二阶逻辑中是可以的</p></li></ul><h2 id="归结算法"><a href="#归结算法" class="headerlink" title="归结算法"></a>归结算法</h2><h3 id="归结反演："><a href="#归结反演：" class="headerlink" title="归结反演："></a>归结反演：</h3><p>steps:</p><ol><li>将α取否定，放到KB中</li><li>将更新的KB转换为clausal form得到新的子句集S</li><li>反复调用单步归结<ul><li>如果得到空子句，即S|- ()，说明KB ∧¬α 不可满足，算法终止，可得KB |&#x3D; α</li><li>如果一直归结直到不产生新的子句，在这个过程中没有得到空子句，则KB |&#x3D; α不成立</li></ul></li></ol><p><strong>clausal form–便于计算机处理的形式</strong></p><ul><li>每一个子句对应一个<strong>元组</strong>，元组中的每一个元素是一个原子公式或原子公式的否定，元素之间的关系是<strong>析取关系</strong>，表示只要一个原子成立，即子句成立。<ul><li>ps：元组是用<strong>逗号</strong>分隔的，<u>即使只有一个元素，也需要在元素后面加上逗号</u>，以区分它与普通变量的不同</li><li>元组的集合组合子句集S，子句集中的每个句子之间是<strong>合取关系</strong></li></ul></li><li>单步归结：<ul><li>从两个子句中分贝寻找相同的原子及其对应的原子否定（只能找其中一组，如果出现两组互补对不可以同时归结）</li><li>去掉该互补对，并将剩余元素合并为新子句</li></ul></li></ul><p>举例：<img src="/img/image-20250310164756545.png" alt="example_归结"></p><h2 id="最一般合一算法"><a href="#最一般合一算法" class="headerlink" title="最一般合一算法"></a>最一般合一算法</h2><h3 id="合一"><a href="#合一" class="headerlink" title="合一"></a>合一</h3><ul><li><p>通过<strong>变量替换</strong>使得两个子句能够被归结（有相同的原子），所以合一也被定义为使得两个原子公式等价的一组变量替换&#x2F;赋值</p></li><li><p>由于一阶逻辑中存在变量，所以归结之前需要进行合一，如<code>(P(john),Q(fred),R(x))</code>和<code>(¬P(y),R(susan),R(y))</code>两个子句中，我们无法找到一样的原子及其对应的否定，但是不代表它们不能够归结</p></li><li><p>通过将y替换为john（替换一定要<strong>全部替换</strong>），我们得到了<code>(P(john),Q(fred),R(x))</code>和<code>(¬P(john),R(susan),R(john))</code>，此时我们两个子句分别存在原子P(john)和它的否定<code>¬P(john)</code>，可以进行归结</p></li></ul><h3 id="最一般合一"><a href="#最一般合一" class="headerlink" title="最一般合一"></a>最一般合一</h3><p>指使得两个原子公式等价，最简单的一组变量替换</p><ul><li>输入：两个原子公式，它们有相同的谓词，不同的参数项和‘’¬“</li><li>输出：一组变量替换&#x2F;赋值</li><li>流程：<img src="/img/image-20250310165405419.png" alt="最一般合一算法流程"></li></ul><p><strong>Tips:变量替换是从两个原子公式中找到的，但是最后要施加给整个子句的</strong></p><h2 id="一阶逻辑归结算法："><a href="#一阶逻辑归结算法：" class="headerlink" title="一阶逻辑归结算法："></a>一阶逻辑归结算法：</h2><p><img src="/img/image-20250310165631716.png" alt="一阶逻辑归结算法"></p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>存储<strong>公式</strong>的python数据结构</p><ul><li><p>用字符串存储</p></li><li><p>符号¬用‘~’代替</p></li><li><p><strong>谓词</strong>的<strong>首字母大写</strong>, 例如用A, B, C, P1, P2, Student等表示; 谓词的每个参数之间用逗号“,”间隔且不加空格</p></li><li><p><strong>常量</strong>用小写单词或a, b, c等小写字母表示;</p></li><li><p>本次作业的公式中不含∃,∀量词符号</p><ul><li><p>例子: ¬child存储为 “~child” boy存储为“boy”</p></li><li><p>几个公式: “R(a)”, “~P(a,zz)”, “Student(tony)”. 这里应该将a,tony看做常量,将zz看做变量</p></li></ul></li></ul><p>存储<strong>子句</strong>的python数据结构</p><ul><li>用tuple的方式存储<ul><li>例子: </li><li>¬child˅¬male˅boy存储为(‘<del>child’, ‘</del>male’, ‘boy’)</li><li>¬S(z) ˅ L(z, snow)存储为(‘~S(z)’, ‘L(z,snow)’)</li></ul></li></ul><p>存储<strong>子句集</strong>的python数据结构</p><ul><li><p>子句集用<strong>set</strong>（可以去重）的方式存储, 每个元素是子句(元组)</p></li><li><p>小心归结的时候重复生成一样的子句</p></li></ul><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="实验一：命题逻辑的归结推理"><a href="#实验一：命题逻辑的归结推理" class="headerlink" title="实验一：命题逻辑的归结推理"></a>实验一：命题逻辑的归结推理</h2><h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><p>编写函数<code>ResolutionProp</code>实现命题逻辑的归结推理，函数要点如下：</p><ul><li>输入为子句集, 每个子句中的元素是原子命题或其否定.</li></ul><ul><li>输出归结推理的过程, <strong>每个归结步骤存为字符串</strong>, 将所有归结步骤按序存到一个列表中并返回, 即返回的数据类型为 <code>list[str]</code>.</li><li>一个归结步骤的格式为 <code>步骤编号 R[用到的子句编号] = 子句</code>. 如果一个字句包含多个公式，则每个公式用编号 <code>a,b,c...</code>区分，如果一个字句仅包含一个公式，则不用编号区分.（见课件和例题）</li></ul><p>例子: 输入子句集</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">KB</span> = &#123;(FirstGrade,), (~FirstGrade,Child), (~Child,)&#125;<br></code></pre></td></tr></table></figure><p>则调用 <code>ResolutionProp(KB)</code>后返回推理过程的列表如下:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(FirstGrade,),<br><span class="hljs-symbol">2 </span>(~FirstGrade,Child)<br><span class="hljs-symbol">3 </span>(~Child,),<br><span class="hljs-symbol">4 </span>R[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>a] = (Child,),<br><span class="hljs-symbol">5 </span>R[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] = ()<br></code></pre></td></tr></table></figure><h3 id="ResolutionProp-函数"><a href="#ResolutionProp-函数" class="headerlink" title="ResolutionProp()函数"></a><code>ResolutionProp()</code>函数</h3><p>working on…</p><ul><li>这里我们设置了两个字典用于存储子句的编号以及子句中元素的编号，方便后续打印；同时先将基本的子句集列举出来</li><li>设置<code>processed_KB</code>用于记录已经归结过的子句，同时建立一个<code>new_KB</code>用于记录每轮新增子句，原KB用于不断更新–保存旧子句和加入新子句</li><li>在进行归结时，需要将完整子句集与新增子句集进行归结，进行归结的子句需要没被归结过–也就是不在processed_KB之中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResolutionProp</span>(<span class="hljs-params">KB</span>):<br>    steps = []<br>    k = <span class="hljs-number">1</span><br>    clause_dict = &#123;&#125;  <span class="hljs-comment"># 记录子句及其编号--同时加入新增语句</span><br>    clause_labels = &#123;&#125;  <span class="hljs-comment"># 记录子句内元素的编号</span><br>    <br>    <span class="hljs-comment"># 初始化子句编号,同时将子句集列举出来</span><br>    <span class="hljs-keyword">for</span> clause <span class="hljs-keyword">in</span> KB:<br>        clause_dict[clause] = k<br>        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> <span class="hljs-subst">&#123;clause&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clause) &gt; <span class="hljs-number">1</span>: <span class="hljs-comment">#有多个元素的子句编号a,b...</span><br>            clause_labels[clause] = &#123;ele: <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i) <span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(clause)&#125; <br>        k += <span class="hljs-number">1</span><br>    <br>    clauses = <span class="hljs-built_in">list</span>(KB)<br>    processed_KB = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 记录已经归结过的子句--保证不会重复归结</span><br>    new_KB = <span class="hljs-built_in">set</span>(clauses)  <span class="hljs-comment"># 初始子句集--需要进行更新</span><br>    <br>    <span class="hljs-keyword">while</span> new_KB:<br>        current_clauses = <span class="hljs-built_in">list</span>(new_KB)  <span class="hljs-comment"># 当前需要归结的新子句--上一轮生成的语句</span><br>        new_KB.clear() <br>        <br>            <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(current_clauses)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(clauses)):  <span class="hljs-comment"># 之前的子句 + 新生成的子句</span><br>                <span class="hljs-keyword">if</span> current_clauses[i] == clauses[j]:  <span class="hljs-comment"># 避免自身归结</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> current_clauses[i] <span class="hljs-keyword">in</span> processed_KB : <span class="hljs-comment"># 这里是防止出现重复归结</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> clauses[j] <span class="hljs-keyword">in</span> processed_KB :<br>                    <span class="hljs-keyword">continue</span><br>                <br>                res, resolved_literals = resolve(current_clauses[i], clauses[j])<br>                <span class="hljs-keyword">if</span> res <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    clause1_id = <span class="hljs-built_in">str</span>(clause_dict[current_clauses[i]])<br>                    clause2_id = <span class="hljs-built_in">str</span>(clause_dict[clauses[j]])<br>                    <br>                    <span class="hljs-comment"># 处理字句编号</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(current_clauses[i]) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> resolved_literals[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> clause_labels[current_clauses[i]]:<br>                        clause1_id += clause_labels[current_clauses[i]][resolved_literals[<span class="hljs-number">0</span>]]<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clauses[j]) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> resolved_literals[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> clause_labels[clauses[j]]:<br>                        clause2_id += clause_labels[clauses[j]][resolved_literals[<span class="hljs-number">1</span>]]<br>                    <span class="hljs-comment">#在这里把已经归结的加入</span><br>                    processed_KB.add(current_clauses[i])<br>                    processed_KB.add(clauses[j])<br>                    <br>                    <span class="hljs-keyword">if</span> res == ():<span class="hljs-comment">#空子句</span><br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>] = ()&quot;</span>)<br>                        <span class="hljs-keyword">return</span> steps<br>                    <br>                    <span class="hljs-keyword">if</span> res <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> clause_dict:<br>                        clause_dict[res] = k<br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &gt; <span class="hljs-number">1</span>:<br>                            clause_labels[res] = &#123;lit: <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i) <span class="hljs-keyword">for</span> i, lit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(res)&#125;<br>                        new_KB.add(res)<br>                        clauses.append(res)<br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>] = <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br>                        k += <span class="hljs-number">1</span><br>        <br>            <br>        <span class="hljs-comment">#clauses.extend(current_clauses)  # 将新子句加入原始子句集中</span><br><br>    <br>    <span class="hljs-keyword">return</span> steps<br></code></pre></td></tr></table></figure><h3 id="resolve-函数"><a href="#resolve-函数" class="headerlink" title="resolve()函数"></a><strong><code>resolve()</code>函数</strong></h3><p>！这个函数主要用于做<strong>单步归结</strong> ！</p><p>思路：</p><ul><li>遍历子句1中的所有元素，对每一个元素都取反，查看这个取反的元素是否在子句2中，如果存在，说明找到了一组互补对，进行归结，并返回新的子句集（合并并去掉互补对）以及互补对；如果取反的元素不在子句2中继续遍历。</li><li>如果遍历到结尾都没有找到，说明这两句无法进行归结，返回空。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">clause1, clause2</span>):<br>    <span class="hljs-keyword">for</span> literal <span class="hljs-keyword">in</span> clause1:<br>        complement = <span class="hljs-string">f&quot;~<span class="hljs-subst">&#123;literal&#125;</span>&quot;</span> <span class="hljs-keyword">if</span> literal[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;~&#x27;</span> <span class="hljs-keyword">else</span> literal[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> clause2:<br>            <span class="hljs-comment"># 新的子句应该去除字面量和互补字面量</span><br>            new_clause = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(clause1).union(<span class="hljs-built_in">set</span>(clause2)) - &#123;literal, complement&#125;))<br>            <br>            <span class="hljs-comment"># 如果新子句为空，返回空子句</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> new_clause:<br>                <span class="hljs-keyword">return</span> (), (literal, complement)<br>            <span class="hljs-keyword">return</span> new_clause, (literal, complement)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>其他注意点：</p><ul><li>子句是元组，但由于元组是一种不可修改的数据结构，我们需要在合并子句集的时候就去除互补对。</li></ul><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h3><p>main函数比较简单，只需要设置好子句集，然后调用<code>ResolutionProp</code>函数，再输出steps这个字符串列表就好了。可以增加一些新例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    KB = &#123;<br>        (<span class="hljs-string">&#x27;FirstGrade&#x27;</span>,), <br>        (<span class="hljs-string">&#x27;~FirstGrade&#x27;</span>, <span class="hljs-string">&#x27;Child&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~Child&#x27;</span>,)<br>    &#125;<br>    KB1=&#123;<br>        (<span class="hljs-string">&#x27;a&#x27;</span>,),<br>        (<span class="hljs-string">&#x27;b&#x27;</span>,)<br>    &#125;<br>    KB2 = &#123;<br>        (<span class="hljs-string">&#x27;A&#x27;</span>,), <br>        (<span class="hljs-string">&#x27;~A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~B&#x27;</span>,)<br>    &#125;<br>    KB3 = &#123;<br>        (<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~P&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~R&#x27;</span>,)<br>    &#125;<br>    KB4 = &#123;<br>        (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~B&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~C&#x27;</span>, <span class="hljs-string">&#x27;~D&#x27;</span>)<br>    &#125;<br>    steps = ResolutionProp(KB)<br>    <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> steps:<br>        <span class="hljs-built_in">print</span>(step)<br></code></pre></td></tr></table></figure><h2 id="实验二：最一般合一算法"><a href="#实验二：最一般合一算法" class="headerlink" title="实验二：最一般合一算法"></a>实验二：最一般合一算法</h2><p>编写函数 <code>MGU</code>实现最一般合一算法. 该函数要点如下:</p><ul><li>输入为<strong>两个原子公式</strong>, 它们的<strong>谓词相同</strong>. 其数据类型为 <code>str</code>, 格式详见课件.</li><li>输出最一般合一的结果, 数据类型为 <code>dict</code>, 格式形如**{变量: 项, 变量: 项}**, 其中的变量和项均为字符串.</li><li>若不存在合一, 则返回空字典.</li></ul><p>例子:</p><p>调用 <code>MGU(&#39;P(xx,a)&#39;, &#39;P(b,yy)&#39;)</code>后返回字典 <code>&#123;&#39;xx&#39;:&#39;b&#39;, &#39;yy&#39;:&#39;a&#39;&#125;</code>.</p><p>调用 <code>MGU(&#39;P(a,xx,f(g(yy)))&#39;, &#39;P(zz,f(zz),f(uu))&#39;)</code>后返回字典 <code>&#123;&#39;zz&#39;:&#39;a&#39;, &#39;xx&#39;:&#39;f(a)&#39;, &#39;uu&#39;:&#39;g(yy)&#39;&#125;</code>.</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ol><li>只含一个元素的 <code>tuple</code>类型要在末尾加 <code>,</code>. 例如 <code>(&#39;a&#39;)</code>是错误的写法, 而正确的写法是 <code>(&#39;a&#39;,)</code>.</li><li><code>&#123;&#125;</code>会被解释成空字典. 若要定义空集合请用 <code>set()</code>.</li></ol><p>这一部分只写了一个函数（MGU）和一个辅助函数（用于判断是否含有变量）</p><h3 id="MGU-literal1-literal2"><a href="#MGU-literal1-literal2" class="headerlink" title="MGU(literal1,literal2)"></a>MGU(literal1,literal2)</h3><p>实现思路：</p><ul><li>输入：两个谓词相同的原子公式（字符串类型）；</li><li>返回&#x2F;输出：字典，格式：{变量: 项, 变量: 项}</li></ul><ol><li>首先处理原子公式，我们需要对各个位置的变量or项进行比较，在此之前，我们可以去掉谓词<code>P()</code>，然后再使用分词器<code>split</code>来将字符串分割成列表元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#其实这部分可以直接使用find()来查找第一个左括号，再使用切片</span><br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(literal1)):<br>    <span class="hljs-keyword">if</span> literal1[i]!=<span class="hljs-string">&#x27;(&#x27;</span>:<br>        i+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 去掉P(),然后使用split以逗号划分项</span><br>lit1=literal1[i+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>lit2=literal2[i+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br><br><span class="hljs-comment">#不等长无法合并--特殊情况</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lit1)!=<span class="hljs-built_in">len</span>(lit2):<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><ol start="2"><li>最重要的处理部分–主要思想就是一个个元素比较，分<strong>三类</strong>：<ul><li>两个元素都是变量–无法合一，返回None</li><li>一个元素是变量，另一个是项–用项替代变量，并加入到res字典中，同时把式子中所有相同变量用项替代</li><li>两个元素都是项–分析是不是f()或f(g())这种函数嵌套的项，如果都含有f()，需要进行<strong>递归</strong>判断（递归调用<strong>MGU()</strong>）</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#遍历两个集合</span><br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lit1)):<br>       <span class="hljs-keyword">if</span> lit1[i]==lit2[i]:<br>           <span class="hljs-keyword">continue</span><br>       <br>       <span class="hljs-keyword">if</span> lit1[i] != lit2[i]:<br>           <span class="hljs-comment"># 查看字符串里是否存在变量？如果都是变量无法合一--单独一个变量，不是项</span><br>           v1=Check_Var(lit1[i])<br>           v2=Check_Var(lit2[i])<br>           <span class="hljs-comment">#全都含有变量，无法合一</span><br>           <span class="hljs-keyword">if</span> v1 <span class="hljs-keyword">and</span> v2:<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br>           <span class="hljs-keyword">elif</span> v1 <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> v2 <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>               <span class="hljs-keyword">if</span> v1 <span class="hljs-keyword">in</span> res:<br>                   <span class="hljs-comment">#如果v1在res中已经进行了项的替换，不能再替换成其他的</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br>               <span class="hljs-comment">#v1是变量，v2是项</span><br>               res[lit1[i]]=lit2[i]<br>               <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(lit1)):<br>                   lit1[j]=lit1[j].replace(lit1[i],lit2[i])<br>                   lit2[j]=lit2[j].replace(lit1[i],lit2[i])<br>           <span class="hljs-keyword">elif</span> v2 <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> v1 <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>               <span class="hljs-keyword">if</span> v2 <span class="hljs-keyword">in</span> res:<br>                   <span class="hljs-comment">#如果v1在res中已经进行了项的替换，不能再替换成其他的</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br>               <span class="hljs-comment">#v1是变量，v2是项</span><br>               res[lit2[i]]=lit1[i]<br>               <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(lit1)):<br>                   lit1[j]=lit1[j].replace(lit2[i],lit1[i])<br>                   lit2[j]=lit2[j].replace(lit2[i],lit1[i])<br>           <span class="hljs-keyword">else</span>:<br>               <span class="hljs-comment">#单独判断--可能存在嵌套的函数项</span><br>               <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">in</span> lit1[i] <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">in</span> lit2[i]:<br>                   sub_res=MGU(lit1[i],lit2[i])<br>                   <span class="hljs-keyword">if</span> sub_res <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>                   <span class="hljs-keyword">else</span>: <br>                       res.update(sub_res)<br>               <span class="hljs-keyword">else</span>:   <br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br><br></code></pre></td></tr></table></figure><h3 id="Check-Var"><a href="#Check-Var" class="headerlink" title="Check_Var()"></a>Check_Var()</h3><p>很普通的一个函数，这里我只判断了是否存在x，y，z，u这几个变量，如果有更多函数符号可以添加，或者后面修改成传递变量集（but…lazy）</p><h3 id="简单测试一下："><a href="#简单测试一下：" class="headerlink" title="简单测试一下："></a>简单测试一下：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># literal1=&#x27;P(f(zz))&#x27;</span><br>    <span class="hljs-comment"># literal2=&#x27;P(f(f(u)))&#x27;</span><br>    <span class="hljs-comment"># literal1=&#x27;P(xx,a)&#x27;</span><br>    <span class="hljs-comment"># literal2=&#x27;P(b,yy)&#x27;</span><br>    <span class="hljs-comment"># literal1=&#x27;P(zz,xx)&#x27;</span><br>    <span class="hljs-comment"># literal2=&#x27;P(a,f(zz))&#x27;</span><br>    literal1=<span class="hljs-string">&#x27;P(a,xx,f(g(yy)))&#x27;</span><br>    literal2=<span class="hljs-string">&#x27;P(zz,f(zz),f(uu))&#x27;</span><br>    res=MGU(literal1,literal2)<br>    <span class="hljs-keyword">if</span> res <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> res.items():<br>            <span class="hljs-built_in">print</span>(key,<span class="hljs-string">&quot;:&quot;</span>,value)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO MGU found&quot;</span>)<br>        <br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">zz</span> : <span class="hljs-variable">a</span><br><span class="hljs-variable">xx</span> : <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">a</span>)</span><br><span class="hljs-variable">uu</span> : <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">yy</span>)</span><br></code></pre></td></tr></table></figure><h2 id="一阶逻辑的归结推理"><a href="#一阶逻辑的归结推理" class="headerlink" title="一阶逻辑的归结推理"></a>一阶逻辑的归结推理</h2><p>编写函数 <code>ResolutionFOL</code>实现一阶逻辑的归结推理. 该函数要点如下:</p><ul><li>输入为子句集, <code>KB</code>子句中的<strong>每个元素是一阶逻辑公式</strong>(不含全称量词和存在量词等量词符号)</li><li>输出归结推理的过程, 每个归结步骤存为字符串, 将所有归结步骤按序存到一个列表中并返回, 即<strong>返回的数据类型</strong>为 <code>list[str]</code></li><li>一个归结步骤的格式为 <code>步骤编号 R[用到的子句编号]&#123;最一般合一&#125; = 子句</code>, 其中最一般合一输出格式为”{变量&#x3D;常量, 变量&#x3D;常量}”.如果一个字句包含多个公式，则每个公式用编号 <code>a,b,c...</code>区分，如果一个字句仅包含一个公式，则不用编号区分。</li></ul><p>例题: 输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">KB = &#123;(<span class="hljs-built_in">GradStudent</span>(sue),),(~<span class="hljs-built_in">GradStudent</span>(<span class="hljs-attribute">x</span>),<span class="hljs-built_in">Student</span>(x)),(~<span class="hljs-built_in">Student</span>(x),<span class="hljs-built_in">HardWorker</span>(x)),(~<span class="hljs-built_in">HardWorker</span>(sue),)&#125;<br></code></pre></td></tr></table></figure><p>则调用 <code>ResolutionFOL(KB)</code>后返回推理过程的列表如下:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(GradStudent(sue),)<br><span class="hljs-symbol">2 </span>(~GradStudent(x),Student(x))<br><span class="hljs-symbol">3 </span>(~Student(x),HardWorker(x))<br><span class="hljs-symbol">4 </span>(~HardWorker(sue),)<br><span class="hljs-symbol">5 </span>R[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>a]&#123;x=sue&#125; = (Student(sue),)<br><span class="hljs-symbol">6 </span>R[<span class="hljs-number">3</span>a,<span class="hljs-number">5</span>]&#123;x=sue&#125; = (HardWorker(sue),)<br><span class="hljs-symbol">7 </span>R[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>] = []<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">KB = &#123;(<span class="hljs-built_in">A</span>(tony),),(<span class="hljs-built_in">A</span>(mike),),(<span class="hljs-built_in">A</span>(john),),(<span class="hljs-built_in">L</span>(tony,rain),),(<span class="hljs-built_in">L</span>(tony,snow),),(~<span class="hljs-built_in">A</span>(<span class="hljs-attribute">x</span>),<span class="hljs-built_in">S</span>(x),<span class="hljs-built_in">C</span>(x)),(~<span class="hljs-built_in">C</span>(y),~<span class="hljs-built_in">L</span>(y,rain)),(<span class="hljs-built_in">L</span>(z,snow),~<span class="hljs-built_in">S</span>(z)),(~<span class="hljs-built_in">L</span>(tony,u),~<span class="hljs-built_in">L</span>(mike,u)),(<span class="hljs-built_in">L</span>(tony,v),<span class="hljs-built_in">L</span>(mike,v)),(~<span class="hljs-built_in">A</span>(w),~<span class="hljs-built_in">C</span>(w),<span class="hljs-built_in">S</span>(w))&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(A(tony),)<br><span class="hljs-symbol">2 </span>(A(mike),)<br><span class="hljs-symbol">3 </span>(A(john),)<br><span class="hljs-symbol">4 </span>(L(tony,rain),)<br><span class="hljs-symbol">5 </span>(L(tony,snow),)<br><span class="hljs-symbol">6 </span>(~A(x),S(x),C(x))<br><span class="hljs-symbol">7 </span>(~C(y),~L(y,rain))<br><span class="hljs-symbol">8 </span>(L(z,snow),~S(z))<br><span class="hljs-symbol">9 </span>(~L(tony,u),~L(mike,u))<br><span class="hljs-symbol">10 </span>(L(tony,v),L(mike,v))<br><span class="hljs-symbol">11 </span>(~A(w),~C(w),S(w))<br><span class="hljs-symbol">12 </span>R[<span class="hljs-number">2</span>,<span class="hljs-number">11</span>a]&#123;w=mike&#125; = (S(mike),~C(mike))<br><span class="hljs-symbol">13 </span>R[<span class="hljs-number">5</span>,<span class="hljs-number">9</span>a]&#123;u=snow&#125; = (~L(mike,snow),)<br><span class="hljs-symbol">14 </span>R[<span class="hljs-number">6</span>c,<span class="hljs-number">12</span>b]&#123;x=mike&#125; = (S(mike),~A(mike),S(mike))<br><span class="hljs-symbol">15 </span>R[<span class="hljs-number">2</span>,<span class="hljs-number">14</span>b] = (S(mike),)<br><span class="hljs-symbol">16 </span>R[<span class="hljs-number">8</span>b,<span class="hljs-number">15</span>]&#123;z=mike&#125; = (L(mike,snow),)<br><span class="hljs-symbol">17 </span>R[<span class="hljs-number">13</span>,<span class="hljs-number">16</span>] = []<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">KB</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">On</span><span class="hljs-punctuation">(</span><span class="hljs-variable">tony</span><span class="hljs-operator">,</span><span class="hljs-variable">mike</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">On</span><span class="hljs-punctuation">(</span><span class="hljs-variable">mike</span><span class="hljs-operator">,</span><span class="hljs-variable">john</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">tony</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-operator">~</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">john</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-operator">~</span><span class="hljs-built_in">On</span><span class="hljs-punctuation">(</span><span class="hljs-variable">xx</span><span class="hljs-operator">,</span><span class="hljs-variable">yy</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,~</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">xx</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">yy</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(<span class="hljs-keyword">On</span>(tony,mike),),<br><span class="hljs-symbol">2 </span>(<span class="hljs-keyword">On</span>(mike,john),),<br><span class="hljs-symbol">3 </span>(Green(tony),),<br><span class="hljs-symbol">4 </span>(~Green(john),),<br><span class="hljs-symbol">5 </span>(~<span class="hljs-keyword">On</span>(xx,yy),~Green(xx),Green(yy)),<br><span class="hljs-symbol">6 </span>R[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>c]&#123;yy=john&#125; = (~<span class="hljs-keyword">On</span>(xx,john),~Green(xx)),<br><span class="hljs-symbol">7 </span>R[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>b]&#123;xx=tony&#125; = (~<span class="hljs-keyword">On</span>(tony,yy),Green(yy)),<br><span class="hljs-symbol">8 </span>R[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>a]&#123;xx=mike&#125; = (~Green(mike),),<br><span class="hljs-symbol">9 </span>R[<span class="hljs-number">1</span>,<span class="hljs-number">7</span>a]&#123;yy=mike&#125; = (Green(mike),),<br><span class="hljs-symbol">10 </span>R[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] = ()<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>只含一个元素的 <code>tuple</code>类型要在末尾加 <code>,</code>. 例如 <code>(&#39;x&#39;)</code>是错误的写法, 而正确的写法是 <code>(&#39;x&#39;,)</code>.</li><li><code>&#123;&#125;</code>会被解释成空字典. 若要定义空集合请用 <code>set()</code>.</li><li>请提交代码时只提交一个 <code>.py</code>代码文件, 请不要提交其他文件.</li><li>例题和作业都会进行代码测试.</li><li>上述作业的输出仅供参考。如果有不同的归结顺序，结果相同的情况，代码也算正确.</li></ol><p><img src="/img/image-20250310165631716.png" alt="一阶逻辑归结算法"></p><h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><blockquote><p>参考以及复用大部分前两个任务的代码来构建</p></blockquote><h4 id="ResolutionFOL-："><a href="#ResolutionFOL-：" class="headerlink" title="ResolutionFOL()："></a><code>ResolutionFOL()</code>：</h4><p>算法思路：</p><ul><li>将KB库以子句集的方式传入到函数中进行归结处理</li><li>对子句集反复进行单步归结，同时使用MGU算法进行合一处理</li></ul><p>具体：</p><ul><li><p>同上面的归结算法，由于输出时需要有美观的编号，我们设置了两个记录字典–<code>clause_dict</code>和<code>clause_labels</code>，前者记录子句的编号，后者记录子句中元素的编号（有多个元素的子句才需要）</p></li><li><p>类似地，先将子句集的子句进行编号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">k = <span class="hljs-number">1</span><br>clause_dict = &#123;&#125;  <span class="hljs-comment"># 记录子句及其编号--同时加入新增语句</span><br>clause_labels = &#123;&#125;  <span class="hljs-comment"># 记录子句内元素的编号</span><br><br><span class="hljs-comment"># 初始化子句编号,同时将子句集列举出来</span><br><span class="hljs-keyword">for</span> clause <span class="hljs-keyword">in</span> KB:<br>    clause_dict[clause] = k<br>    clause_str = format_clause(clause)<br>    steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> <span class="hljs-subst">&#123;clause_str&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clause) &gt; <span class="hljs-number">1</span>:<span class="hljs-comment">#有多个元素的子句编号a,b...</span><br>        clause_labels[clause] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, literal <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(clause):<br>            clause_labels[clause][literal] = <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i)  <br>        k += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>进入归结的主要步骤，需要维持一个已经归结的子句对的集合–保证子句对不会重复归结（这部分和上面的归结算法有点出入，前者只需要保证我归结过的句子不用再出现就可以了），但是由于我们可以对谓词P(x)赋不同的值，所以可以对他赋值后产生的新子句再次归结。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResolutionFOL</span>(<span class="hljs-params">KB</span>):<br>    steps = []<br>    k = <span class="hljs-number">1</span><br>    clause_dict = &#123;&#125;  <span class="hljs-comment"># 记录子句及其编号--同时加入新增语句</span><br>    clause_labels = &#123;&#125;  <span class="hljs-comment"># 记录子句内元素的编号</span><br>    <br>    <span class="hljs-comment"># 初始化子句编号,同时将子句集列举出来</span><br>    <span class="hljs-keyword">for</span> clause <span class="hljs-keyword">in</span> KB:<br>        clause_dict[clause] = k<br>        clause_str = format_clause(clause)<br>        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> <span class="hljs-subst">&#123;clause_str&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clause) &gt; <span class="hljs-number">1</span>:<span class="hljs-comment">#有多个元素的子句编号a,b...</span><br>            clause_labels[clause] = &#123;&#125;<br>            <span class="hljs-keyword">for</span> i, literal <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(clause):<br>                clause_labels[clause][literal] = <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i)  <br>        k += <span class="hljs-number">1</span><br>    <br>    original_size = k - <span class="hljs-number">1</span>  <span class="hljs-comment"># 记录原始子句集的大小</span><br>    <span class="hljs-comment">#原始子句集</span><br>    clauses = <span class="hljs-built_in">list</span>(KB)<br>    <span class="hljs-comment"># 记录已经归结过的子句--保证不会重复归结（但问题是一阶逻辑是可以多次为量词赋值的，所有我们记录的不是归结过的单个子句，而是子句对）</span><br>    processed = <span class="hljs-built_in">set</span>()   <br>   <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_resolvents = []<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(clauses)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(clauses)):<br>                <span class="hljs-keyword">if</span> clauses[i] == clauses[j]:  <span class="hljs-comment"># 避免自身归结</span><br>                    <span class="hljs-keyword">continue</span><br>                c1 = clauses[i]<br>                c2 = clauses[j]<br>                <br>                <span class="hljs-keyword">if</span> (c1, c2) <span class="hljs-keyword">in</span> processed:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment">#这里加入子句对</span><br>                processed.add((c1, c2))<br>                processed.add((c2, c1))<br>                <br>                resolvents = resolve(c1, c2)<br>                <br>                <span class="hljs-keyword">for</span> resolvent_info <span class="hljs-keyword">in</span> resolvents:<br>                    <span class="hljs-comment">#由于输出需要含有合一替换，所以resolve函数有一些变化</span><br>                    resolvent, lit1, lit2, mgu = resolvent_info<br>                    <br>                    <span class="hljs-comment"># 编号</span><br>                    clause1_id = <span class="hljs-built_in">str</span>(clause_dict[c1])<br>                    clause2_id = <span class="hljs-built_in">str</span>(clause_dict[c2])<br>                    <br>                    <span class="hljs-comment"># 处理元素的编号</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c1) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> lit1 <span class="hljs-keyword">in</span> clause_labels.get(c1, &#123;&#125;):<br>                        clause1_id += clause_labels[c1][lit1]<br>                    <br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c2) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> lit2 <span class="hljs-keyword">in</span> clause_labels.get(c2, &#123;&#125;):<br>                        clause2_id += clause_labels[c2][lit2]<br>                    <br>                    <span class="hljs-comment">#MGU调用</span><br>                    mgu_str = format_mgu(mgu)<br>                    <br>                    <span class="hljs-comment"># 查看是否产生了空集</span><br>                    <span class="hljs-keyword">if</span> resolvent == ():<br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>]<span class="hljs-subst">&#123;mgu_str&#125;</span> = ()&quot;</span>)<br>                        <span class="hljs-comment"># 找到空子句，简化归结过程</span><br>                        simplified_steps = Simplify(steps, original_size)<br>                        <span class="hljs-keyword">return</span> simplified_steps<br>                    <br>                    <span class="hljs-comment"># 将新的子句加入子句集</span><br>                    <span class="hljs-keyword">if</span> resolvent <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> clause_dict:<br>                        clause_dict[resolvent] = k<br>                        <br>                        <span class="hljs-comment"># 编号</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resolvent) &gt; <span class="hljs-number">1</span>:<br>                            clause_labels[resolvent] = &#123;&#125;<br>                            <span class="hljs-keyword">for</span> idx, lit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(resolvent):<br>                                clause_labels[resolvent][lit] = <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + idx)<br>                        <br>                        resolvent_str = format_clause(resolvent)<br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>]<span class="hljs-subst">&#123;mgu_str&#125;</span> = <span class="hljs-subst">&#123;resolvent_str&#125;</span>&quot;</span>)<br>                        new_resolvents.append(resolvent)<br>                        k += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment">#不产生新子句，返回结果</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> new_resolvents:<br>            <span class="hljs-keyword">return</span> steps<br>        <br>        <span class="hljs-comment"># 扩展旧子句集</span><br>        clauses.extend(new_resolvents)<br></code></pre></td></tr></table></figure><h4 id="extract-parents"><a href="#extract-parents" class="headerlink" title="extract_parents()"></a><code>extract_parents()</code></h4><p>用于从归结步骤中提取父子句编号，用于筛选出真正有用的归结步骤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_parents</span>(<span class="hljs-params">step</span>):<br>    <span class="hljs-comment">#从归结步骤中提取父子句编号</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;R[&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> step:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-comment"># 提取R[]内的内容</span><br>    relation_part = step[step.index(<span class="hljs-string">&quot;R[&quot;</span>) + <span class="hljs-number">2</span>:step.index(<span class="hljs-string">&quot;]&quot;</span>)]<br>    parents = relation_part.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 提取数字部分</span><br>    parent1 = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> c.isdigit()))<br>    parent2 = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> c.isdigit()))<br>    <br>    <span class="hljs-comment"># 提取字母后缀</span><br>    parent1_suffix = <span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> c.isalpha())<br>    parent2_suffix = <span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> c.isalpha())<br>    <br>    <span class="hljs-keyword">return</span> parent1, parent2, parent1_suffix, parent2_suffix<br></code></pre></td></tr></table></figure><h4 id="get-step-number-step"><a href="#get-step-number-step" class="headerlink" title="get_step_number(step)"></a><code>get_step_number(step)</code></h4><p>获取编号，把step的第一个标号提取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_step_number</span>(<span class="hljs-params">step</span>): <span class="hljs-comment">#获取编号</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(step.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="Simplify-steps-original-size"><a href="#Simplify-steps-original-size" class="headerlink" title="Simplify(steps, original_size)"></a><strong>Simplify</strong>(steps, original_size)</h4><p>简化归结过程–把又臭又长的过程删减成有用的过程</p><ul><li>记录初始子句集（也就是KB库转换的最初的子句集）</li><li>同时建立一个存储有用子句的集合</li><li>在旧的step的基础上进行筛选，同时创建新的编号，创建num2idx字典，用于存储编号到索引的映射</li><li>为了简化过程，我们是从空子句开始回溯，找到能得到空子句的核心步骤。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Simplify</span>(<span class="hljs-params">steps, original_size</span>): <span class="hljs-comment">#简化归结过程--把又臭又长的过程删减成有用的过程</span><br>    base_process = steps[<span class="hljs-number">0</span>:original_size]  <span class="hljs-comment"># 初始子句集</span><br>    useful_steps = []  <span class="hljs-comment"># 有用子句集</span><br>    <br>    <span class="hljs-comment"># 创建编号到索引的映射</span><br>    number_to_index = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i, step <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(steps):<br>        number = get_step_number(step)<br>        number_to_index[number] = i<br>    <br>    <span class="hljs-comment"># 从空子句开始，队列中存放需要处理的子句编号</span><br>    number = [get_step_number(steps[-<span class="hljs-number">1</span>])]  <span class="hljs-comment"># 空子句的编号</span><br>    processed = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 已处理的子句编号</span><br>    <br>    <span class="hljs-keyword">while</span> number:<br>        number0 = number.pop(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 提取队列首元素</span><br>        <span class="hljs-keyword">if</span> number0 <span class="hljs-keyword">in</span> processed:  <span class="hljs-comment"># 避免处理已处理的子句</span><br>            <span class="hljs-keyword">continue</span><br>            <br>        processed.add(number0)<br>        step_index = number_to_index[number0]<br>        step = steps[step_index]<br>        <br>        <span class="hljs-keyword">if</span> step_index &gt;= original_size:  <span class="hljs-comment"># 非原始子句才加入useful_steps</span><br>            useful_steps.append(step)<br>            <br>        <span class="hljs-comment"># 获取父子句编号</span><br>        parent_info = extract_parents(step)<br>        <span class="hljs-keyword">if</span> parent_info[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            num1, num2 = parent_info[<span class="hljs-number">0</span>], parent_info[<span class="hljs-number">1</span>]<br>            <br>            <span class="hljs-comment"># 如果不是初始子句，加入队列</span><br>            <span class="hljs-keyword">if</span> num1 &gt; original_size <span class="hljs-keyword">and</span> num1 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> processed:<br>                number.append(num1)<br>            <span class="hljs-keyword">if</span> num2 &gt; original_size <span class="hljs-keyword">and</span> num2 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> processed:<br>                number.append(num2)<br>    <br>    <span class="hljs-comment"># 结果需要反转--回溯</span><br>    useful_steps.reverse()<br>    <br>    <span class="hljs-comment"># 得到新的归结过程：原始子句 + 有用子句</span><br>    final_steps = base_process + useful_steps<br>    <br>    <span class="hljs-comment"># 创建新旧编号的映射</span><br>    old_to_new = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i, step <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(final_steps):<br>        old_num = get_step_number(step)<br>        new_num = i + <span class="hljs-number">1</span><br>        old_to_new[old_num] = new_num<br>    <br>    <span class="hljs-comment"># 将归结过程重新编号</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(original_size, <span class="hljs-built_in">len</span>(final_steps)):<br>        step = final_steps[i]<br>        parent_info = extract_parents(step)<br>        <br>        <span class="hljs-keyword">if</span> parent_info[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            old_num1, old_num2 = parent_info[<span class="hljs-number">0</span>], parent_info[<span class="hljs-number">1</span>]<br>            suffix1, suffix2 = parent_info[<span class="hljs-number">2</span>], parent_info[<span class="hljs-number">3</span>]<br>            <br>            <span class="hljs-comment"># 获取新编号</span><br>            new_num1 = old_to_new[old_num1]<br>            new_num2 = old_to_new[old_num2]<br>            <br>            <span class="hljs-comment"># 构造新的引用字符串</span><br>            old_ref = <span class="hljs-string">f&quot;R[<span class="hljs-subst">&#123;old_num1&#125;</span><span class="hljs-subst">&#123;suffix1&#125;</span>,<span class="hljs-subst">&#123;old_num2&#125;</span><span class="hljs-subst">&#123;suffix2&#125;</span>]&quot;</span><br>            new_ref = <span class="hljs-string">f&quot;R[<span class="hljs-subst">&#123;new_num1&#125;</span><span class="hljs-subst">&#123;suffix1&#125;</span>,<span class="hljs-subst">&#123;new_num2&#125;</span><span class="hljs-subst">&#123;suffix2&#125;</span>]&quot;</span><br>            <br>            <span class="hljs-comment"># 替换引用</span><br>            final_steps[i] = final_steps[i].replace(old_ref, new_ref)<br>        <br>        <span class="hljs-comment"># 更新步骤编号</span><br>        old_step_num = get_step_number(final_steps[i])<br>        new_step_num = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> old_step_num != new_step_num:<br>            final_steps[i] = <span class="hljs-built_in">str</span>(new_step_num) + final_steps[i][<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(old_step_num)):]<br>    <br>    <span class="hljs-keyword">return</span> final_steps<br><br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cs50-Ai-Machine-Learning</title>
    <link href="/2025/03/06/cs50-ai-Machine-Learning/"/>
    <url>/2025/03/06/cs50-ai-Machine-Learning/</url>
    
    <content type="html"><![CDATA[<h1 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h1><ul><li>机器学习为计算机提供数据，而非确切的指令，通过这些数据，计算机学习去识别模式并自行执行</li></ul><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><ul><li>监督学习是指计算机<strong>基于输入-输出对数据集</strong>来学习函数映射。</li><li>监督意味着这些数据已经有了确切的标签or分类</li></ul><h3 id="分类学习：最近邻居分类"><a href="#分类学习：最近邻居分类" class="headerlink" title="分类学习：最近邻居分类"></a>分类学习：最近邻居分类</h3><ul><li>为相关变量分配<strong>最近的观察值</strong></li></ul><p><img src="/img/nearestneighbor.png" alt="Nearest Neighbor Classification"></p><p>比如这张图，根据最近观察值策略，可能会认为他是红色的；然而从更大角度来看，它周围蓝色点居多，我们直觉地认为，蓝色可能是更好的预测，即时最近的观察值是红色的（局限性or不准确）</p><ul><li>优化：k最近邻居分类，根据点最近的k个邻居的值来判断。缺点是需要消耗计算力去测量各个点到相关点的距离。（进一步可以通过剪枝或更符合的数据结构加速）<ul><li><strong>选择k值</strong>：k是一个超参数，表示需要考虑的最近邻居的数量。k的选择会影响模型的性能：<ul><li>如果k太小，模型可能会过拟合，对噪声敏感。</li><li>如果k太大，模型可能会欠拟合，忽略数据的局部特征。</li></ul></li></ul></li></ul><h3 id="感知器学习"><a href="#感知器学习" class="headerlink" title="感知器学习"></a>感知器学习</h3><ul><li>神经网络：由一个或多个神经元组成，而一个神经元包含输入、输出和内部处理器</li><li>感知器（perceptron）：单层感知器（包含输入和输出层，且二者直接相连）、多层感知器（多层计算）</li><li>与最近邻策略相反，解决分类问题的另一种方法是将数据作为一个整体来查看，并尝试创建一个<strong>决策边界</strong>–二分类的线性分类模型</li></ul><p><img src="/img/decisionboundary.png" alt="Decision Boundary"></p><p>缺点：数据很混乱，很少能画一条线并将类整齐地划分为两个观测值而没有任何错误。</p><p>将各个参数与对应的权重相乘之后相加，输入到激活函数，通过判断是否超过阈值得到期望。</p><p>例子：</p><ul><li>输入–x1&#x3D;humidity（湿度）；x2&#x3D;pressure（压力）；函数h(x1,x2)</li><li>该函数对每个输入进行加权，并添加一个常数，产生如下的线性方程： <ul><li>Rain w₀ + w₁x₁ + w₂x₂ ≥ 0</li><li>No Rain otherwise</li></ul></li></ul><p><img src="/img/perceptronlearning.png" alt="Perceptron Learning Rule"></p><p>这里的y代表观测值，而h(x)代表估计值，如果他们误差较大，说明要调整这个数据的权重</p><ul><li><p>如果它们<strong>相同</strong>，则整个项等于零，因此<strong>权重不会改变</strong>。如果我们低估了（在观察到 Rain 时调用 No Rain），那么括号中的值将为 1，权重将增加新的值α学习系数。如果我们高估（在观察到 No Rain 时调用 Rain），则括号中的值将为 -1，权重将减少 x 的值，缩放 α。α越高，每个新事件对权重的影响就越大。</p></li><li><p>结果是一个阈值函数，一旦超过设定的值函数值就会发生跳跃</p><ul><li>硬性阈值<img src="/img/hardthreshold.png" alt="Hard Threshold"></li><li>软性阈值    <img src="/img/softthreshold.png" alt="软阈值"></li></ul></li></ul><p>​软性阈值会存在中间过渡的值</p><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>这种方法是在决策边界附件使用一个<strong>额外的向量</strong>（支持向量），以便在分离数据时做出最佳决策–<strong>Maximum Margin Separator</strong></p><p>优点：可以表示两个维度以上的决策边界，以及非线性决策边界</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归是函数的监督学习任务，它将输入点映射到连续值。</p><p>目标不是在观察类型之间进行分离，而是根据输入预测输出的值</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h4 id="0-1损失函数"><a href="#0-1损失函数" class="headerlink" title="0-1损失函数"></a>0-1损失函数</h4><ul><li>L(预测，损失)：当实际&#x3D;预测，则L&#x3D;0；否则，L&#x3D;1</li></ul><p><img src="/img/01loss.png" alt="0-1 Loss Function"></p><ul><li>预测连续值时，可以使用L1和L2损失函数，更加看重每个预测域观测值之间的差异程度。<ul><li>L1：L(实际，预测)&#x3D;|实际-预测|</li><li>L2：L(实际，预测）&#x3D;|实际-预测|²</li></ul></li></ul><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>过拟合是指模型与训练数据的你和非常好，以至于无法推广到其他数据集。</p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化是惩罚更复杂的假设以支持更简单、更一般的假设的过程。我们使用正则化来避免过拟合。</p><p><code>cost(h) = loss(h) + λcomplexity(h)</code></p><p>测试我们是否过度拟合模型的一种方法是使用 <strong>Holdout Cross Validation</strong>。在这种技术中，我们将所有数据一分为二：<strong>训练集</strong>和测试<strong>集</strong>。我们在训练集上运行学习算法，然后查看它对测试集中数据的预测能力如何。这里的想法是，通过测试训练中未使用的数据，我们可以衡量学习的泛化程度。</p><p>保持交叉验证的缺点是，我们无法使用一半的数据来训练模型，因为它用于评估目的。解决这个问题的一种方法是使用 <strong>k-Fold\ 交叉验证</strong>。在这个过程中，我们将数据分成 k 个集合。我们运行训练 k 次，每次都省略一个数据集并将其用作测试集。我们最终对模型进行了 k 种不同的评估，我们可以对模型进行平均并估计我们的模型如何泛化而不会丢失任何数据。</p><h3 id="强度学习"><a href="#强度学习" class="headerlink" title="强度学习"></a>强度学习</h3><p>在每次行动过后，agent会得到反馈（正反馈或负反馈</p><p><img src="/img/reinforcement.png" alt="Reinforcement Learning"></p><h3 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h3><ul><li>Set of states <strong>S</strong></li><li>Set of actions <strong>Actions(S)</strong></li><li>Transition model <strong>P(s’ | s, a)</strong></li><li>Reward function <strong>R(s, a, s’)</strong></li></ul><h3 id="Q学习"><a href="#Q学习" class="headerlink" title="Q学习"></a>Q学习</h3><p>函数 Q(s, a) 输出在状态 <em>s</em> 下采取行动 <em>a</em> 的值的估计值</p><p>模型从所有估计值等于0开始，当执行作并收到奖励时，该函数会执行两项作：</p><p>1） 它根据当前奖励和预期的未来奖励估计 <strong>Q（s， a）</strong> 的值，以及</p><p> 2） 更新 <strong>Q（s， a）</strong> 以同时考虑旧估计值和新估计值。</p><p><img src="/img/qlearning.png" alt="Q 学习公式"></p><p>训练强化学习模型的另一种方法是，不是在每次移动时提供反馈，而是在整个过程结束时提供反馈</p><h2 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h2><ul><li>没有人为进行分类，只有输入数据，AI会学习这些数据中的模式</li></ul><p>聚类：</p><p>获取输入数据并将其组织成组，以便相似的对象最终属于同一组</p><p>K-means聚集</p><p>它映射一个空间中的所有数据点，然后在空间中随机放置 k 个集群中心（由程序员决定多少个，这是我们在左侧看到的起始状态）。每个集群中心只是空间中的一个点。然后，每个聚类都会分配最接近其中心的所有点，而不是任何其他中心（这是中间的图片）。然后，在迭代过程中，聚类中心移动到所有这些点的中间（右侧的状态），然后再次将点重新分配给现在最靠近它们的聚类。当重复该过程后，每个点都保持在与之前相同的集群中时，我们已经达到了平衡，算法结束了，给我们留下了在集群之间划分的点。</p><h1 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h1><h2 id="shopping"><a href="#shopping" class="headerlink" title="shopping"></a>shopping</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当用户在线购物时，并非所有人最终都会购买东西。事实上，在线购物网站的大多数访问者可能不会在网络浏览会话期间进行购买。不过，购物网站能够预测用户是否打算进行购买可能很有用：也许向用户显示不同的内容，例如，如果网站认为用户不打算完成购买，则向用户显示折扣优惠。网站如何确定用户的购买意向？这就是机器学习的用武之地。</p><p>您在此问题中的任务是构建一个最近邻分类器来解决此问题。给定有关用户的信息 — 他们访问了多少个页面，他们是否在周末购物，他们正在使用什么 Web 浏览器等 — 您的分类器将预测用户是否会进行购买。您的分类器不会完全准确 — 完美地模拟人类行为是一项远远超出本课程范围的任务 — 但它应该比随机猜测要好。为了训练您的分类器，我们将为您提供来自某个购物网站的一些数据，这些数据来自大约 12000 个用户会话。</p><p>我们如何衡量此类系统的准确性？如果我们有一个测试数据集，我们可以对数据运行分类器，并计算我们正确分类用户意图的时间比例。这将为我们提供一个准确率。但这个数字可能有点误导。例如，想象一下，如果大约 15% 的用户最终完成了购买。如果分类器始终预测用户不会完成购买，那么，我们将衡量为 85% 的准确率：它唯一错误分类的用户是 15% 的用户。虽然 85% 的准确率听起来不错，但这似乎不是一个非常有用的分类器。</p><p>相反，我们将测量两个值：灵敏度（也称为“真阳性率”）和特异性（也称为“真阴性率”）。敏感度是指正确识别的正面示例的比例：换句话说，正确识别完成购买的用户比例。特异性是指被正确识别的负面示例的比例：在这种情况下，未完成购买但被正确识别的用户比例。因此，我们之前的 “always guess no” 分类器将具有完美的特异性 （1.0），但没有灵敏度 （0.0）。我们的目标是构建一个在这两个指标上都执行合理的分类器。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li><p>shopping.csv文件中是数据集</p><ul><li>前六列衡量了用户在会话中访问的不同类型页面</li><li><code>Administrative</code>、<code>Informational</code>、<code>ProductRelated</code>列指示下的值代表用户访问过多少这类型的页面</li><li><code>_Duration</code>列指示了用户留存时间</li><li><code>BounceRates</code>，<code>ExitRates</code>和<code>PageValues</code>衡量来自谷歌评估的有关用户访问的页面信息</li><li><code>SpecialDay</code>评估了用户访问日期和特殊日期的接近程度</li><li>还有一些有关用户的属性</li><li><code>VisitorType</code>指示了是回头客或新用户</li><li><code>Weekend</code>是布尔值，代表是否在周末进行访问</li><li>最后还有一个指示用户是否购买的列 <code>Revenue</code></li></ul></li><li><p>shopping.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    <span class="hljs-comment"># Check command-line arguments</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">2</span>:<br>        sys.exit(<span class="hljs-string">&quot;Usage: python shopping.py data&quot;</span>)<br><br>    <span class="hljs-comment"># Load data from spreadsheet and split into train and test sets</span><br>    evidence, labels = load_data(sys.argv[<span class="hljs-number">1</span>])<br>    X_train, X_test, y_train, y_test = train_test_split(<br>        evidence, labels, test_size=TEST_SIZE<br>    )<br><br>    <span class="hljs-comment"># Train model and make predictions</span><br>    model = train_model(X_train, y_train)<br>    predictions = model.predict(X_test)<br>    sensitivity, specificity = evaluate(y_test, predictions)<br><br>    <span class="hljs-comment"># Print results</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Correct: <span class="hljs-subst">&#123;(y_test == predictions).<span class="hljs-built_in">sum</span>()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Incorrect: <span class="hljs-subst">&#123;(y_test != predictions).<span class="hljs-built_in">sum</span>()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;True Positive Rate: <span class="hljs-subst">&#123;<span class="hljs-number">100</span> * sensitivity:<span class="hljs-number">.2</span>f&#125;</span>%&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;True Negative Rate: <span class="hljs-subst">&#123;<span class="hljs-number">100</span> * specificity:<span class="hljs-number">.2</span>f&#125;</span>%&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>load_data</code>函数用来加载数据和分割数据</p><p><code>train_model</code>函数是用来训练的，会对测试集的输入做出预测</p><p><code>evaluate</code>函数用于检测敏感度和特异性</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="load-data-函数"><a href="#load-data-函数" class="headerlink" title="load_data 函数"></a><code>load_data</code> 函数</h4><p><code>load_data</code> 函数应接受一个 CSV 文件名作为参数，打开该文件，并返回一个元组 <code>(evidence, labels)</code>。<code>evidence</code> 应是一个包含所有数据点证据的列表，<code>labels</code> 应是一个包含所有数据点标签的列表。</p><p>由于每一行数据对应一个证据和一个标签，<code>evidence</code> 列表和 <code>labels</code> 列表的长度应等于 CSV 文件中的行数（不包括标题行）。列表的顺序应与用户在电子表格中的顺序一致。也就是说，<code>evidence[0]</code> 应是第一个用户的证据，<code>labels[0]</code> 应是第一个用户的标签。</p><p><code>evidence</code> 列表中的每个元素应是一个长度为 17 的列表，对应电子表格中除最后一列（标签列）外的每一列。证据列表中的值应与电子表格中的列顺序一致。你可以假设 <code>shopping.csv</code> 中的列顺序始终不变。</p><p>请注意，为了构建最近邻分类器，所有数据都必须是数值类型。确保你的值具有以下类型：</p><ul><li><code>Administrative</code>, <code>Informational</code>, <code>ProductRelated</code>, <code>Month</code>, <code>OperatingSystems</code>, <code>Browser</code>, <code>Region</code>, <code>TrafficType</code>, <code>VisitorType</code>, 和 <code>Weekend</code> 应为 <code>int</code> 类型。</li><li><code>Administrative_Duration</code>, <code>Informational_Duration</code>, <code>ProductRelated_Duration</code>, <code>BounceRates</code>, <code>ExitRates</code>, <code>PageValues</code>, 和 <code>SpecialDay</code> 应为 <code>float</code> 类型。</li><li><code>Month</code> 应为 0（一月）到 11（十二月）。</li><li><code>VisitorType</code> 应为 1（返回访客）或 0（非返回访客）。</li><li><code>Weekend</code> 应为 1（用户在周末访问）或 0（否则）。</li></ul><p><code>labels</code> 中的每个值应为整数 1（用户完成购买）或 0（否则）。</p><p>例如，第一个证据列表的值应为 <code>[0, 0.0, 0, 0.0, 1, 0.0, 0.2, 0.2, 0.0, 0.0, 1, 1, 1, 1, 1, 1, 0]</code>，第一个标签的值应为 <code>0</code>。</p><p>更加顺序化：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">evidence should be <span class="hljs-keyword">a</span> list <span class="hljs-keyword">of</span> lists, where <span class="hljs-keyword">each</span> list <span class="hljs-keyword">contains</span> <span class="hljs-keyword">the</span><br>    following values, <span class="hljs-keyword">in</span> order:<br>        - Administrative, <span class="hljs-keyword">an</span> integer0<br>        - Administrative_Duration, <span class="hljs-keyword">a</span> floating point number1<br>        - Informational, <span class="hljs-keyword">an</span> integer2<br>        - Informational_Duration, <span class="hljs-keyword">a</span> floating point number3<br>        - ProductRelated, <span class="hljs-keyword">an</span> integer4<br>        - ProductRelated_Duration, <span class="hljs-keyword">a</span> floating point number5<br>        - BounceRates, <span class="hljs-keyword">a</span> floating point number6<br>        - ExitRates, <span class="hljs-keyword">a</span> floating point number7<br>        - PageValues, <span class="hljs-keyword">a</span> floating point number8<br>        - SpecialDay, <span class="hljs-keyword">a</span> floating point number9<br>        - Month, <span class="hljs-keyword">an</span> index <span class="hljs-built_in">from</span> <span class="hljs-number">0</span> (January) <span class="hljs-built_in">to</span> <span class="hljs-number">11</span> (December)<span class="hljs-number">10</span><br>        - OperatingSystems, <span class="hljs-keyword">an</span> integer11<br>        - Browser, <span class="hljs-keyword">an</span> integer12<br>        - Region, <span class="hljs-keyword">an</span> integer13<br>        - TrafficType, <span class="hljs-keyword">an</span> integer14<br>        - VisitorType, <span class="hljs-keyword">an</span> <span class="hljs-keyword">integer</span> <span class="hljs-number">0</span> (<span class="hljs-keyword">not</span> returning) <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> (returning)<span class="hljs-number">15</span><br>        - Weekend, <span class="hljs-keyword">an</span> <span class="hljs-keyword">integer</span> <span class="hljs-number">0</span> (<span class="hljs-keyword">if</span> <span class="hljs-literal">false</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> (<span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>)<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h4 id="train-model-函数"><a href="#train-model-函数" class="headerlink" title="train_model 函数"></a><code>train_model</code> 函数</h4><p><code>train_model</code> 函数应接受一个证据列表和一个标签列表，并返回一个基于该训练数据训练的 scikit-learn 最近邻分类器（k&#x3D;1 的 k-最近邻分类器）。</p><p>请注意，我们已经为你导入了 <code>from sklearn.neighbors import KNeighborsClassifier</code>。你应在此函数中使用 <code>KNeighborsClassifier</code>。</p><h4 id="evaluate-函数"><a href="#evaluate-函数" class="headerlink" title="evaluate 函数"></a><code>evaluate</code> 函数</h4><p><code>evaluate</code> 函数应接受一个标签列表（测试集中用户的真实标签）和一个预测列表（分类器预测的标签），并返回两个浮点值 <code>(sensitivity, specificity)</code>。</p><ul><li><code>sensitivity</code> 应为 0 到 1 之间的浮点值，表示“真正例率”：实际为正例的标签中被准确识别的比例。</li><li><code>specificity</code> 应为 0 到 1 之间的浮点值，表示“真负例率”：实际为负例的标签中被准确识别的比例。</li></ul><p>你可以假设每个标签为 1（正例，用户完成购买）或 0（负例，用户未完成购买）。你可以假设真实标签列表至少包含一个正例和一个负例。</p><h3 id="指导"><a href="#指导" class="headerlink" title="指导"></a>指导</h3><ol><li><p><strong><code>load_data</code> 函数</strong>：</p><ul><li>使用 Python 的 <code>csv</code> 模块或 <code>pandas</code> 库读取 CSV 文件。</li><li>遍历每一行数据，将除最后一列外的所有列转换为适当的类型，并存储在 <code>evidence</code> 列表中。</li><li>将最后一列（标签列）转换为整数，并存储在 <code>labels</code> 列表中。</li><li>确保所有数据的类型正确，特别是 <code>Month</code>、<code>VisitorType</code> 和 <code>Weekend</code> 的转换。</li></ul></li><li><p><strong><code>train_model</code> 函数</strong>：</p><ul><li>使用 <code>KNeighborsClassifier</code> 创建一个 k&#x3D;1 的最近邻分类器。</li><li>使用 <code>fit</code> 方法将证据和标签作为训练数据拟合模型。</li><li>返回训练好的模型。</li></ul></li><li><p><strong><code>evaluate</code> 函数</strong>：</p><ul><li>计算真正例（True Positives, TP）、真负例（True Negatives, TN）、假正例（False Positives, FP）和假负例（False Negatives, FN）。</li><li>使用公式 <code>sensitivity = TP / (TP + FN)</code> 计算敏感度。</li><li>使用公式 <code>specificity = TN / (TN + FP)</code> 计算特异性。</li><li>返回计算得到的敏感度和特异性。</li></ul></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保数据类型转换正确，特别是 <code>Month</code>、<code>VisitorType</code> 和 <code>Weekend</code> 的转换。</li><li>在 <code>evaluate</code> 函数中，确保正确处理边界情况，例如所有预测都为正例或负例的情况。</li><li>使用适当的库函数和方法来简化代码，例如 <code>pandas</code> 的 <code>read_csv</code> 函数和 <code>scikit-learn</code> 的 <code>KNeighborsClassifier</code>。</li></ul><p>通过这些步骤，你应该能够成功实现 <code>load_data</code>、<code>train_model</code> 和 <code>evaluate</code> 函数。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ysos</title>
    <link href="/2025/03/05/ysos/"/>
    <url>/2025/03/05/ysos/</url>
    
    <content type="html"><![CDATA[<h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><p>教学网站：<a href="https://ysos.gzti.me/">https://ysos.gzti.me/</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab2</title>
    <link href="/2025/03/05/OS-lab2/"/>
    <url>/2025/03/05/OS-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lab2"><a href="#OS-Lab2" class="headerlink" title="OS_Lab2"></a>OS_Lab2</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>在本次实验中，同学们会学习到x86汇编、计算机的启动过程、IA-32处理器架构和字符显存原理。根据所学的知识，同学们能自己编写程序，并且让计算机在启动后加载运行，增进对计算机启动过程的理解，为后面编写操作系统加载程序奠定基础。同时，同学们将学习使用gdb来调试程序的基本方法。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>DDL：2025.3.23</p><p>提交内容：将<strong>3+1（选做）个任务的代码</strong>和<strong>实验报告</strong>放到<strong>压缩包</strong>中，命名为“<strong>lab2-姓名-学号</strong>”，提交到实验课程邮箱：<a href="mailto:&#111;&#115;&#x5f;&#x73;&#x79;&#115;&#117;&#x5f;&#x6c;&#97;&#x62;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;">os_sysu_lab@163.com</a>。</p><p>将实验报告的pdf提交至 <a href="http://inbox.weiyun.com/zPIW1se1">http://inbox.weiyun.com/zPIW1se1</a></p><h2 id="实验入门"><a href="#实验入门" class="headerlink" title="实验入门"></a>实验入门</h2><ul><li>从汇编语言开始–汇编语言提供了一些特权指令，而高级指令并未提供对应的指令。</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ul><li><p>IA-32处理器：从Intel 80386开始到32位的奔腾4处理器</p></li><li><p>Intel 32位的处理器也被称为x86处理器</p></li><li><p>IA-32处理器有三种基本操作模式：<em><strong>保护模式*、*实地址模式</strong></em>(简称实模式)和<strong>系统管理模式</strong>。</p></li><li><p>IA-32的重要组成部分：</p><ul><li>地址空间：保护模式：使用32位地址总线、32位寄存器；实模式：20位地址总线、16位寄存器</li><li>基本寄存器：IA-32处理器主要有8个通用寄存器eax, ebx, ecx, edx, ebp, esp, esi, edi、6个<strong>段寄存器cs, ss, ds, es, fs, gs</strong>、标志寄存器eflags、指令地址寄存器eip。</li><li>通用寄存器：通用寄存器有8个，分别是eax, ebx, ecx, edx, ebp, esp, esi, edi，均是<strong>32位寄存器</strong>。<ul><li>通用寄存器用于<strong>算术运算和数据传输</strong>。32位寄存器用于保护模式，为了兼容16位的实模式，每一个32位寄存器又<strong>可以拆分成16位寄存器和8位寄存器</strong>来访问。</li></ul></li></ul></li></ul><table><thead><tr><th>0-31位</th><th>0-15位</th><th>8-15位</th><th>0-7位</th></tr></thead><tbody><tr><td>eax</td><td>ax</td><td>ah</td><td>al</td></tr><tr><td>ebx</td><td>bx</td><td>bh</td><td>bl</td></tr><tr><td>ecx</td><td>cx</td><td>ch</td><td>cl</td></tr><tr><td>edx</td><td>dx</td><td>dh</td><td>dl</td></tr></tbody></table><p>esi，edi，ebp和esp并无8位的寄存器访问方式</p><table><thead><tr><th>0-31位</th><th>0-15位</th></tr></thead><tbody><tr><td>esi</td><td>si</td></tr><tr><td>edi</td><td>di</td></tr><tr><td>esp</td><td>sp</td></tr><tr><td>ebp</td><td>bp</td></tr></tbody></table><h4 id="通用寄存器的特殊用法："><a href="#通用寄存器的特殊用法：" class="headerlink" title="通用寄存器的特殊用法："></a>通用寄存器的特殊用法：</h4><ul><li><strong>eax</strong>在<strong>乘法和除法</strong>指令中被自动使用，通常称之为<strong>扩展累加寄存器</strong>。</li></ul><ul><li><p>ecx在loop指令中默认为循环计数器。</p></li><li><p>esp用于<strong>堆栈寻址</strong>。因此，我们绝对不可以随意使用esp。</p></li><li><p>esi和edi通常用于<strong>内存数据的高速传送</strong>，通常称之为扩展源指针和扩展目的指针寄存器。</p></li><li><p>ebp通常出现在高级语言翻译成的汇编代码中，用来引用函数参数和局部变量。除非用于高级语言的设计技巧中，ebp不应该在算术运算和数据传送中使用。ebp一般称之为扩展帧指针寄存器。</p></li><li><p><strong>段寄存器</strong>。段寄存器有cs, ss, ds, es, fs, gs，用于存放<strong>段的基地址</strong>，段实际上就是一块连续的内存区域。</p></li><li><p><strong>指令指针</strong>。<strong>eip存放下一条指令的地址</strong>。有些机器指令可以改变eip的地址，导致程序向新的地址进行转移，如ret指令。</p></li><li><p><strong>状态寄存器</strong>。eflags存放CPU的一些状态标志位。下面提到的标志如进位标志实际上是eflags的某一个位。常用的标志位如下。</p><ul><li>进位标志(CF)。在无符号算术运算的结果无法容纳于目的操作数时被置1。</li><li>溢出标志(OF)。在有符号算术运算的结果无法容纳于目的操作数时被置1。</li><li>符号标志(SF)。在算术或逻辑运算产生的结果为负时被置1。</li><li>零标志(ZF)。在算术或逻辑运算产生的结果为0时被置1。</li></ul></li></ul><h3 id="实地址模式"><a href="#实地址模式" class="headerlink" title="实地址模式"></a>实地址模式</h3><ul><li>如上述所说，实地址模式的寄存器都是16位的，因此名称都不带e</li><li>实地址的地址线是20位的，但寄存器都是16位的–采用“<strong>段地址+偏移地址</strong>”</li></ul><p>$$<br>物理地址&#x3D;(段地址&lt;&lt;4)+偏移地址<br>$$</p><p>段寄存器也有约定俗成的规则。一个典型的程序有3个段，数据段、代码段和堆栈段。</p><ul><li>cs包含16位代码段的基地址。</li><li>ds包含16位数据段的基地址。</li><li>ss包含一个16位堆栈段的基地址。</li><li>es、fs和gs可以指向其他数据段的基地址。</li></ul><p>由于段地址必须通过段寄存器给出，因此下面直接用“段寄存器”来代替“段地址”，即物理地址可表示为“段寄存器:偏移地址”。</p><h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><ul><li>汇编代码一般保存在以 <code>.s</code> 或 <code>.asm</code> 为后缀的文件中。（我们可以在终端采用特定命令将高级语言代码转换为汇编代码）</li></ul><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>ax</td><td>累加寄存器</td></tr><tr><td>cx</td><td>计数寄存器</td></tr><tr><td>dx</td><td>数据寄存器</td></tr><tr><td>ds</td><td>数据段寄存器</td></tr><tr><td>es</td><td>附加段寄存器</td></tr><tr><td>bx</td><td><strong>基地址</strong>寄存器</td></tr><tr><td>si</td><td>源变址寄存器</td></tr><tr><td>di</td><td>目的变址寄存器</td></tr><tr><td>cs</td><td>代码段寄存器</td></tr><tr><td>ip</td><td>指令指针寄存器</td></tr><tr><td>ss</td><td>栈段寄存器</td></tr><tr><td>sp</td><td>栈指针寄存器</td></tr><tr><td>bp</td><td>基指针寄存器</td></tr><tr><td>flags</td><td>标志寄存器</td></tr></tbody></table><ul><li>汇编注释：在汇编代码中使用<strong>分号</strong> <code>;</code>来注释</li><li>在汇编代码中，<strong>一行只能写一条汇编语句</strong>而<strong>无需以任何符号结尾</strong><ul><li>例子：<code>add eax,3 ;这是注释</code></li></ul></li></ul><h4 id="nasm汇编–标识符"><a href="#nasm汇编–标识符" class="headerlink" title="nasm汇编–标识符"></a>nasm汇编–标识符</h4><ul><li>标识符用来表示变量、常量、过程或代码标号<ul><li>标识符包含1-247个字符</li><li>对大小写不敏感！</li><li>标识符第一个字符必须是字母、下划线或@；不可以是数字</li><li>标识符不能与汇编器的保留字相同。</li></ul></li></ul><h4 id="nasm汇编–标号"><a href="#nasm汇编–标号" class="headerlink" title="nasm汇编–标号"></a>nasm汇编–标号</h4><ul><li>标号是<strong>充当指令或数据位置标记</strong>的标识符；标号的值就是其后指令或数据的<strong>起始地址</strong>（偏移地址）</li><li><strong>数据标号</strong>标识了<strong>变量的地址</strong>，为在代码中引用该变量提供了方便。</li></ul><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>db</td><td>一个字节</td></tr><tr><td>dw</td><td>一个字，2个字节</td></tr><tr><td>dd</td><td>双字，4个字节</td></tr></tbody></table><p>例子：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">array dw 1024, 2048<br>      dw 4096, 8192<br>  <span class="hljs-built_in"></span><br><span class="hljs-built_in">array </span>dw 1024, 2048, 4096, 8192 ;和上面是同样的<br></code></pre></td></tr></table></figure><p>对应了：</p><p>array[0] &#x3D; 1024<br>array[1] &#x3D; 2048<br>array[2] &#x3D; 4096<br>array[3] &#x3D; 8192</p><ul><li>代码标号：代码标号标识了<strong>汇编指令的起始地址</strong>，通常作为<strong>跳转指令的操作数</strong>。</li><li>代码标号后面必须要有冒号 <code>:</code> ；但数据标号后面没有</li></ul><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>&lt;reg&gt;</code></td><td>寄存器，如ax，bx等</td></tr><tr><td><code>&lt;mem&gt;</code></td><td>内存地址，如标号var1，var2等</td></tr><tr><td><code>&lt;con&gt;</code></td><td>立即数，如3，9等</td></tr></tbody></table><ul><li><code>mov</code>指令：将<strong>源操作数</strong>的内容复制到<strong>目的操作数</strong>中</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;<span class="hljs-keyword">reg</span>&gt;<br><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;<span class="hljs-keyword">reg</span>&gt;<br><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;mem&gt;<br><span class="hljs-keyword">mov</span> &lt;mem&gt;, &lt;<span class="hljs-keyword">reg</span>&gt;<br><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;con&gt;<br><span class="hljs-keyword">mov</span> &lt;mem&gt;, &lt;con&gt;<br></code></pre></td></tr></table></figure><p>Intel汇编中，前者是目的操作数，后者是源操作数</p><h4 id="nasm汇编–内存寻址方法"><a href="#nasm汇编–内存寻址方法" class="headerlink" title="nasm汇编–内存寻址方法"></a>nasm汇编–内存寻址方法</h4><ul><li><p>寄存器寻址：<code>mov ax,cx</code></p></li><li><p>立即数寻址：<code>mov ax,7</code> or <code>mov ax,tag</code> (tag表示的是标号)</p></li><li><p>直接寻址：<code>mov ax, [0x5c00] ; ax = 0xFF</code></p><ul><li><p><strong>在根据偏移地址去取内存中的变量时，要加上 <code>[]</code>，否则就只是将变量地址放到寄存器中</strong></p><p><code>mov ax, [tag] ; ax = 0xFF</code></p></li><li><p>我们指令中如果没有显式指定段地址，那么我们的地址就是偏移地址</p></li><li><p>访问数据段，使用段寄存器ds。</p></li><li><p>访问代码段，使用段寄存器cs。</p></li></ul><ul><li>访问栈段，使用段寄存器ss。</li></ul></li><li><p>基址寻址：基址寻址使用<strong>基址寄存器和立即数</strong>来构成真实的偏移地址</p><ul><li>基址寄存器只能是bx或bp；用bx做基址寄存器时，段地址寄存器默认为ds，使用bp时默认为ss</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 使用bx做基址寄存器时段寄存器为ds存放的内容</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>]<br><span class="hljs-comment">; 使用bp做基址寄存器时段寄存器为ss存放的内容</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bp</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><ul><li><p>变址寻址：变址寻址使用<strong>变址寄存器和立即数</strong>来构成真实的偏移地址。</p><ul><li><p>变址寄存器只能是 <code>si</code>或 <code>di</code>，默认段寄存器为 <code>ds</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">si</span> + <span class="hljs-number">4</span> * <span class="hljs-number">4</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">di</span>], <span class="hljs-number">0x5</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>基址变址寻址:我们通过基址寄存器、变址寄存器、立即数来构成真实的偏移地址。默认段地址由基址寄存器的类型确定，即 <code>bx</code>对应 <code>ds</code>、<code>bp</code>对应 <code>ss</code>，如下所示。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-built_in">si</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-built_in">di</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span> + <span class="hljs-built_in">si</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-built_in">si</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-built_in">di</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure></li></ul><h4 id="x86汇编–算数和逻辑指令"><a href="#x86汇编–算数和逻辑指令" class="headerlink" title="x86汇编–算数和逻辑指令"></a>x86汇编–算数和逻辑指令</h4><ol><li><p><strong>add</strong>指令：前面是目的操作数，所以const不可以在前面。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">add</span> &lt;reg&gt;, &lt;reg&gt;<br><span class="hljs-built_in">add</span> &lt;reg&gt;, &lt;mem&gt;<br><span class="hljs-built_in">add</span> &lt;mem&gt;, &lt;reg&gt;<br><span class="hljs-built_in">add</span> &lt;reg&gt;, &lt;con&gt;<br><span class="hljs-built_in">add</span> &lt;mem&gt;, &lt;con&gt;<br>; e.g.<br><span class="hljs-built_in">add</span> ax, 10 ; eax := eax + 10<br><span class="hljs-built_in">add</span> byte[tag], al<br></code></pre></td></tr></table></figure></li><li><p><strong>sub</strong>指令：类似于add</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> &lt;<span class="hljs-title">reg</span>&gt;, &lt;<span class="hljs-title">reg</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">reg</span>&gt;, &lt;<span class="hljs-title">mem</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">mem</span>&gt;, &lt;<span class="hljs-title">reg</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">reg</span>&gt;, &lt;<span class="hljs-title">con</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">mem</span>&gt;, &lt;<span class="hljs-title">con</span>&gt;</span><br><span class="hljs-function"></span>; e.g.<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">al</span>, <span class="hljs-title">ah</span> </span>; al := al - ah<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">ax</span>, 126</span><br></code></pre></td></tr></table></figure></li><li><p><strong>imul</strong>是整数相乘指令，它有<strong>两种指令格式</strong>，一种为两个操作数，将两个操作数的值相乘，并将结果保存在第一个操作数中，<strong>第一个操作数必须为寄存器</strong>；第二种格式为三个操作数，其语义为：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，<strong>第一个操作数必须为寄存器</strong>。</p></li></ol><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br>imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br>imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br>imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br>; e.g.<br>imul eax, [var] ; <span class="hljs-attr">eax</span> <span class="hljs-operator">=</span> eax <span class="hljs-operator">*</span> [var]<br>imul esi, edi, <span class="hljs-number">25</span> ; <span class="hljs-attr">esi</span> <span class="hljs-operator">=</span> edi <span class="hljs-operator">*</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>idiv完成整数除法操作，idiv<strong>只有一个操作数</strong>，此操作数为除数，而<strong>被除数</strong>则为 <code>edx:eax</code>中的内容（一个64位的整数），操作的结果有两部分：商和余数，其中<strong>商</strong>放在<strong>eax寄存器</strong>中，而<strong>余数</strong>则放在<strong>edx寄存器</strong>中</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">idiv</span> &lt;reg&gt; <span class="hljs-comment">;这里给出的是除数</span><br><span class="hljs-keyword">idiv</span> &lt;mem&gt;<br><span class="hljs-comment">; e.g.</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">dword</span>[var]<br></code></pre></td></tr></table></figure></li><li><p>inc，dec指令分别表示自增1或自减1</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">inc</span> &lt;reg&gt;<br><span class="hljs-keyword">inc</span> &lt;mem&gt;<br><span class="hljs-keyword">dec</span> &lt;reg&gt;<br><span class="hljs-keyword">dec</span> &lt;mem&gt;<br><span class="hljs-comment">; e.g.</span><br><span class="hljs-keyword">dec</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span>[tag]<br></code></pre></td></tr></table></figure></li><li><p>and, or, xor分别表示将两个操作数逻辑与、逻辑或和逻辑异或后放入到第一个操作数中</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>not表示对操作数每一位取反</p></li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">not &lt;reg&gt;<br>not &lt;mem&gt;<br><span class="hljs-comment">; e.g.</span><br>not ax<br>not word[tag] <span class="hljs-comment">; 取反一个字,2个字节</span><br>not <span class="hljs-keyword">byte[tag] </span><span class="hljs-comment">; 取反一个字节</span><br>not dword[tag] <span class="hljs-comment">; 取反一个双字，4个字节</span><br></code></pre></td></tr></table></figure><ol start="8"><li>neg表示取负</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">neg <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span><br>neg <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="9"><li>shl,shr表示逻辑左移和逻辑右移</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">; cl是寄存器ecx的低8位寄存器<br><br>shl <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shl <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shl <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, cl<br>shl <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, cl<br><br>shr <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shr <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shr <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, cl<br>shr <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, cl<br></code></pre></td></tr></table></figure><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul><li><p>jmp无条件跳转–<code>jmp &lt;label&gt;</code></p></li><li><p>jcondition有条件跳转</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">je &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when equal</span><br>jne &lt;<span class="hljs-type">label</span>&gt;  <span class="hljs-comment">; jump when not equal</span><br>jz &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when last result was zero</span><br>jg &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when greater than</span><br>jge &lt;<span class="hljs-type">label</span>&gt;  <span class="hljs-comment">; jump when greater than or equal to</span><br>jl &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when less than</span><br>jle &lt;<span class="hljs-type">label</span>&gt;  <span class="hljs-comment">; jump when less than or equal to</span><br></code></pre></td></tr></table></figure></li><li><p>cmp指令：操作数1-操作数2，结果与机器状态寄存器eflags中的条件码比较</p></li></ul><h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><ul><li>栈的增长方式是从高地址向低地址增长</li><li>push指令：将操作数压入内存的栈中；可以对reg，mem，con做</li><li>pop指令：将栈顶的数据放入到操作数中；reg，mem</li><li>pushad指令是将ax, cx, dx, bx, sp, bp, si, di 依次压入栈中。</li><li><code>popad</code>指令是对栈指令一系列的pop操作，pop出的数据放入到di, si, bp, sp, bx, dx, cx, ax中。</li></ul><h4 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h4><p>call和ret指令是用来实现子过程(或者称函数，过程，意思相同)调用和返回。call指令首先将当前eip的内容入栈，然后将操作数的内容放入到eip中。ret指令将栈顶的内容弹出栈，放入到eip中。</p><h2 id="计算机开机启动过程"><a href="#计算机开机启动过程" class="headerlink" title="计算机开机启动过程"></a>计算机开机启动过程</h2><ul><li>计算机的启动需要程序加载，而计算机不启动则无法运行程序。</li><li>加电开机–BIOS启动–加载MBR–硬盘启动–内核启动</li></ul><h2 id="Example1：Hello-World"><a href="#Example1：Hello-World" class="headerlink" title="Example1：Hello World"></a>Example1：Hello World</h2><ul><li>task：在MBR被加载到内存地址0x7c00之后，向屏幕输出蓝色的Hello World</li><li>为了便于控制显示，IA-32处理器将显示矩阵映射到了内存<strong>0xB8000~0xBFFFF</strong>处，称为显存地址。</li><li>在文本模式下，控制器的<strong>最小可控制单位为字符</strong>，每一个显示字符自上向下，从左到右依次使用显存地址中的<strong>两个字节</strong>表示–低字节表示所要<strong>显示的字符</strong>，高字节表示字符的<strong>颜色属性</strong>。</li></ul><p><img src="/img/%E6%98%BE%E5%AD%98%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="显存对应关系"></p><p>字符的颜色属性的字节高四位为背景色，低四位为前景色，具体如下：</p><p><img src="/img/%E5%AD%97%E7%AC%A6%E5%B1%9E%E6%80%A7%E5%AF%B9%E5%BA%94%E8%A1%A8.png" alt="字符属性对应表"></p><ul><li><p>我们使用的是二维的点，但是在栈上是线性的 &#x3D;》转换为一维的点</p><p>$$<br>\text{显存起始位置}&#x3D;\text{0xB8000}+2\cdot(80\cdot x+y)<br>$$</p><p>(x,y)&#x3D;(row,col)，公式中的乘2是因为每个显示字符会使用两个字节表示</p></li></ul><p>编写MBR：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">org <span class="hljs-number">0x7c00</span> <span class="hljs-comment">; MBR被加载到内存地址0x7c00</span><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>] <span class="hljs-comment">; 指定代码在16位实模式下运行</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span> <span class="hljs-comment">; eax = 0 相当于mov ax,0，但是前者机器码更短，执行更快</span><br><span class="hljs-comment">; 初始化段寄存器, 段地址全部设为0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">fs</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">; 初始化栈指针</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span> <span class="hljs-comment">;0xb800是显存的段地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">;ah高位，al低位</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x01</span> <span class="hljs-comment">;蓝色--背景色是黑色，字是蓝色--0000 0001=0x01</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;H&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">0</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;e&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">1</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">2</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">3</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27; &#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">5</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;W&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">6</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">7</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;r&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">8</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">9</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;d&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">10</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">; 死循环</span><br><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span> - ($ - $$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>, <span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p><code>org</code>是汇编语言中的<strong>伪指令</strong>，用于指令程序 <code>&lt;u&gt;</code>加载到内存中的起始地址 <code>&lt;/u&gt;</code></p><p><code>0x7c00</code> 是 BIOS 将引导扇区加载到内存中的固定地址。BIOS 在启动时会自动<strong>将磁盘的第一个扇区（512字节）加载到内存地址 <code>0x7c00</code> 处</strong>，然后从这里开始执行。</p><p>6个<strong>段寄存器cs, ss, ds, es, fs, gs</strong></p><p>由于汇编不允许使用立即数直接对段寄存器赋值，所以要借助ax，在第三行给ax赋值为0之后，再让ax给段寄存器赋值</p><p><code>$</code>表示当前汇编地址，<code>$$</code>表示代码开始的汇编地址。<code>times 510 - ($ - $$) db 0</code>表示填充字符0直到第510个字节</p><ul><li><p>利用nasm汇编器来将代码编译成二进制文件：</p><p><code>nasm -f bin mbr.asm -o mbr.bin</code></p><ul><li><code>-f</code>参数制定了输出文件格式</li><li><code>-o</code>指定的是输出的文件名</li></ul><p><img src="/img/image-20250305172419639.png" alt="image-20250305172419639"></p></li><li><p>生成MBR后，将其写入到硬盘的首扇区。</p><ul><li><p>创建一个虚拟磁盘– <code>qemu-img create filename [size]</code></p><ul><li>qemu-img create hd.img 10m</li></ul></li><li><p>将MBR写入 <code>hd.img</code>的首扇区–使用 <code>dd</code>命令<br><code>dd if=mbr.bin of=hd.img bs=512 count=1 seek=0 conv=notrunc</code></p><ul><li><code>if</code>表示输入文件。</li><li><code>of</code>表示输出文件。</li><li><code>bs</code>表示块大小，以字节表示。</li><li><code>count</code>表示写入的块数目。</li><li><code>seek</code>表示越过输出文件中多少块之后再写入。</li><li><code>conv=notrunc</code>表示不截断输出文件，如果不加上这个参数，那么硬盘在写入后多余部份会被截断。</li></ul></li><li><p>启动qemu来模拟计算机启动：</p><p><code>qemu-system-i386 -hda hd.img -serial null -parallel stdio</code></p><ul><li><code>-hda hd.img</code>表示将文件 <code>hd.img</code>作为<strong>第0号磁盘映像</strong>。</li><li><code>-serial dev</code>表示重定向虚拟串口到空设备中。</li><li><code>-parallel stdio </code>表示重定向虚拟并口到主机标准输入输出设备中。</li><li><a href="https://c.biancheng.net/view/8123.html">GDB是什么？ - C语言中文网</a> 更多参数详见文档</li></ul></li></ul></li></ul><p><img src="/img/9cbfaf1fe8a7437aae3bc3d5cfd9aa9.png" alt="9cbfaf1fe8a7437aae3bc3d5cfd9aa9"></p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>使用gdb来配合qemu来进行debug，需要在qemu的启动命令中加入 <code>-s -S</code>参数，举例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">qemu-<span class="hljs-keyword">system</span>-i386 -hda hd.img -s -S -parallel stdio -<span class="hljs-type">serial</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>在另一个终端进入gdb，让gdb连接上qemu：<code>target remote:1234</code></p><p><a href="https://c.biancheng.net/view/8123.html">GDB是什么？ - C语言中文网</a></p><p>本次实验会用到的指令：</p><table><thead><tr><th>gdb指令</th><th>含义</th></tr></thead><tbody><tr><td>b *address</td><td>在内存地址address中设置断点</td></tr><tr><td>r</td><td>运行程序</td></tr><tr><td>c</td><td>继续运行</td></tr><tr><td>p *addr</td><td>打印地址的值</td></tr><tr><td>info registers</td><td>查看寄存器</td></tr><tr><td>x&#x2F;10i $pc</td><td>显示从程序计数器的地址开始的10条汇编指令</td></tr><tr><td>set disassembly-flavor intel</td><td>设置gdb反汇编的语法为intel风格</td></tr></tbody></table><h2 id="任务1-MBR"><a href="#任务1-MBR" class="headerlink" title="任务1 MBR"></a>任务1 MBR</h2><h3 id="1-1-复现example1"><a href="#1-1-复现example1" class="headerlink" title="1.1 复现example1"></a>1.1 复现example1</h3><p>done！<img src="/img/9cbfaf1fe8a7437aae3bc3d5cfd9aa9.png" alt="9cbfaf1fe8a7437aae3bc3d5cfd9aa9"></p><h3 id="1-2-修改example1的代码"><a href="#1-2-修改example1的代码" class="headerlink" title="1.2 修改example1的代码"></a>1.2 修改example1的代码</h3><p>修改Example 1的代码，使得MBR被加载到0x7C00后在(12,12)处开始输出你的学号。注意，你的学号显示的前景色和背景色必须和教程中不同。说说你是怎么做的，并将结果截图。</p><p>编译汇编文件：<code>nasm -f bin mbr.asm -o mbr2.bin</code></p><p>创建虚拟磁盘：<code> qemu-img create hd.img 10m</code></p><p>将MBR写入hd.img的首扇区： <code>dd if=mbr2.bin of=hd.img bs=512 count=1 seek=0 conv=notrunc</code></p><p>启动qemu：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">qemu-<span class="hljs-keyword">system</span>-i386 -hda hd.img -<span class="hljs-type">serial</span> <span class="hljs-keyword">null</span> -parallel stdio<br></code></pre></td></tr></table></figure><p>结果：<img src="/img/image-20250305180510397.png" alt="image-20250305180510397"></p><h2 id="任务2-实模式中断"><a href="#任务2-实模式中断" class="headerlink" title="任务2 实模式中断"></a>任务2 实模式中断</h2><h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p><a href="https://blog.csdn.net/kakitgogogo/article/details/52804340">INT10H中断服务详解-CSDN博客</a></p><table><thead><tr><th>AH</th><th>功 能</th><th>调用参数</th><th>返回参数 &#x2F; 注释</th></tr></thead><tbody><tr><td>1</td><td>置光标类型</td><td>（CH）0―3 &#x3D; 光标开始行 　　（CL）0―3 &#x3D; 光标结束行</td><td></td></tr><tr><td>2</td><td>置光标位置</td><td>BH &#x3D; 页号 　　DH &#x3D; 行 　　DL &#x3D; 列</td><td></td></tr><tr><td>3</td><td>读光标位置</td><td>BH &#x3D; 页号</td><td>CH &#x3D; 光标开始行 　CL &#x3D; 光标结束行 　DH &#x3D; 行 　DL &#x3D; 列</td></tr><tr><td>4</td><td>读光笔位置</td><td></td><td>AH&#x3D;0 光笔未触发 &#x3D;1 光笔触发 CH&#x3D;象素行 BX&#x3D;象素列 DH&#x3D;字符行 DL&#x3D;字符列</td></tr><tr><td>5</td><td>显示页</td><td>AL &#x3D; 显示页号</td><td></td></tr><tr><td>6</td><td>屏幕初始化或上卷</td><td>AL &#x3D; 上卷行数 　　AL &#x3D;0全屏幕为空白 　　BH &#x3D; 卷入行属性 　　CH &#x3D; 左上角行号 　　CL &#x3D; 左上角列号 　　DH &#x3D; 右下角行号 　　DL &#x3D; 右下角列号</td><td></td></tr><tr><td>7</td><td>屏幕初始化或下卷</td><td>AL &#x3D; 下卷行数 　　AL &#x3D; 0全屏幕为空白 　　BH &#x3D; 卷入行属性 　　CH &#x3D; 左上角行号 　　CL &#x3D; 左上角列号 　　DH &#x3D; 右下角行号 　　DL &#x3D; 右下角列号</td><td></td></tr><tr><td>8</td><td>读光标位置的属性和字符</td><td>BH &#x3D; 显示页</td><td>AH &#x3D; 属性 　AL &#x3D; 字符</td></tr><tr><td>9</td><td>在光标位置显示字符及其属性</td><td>BH &#x3D; 显示页 　　AL &#x3D; 字符 　　BL &#x3D; 属性 　　CX &#x3D; 字符重复次数</td><td></td></tr><tr><td>A</td><td>在光标位置只显示字符</td><td>BH &#x3D; 显示页 　　AL &#x3D; 字符 　　CX &#x3D; 字符重复次数</td><td></td></tr><tr><td>E</td><td>显示字符(光标前移)</td><td>AL &#x3D; 字符 　　BL &#x3D; 前景色</td><td>光标跟随字符移动</td></tr><tr><td>13</td><td>显示字符串</td><td>ES:BP &#x3D; 串地址 　　CX &#x3D; 串长度 　　DH， DL &#x3D; 起始行列 　　BH &#x3D; 页号 　　AL &#x3D; 0，BL &#x3D; 属性 　　串：Char，char，……，char 　　AL &#x3D; 1，BL &#x3D; 属性 　　串：Char，char，……，char 　　AL &#x3D; 2 　　串：Char，attr，……，char，attr 　　AL &#x3D; 3 　　串：Char，attr，……，char，attr</td><td>光标返回起始位置  　光标跟随移动   　光标返回起始位置   　光标跟随串移动</td></tr></tbody></table><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>应用举例：<a href="https://www.cnblogs.com/b1ing/p/13044913.html">汇编语言——一些中断的调用 - b1ing丶 - 博客园</a></p><p>本任务会用到的：</p><table><thead><tr><th>功能</th><th>功能号</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>设置光标位置</td><td>AH&#x3D;02H</td><td>BH&#x3D;页码，DH&#x3D;行，DL&#x3D;列</td><td>无</td></tr><tr><td>获取光标位置和形状</td><td>AH&#x3D;03H</td><td>BX&#x3D;页码</td><td>AX&#x3D;0，CH&#x3D;行扫描开始，CL&#x3D;行扫描结束，DH&#x3D;行，DL&#x3D;列</td></tr><tr><td>在当前光标位置写字符和属性</td><td>AH&#x3D;09H</td><td>AL&#x3D;字符，BH&#x3D;页码，BL&#x3D;颜色，CX&#x3D;输出字符的个数</td><td>无</td></tr></tbody></table><p>中断的调用方式：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">将参数和功能号写入寄存器<br><span class="hljs-built_in">int</span> 中断号<br>从寄存器中取出返回值<br></code></pre></td></tr></table></figure><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>请探索实模式下的光标中断<code>int 10h</code>，<strong>实现将光标移动至(8,8)，获取并输出光标的位置</strong>。说说你是怎么做的，并将结果截图。</p><p>做法：</p><ul><li><p>利用任务1中打印到输出端的方法，先将段寄存器初始化为0，以及栈顶指向显示矩阵的首地址。</p></li><li><p>设置光标的位置：ah&#x3D;2</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">2</span>    <span class="hljs-comment">;设置光标位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;page set to be  0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>    <span class="hljs-comment">;row</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">8</span>    <span class="hljs-comment">;col</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br></code></pre></td></tr></table></figure></li><li><p>获取光标的位置：ah&#x3D;3</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">3</span>    <span class="hljs-comment">;获取光标位置和形状</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br></code></pre></td></tr></table></figure></li><li><p>再将坐标字符送到显示矩阵中存储：要注意这里的需要将二进制转换为ASCII字符</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;(&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">8</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">dh</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-comment">;将二进制转换为ASCII字符</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">9</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;,&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">10</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">dl</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;0&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">11</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;)&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">12</span>)],<span class="hljs-built_in">ax</span><br></code></pre></td></tr></table></figure></li><li><p>ending</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">jmp</span> $<br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure></li></ul><p>结果：</p><p><img src="/img/image-20250309145148543.png" alt="2"></p><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><p>利用实模式下的中断，<strong>从(8,8)开始输出你的学号</strong>。说说你是怎么做的，并将结果截图。</p><ul><li><p>光标移动到(8,8)，复用2.1任务中的指令</p></li><li><p>在光标位置输出学号，需要利用光标位置来计算显存矩阵位置的偏移量，然后循环打印学号即可，过程中要记得将地址<code>+2</code></p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;计算偏移量--输出移动到光标处--2*(80*x+y)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">80</span><br><span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">dl</span><br><span class="hljs-keyword">adc</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">shl</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">;把学号存储在寄存器中</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,student_id<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span> <span class="hljs-comment">;长度</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x0A</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">print_loop:</span><br>    <span class="hljs-keyword">lodsb</span>   <span class="hljs-comment">;从si加载字符到al</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x0A</span> <br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">di</span>],<span class="hljs-built_in">ax</span> <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span>    <span class="hljs-comment">;累加，往后输出</span><br>    <span class="hljs-keyword">loop</span> print_loop<br><br><span class="hljs-keyword">jmp</span> $ <br>student_id <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;23336139&#x27;</span><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p>光标移动到(8,8)，并从此开始输出我的学号。</p><ul><li>结果：</li></ul><p><img src="/img/image-20250306104000712.png" alt="image-20250306104000712"></p><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><p>参考《汇编语言》第17章、<a href="https://gitee.com/link?target=https://blog.csdn.net/deniece1/article/details/103447413">键盘I&#x2F;O中断调用</a>。关于键盘扫描码，可以参考<a href="https://gitee.com/link?target=http://blog.sina.com.cn/s/blog_1511e79950102x2b0.html">键盘扫描码表</a>。</p><p>在2.1和2.2的知识的基础上，探索实模式下的键盘中断<code>int 16h</code>，<strong>利用键盘中断，实现任意 键盘输入并回显 的效果</strong>。说说你是怎么做的，并将结果截图。</p><p>INT 16H（键盘I&#x2F;O中断）<br>　 AH&#x3D;0：从键盘读入ASCII字符，放在AL中。<br>　 AH&#x3D;1：测试有无键被按下。ZF&#x3D;0，表示按过任意键，并在AL中获得该键的ASCII码。ZF&#x3D;1，未按过键。<br>　 AH&#x3D;2：读取特殊功能键的状态至AL中。</p><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>Ins</td><td>CapsLock</td><td>NumLock</td><td>ScrollLock</td><td>Alt</td><td>Ctrl</td><td>左Shift</td><td>右Shift</td></tr></tbody></table><p>过程：</p><ul><li><p>为了在显存输出，也是类似地进行初始化。</p></li><li><p>会使用到int 16h </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">org <span class="hljs-number">0x7c00</span>      <br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>]       <br><br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 清零 ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 初始化段寄存器</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span>  <span class="hljs-comment">; 设置栈指针</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span>  <span class="hljs-comment">; 设置显存段地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x00</span>    <span class="hljs-comment">; 从键盘读取一个字符</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">0x16</span>        <span class="hljs-comment">; AL = ASCII 字符，AH = 扫描码</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0xF2</span>    <span class="hljs-comment">; 设置字符属性--颜色</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0</span>], <span class="hljs-built_in">ax</span>  <span class="hljs-comment">; 将字符和属性写入显存</span><br><br><span class="hljs-keyword">jmp</span> $           <span class="hljs-comment">; 无限循环</span><br><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>  <span class="hljs-comment">; 填充剩余空间</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>, <span class="hljs-number">0xaa</span>          <span class="hljs-comment">; 引导扇区结束标志</span><br></code></pre></td></tr></table></figure></li></ul><p>结果：</p><p><img src="/img/image-20250306114833724.png" alt="image-20250306114833724"></p><p><img src="/img/image-20250306114913976.png" alt="image-20250306114913976"></p><h2 id="任务3-汇编"><a href="#任务3-汇编" class="headerlink" title="任务3 汇编"></a>任务3 汇编</h2><p>要求：</p><ul><li>任务3使用的是32位寄存器</li><li><code>a1</code>、<code>if_flag</code>、<code>my_random</code>等都是预先定义好的变量和函数，直接使用即可。</li><li>需要补全的代码文件在 <code>assignment/student.asm</code>中。</li><li>代码编写好之后使用 <code>make run</code> 来测试代码</li><li>你可以修改 <code>test.cpp</code>中的 <code>student_setting</code>中的语句来得到你想要的 <code>a1,a2</code>。</li><li>最后附上结果截图</li></ul><h3 id="3-1-分支逻辑的实现"><a href="#3-1-分支逻辑的实现" class="headerlink" title="3.1 分支逻辑的实现"></a>3.1 分支逻辑的实现</h3><p>请将下列伪代码转换成汇编代码，并放置在标号 <code>your_if</code>之后。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> a1 &lt; <span class="hljs-number">12</span> then<br><span class="hljs-attribute">if_flag</span> = a1 / <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br><span class="hljs-attribute">else</span> if a1 &lt; <span class="hljs-number">24</span> then<br><span class="hljs-attribute">if_flag</span> = (<span class="hljs-number">24</span> - a1) * a1<br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">if_flag</span> = a1 &lt;&lt; <span class="hljs-number">4</span><br><span class="hljs-attribute">end</span><br></code></pre></td></tr></table></figure><p>条件分支</p><ul><li>利用跳转指令、跳跃指令、条件跳转指令</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">jmp</span> label<br></code></pre></td></tr></table></figure><ul><li>条件跳转指令：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">cmp <span class="hljs-tag">&lt;<span class="hljs-name">源操作数</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">目标操作数</span>&gt;</span><br>jcc <span class="hljs-tag">&lt;<span class="hljs-name">目标地址</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>用于算术运算：</li></ul><table><thead><tr><th align="center">指令</th><th align="center">描述</th><th align="center">标志测试</th></tr></thead><tbody><tr><td align="center">JE&#x2F;JZ</td><td align="center">跳转等于或跳转零</td><td align="center">ZF</td></tr><tr><td align="center">JNE&#x2F;JNZ</td><td align="center">跳转不等于或跳转不为零</td><td align="center">ZF</td></tr><tr><td align="center">JG&#x2F;JNLE</td><td align="center">跳转大于或跳转不小于&#x2F;等于</td><td align="center">OF, SF, ZF</td></tr><tr><td align="center">JGE&#x2F;JNL</td><td align="center">跳转大于&#x2F;等于或不小于跳转</td><td align="center">OF, SF</td></tr><tr><td align="center">JL&#x2F;JNGE</td><td align="center">跳转小于或不大于&#x2F;等于</td><td align="center">OF, SF</td></tr><tr><td align="center">JLE&#x2F;JNG</td><td align="center">跳少&#x2F;等于或跳不大于</td><td align="center">OF, SF, ZF</td></tr></tbody></table><ul><li>逻辑运算：</li></ul><table><thead><tr><th align="center">指令</th><th align="center">描述</th><th align="center">标志测试</th></tr></thead><tbody><tr><td align="center">JE&#x2F;JZ</td><td align="center">跳转等于或跳转零</td><td align="center">ZF</td></tr><tr><td align="center">JNE&#x2F;JNZ</td><td align="center">跳转不等于或跳转不为零</td><td align="center">ZF</td></tr><tr><td align="center">JA&#x2F;JNBE</td><td align="center">跳转向上或不低于&#x2F;等于</td><td align="center">CF, ZF</td></tr><tr><td align="center">JAE&#x2F;JNB</td><td align="center">高于&#x2F;等于或不低于</td><td align="center">CF</td></tr><tr><td align="center">JB&#x2F;JNAE</td><td align="center">跳到以下或跳到不高于&#x2F;等于</td><td align="center">CF</td></tr><tr><td align="center">JBE&#x2F;JNA</td><td align="center">跳到下面&#x2F;等于或不跳到上方</td><td align="center">AF, CF</td></tr></tbody></table><p>结果代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">your_if:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,[a1] <span class="hljs-comment">;提取值</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">12</span><br><span class="hljs-symbol">    jl label</span>1<br><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">24</span><br><span class="hljs-symbol">    jl label</span>2<br><span class="hljs-symbol">    jmp label</span>3<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label1:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> [if_flag],<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">jmp</span> if_done<br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label2:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">24</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">imul</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">mov</span> [if_flag],<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">jmp</span> if_done<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label3:</span><br>    <span class="hljs-keyword">shl</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">4</span><br>    <span class="hljs-keyword">mov</span> [if_flag],<span class="hljs-built_in">eax</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">if_done:</span><br><br></code></pre></td></tr></table></figure><p>只要搞清楚如何分析分支跳转就可以了！</p><p>div: 只有一个操作数，计算后<strong>商</strong>放在<strong>eax寄存器</strong>中，而<strong>余数</strong>则放在<strong>edx寄存器</strong>中</p><h3 id="3-2-循环逻辑的实现"><a href="#3-2-循环逻辑的实现" class="headerlink" title="3.2 循环逻辑的实现"></a>3.2 循环逻辑的实现</h3><p>请将下列伪代码转换成汇编代码，并放置在标号 <code>your_while</code>之后。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">while</span> <span class="hljs-built_in">a2</span> &gt;= <span class="hljs-number">12</span> then<br>call my_random        <span class="hljs-comment">// my_random将产生一个随机数放到eax中返回</span><br>while_flag[<span class="hljs-built_in">a2</span> - <span class="hljs-number">12</span>] = eax<br>--<span class="hljs-built_in">a2</span><br><span class="hljs-symbol">end</span><br></code></pre></td></tr></table></figure><ul><li>​无条件循环指令</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">jmp <span class="hljs-tag">&lt;<span class="hljs-name">目标地址</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>条件循环指令</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">cmp <span class="hljs-variable">&lt;源操作数&gt;</span>, <span class="hljs-variable">&lt;目标操作数&gt;</span><br>jcc <span class="hljs-keyword">label</span><br></code></pre></td></tr></table></figure><p>结果：（更新）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">your_while:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [a2]   <span class="hljs-comment">; 读取 a2，这里不能用 eax 存储 [a2] 的值，调用 my_random 返回的随机数会覆盖 eax！！！</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loop:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">12</span><br>    <span class="hljs-keyword">jl</span> while_end    <span class="hljs-comment">; 若 a2 &lt; 12，则退出循环</span><br><br>    <span class="hljs-keyword">call</span> my_random  <span class="hljs-comment">; 产生随机数，存入 eax</span><br>    <span class="hljs-comment">; 计算 while_flag[a2 - 12] 的地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">12</span>      <span class="hljs-comment">; edx = a2 - 12</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, [while_flag]<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">ecx</span>     <span class="hljs-comment">; edx = while_flag + (a2 - 12)</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">edx</span>], <span class="hljs-built_in">al</span>    <span class="hljs-comment">; 将随机数存入 while_flag[a2 - 12]</span><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">mov</span> [a2], <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">jmp</span> <span class="hljs-keyword">loop</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">while_end:</span><br><br></code></pre></td></tr></table></figure><p>重点：</p><ul><li><p>不可以把a2的值读取到eax中</p></li><li><p>要记得把地址 *4 ，因为存储的是字节</p></li></ul><h3 id="3-3-函数的实现"><a href="#3-3-函数的实现" class="headerlink" title="3.3 函数的实现"></a>3.3 函数的实现</h3><p>请编写函数 <code>your_function</code>并调用之，函数的内容是遍历字符数组 <code>string</code>。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">your_function:</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; <span class="hljs-type">string</span>[i] != <span class="hljs-comment">&#x27;\0&#x27;; ++i then</span><br>pushad<br>push <span class="hljs-type">string</span>[i] <span class="hljs-keyword">to</span> stack<br><span class="hljs-keyword">call</span> print_a_char<br>pop stack<br>popad<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>结果：（更新–旧版本没意识到出错了……）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">your_function:</span><br><span class="hljs-comment">; put your implementation here</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;i设置为0</span><br><span class="hljs-symbol">loop_start:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,[your_string]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">edx</span>+<span class="hljs-built_in">ecx</span>]<br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">je</span> function_end<br><br>    <span class="hljs-keyword">pushad</span>  <span class="hljs-comment">;保存所有通用寄存器的状态</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>     <span class="hljs-comment">;将字符压入栈中</span><br>    <span class="hljs-keyword">call</span> print_a_char  <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">4</span>   <span class="hljs-comment">;弹出</span><br>    <span class="hljs-keyword">popad</span>   <span class="hljs-comment">;恢复状态</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">jmp</span> loop_start<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">function_end:</span><br>    <span class="hljs-keyword">ret</span><br><br></code></pre></td></tr></table></figure><p>重点：</p><ul><li>在 32 位汇编中，栈的操作单位是 <strong>4 字节（32 位）</strong>。无论是压栈（<code>push</code>）还是弹栈（<code>pop</code>），都是以 4 字节为单位进行的。</li><li>函数要记得返回</li></ul><p>make run结果：</p><p><img src="/img/image-20250312145851121.png"></p><h2 id="任务-4-汇编小程序（选做）"><a href="#任务-4-汇编小程序（选做）" class="headerlink" title="任务 4 汇编小程序（选做）"></a>任务 4 汇编小程序（选做）</h2><p>字符弹射程序。请编写一个字符弹射程序，其从点(2,0)处开始向<strong>右下角45度</strong>开始射出，遇到边界反弹，反弹后按45度角射出，方向视反弹位置而定。同时，你可以加入一些其他效果，如变色，双向射出等。注意，你的程序应该不超过510字节，否则无法放入MBR中被加载执行。静态示例效果如下，动态效果见视频<code>assignment/assignment-4-example.mp4</code>。</p><p>实现思路：</p><ul><li><p>设置显示字符的行、列寄存器（ch-行，cl-列），然后设置两个寄存器分别用于做<strong>水平</strong>方向和<strong>竖直</strong>方向的位移（最初设置为1,1是因为我们要从(2,0)点出发往右下方45°移动</p></li><li><p>设置一个专门进行弹跳的循环</p><ul><li>判断是否到达边界，如果到达边界需要反转对应方向的增量（其实还可以直接使用neg反转）</li><li>边界调整完后进入展示循环</li></ul></li><li><p>展示循环</p><ul><li>需要计算当前字符需要被放置到的显存矩阵的位置（这里尤其要注意，我们原本放置的寄存器是8位寄存器，但是bx是16位寄存器，需要进行0扩展）</li><li>将字符和颜色传入显存矩阵</li><li>修改字符和颜色（简单地通过+1来实现）</li><li>调用<strong>延时</strong>（由于我们把延时设置为一个标签了，这时候要保存原来的值后跳转出去需要借用到<strong>栈</strong>，在调用完之后返回再弹出栈）</li></ul></li></ul><p>实验代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">org <span class="hljs-number">0x7c00</span>      <br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>]       <br><span class="hljs-comment">;基础设置</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 清零 ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 初始化段寄存器</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span>  <span class="hljs-comment">; 设置栈指针</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span>  <span class="hljs-comment">; 设置显存段地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">;初始化字符1：(2,0)--(ch,cl)=(row,col)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>, <span class="hljs-number">2</span>       <span class="hljs-comment">; 初始行位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0</span>       <span class="hljs-comment">; 初始列位置</span><br><span class="hljs-comment">;增量，line1向右下移动（初始）</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 行方向增量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 列方向增量</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x0A</span>    <span class="hljs-comment">; 字符颜色（亮绿色）</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;0&#x27;</span>     <span class="hljs-comment">; 显示的字符</span><br><br><span class="hljs-comment">;显存矩阵大小：25*80</span><br><span class="hljs-symbol">bounce_loop:</span><br>    <span class="hljs-comment">; 检查上下边界</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-number">ch</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle</span> bounce_up   <span class="hljs-comment">; 如果行 &lt;= 0，需要向下反弹</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-number">ch</span>, <span class="hljs-number">24</span><br>    <span class="hljs-keyword">jge</span> bounce_down <span class="hljs-comment">; 如果行 &gt;= 24，需要向上反弹</span><br>    <br>    <span class="hljs-comment">; 检查左右边界</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle</span> bounce_right <span class="hljs-comment">; 如果列 &lt;= 0，需要向右反弹</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">79</span><br>    <span class="hljs-keyword">jge</span> bounce_left  <span class="hljs-comment">; 如果列 &gt;= 79，需要向左反弹</span><br>    <br>    <span class="hljs-keyword">jmp</span> display     <span class="hljs-comment">; 通过所有边界检查，显示字符</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_up:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 将行方向改为向下(正)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_down:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, -<span class="hljs-number">1</span>      <span class="hljs-comment">; 将行方向改为向上(负)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_right:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 将列方向改为向右(正)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_left:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, -<span class="hljs-number">1</span>      <span class="hljs-comment">; 将列方向改为向左(负)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">display:</span><br>    <span class="hljs-comment">; 计算显存位置</span><br>    <span class="hljs-keyword">movzx</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">ch</span>    <span class="hljs-comment">; 直接用ch*80会溢出 这里不能用mov--因为类型寄存器位数不同</span><br>    <span class="hljs-keyword">imul</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">80</span> <span class="hljs-comment">; bx *=  80</span><br>    <span class="hljs-keyword">movzx</span> <span class="hljs-built_in">si</span>, <span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">si</span>      <span class="hljs-comment">; bx = ch * 80 + cl</span><br>    <span class="hljs-keyword">shl</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; bx = 2 * (ch * 80 + cl)</span><br>    <br>    <span class="hljs-comment">; 当下的点传入显存矩阵</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">al</span>   <span class="hljs-comment">; 写入字符</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>], <span class="hljs-number">ah</span> <span class="hljs-comment">; 写入属性（颜色）</span><br>    <br>    <span class="hljs-comment">;增量</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-number">ch</span>, <span class="hljs-number">dh</span>        <span class="hljs-comment">; 更新行位置</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">cl</span>, <span class="hljs-built_in">dl</span>        <span class="hljs-comment">; 更新列位置</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-number">ah</span>            <span class="hljs-comment">; 改变颜色</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">al</span>            <span class="hljs-comment">; 改变字符</span><br><br>    <span class="hljs-comment">; 添加延迟--需要入栈存储寄存器的值，然后使用int 15h的86功能（延时），在时延后需要将寄存器的值弹出，同时返回继续显示</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x86</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0x0001</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0xa120</span>   <br>    <span class="hljs-keyword">int</span> <span class="hljs-number">15h</span> <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">delay:</span><br>    <span class="hljs-keyword">loop</span> delay<br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br><br>    <span class="hljs-keyword">jmp</span> bounce_loop   <span class="hljs-comment">; 继续主循环</span><br><br><br><span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">; 死循环</span><br><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span> - ($ - $$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>, <span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p>本任务感谢<strong>隔壁舍友L同学</strong>的鼎力支持！从她的代码中学习到了不同位数寄存器要使用<code>movzx</code>存储，同时使用<code>int 15h</code>的0x86功能来产生延时 等知识。</p><h3 id="此处同时贴上相关的知识点："><a href="#此处同时贴上相关的知识点：" class="headerlink" title="此处同时贴上相关的知识点："></a>此处同时贴上相关的知识点：</h3><h4 id="功能86H"><a href="#功能86H" class="headerlink" title="功能86H"></a><strong>功能86H</strong></h4><p><a href="https://blog.csdn.net/qq_16494381/article/details/122760587">BIOS设备中断 15号中断详解-CSDN博客</a></p><p><a href="https://blog.csdn.net/longintchar/article/details/70149027">BIOS中断实现延时-CSDN博客</a></p><p>功能描述：延迟</p><p>入口参数：AH＝86H</p><p>CX:DX＝微秒</p><p>出口参数：CF＝0——操作成功，AH＝00H</p><ul><li>总微秒数 &#x3D; CX * 65536 + DX</li><li>例如，如果CX &#x3D; 0001h，DX &#x3D; 86A0h，则延时为： 0001h * 65536 + 86A0h &#x3D; 65536 + 34464 &#x3D; 100,000微秒 &#x3D; 100毫秒</li></ul><table><thead><tr><th>延时时间</th><th>CX值</th><th>DX值</th><th>16进制总微秒</th></tr></thead><tbody><tr><td>10毫秒</td><td>0000h</td><td>2710h</td><td>0000’2710h</td></tr><tr><td>50毫秒</td><td>0000h</td><td>C350h</td><td>0000’C350h</td></tr><tr><td>100毫秒</td><td>0001h</td><td>86A0h</td><td>0001’86A0h</td></tr><tr><td>250毫秒</td><td>0003h</td><td>D090h</td><td>0003’D090h</td></tr><tr><td>500毫秒</td><td>0007h</td><td>A120h</td><td>0007’A120h</td></tr><tr><td>1秒</td><td>000Fh</td><td>4240h</td><td>000F’4240h</td></tr><tr><td>5秒</td><td>004Ch</td><td>4B40h</td><td>004C’4B40h</td></tr></tbody></table><p>代码示例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 延时100毫秒</span><br><span class="hljs-symbol">delay_100ms:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">86h</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">0001h</span>    <span class="hljs-comment">; 100,000微秒的高16位</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">86A0h</span>    <span class="hljs-comment">; 100,000微秒的低16位</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">15h</span><br>    <span class="hljs-keyword">ret</span><br><br><span class="hljs-comment">; 延时1秒</span><br><span class="hljs-symbol">delay_1s:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">86h</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">000Fh</span>    <span class="hljs-comment">; 1,000,000微秒的高16位</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">4240h</span>    <span class="hljs-comment">; 1,000,000微秒的低16位</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">15h</span><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h4 id="movzx"><a href="#movzx" class="headerlink" title="movzx"></a>movzx</h4><p><a href="https://blog.csdn.net/chuanwang66/article/details/83973495">理解MOVZX指令：汇编语言数据传送的无符号扩展-CSDN博客</a></p><p>用处是将数据从源操作数复制到目的操作数，并使用零扩展将剩余高位填充为0.</p><p><code>movzx destination, source</code></p><p>代码中奖ch移动到bx，将一个8位的寄存器复制到16位寄存器并进行了零扩展。</p><p>类似：movsx（复制并进行符号扩展）</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid魔改记录</title>
    <link href="/2025/03/05/Fluid%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/03/05/Fluid%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol><li>创建custom文件夹以及 <code>.css</code>和 <code>.js</code>文件</li></ol><h2 id="标签变化"><a href="#标签变化" class="headerlink" title="标签变化"></a>标签变化</h2><p>离开界面和处于界面有不同文字。</p><p>参考：<a href="https://asteri5m.icu/archives/0c8538e7-5b5f-4897-8e8b-0cff84320473">Hexo&amp;Fluid魔改笔记 - Asteri5m的小破站</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 浏览器搞笑标题</span><br>varOriginTitle = <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>;<br><span class="hljs-keyword">var</span> titleTime;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">hidden</span>) &#123;<br>$(<span class="hljs-string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&quot;/funny.ico&quot;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;╭(°A°`)╮ 页面崩溃啦 ~&#x27;</span>;<br><span class="hljs-built_in">clearTimeout</span>(titleTime);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>$(<span class="hljs-string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&quot;/img/newtubiao.png&quot;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~&#x27;</span> + <span class="hljs-title class_">OriginTitle</span>;<br>titleTime = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-title class_">OriginTitle</span>;<br>&#125;, <span class="hljs-number">2000</span>);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后将路径添加到custom下就可以了</p><ol start="2"><li>配置obsidian中的图片路径<br>安装插件custom attachment location，同时设置如下图：<br><img src="/img/file-20250329000741766.png"><br>然后设置文件与链接中的设置：<br><img src="/img/file-20250329000655306.png"></li></ol><p>最近又莫名其妙出现了图片显示不了的问题，匪夷所思，发现root设置自己改掉了。，。，最后重新加上解决了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">True</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">external_link:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 修改为false</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 修改为false，这是关键</span><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">syntax_highlighter:</span> <span class="hljs-string">highlight.js</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>以及：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">url:</span> https:<span class="hljs-symbol">//pqcu77.github.io</span><br><span class="hljs-params">root:</span> <span class="hljs-symbol">/</span><br><span class="hljs-params">permalink:</span> <span class="hljs-meta">:year</span><span class="hljs-operator">/</span>:month<span class="hljs-operator">/</span>:day<span class="hljs-operator">/</span>:title<span class="hljs-symbol">/</span><br><span class="hljs-params">permalink_defaults:</span><br><span class="hljs-params">pretty_urls:</span><br>  <span class="hljs-params">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-params">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></code></pre></td></tr></table></figure><p>在这里添加 <code>root: /</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>record</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python_basic</title>
    <link href="/2025/03/03/python-basic/"/>
    <url>/2025/03/03/python-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-basic-for-AI-course"><a href="#Python-basic-for-AI-course" class="headerlink" title="Python-basic for AI course"></a>Python-basic for AI course</h1><p>实验课要求：</p><p>课件：<a href="https://github.com/pqcu77/2025AI/tree/main">https://github.com/pqcu77/2025AI/tree/main</a></p><h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><p>资料：<a href="https://python.iswbm.com/">https://python.iswbm.com/</a></p><p><a href="https://www.runoob.com/python3/python3-tutorial.html">https://www.runoob.com/python3/python3-tutorial.html</a></p><p><strong>常用conda命令</strong>:</p><ul><li><p><code>conda env list</code> 查看conda环境列表</p></li><li><p><code>conda create –n env_id python=3.9</code> 创建新py3.9虚</p></li></ul><p>拟环境</p><ul><li><p><code>conda activate env_id</code> 激活对应python环境</p></li><li><p><code>conda deactivate</code> 关闭对应python环境</p></li></ul><p><strong>print():</strong></p><ul><li>输入参数为要打印的对象，对象可以有多个</li><li>sep参数，默认值为” “—默认用空格隔开</li><li>end参数，默认值为 “\n”</li></ul><p><strong>input():</strong></p><ul><li>输入参数可以作为<strong>提示字符串</strong>。会打印出来“提示”用户</li><li>返回值是读入的字符串</li></ul><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><p><strong>简单&#x2F;基本数据类型</strong></p><ul><li><p>数字</p><ul><li><p>整数</p></li><li><p>浮点数</p></li><li><p>布尔值：True &#x2F; False （注意大写）</p><ul><li>int(True)返回1，int(False)返回0</li></ul></li><li><p>字符串</p><ul><li>※空值：<strong>a &#x3D; None</strong></li></ul></li></ul></li></ul><p><strong>计算</strong></p><ul><li>整数：加（+）、减（-）、乘（*）、除（&#x2F;）、<strong>整除（&#x2F;&#x2F;）</strong>、幂（**）、<strong>模（%）</strong></li><li>浮点数：加（+）、减（-）、乘（*）、除（&#x2F;）、<strong>整除（&#x2F;&#x2F;）</strong>、幂（**）</li><li>四舍五入保留k位：round(x,k)</li></ul><p><strong>函数：</strong></p><ul><li>绝对值：abs()</li><li>最大，最小值：max(),min()</li><li>math模块</li></ul><p>**运算符：<strong>如+&#x3D;，</strong>&#x3D;等。python没有<code>++</code>，<code>--</code>运算符</p><p><strong>字符串</strong></p><ul><li><p><strong>引号</strong>括起的。可以是单引号也可以是双引号</p></li><li><p>拼接：</p><ul><li>用 <code>+</code> 来拼接—慢</li><li>用 <code>*</code> 来<strong>重复</strong>自拼接。如print(”hello”*4)</li></ul></li><li><p>大小写转换</p><ul><li>title()：首字母转换为大写</li><li>lower()</li><li>upper()</li></ul></li><li><p>常用函数</p><ul><li>删除空白：<ul><li>str.strip()  删除字符串<strong>前后</strong>的空白字符</li><li>str.rstrip() 删除字符串**后面（右边）**的空白字符<ul><li>str.lstrip() 删除字符串**前面（左边）**的空白字符</li></ul></li></ul></li><li>分割<ul><li><strong>print(sentence.split())</strong></li><li><strong>print(sentence.split(“,”))</strong></li></ul></li><li><strong>替换</strong></li></ul><p><strong>sentence &#x3D; “Life is short, you need Python.”</strong></p><p><strong>print(sentence.replace(“h”, “XD”))</strong></p><p><strong>print(sentence.replace(“short”, “long”).replace(“Python”, “C++”))</strong></p></li></ul><p><strong>类型转换</strong></p><ul><li>datatype() →如：int(),float(),str()…</li><li><code>print(int(4/3))</code></li><li></li></ul><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><ul><li>代码块与<strong>缩进</strong>；用缩进来区分关系</li><li>比较运算符</li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于 - 比较对象是否相等</td><td>(a &#x3D;&#x3D; b) 返回 False</td></tr><tr><td>!&#x3D;</td><td>不等于 - 比较两个对象是否不相等</td><td>(a !&#x3D; b) 返回 True</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td><td>(a &gt; b) 返回 False</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y</td><td>(a &lt; b) 返回 True</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于 - 返回x是否大于等于y</td><td>(a &gt;&#x3D; b) 返回 False</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于 - 返回x是否小于等于y</td><td>(a &lt;&#x3D; b) 返回 True</td></tr></tbody></table><p>逻辑控制符：and or not</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y返回 x 的值，否则返回 y 的计算值。</td><td>(a and b) 返回 20</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” - 如果 x 是 True，它返回 x的值，否则它返回 y 的计算值。</td><td>(a or b) 返回 10</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回False。如果 x 为 False，它返回 True。</td><td>not (a and b) 返回False</td></tr></tbody></table><p>分支结构：</p><ul><li><p><code>if</code> 和 <code>elif</code>，后面加冒号，无大括号</p></li><li><pre><code class="hljs">while<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>  - <span class="hljs-keyword">break</span>和<span class="hljs-keyword">continue</span>；用法类似c++<br><br>```python<br><span class="hljs-keyword">while</span> condition:<br><span class="hljs-keyword">do</span> something<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>for</code> ：常与迭代器一同使用</p><ul><li><code>range(n)</code>—从0遍历到n-1，步长为1</li><li><code>range(a,b)</code> —从a遍历到b-1。左闭右开</li><li><code>range(start,stop,step)</code> —从start遍历到stop-step，步长为step，step默认为1</li></ul></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>列表list</strong></p><ul><li>类似与数组，由一系列按特定顺序排列的元素构成</li><li>list里的元素<strong>可以是不同类型</strong></li><li>访问元素：<ul><li>索引访问：可以是<strong>非负索引</strong>也可以是<strong>负索引</strong></li></ul></li><li>修改—可以动态增删&amp;修改</li><li>添加<ul><li><code>append()</code> 在末尾添加</li><li><code>insert()</code> 插入</li></ul></li><li>删除<ul><li><code>del xxx</code> —使用del语句删除</li><li><code>remove()</code>—按值删除元素</li><li><code>pop()</code></li></ul></li><li>长度：<code>len()</code></li><li>翻转：<code>reverse()</code> —原地操作，永久修改</li><li>排序</li><li>切片<ul><li><code>list[start:end]</code>   <code>list[start:end:step]</code></li></ul></li><li>赋值（浅复制），指向同一块内存<ul><li>可以用id()函数来获取对象的内存地址</li><li>身份运算符 <code>is</code> ：x is y ⇒id(x)&#x3D;&#x3D;id(y) 表示二者指向同一块内存。</li><li><code>is</code> 和 <code>==</code> 是不一样的，后者是用于判断引用变量的值是否相等</li></ul></li><li>复制<ul><li>深复制</li><li>浅复制</li></ul></li><li>遍历： <strong><code>for ele in list:</code></strong> 前面这个是遍历全体，或者是range来选定一个范围</li></ul><h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><ul><li><strong>不可变</strong>的列表</li><li><strong>圆括号标识</strong></li></ul><h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><ul><li>无序不重复的元素序列</li></ul><h3 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h3><ul><li>键值对</li><li>访问字典中的值，dic(”key”);</li><li>修改值</li><li>添加键值对</li><li>删除键值对：del</li><li>遍历所有的键值对 <code>for key,value in dic.items():</code></li><li>遍历所有键 <code>for key in dic.keys():</code></li><li>遍历所有值 <code>for value in dic.values():</code></li></ul><p>两个字典同时遍历：</p><ul><li>以key同时遍历两个字典（两个字典长度一样，否则以最短的次数输出）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_map = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;<br>dict_map1 = &#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;hi&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> key1, key2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(dict_map.keys(), dict_map1.keys()):<br>    <span class="hljs-built_in">print</span>(key1, dict_map[key1], key2, dict_map1[key2])<br></code></pre></td></tr></table></figure><ul><li>以key、value同时遍历两个字典（两个字典长度一样，否则以最短的次数输出）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_map = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;<br>dict_map1 = &#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;hi&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(dict_map.items(), dict_map1.items()):<br>    <span class="hljs-built_in">print</span>(key, value)                    <br></code></pre></td></tr></table></figure><ul><li>逐项同时遍历两个字典（两个字典长度一样，否则以最短的次数输出）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_map = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;<br>dict_map1 = &#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;hi&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> kv <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(dict_map.items(), dict_map1.items()):<br>    <span class="hljs-built_in">print</span>(kv)<br></code></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/wsq119/article/details/115221881">https://blog.csdn.net/wsq119/article/details/115221881</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>结构：def开头，函数名，括号，冒号结尾，紧跟的所有缩进构成函数体</p><ul><li>可以处理一组数据，并返回一个或一组值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_formatted_name</span>(<span class="hljs-params">first_name, last_name, middle_name=<span class="hljs-string">&#x27;&#x27;</span></span>):<br><span class="hljs-keyword">if</span> middle_name:<br>full_name = first_name + <span class="hljs-string">&#x27; &#x27;</span> + middle_name + <span class="hljs-string">&#x27; &#x27;</span> + last_name<br><span class="hljs-keyword">return</span> full_name.title()<br><span class="hljs-keyword">else</span>:<br>full_name = first_name + <span class="hljs-string">&#x27; &#x27;</span> + last_name<br><span class="hljs-keyword">return</span> first_name.title(), last_name.title()<br></code></pre></td></tr></table></figure><ul><li>用一个或多个变量存储返回的值，或直接使用返回的值</li></ul><h3 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h3><ul><li>位置实参：基于实参的顺序，将实参关联到啊哈怒火定义中的形参</li><li>默认值：具有默认值的形参<strong>需排列在参数列表后面</strong>（才能达到可以省略的目的）</li><li>关键字实参：无需考虑实参顺序。将形参变量名写出来，然后赋值</li></ul><p><img src="/img/func.png" alt="func"></p><ul><li>对某些数据类型来说，在函数内部对传入变量做的修改，会导致函数外的值夜发生修改，产生副作用（<strong>列表、字典</strong>会改，但数值、字符串不改）<ul><li>对于数值、字符串等，可以通过返回值传到函数外</li></ul></li></ul><p>如果希望不影响函数外的话：向函数传递列表副本</p><ul><li>利用切片创建副本 list_name[:]</li><li>形参前加<code>*</code>号，可以传递<strong>任意数量的实参</strong></li><li>形参前加<code>**</code>号，可以传递<strong>任意数量的关键字实参</strong></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight plaintext"><figcaption><span>Dog</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs class">class Dog():<br>def __init__(self, name, age):<br>self.name = name<br>self.age = age<br>def sit(self):<br>        print(self.name.title() + &quot; is now sitting.&quot;)<br>def roll_over(self):<br>print(self.name.title() + &quot; rolled over!&quot;)<br></code></pre></td></tr></table></figure><ul><li><p>方法<code>_init_()</code>：构造函数，创建新对象自动调用</p></li><li><p>self：</p><ul><li><strong>必须</strong>写在所有方法参数列表的<strong>第一位</strong></li><li>指代这个对象本身</li><li>以self为前缀的成员变量可供类中所有方法使用–属性</li><li>self.variable可以访问、创建与修改属性值</li></ul></li><li><p>python的类属性默认是公有属性，要标记为私有的则要在变量名或函数名前加上两个下划线 “<code>__</code>”</p></li><li><p>属性修改：<strong>最好写一个update的方法</strong></p><ul><li>也可以直接修改，但破坏了封装</li></ul></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p><code>class 子类名(父类名)</code>   </p></li><li><p>super()–在子类中通过<code>super()</code>指向父类</p></li><li><p>允许父类调用子类的方法</p></li><li><p>子类可以重写父类的方法，可以添加新的属性和方法，继承所有父类的方法</p></li></ul><h2 id="文件与异常"><a href="#文件与异常" class="headerlink" title="文件与异常"></a>文件与异常</h2><ul><li>读取文件：read()</li><li>open() ：参数是文件路径（相对路径和绝对路径都可以）<ul><li>open(“文件路径”，“模式”)，对于模式参数：<ul><li>‘r’：读取模式（默认）</li><li>‘w’：写入模式, 如果该文件已存在则打开文件，并从开头开始编辑<br>，即原有内容会被删除。如果该文件不存在，创建新文件。</li><li>‘a’：追加模式. 如果该文件已存在，文件指针将会放在文件的结尾<br>。也就是说，新的内容将会被写入到已有内容之后。如果该文件不<br>存在，创建新文件进行写入</li></ul></li></ul></li><li>with()：在不再需要访问文件后将文件关闭，无需调用close()</li><li>逐行读取 readlines()</li><li>只能将字符串写入文件，如果需要换行，记得写换行符</li></ul><h3 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h3><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a>**Python 3 中的 File 对象不支持 next() 方法。**返回文件下一行。</td></tr><tr><td align="left">6</td><td align="left">[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left">7</td><td align="left">[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td></tr><tr><td align="left">8</td><td align="left">[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left">9</td><td align="left">[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td></tr><tr><td align="left">11</td><td align="left">[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><p>举例：</p><ul><li>读取文件：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;num.txt&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        <span class="hljs-comment">#1.打印整个文档</span><br>        <span class="hljs-comment"># num=file.read()</span><br>        <span class="hljs-comment"># print(num)</span><br>        <br>        <span class="hljs-comment">#2.逐行读取并打印</span><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file.readlines():<br>            <span class="hljs-comment"># print(line)#这里由于没有去除换行符，会导致换行符单独占据一行</span><br>            <span class="hljs-built_in">print</span>(line.rstrip()) <span class="hljs-comment">#这样子会去掉换行符</span><br>        <br>        <br>        <br>main()<br></code></pre></td></tr></table></figure><p>情况1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>情况2.1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>情况2.2：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><ul><li>写文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;num.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file: <span class="hljs-comment">#这里设置为write模式</span><br>        file.write(<span class="hljs-string">&quot;hello world\n&quot;</span>)<br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;num.txt&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> file: <span class="hljs-comment">#设置为append模式</span><br>        file.write(<span class="hljs-string">&quot;appending...&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li><p>将函数与类存储在被称为模块的独立文件中，与主程序分离</p></li><li><p>模块式拓展名为<code>.py</code>的文件，包含要导入到程序中的代码</p></li><li><p>模块导入</p><ul><li>导入整个模块 <code>import module</code></li><li>导入部分函数或类 <code>from module_name import func</code> <code>from module_name import class_name</code></li><li><code>import module_name as nickname</code></li><li><code>from module_name import funcName as nickName</code></li><li><code>from moduleNmae import *</code></li></ul></li><li><p>导入一个模块时，该模块文件的无缩进代码将直接执行</p></li><li><p>在编写自己的模块时，模块测试代码等要记得缩进于<code>if __name__ ==</code> </p><p><code>&#39;__main__&#39;</code>:<a href="https://www.zhihu.com/question/49136398">if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘ 如何正确理解? - 知乎</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫</title>
    <link href="/2025/03/02/%E7%88%AC%E8%99%AB/"/>
    <url>/2025/03/02/%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><hr><h2 id="简单概念"><a href="#简单概念" class="headerlink" title="简单概念"></a>简单概念</h2><p>网络爬虫：模拟浏览器发送网络请求，接受请求响应，一种按一定规则，自动地抓取互联网信息的程序</p><ul><li>可以用于自动地从网络上获取信息，节省人工</li></ul><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><ul><li>可以使用python</li><li>一些可能使用到的库：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- codeing = utf-8 -*-</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup  <span class="hljs-comment"># 网页解析，获取数据</span><br><span class="hljs-keyword">import</span> re  <span class="hljs-comment"># 正则表达式，进行文字匹配`</span><br><span class="hljs-keyword">import</span> urllib.request, urllib.error  <span class="hljs-comment"># 制定URL，获取网页数据</span><br><span class="hljs-keyword">import</span> xlwt  <span class="hljs-comment"># 进行excel操作</span><br><span class="hljs-comment">#import sqlite3  # 进行SQLite数据库操作</span><br><br></code></pre></td></tr></table></figure></li><li><code># coding=utf-8</code> 或 <code># -*- coding: utf-8 -*-</code> 来指定源代码的编码方式，防止乱码</li></ul><h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><ol><li>爬取网页</li><li>逐一解析数据</li><li>保存网页</li></ol><h3 id="详细展开"><a href="#详细展开" class="headerlink" title="详细展开"></a>详细展开</h3><p><strong>爬取网页：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>):  <span class="hljs-comment"># 调用获取页面信息的函数，10次</span><br>      url = baseurl + <span class="hljs-built_in">str</span>(i * <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><p>baseurl是要爬虫的网址，加上的str(i*25)是用于 <strong>翻页</strong> ，通过这样子设置可以跳转到不同的界面</p><p><code>askURL()</code>用于请求网页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">askURL</span>(<span class="hljs-params">url</span>):<br>    head = &#123;  <span class="hljs-comment"># 模拟浏览器头部信息，向豆瓣服务器发送消息</span><br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla / 5.0(Windows NT 10.0; Win64; x64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 80.0.3987.122  Safari / 537.36&quot;</span><br>    &#125;<br>    <span class="hljs-comment"># 用户代理，表示告诉豆瓣服务器，我们是什么类型的机器、浏览器（本质上是告诉浏览器，我们可以接收什么水平的文件内容）</span><br><br>    request = urllib.request.Request(url, headers=head)<br>    html = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        response = urllib.request.urlopen(request)<br>        html = response.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">except</span> urllib.error.URLError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;code&quot;</span>):<br>            <span class="hljs-built_in">print</span>(e.code)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;reason&quot;</span>):<br>            <span class="hljs-built_in">print</span>(e.reason)<br>    <span class="hljs-keyword">return</span> html<br><br></code></pre></td></tr></table></figure><p>head用于模拟浏览器头部信息，相当于我们在模拟人工查询网页时目标服务器会接受到的信息</p><p>如果不写head可能会被认出来是爬虫，导致错误</p><p><strong>逐一解析数据：</strong></p><p>解析数据用到了BeautifulSoup这个库（爬虫必备库）</p><p>用正则表达式去匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">findLink = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;</span>)  <span class="hljs-comment"># 创建正则表达式对象，标售规则   影片详情链接的规则</span><br>findImgSrc = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;img.*src=&quot;(.*?)&quot;&#x27;</span>, re.S)<br>findTitle = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findRating = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findJudge = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span&gt;(\\d*)人评价&lt;/span&gt;&#x27;</span>)<br>findInq = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findBd = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;p class=&quot;&quot;&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)<br></code></pre></td></tr></table></figure><p>一些解释：</p><ul><li><code>r&#39;&#39;</code> ：用于表示python的原始字符串，避免 <code>\\</code> 作为转义符干扰，让正则表达式更易读</li><li><code>&lt;p class=&quot;&quot;&gt;</code><ul><li>这里匹配 <code>&lt;p&gt;</code>标签，要求 <code>class</code>属性为空</li><li>如果网页class属性省略了，还需要调整匹配方式</li></ul></li><li><code>(.*?)</code><ul><li>小括号表示一个捕获组，可以提取匹配到的内容</li><li><code>.*?</code> ：<ul><li><code>.</code> 匹配任意字符</li><li><code>*?</code> 非贪婪匹配，匹配尽可能少的字符，遇到 <code>&lt;/p&gt;</code>（结束标签）就停止</li><li><code>*</code> 表示匹配任意次数，但 <code>?</code> 让它变成非贪婪模式</li></ul></li></ul></li><li><code>re.S</code> (<code>re.DOTALL</code>)<ul><li>让 <code>.</code> 可以匹配换行符，<code>&lt;p&gt;</code>标签内部文本可以是多行的</li><li>如果没有 <code>re.S</code>，换行符 <code>\\n</code>可能会导致匹配失败</li></ul></li></ul><p><strong>保存数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">saveData(datalist,savepath)      <span class="hljs-comment">#2种存储方式可以只选择一种</span><br><span class="hljs-comment"># saveData2DB(datalist,dbpath)</span><br></code></pre></td></tr></table></figure><p>保存数据可以选择保存到 xls表（xlwt库支持），或者保存到sqlite数据库（sqlite3库支持）</p><ul><li>保存到xls：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params">datalist,savepath</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;save.......&quot;</span>)<br>    book = xlwt.Workbook(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>,style_compression=<span class="hljs-number">0</span>) <span class="hljs-comment">#创建workbook对象</span><br>    sheet = book.add_sheet(<span class="hljs-string">&#x27;豆瓣电影Top250&#x27;</span>, cell_overwrite_ok=<span class="hljs-literal">True</span>) <span class="hljs-comment">#创建工作表</span><br>    col = (<span class="hljs-string">&quot;电影详情链接&quot;</span>,<span class="hljs-string">&quot;图片链接&quot;</span>,<span class="hljs-string">&quot;影片中文名&quot;</span>,<span class="hljs-string">&quot;影片外国名&quot;</span>,<span class="hljs-string">&quot;评分&quot;</span>,<span class="hljs-string">&quot;评价数&quot;</span>,<span class="hljs-string">&quot;概况&quot;</span>,<span class="hljs-string">&quot;相关信息&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>):<br>        sheet.write(<span class="hljs-number">0</span>,i,col[i])  <span class="hljs-comment">#列名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">250</span>):<br>        <span class="hljs-comment"># print(&quot;第%d条&quot; %(i+1))       #输出语句，用来测试</span><br>        data = datalist[i]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>):<br>            sheet.write(i+<span class="hljs-number">1</span>,j,data[j])  <span class="hljs-comment">#数据</span><br>    book.save(savepath) <span class="hljs-comment">#保存</span><br></code></pre></td></tr></table></figure><p><code>sheet = book.add_sheet(&#39;豆瓣电影Top250&#39;, cell_overwrite_ok=True) #创建工作表</code></p><p>创建工作表</p><p><code>col = (&quot;电影详情链接&quot;,&quot;图片链接&quot;,&quot;影片中文名&quot;,&quot;影片外国名&quot;,&quot;评分&quot;,&quot;评价数&quot;,&quot;概况&quot;,&quot;相关信息&quot;)</code></p><p>创建列</p><p>But!这个xls有点老旧的样子，在vscode和wps都没办法打开文件，所以叫ai重写了一下。改为使用openpyxl库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params">datalist, savepath</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存数据......&quot;</span>)<br>    wb = openpyxl.Workbook()<br>    sheet = wb.active<br>    sheet.title = <span class="hljs-string">&quot;豆瓣电影Top250&quot;</span><br>    col = [<span class="hljs-string">&quot;电影详情链接&quot;</span>, <span class="hljs-string">&quot;图片链接&quot;</span>, <span class="hljs-string">&quot;影片中文名&quot;</span>, <span class="hljs-string">&quot;影片外国名&quot;</span>, <span class="hljs-string">&quot;评分&quot;</span>, <span class="hljs-string">&quot;评价数&quot;</span>, <span class="hljs-string">&quot;概况&quot;</span>, <span class="hljs-string">&quot;相关信息&quot;</span>]<br>    sheet.append(col)<br>  <br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> datalist:<br>        sheet.append(data)<br><br>    wb.save(savepath)<br><br></code></pre></td></tr></table></figure><h2 id="开展："><a href="#开展：" class="headerlink" title="开展："></a>开展：</h2><p>（一）分析目标网站</p><p>在编写爬虫前，先查看目标网站的robots.txt文件，了解网站允许的爬取范围。同时，使用浏览器开发者工具（F12）检查页面结构，分析数据所在位置和标签特征。</p><p>（二）发送请求</p><p>利用工具向目标网站发送HTTP请求，获取网页内容。在发送请求时，要注意设置合适的请求头，模拟真实浏览器行为，避免被网站识别为爬虫。</p><p>（三）解析内容</p><p>将获取到的网页内容进行解析，提取所需数据。根据网页结构和数据特点，选择合适的解析工具和方法。</p><p>（四）存储数据</p><p>将提取到的数据存储到本地文件或数据库中，方便后续使用和分析。根据数据量和使用需求，选择合适的存储方式。</p><p>（五）处理动态内容</p><p>对于动态生成的网页内容，需要使用专门的工具模拟浏览器操作，获取完整的页面数据。在处理动态内容时，要注意页面加载时间和操作的稳定性。</p><p>（六）反爬策略应对</p><p>网站为了保护自身数据，会采取各种反爬措施。可以通过设置请求头、使用代理IP、添加延迟等方式应对反爬策略，确保爬虫的稳定运行。</p><h2 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h2><h3 id="七个主要方法"><a href="#七个主要方法" class="headerlink" title="七个主要方法"></a>七个主要方法</h3><p><code>req.request()</code> 构造一个请求</p><p><code>req.get()</code> 获取HTML网页</p><p><code>req.head()</code> 获取HTML网页头信息</p><p><code>req.post()</code> 向HTML网页提交POST请求</p><p><code>req.put()</code> 提交PUT请求</p><p><code>req.patch()</code> 提交局部修改请求</p><p><code>req.delete()</code> 提交删除请求</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>$ 表示结束匹配</strong></p><table><thead><tr><th><strong>元字符</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配<strong>任意</strong>一个字符（除了换行符 <code>\\n</code>）</td><td><code>a.b</code>匹配 <code>&quot;acb&quot;</code>、<code>&quot;a2b&quot;</code></td></tr><tr><td><code>^</code></td><td>匹配<strong>行首</strong></td><td><code>^abc</code>只能匹配 <code>&quot;abc&quot;</code>在字符串开头的情况</td></tr><tr><td><code>$</code></td><td>匹配<strong>行尾</strong></td><td><code>xyz$</code>只能匹配 <code>&quot;xyz&quot;</code>在字符串结尾的情况</td></tr><tr><td><code>*</code></td><td>匹配<strong>0 或多次</strong>前面的字符</td><td><code>ab*c</code>匹配 <code>&quot;ac&quot;</code>、<code>&quot;abc&quot;</code>、<code>&quot;abbc&quot;</code></td></tr><tr><td><code>+</code></td><td>匹配<strong>1 或多次</strong>前面的字符</td><td><code>ab+c</code>匹配 <code>&quot;abc&quot;</code>、<code>&quot;abbc&quot;</code>，但不匹配 <code>&quot;ac&quot;</code></td></tr><tr><td><code>?</code></td><td>匹配<strong>0 或 1 次</strong>前面的字符</td><td><code>ab?c</code>匹配 <code>&quot;ac&quot;</code>和 <code>&quot;abc&quot;</code></td></tr><tr><td><code>&#123;m,n&#125;</code></td><td>匹配<strong>m 到 n 次</strong>前面的字符</td><td><code>ab&#123;1,3&#125;c</code>匹配 <code>&quot;abc&quot;</code>、<code>&quot;abbc&quot;</code>、<code>&quot;abbbc&quot;</code></td></tr></tbody></table><table><thead><tr><th><strong>符号</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>\\d</code></td><td>匹配<strong>数字</strong> （等价于 <code>[0-9]</code>）</td><td><code>\\d+</code>匹配 <code>&quot;123&quot;</code></td></tr><tr><td><code>\\D</code></td><td>匹配<strong>非数字</strong> （等价于 <code>[^0-9]</code>）</td><td><code>\\D+</code>匹配 <code>&quot;abc&quot;</code></td></tr><tr><td><code>\\w</code></td><td>匹配<strong>单词字符</strong> （字母、数字、下划线 <code>a-zA-Z0-9_</code>）</td><td><code>\\w+</code>匹配 <code>&quot;hello123&quot;</code></td></tr><tr><td><code>\\W</code></td><td>匹配<strong>非单词字符</strong> （等价于 <code>[^a-zA-Z0-9_]</code>）</td><td><code>\\W+</code>匹配 <code>&quot;$#@&quot;</code></td></tr><tr><td><code>\\s</code></td><td>匹配<strong>空白字符</strong> （空格、Tab、换行）</td><td><code>\\s+</code>匹配 <code>&quot; &quot;</code></td></tr><tr><td><code>\\S</code></td><td>匹配<strong>非空白字符</strong></td><td><code>\\S+</code>匹配 <code>&quot;hello&quot;</code></td></tr></tbody></table><p><code>.*</code> 默认匹配<strong>尽可能多</strong>的字符：默认为贪婪匹配</p><p>使用 <code>*?</code> 或 <code>+?</code> 让匹配 <strong>尽可能少</strong> ：非贪婪匹配</p><h3 id="Python-正则表达式常用方法"><a href="#Python-正则表达式常用方法" class="headerlink" title="Python 正则表达式常用方法"></a><strong>Python 正则表达式常用方法</strong></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>re.match(pattern, string)</code></td><td><strong>从头</strong>匹配字符串</td></tr><tr><td><code>re.search(pattern, string)</code></td><td><strong>搜索</strong>第一个匹配项</td></tr><tr><td><code>re.findall(pattern, string)</code></td><td>返回<strong>所有匹配项</strong> （列表）</td></tr><tr><td><code>re.finditer(pattern, string)</code></td><td>以迭代器返回所有匹配项</td></tr><tr><td><code>re.sub(pattern, repl, string)</code></td><td><strong>替换</strong>匹配项</td></tr><tr><td><code>re.split(pattern, string)</code></td><td><strong>分割</strong>字符串</td></tr></tbody></table><h1 id="用爬虫爬idol的照片"><a href="#用爬虫爬idol的照片" class="headerlink" title="用爬虫爬idol的照片"></a>用爬虫爬idol的照片</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_images</span>(<span class="hljs-params">keyword, num_images=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-comment"># 随机 User-Agent 列表</span><br>    user_agents = [<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1&#x27;</span><br>    ]<br><br>    <span class="hljs-comment"># 创建会话</span><br>    session = requests.Session()<br><br>    <span class="hljs-comment"># Bing图片搜索URL</span><br>    url = <span class="hljs-string">f&#x27;&lt;https://cn.bing.com/images/search?q=<span class="hljs-subst">&#123;keyword&#125;</span>&amp;form=HDRSC2&amp;first=1&gt;&#x27;</span><br><br>    <span class="hljs-comment"># 随机选择一个 User-Agent</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: random.choice(user_agents),<br>        <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;&lt;https://cn.bing.com/&gt;&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 发送请求</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始发送请求...&quot;</span>)<br>        response = session.get(url, headers=headers, timeout=<span class="hljs-number">10</span>)<br>        response.raise_for_status()  <span class="hljs-comment"># 检查请求是否成功</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求成功，状态码:&quot;</span>, response.status_code)<br>    <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;请求失败: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 解析页面</span><br>    soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><br>    <span class="hljs-comment"># 提取图片URL</span><br>    image_urls = []<br>    <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;img&#x27;</span>, class_=<span class="hljs-string">&#x27;mimg&#x27;</span>):<br>        img_url = img.get(<span class="hljs-string">&#x27;src&#x27;</span>)<br>        <span class="hljs-keyword">if</span> img_url <span class="hljs-keyword">and</span> img_url.startswith((<span class="hljs-string">&#x27;http://&#x27;</span>, <span class="hljs-string">&#x27;https://&#x27;</span>)):  <span class="hljs-comment"># 过滤无效 URL</span><br>            image_urls.append(img_url)<br><br>    <span class="hljs-comment"># 创建保存图片的文件夹</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&#x27;images&#x27;</span>):<br>        os.makedirs(<span class="hljs-string">&#x27;images&#x27;</span>)<br><br>    <span class="hljs-comment"># 下载图片</span><br>    <span class="hljs-keyword">for</span> i, img_url <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(image_urls[:num_images]):  <span class="hljs-comment"># 只取前 num_images 张</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 随机延时 2~5 秒</span><br>            time.sleep(random.uniform(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br><br>            <span class="hljs-comment"># 随机选择一个 User-Agent</span><br>            headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] = random.choice(user_agents)<br><br>            <span class="hljs-comment"># 发送请求</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载图片 <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>: <span class="hljs-subst">&#123;img_url&#125;</span>&quot;</span>)<br>            response = session.get(img_url, headers=headers, timeout=<span class="hljs-number">10</span>)<br>            response.raise_for_status()<br><br>            <span class="hljs-comment"># 保存图片</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;images/image_<span class="hljs-subst">&#123;i&#125;</span>.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(response.content)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;下载完成: image_<span class="hljs-subst">&#123;i&#125;</span>.jpg&#x27;</span>)<br>        <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;下载失败: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    keyword = <span class="hljs-string">&#x27;姚琛&#x27;</span><br>    num_images = <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始抓取 <span class="hljs-subst">&#123;num_images&#125;</span> 张 &#x27;<span class="hljs-subst">&#123;keyword&#125;</span>&#x27; 的图片...&quot;</span>)<br>    fetch_images(keyword, num_images)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序运行结束。&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>结果：</p><p>笔记参考&amp;资料：</p><p><a href="https://blog.csdn.net/bookssea/article/details/107309591">https://blog.csdn.net/bookssea/article/details/107309591</a></p><p><a href="https://www.runoob.com/python3/python-spider-beautifulsoup.html">https://www.runoob.com/python3/python-spider-beautifulsoup.html</a></p><p><a href="https://github.com/Ehco1996/Python-crawler?tab=readme-ov-file">https://github.com/Ehco1996/Python-crawler?tab=readme-ov-file</a></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>extra learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YatCPU</title>
    <link href="/2025/02/28/YatCPU/"/>
    <url>/2025/02/28/YatCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li><strong>单周期 CPU</strong>：本实验的目的是从零开始编写一个可以运行 RV32I 指令集程序的单周期 CPU，这个 CPU 将会是后续所有实验的基础。完成本实验之后，可以通过仿真的方式，加载运行 RV32I 程序，验证正确性。</li><li><strong>中断机制</strong>：本实验在单周期 CPU 的基础上，添加了中断控制器以及中断控制流的内容，使单周期 CPU 可以处理来自外部设备的中断，响应 IO。完成本实验之后，CPU 将具备响应 UART 数据中断、时钟中断的功能，你将可以使用 UART 端口来操作 CPU 运行中的程序。</li><li><strong>流水线 CPU</strong>：本实验在以上两个实验基础上，对 CPU 进行性能优化，从单周期的 CPU 修改为多周期以及流水线的 CPU。本实验将通过几个性能评测，来验证 CPU 性能优化的效果。</li><li><strong>总线处理</strong>：本实验在流水线 CPU 的基础上，给 CPU 添加总线功能，实现外设与 CPU 的解耦。在完成总线实验后，添加外设无需修改 CPU 本身，只需要实现总线协议并与总线对接即可。本实验目的是进一步完善 CPU 实验的总体框架，提供更贴近真实计算机系统的结构实践。</li></ul><h1 id="Lab0—get-ready-for-experiment"><a href="#Lab0—get-ready-for-experiment" class="headerlink" title="Lab0—get ready for experiment"></a>Lab0—get ready for experiment</h1><blockquote><p>chisel 3基本学习</p></blockquote><h2 id="chisel3基本语法和功能"><a href="#chisel3基本语法和功能" class="headerlink" title="chisel3基本语法和功能"></a>chisel3基本语法和功能</h2><ul><li>区别举例：想要在chisel3中使用一个常量，要写<strong>when(value&#x3D;&#x3D;&#x3D;12.U)</strong>，而不是if(value&#x3D;&#x3D;12)</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>无符号整数**<code>UInt</code><strong>与有符号整数</strong> <code>SInt</code>** ，使用.W来指定整数位宽（<code>Uint(8.W)</code>），.U来将scala中的整数转换为chisel3的<strong>硬件整数</strong>（见我们最开始举的例子）</li><li>布尔值Bool；使用.B来转换成硬件布尔值（如**<code>true.B</code>**)</li><li>模块：声明一个模块需要<strong>继承 <code>Module</code> 类</strong>，并通过 <code>io</code> 成员声明输入输出端口。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>_<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModule</span> **extends Module** &#123;<br>    val io = <span class="hljs-built_in">IO</span>(<span class="hljs-keyword">new</span> Bundle &#123;<br>        val in = <span class="hljs-built_in">Input</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">8.</span>W))<br>        val out = <span class="hljs-built_in">Output</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">8.</span>W))<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>组合逻辑</li></ul><p><code>val wire = Wire(UInt(8.W))  val wireinit = WireInit(0.U(8.W))</code></p><ul><li>时序电路</li><li>寄存器</li></ul><p><code>val reg = Reg(UInt(8.W))  val reginit = RegInit(0.U(8.W))</code></p><h3 id="Chisel3-项目结构"><a href="#Chisel3-项目结构" class="headerlink" title="Chisel3 项目结构"></a>Chisel3 项目结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- labx<br>    - coremark              # CPU 性能测试<br>    - csrc                  # 存放汇编语言和 C 语言源代码<br>    - project               <span class="hljs-meta"># sbt 的插件以及配置文件</span><br>    - src <br>        - main<br>            - scala         # Chisel <span class="hljs-number">3</span> 源代码 &lt;--<br>        - resources         # 资源文件<br>        - test<br>            - scala         # Chisel <span class="hljs-number">3</span> 测试代码 <br>    - target                <span class="hljs-meta"># sbt 生成的文件</span><br>    - test_run_dir          # 运行测试时生成的文件<br>    - verilog               # Verilog 代码<br>    - vivado                <span class="hljs-meta"># tcl 脚本以及约束文件（用于自动化烧板）</span><br>    - build.sbt             <span class="hljs-meta"># sbt 配置文件</span><br>  <br></code></pre></td></tr></table></figure><ul><li>反汇编：llvm-objdump<ul><li>目标文件反汇编：<code>objdump -s -d main.o &gt; main.o.txt</code> &#x2F;&#x2F;将main.o 反汇编并将结果输出到txt文件中。</li><li>可执行文件反汇编： <code>objdump -s -d main&gt; main.txt</code></li></ul></li></ul><p><strong>objdump反汇编常用参数</strong></p><ul><li><code>objdump -d &lt;file(s)&gt;</code>: 将代码段反汇编；</li><li><code>objdump -S &lt;file(s)&gt;</code>: 将代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用 <code>g</code>参数，即需要调试信息；</li><li><code>objdump -C &lt;file(s)&gt;</code>: 将C++符号名逆向解析</li><li><code>objdump -l &lt;file(s)&gt;</code>: 反汇编代码中插入文件名和行号</li><li><code>objdump -j section &lt;file(s)&gt;</code>: 仅反汇编指定的section</li></ul><h1 id="Lab1：单周期CPU"><a href="#Lab1：单周期CPU" class="headerlink" title="Lab1：单周期CPU"></a>Lab1：单周期CPU</h1><p>本实验的目的：理解 CPU 的基本结构以及 CPU 是如何执行指令的。</p><ul><li><strong>基本概念</strong>，然后会按照指令执行的步骤逐步<strong>构造数据通路和控制单元</strong>（期间会留有填写代码的任务，请记得完成），最终构造成一个<strong>简单的单周期 RISC-V 处理器。</strong></li></ul><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><ul><li>数据通路：显示数据从一个组件流向另一个组件的所有方式。</li><li>控制信号：让各个数据通路部件知道自己要干什么。CPU 原理图中的 <strong>Decoder、ALUControl、JumpJudge</strong> 三个元件都可以看作控制单元。他们接收指令并输出控制信号。</li><li>组合单元与状态单元：组合逻辑电路构成的单元叫组合单元，时序逻辑电路构成的单元叫做状态单元。<ul><li>本实验中只有<strong>寄存器</strong>属于<strong>状态单元</strong>（内存不属于 CPU 内核的范畴），其余的均为组合单元。</li><li>组合单元：输出只取决于当前的输入，并且<strong>不需要时钟作为触发条件</strong>，输入会立即（不考虑延时）反映到输出</li><li>状态单元：存储了状态，并且<strong>以时钟作为触发条件</strong>，时钟的上升沿到来时输入才会反映到输出</li></ul></li></ul><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p>我们设计的 RISC-V CPU 能执行 RISC-V 指令的一个核心子集（RV32I）：</p><ul><li>算术逻辑指令：<code>add</code>、<code>sub</code>、<code>slt</code> 等</li><li>存储器访问指令：<code>lb</code>、<code>lw</code>、<code>sb</code> 等</li><li>分支指令：<code>beq</code>、<code>jar</code> 等</li></ul><p>我们将执行指令分<strong>为五个不同的阶段</strong>：</p><ul><li>取指：从内存中获取指令数据</li><li>译码：弄清楚这条指令的意义，并读取寄存器数据</li><li>执行：用 ALU 计算结果</li><li>访存（<code>load</code>&#x2F;<code>store</code> 指令）：读写内存</li><li>回写（除了 <code>store</code> 指令外所有指令）：将结果写回寄存器</li></ul><p>下面我们先按照上述步骤<strong>逐步构建数据通路部件</strong>，<strong>然后在 CPU 顶层模块将这些数据通路部件实例化并且连接起来</strong>。（下面涉及的代码都位于 <code>lab1/src/main/scala/riscv</code> 目录下）</p><p><a href="https://blog.csdn.net/weixin_43681766/article/details/122860354">Chisel教程——02.Chisel环境配置和第一个Chisel模块的实现与测试-CSDN博客</a></p><h3 id="取指："><a href="#取指：" class="headerlink" title="取指："></a>取指：</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/1e02e04b-2e21-4de8-a487-b25c0b342f76/image.png" alt="image.png"></p><p>重点：</p><ul><li>理解各个变量都是什么。，我们需要实现的是when指令有效时，先取出pc的当前指令，然后再判断是否需要jump—也就是判断jump_flag_id是否有效，如果有效就要把pc的值换成需要jump到的地址，否则就是顺序执行pc+4；</li><li>主要pc+4这个点，chisel语言写的比较不同4.U表示无符号的整数。</li></ul><p>进行测试：<code>sbt &quot;testOnly riscv.singlecycle.InstructionFetchTest&quot;</code></p><h3 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h3><p>一些知识：</p><ul><li>多路选择器：Mux</li></ul><p><code>Mux</code>类似于传统的三元运算符，参数依次为 <code>(条件, 为真时的值, 为假时的值)</code>，建议用 <code>true.B</code>和 <code>false.B</code>来创建Chisel中的布尔值。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c37be282-9bcc-4705-8144-c6416df8b2c7/image.png" alt="image.png"></p><p>重点：</p><ul><li><p>对于ALUop2，我有个小疑惑，提供的图里是0的时候连接reg，而1连接immediate，但是实际写的时候反过来了。不太理解。<strong>已经理解了，看前面提供的代码发现，所提供的Aluop2source结构体里面，reg对应的值是0，immediate对应的是1，故要对应上。</strong></p></li><li><p>注意不要漏，所有i指令都要添加上，他甚至有一个单独的lui没有被添加，要额外加上。主要就是看那个指令有没有i标识。</p></li><li><p>对于使能指令比较简单，一开始傻傻的还去使用Mux，其实完全没有必要，因为值仅仅是真或假，直接判断是否符合就行了。Mux一般用于给条件后，读取不同值（非0,1）</p><ul><li>只有load指令可以访问内存</li><li>只有store指令可以写入到内存</li><li>故自然而然得到结果</li></ul></li><li><p>稍微困难一点点的是写回输入来源，由于有四个来源，不能使用两个通路的Mux了，要使用MuxLookup。使用指南：</p><ul><li>三个参数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>_<br><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>util._<br><br>val key = <span class="hljs-built_in">Wire</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">3.</span>W))<br>val <span class="hljs-keyword">default</span> = <span class="hljs-number">0.</span>U<br>val lookupTable = <span class="hljs-built_in">Seq</span>(<br>  <span class="hljs-number">0.</span>U -&gt; <span class="hljs-string">&quot;b000&quot;</span>.U,<br>  <span class="hljs-number">1.</span>U -&gt; <span class="hljs-string">&quot;b001&quot;</span>.U,<br>  <span class="hljs-number">2.</span>U -&gt; <span class="hljs-string">&quot;b010&quot;</span>.U,<br>  <span class="hljs-number">3.</span>U -&gt; <span class="hljs-string">&quot;b011&quot;</span>.U<br>)<br><br>val result = <span class="hljs-built_in">MuxLookup</span>(key, <span class="hljs-keyword">default</span>, lookupTable)<br></code></pre></td></tr></table></figure><ul><li>两个参数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>_<br><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>util._<br><br>val key = <span class="hljs-built_in">Wire</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">3.</span>W))<br>val <span class="hljs-keyword">default</span> = <span class="hljs-number">0.</span>U<br>val lookupTable = <span class="hljs-built_in">Seq</span>(<br>  <span class="hljs-number">0.</span>U -&gt; <span class="hljs-string">&quot;b000&quot;</span>.U,<br>  <span class="hljs-number">1.</span>U -&gt; <span class="hljs-string">&quot;b001&quot;</span>.U,<br>  <span class="hljs-number">2.</span>U -&gt; <span class="hljs-string">&quot;b010&quot;</span>.U,<br>  <span class="hljs-number">3.</span>U -&gt; <span class="hljs-string">&quot;b011&quot;</span>.U<br>)<br><br>val result = <span class="hljs-built_in">MuxLookup</span>(key, <span class="hljs-keyword">default</span>)(lookupTable)<br></code></pre></td></tr></table></figure><p>seq表示有序集合&#x2F;序列。然后箭头左右表示的是一种映射关系。</p></li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/cf433301-39de-45c2-96fe-9525ae145101/image.png" alt="image.png"></p><ul><li>目的：给ALU的输入端口赋值。</li><li>我们要看到ALU.scala实现文件：</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/75f5ed2a-c27b-4143-b645-20e150da257d/image.png" alt="image.png"></p><p>可以看到我们需要传入的是alu执行什么功能，op1和op2，然后他会计算出结果result。至于func的来源就是ALU_control，里面有一个output是会根据指令内容来输出alu_funct。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/583e23ee-4823-4aea-8aa4-ca69b16a7691/image.png" alt="image.png"></p><p>值得注意的是，我们在得到op1和op2时，op1_source和op2_source均是指示变量（类似于bool）表示输入来源，而没有运用我们上一个模块写的 如下：（或许是还没有到组合成一个完整单周期CPU的时候，尚且在一个周期一个周期实现，且各种数据来源比较割裂）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/62affc69-210d-4c60-9ef5-9b57ae74a723/image.png" alt="image.png"></p><h3 id="访存"><a href="#访存" class="headerlink" title="访存"></a>访存</h3><ul><li>只有load和store才有访存阶段。数据从内存读到寄存器或者反过来。</li><li>判断读还是写看 memory_read_enable使能，为1则read，反之write。</li></ul><h3 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h3><p>多路选择器，决定从哪里得到写回的数据。</p><h3 id="组成CPU"><a href="#组成CPU" class="headerlink" title="组成CPU"></a>组成CPU</h3><ul><li>CPUBundle 是 CPU 和内存等外设进行数据交换的通道。</li></ul><h1 id="烧板"><a href="#烧板" class="headerlink" title="烧板"></a>烧板</h1><ol><li>生成verilator文件（运行Top.scala)</li></ol><aside>💡<p>注意：是在lab1内进行，然后z710v1_3这个包！不是z710v1.3!!!</p></aside><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/554ad192-24f8-471f-81f7-36771022fc8a/image.png" alt="image.png"></p><ol><li><strong>生成 Vivado 项目</strong></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/259f6157-65c2-40b3-b8a5-b99a37013dba/image.png" alt="image.png"></p><ol><li>生成比特流文件</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/53c8d9cd-8206-4f22-b174-1b87584763f5/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4e1943bf-e7f9-4359-a1fa-d8e922338b35/image.png" alt="image.png"></p><ol><li>烧录：由于是在wsl中进行的，会导致没有“驱动”的问题，然后发现了win上之前安装的vivado是可以连接到debian里面的，所以就直接在里面打开，根据program_device.tcl里面的指令（结合vivado中的烧录键），实际上只需要自己多输入最后那步 <code>close_hw_target</code> ，这样子能够保证vitis正常工作。</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c678f2ed-b03e-426e-a1bd-1d93015011d4/image.png" alt="image.png"></p><p>烧录结果：（后打开clock之后，会一闪一闪亮红灯）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/789c4161-6b8e-4d97-bf31-954bcc9a8d27/be3cee1cacb047c90c08ad06a6b68ee.jpg" alt="be3cee1cacb047c90c08ad06a6b68ee.jpg"></p><p>vitis显示如下：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/03254c1f-b2a3-4380-9bb6-e23dc05ed7fe/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17338008355682.png" alt="企业微信截图_17338008355682.png"></p><h2 id="实验报告："><a href="#实验报告：" class="headerlink" title="实验报告："></a>实验报告：</h2><p>合规性测试部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> TARGET_SIM=~/YatCPU/yatcpu23_new/lab1/verilog/verilator/obj_dir/VTop<br><span class="hljs-keyword">export</span> TARGETDIR=~/YatCPU/yatcpu23_new/lab1/riscv-target<br><span class="hljs-keyword">export</span> RISCV_TARGET=yatcpu<br>make<br></code></pre></td></tr></table></figure><aside>💡<p>如果要测试其他的lab要注意把路径修改了</p></aside><p>lab2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># 测试 lab2 的 CPU<br><span class="hljs-keyword">export</span> TARGET_SIM=~/YatCPU/yatcpu23_new/lab2/verilog/verilator/obj_dir/VTop<br><span class="hljs-keyword">export</span> TARGETDIR=~/YatCPU/yatcpu23_new/lab2/riscv-target<br><span class="hljs-keyword">export</span> RISCV_TARGET=yatcpu<br></code></pre></td></tr></table></figure><p>lab3:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># 测试 lab3 的 CPU<br><span class="hljs-keyword">export</span> TARGET_SIM=~/YatCPU/yatcpu23_new/lab3/verilog/verilator/obj_dir/VTop<br><span class="hljs-keyword">export</span> TARGETDIR=~/YatCPU/yatcpu23_new/lab3/riscv-target<br><span class="hljs-keyword">export</span> RISCV_TARGET=yatcpu<br></code></pre></td></tr></table></figure><p>lab1的测试结果：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9152e9ef-2e5b-4ee9-be3c-650d1784d6bd/32d668896c5b7ecbacf247af766530d.png" alt="32d668896c5b7ecbacf247af766530d.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9152e9ef-2e5b-4ee9-be3c-650d1784d6bd/32d668896c5b7ecbacf247af766530d.png" alt="32d668896c5b7ecbacf247af766530d.png"></p><h1 id="Lab2中断"><a href="#Lab2中断" class="headerlink" title="Lab2中断"></a>Lab2中断</h1><p>实验目的：</p><ul><li>学习CSR寄存器及其操作命令</li><li>中断控制器的原理和设计</li><li>编写一个简单的定时中断发生器</li></ul><h2 id="CSR寄存器的操作命令："><a href="#CSR寄存器的操作命令：" class="headerlink" title="CSR寄存器的操作命令："></a>CSR寄存器的操作命令：</h2><h3 id="回顾：中断和异常"><a href="#回顾：中断和异常" class="headerlink" title="回顾：中断和异常"></a>回顾：中断和异常</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/2d2dbece-9226-4a85-ad6a-28ff2a170cdb/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/7563df56-5735-4444-a001-17f6ca6ecd14/image.png" alt="image.png"></p><h3 id="CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。"><a href="#CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。" class="headerlink" title="CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。"></a>CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。</h3><ul><li>mstatus寄存器：记录<strong>机器模式下的状态</strong>（status），如中断是否启用等。</li><li>mepc寄存器：保存了<strong>终端返回后需要执行的指令地址</strong>，当 CPU 执行中断时，<code>mepc</code> 寄存器被自动设置为当前指令的地址，如果 <code>EX</code> 阶段正在执行跳转，则设置为跳转的目标地址。</li><li>mcause寄存器：保存了中断的<strong>原因</strong></li><li>mtvec寄存器：保存了<strong>中断处理程序</strong>的地址。发生执行中断时会传给pc寄存器</li><li>中断发生时，CPU需要清空并阻塞流水线，并在CSR寄存器写入中断相关的信息。由于CSR寄存器堆实现只有一个读写端口，故需要多个周期才能写入CSR寄存器。写完后，发出控制信号，开始处理。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9f9ceea2-a7f4-4560-810d-ce43a10e3c71/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/00dc7cf5-97b3-424c-8922-a71d85ffb886/image.png" alt="image.png"></p><h3 id="中断处理程序：实现更加复杂的功能。"><a href="#中断处理程序：实现更加复杂的功能。" class="headerlink" title="中断处理程序：实现更加复杂的功能。"></a>中断处理程序：实现更加复杂的功能。</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/e0ec95e0-c34c-440a-a56a-0dfe2d089312/image.png" alt="image.png"></p><ul><li>我们可以将CSR指令分解为：CSR寄存器组，ID译码单元，EX执行单元，WB写回单元。<ul><li>CSR寄存器组需要根据<strong>ID模块译码后给出的控制信号</strong>和<strong>CSR寄存器地址</strong>来对内部寄存器进行寻址，获取其内容并修改。</li><li>ID译码单元需要识别CSR指令。（看手册）</li><li>EX执行单元：CSR 指令都是<strong>原子读写</strong>的，即一条指令的执行结果中，既要把<strong>目标 CSR 寄存器原来的内容</strong>写入到<strong>目标通用寄存器</strong>中，还要按指令语义把从目标 CSR 寄存器读出来的<strong>内容修改之后再写回给该CSR 寄存器</strong>。此时 EX 里面的 ALU 单元是<strong>空闲</strong>的，要得到写入 CSR 寄存器的值，可以复用 ALU，也可以不复用。</li><li>WB写回单元：支持 CSR 相关操作指令后，<strong>写回到目标通用寄存器</strong>的数据来源就多了一个<strong>从目标 CSR 寄存器读出来的修改前的值</strong>。</li></ul></li></ul><h2 id="中断控制器CLINT"><a href="#中断控制器CLINT" class="headerlink" title="中断控制器CLINT"></a>中断控制器CLINT</h2><blockquote><p>检测外部中断，并在中断到来并且中断使能时，中断CPU目前执行流，设置好相关的CSR信息后跳转到中断处理程序。</p></blockquote><ul><li>保存到CSR寄存器的信息：<strong>CPU执行完当前指令的下一个状态。</strong></li><li>让当前指令执行完后再跳转到中断处理程序</li></ul><h3 id="响应（硬件）中断"><a href="#响应（硬件）中断" class="headerlink" title="响应（硬件）中断"></a>响应（硬件）中断</h3><p><a href="https://blog.csdn.net/zyhse/article/details/136390088">https://blog.csdn.net/zyhse/article/details/136390088</a></p><ul><li>获取CPU下一个状态信息，一个周期内写入到相应的寄存器。</li></ul><p>写入的内容包括：mepc，mcause，mstatus。</p><ul><li><p><code>mepc</code>：保存的是中断或者异常处理完成后，CPU返回并开始执行的地址。所以对于异常和中断，<code>mepc</code> 的保存内容需要注意。</p></li><li><p><code>mcause</code>：保存的是导致中断或者异常的原因，具体内容请查阅特权级手册里的相关内容。</p></li><li><p><code>mstatus</code>：在响应中断时，需要将 <code>mstatus</code> 寄存器中的 <code>MPIE</code> 标志位设置为 <code>0</code>，禁用中断。</p><ul><li><strong>注意注意注意：这里不是自己手动地将MPIE位设置为0，是将MIE位设置为0，然后硬件会自动的把MPIE位修改</strong>然后从 <code>mtvec</code> 获取中断处理程序的地址，跳转到该地址执行进一步的中断处理</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9f234702-1688-497c-8010-651f7dc53f7e/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/cd72c169-cbfe-45be-8a44-4989200794d3/image.png" alt="image.png"></p></li></ul><p>该部分的代码截图：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/01c995c9-3901-4573-a576-d4f29ed0dba3/image.png" alt="image.png"></p><p>解释：disable_interrupt是用来修改MIE位的，并且让后续禁用中断（因为我们要保证不会发生中断嵌套）</p><p>然后看到数据中的信号连接：</p><ul><li>着重提醒mcause的原因，我们在同一个文件的最上方看到了Status的结构体定义，了解到就这么几种，并没有把所有的原因都列举出来，所以暂时只需要这样子写。（更多的mcause原因可以查看后面的截图或者直接看特权手册第二卷）</li></ul><p><strong>mstatus的指令结构：</strong></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/1f1384af-b7e5-4fe5-8998-67b49e091e5b/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/a2857746-2f3c-48b8-82ba-81bfe76bc25c/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/bf9f34e1-6e68-4368-8b05-842a2af9d624/image.png" alt="image.png"></p><h3 id="（硬件）中断返回"><a href="#（硬件）中断返回" class="headerlink" title="（硬件）中断返回"></a>（硬件）中断返回</h3><p>需要写入的寄存器：mstatus</p><p>从mepc中获取跳转目标地址（原本正常执行的下一条地址）</p><p>把 <strong>MIE</strong> 位置为 <strong>MPIE 位</strong>，那么 MPIE 为 1 的话 <code>mret</code> 就会恢复中断，如果 MPIE 为 0 的话，<code>mret</code> 则不改变 <code>mstatus</code> 的值，这也导致了我们不支持中断嵌套。</p><p>CLINT的实现：for简单—采用纯组合逻辑实现。</p><p>CLINT 需要<strong>一个周期</strong>就<strong>把多个寄存器的内容修改</strong>的功能，而<strong>正常的 CSR 指令只能对一个</strong>寄存器读-修改-写（Read-Modify-Write, RMW）。所以 CLINT 和 CSR 之间有独立的优先级更高的通路，用来<strong>快速更新</strong> CSR 寄存器的值。</p><p>一个好的解释：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/16c62b2d-399d-46fe-8508-9c953d559c9f/image.png" alt="image.png"></p><h2 id="简单的定时中断发生器"><a href="#简单的定时中断发生器" class="headerlink" title="简单的定时中断发生器"></a>简单的定时中断发生器</h2><p>MMIO的定时中断发生器—Timer</p><blockquote><p>MMIO 简单来说就是：<strong>该外设用来和 CPU 交互的寄存器是与内存一起编址的</strong>，所以 CPU 可以通过<strong>访存指令</strong>（load&#x2F;store）来修改这些寄存器的值，从而达到 CPU 和外设交互的目的。</p></blockquote><p>CPU发出的逻辑地址要发送到哪个设备，就由<strong>逻辑地址的高位</strong>作为<strong>外围设备的位选信号</strong>即可，<strong>低位</strong>则用于<strong>设备内部</strong>的寻址。</p><h2 id="实验任务："><a href="#实验任务：" class="headerlink" title="实验任务："></a>实验任务：</h2><ol><li>EX 执行单元在处理 CSR 指令时能够<strong>正确地得到写入 CSR 寄存器的数据</strong>。（done</li><li>CSR 寄存器组可以<strong>正确支持CLINT和来自CSR指令的读写操作</strong>。（done</li><li>定时中断发生器可以<strong>正确产生中断信号</strong>，并且<strong>实现 Timer 寄存器的 MMIO</strong>。</li><li>CLINT 能够<strong>正确的响应中断</strong>并且<strong>在中断结束后回到原来的执行流</strong>。（done</li></ol><p>如果能够正确完成本次实验，那么你的 CPU 就可以运行更加复杂的程序了，可以运行一下俄罗斯方块程序试试，如果想要上手玩的话，也许需要一个串口转接板，这样就可以通过电脑的键盘通过 UART 串口给程序输入字符了。</p><h3 id="任务1：EX-执行单元在处理-CSR-指令时能够正确地得到写入-CSR-寄存器的数据"><a href="#任务1：EX-执行单元在处理-CSR-指令时能够正确地得到写入-CSR-寄存器的数据" class="headerlink" title="任务1：EX 执行单元在处理 CSR 指令时能够正确地得到写入 CSR 寄存器的数据"></a>任务1：EX 执行单元在处理 CSR 指令时能够<strong>正确地得到写入 CSR 寄存器的数据</strong></h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4290bbb4-24b4-44c9-9160-13af9a9b6da6/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c3f7e361-4110-4940-aab4-ba28ad60defb/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/e585e7a2-a06a-4c05-aab6-e1dc23232281/0a3f20ee132b54699d4134c1320040d.png" alt="0a3f20ee132b54699d4134c1320040d.png"></p><p>这个地方要注意，csr寄存器的立即数和之前译码阶段的立即数是不太一样的。译码阶段取立即数主要是针对立即数长度or位置不同于一般指令的进行获取。（如图）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/918f657a-115b-4ba0-82d6-ed9486d52f0f/image.png" alt="image.png"></p><p>从上方的指令划分的图中可以看到，crs寄存器的立即数和R指令寄存器指令取寄存器数是一样的（15-19）→ 在上图也是可以看到<strong>目标寄存器的值和立即数来源都是rs1</strong>，故后面只用在此处取值就行了。唯一的区别是第二个寄存器加上原本的func7组合在一起合成了crs寄存器的func7指示。（附上译码阶段的取指令的图：其中rs1对应的数据存储到reg1_data，rs2对应的数据存储到reg2_data—但此处是应该被忽略的，因为rs2部分的数据被合并到了func7中） <strong>mips的rs，rt的位置是确定的。</strong></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/41cd5ebf-b1d8-4c44-a4b1-550bebbc029c/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/8246c754-17b2-4c49-ace1-6581ed7d8f24/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/ce9f61ea-c7ce-4fd9-9e4e-9030d6b0f349/image.png" alt="image.png"></p><p>要注意的是，uimm是15-19位的原码，而source是rs1里面的值</p><p>任务一结果：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/8c80ac24-145b-4414-8515-263cf7038800/image.png" alt="image.png"></p><h3 id="任务2：CSR-寄存器组可以正确支持CLINT和来自CSR指令的读写操作。"><a href="#任务2：CSR-寄存器组可以正确支持CLINT和来自CSR指令的读写操作。" class="headerlink" title="任务2：CSR 寄存器组可以正确支持CLINT和来自CSR指令的读写操作。"></a>任务2：CSR 寄存器组可以<strong>正确支持CLINT和来自CSR指令的读写操作</strong>。</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c1ed0bf3-0f89-469a-89f3-10e24ee656b6/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4604f572-0a2d-4805-ab6e-a522ad2f8832/image.png" alt="image.png"></p><ul><li><code>CSRRegister.CycleL</code> 和 <code>CSRRegister.CycleH</code> 这两个参数通常是用于访问或设置 CSR（Control and Status Registers）寄存器中的低位和高位的值。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/0a3ec965-8a4a-46d3-be51-7b0073b5844a/image.png" alt="image.png"></p><p>首先我们看到CSR中需要我们实现的是可以正确读取CSR寄存器组的信息，并且可以正确与CLINT交互—将信息传到CLINT）</p><p>然后我们看到提示写了：如果数据线与CLINT冲突了，我们需要优先进行数据更新，这样子保证了CLINT读到的数是最新的。</p><p>我们可以借鉴已经写好的代码中判断条件的方法：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/26456738-a558-452b-b30f-c0748264ac9c/image.png" alt="image.png"></p><p>可以看到如果需要进行数据更新，要判断reg_write_enable_id是否为1，然后判断对应的地址是哪一个—&gt;对应了需要更改的那一个寄存器的值。使用Mux来进行数据选择，如果条件满足，那么输入到CLINT中的值是reg_write_data_ex，若不满足则输入旧的值（也就是前面读取的寄存器组原本的值）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/0337e759-5933-4113-884e-ff789094a897/image.png" alt="image.png"></p><h3 id="功能3：定时中断发生器可以正确产生中断信号，并且实现-Timer-寄存器的-MMIO"><a href="#功能3：定时中断发生器可以正确产生中断信号，并且实现-Timer-寄存器的-MMIO" class="headerlink" title="功能3：定时中断发生器可以正确产生中断信号，并且实现 Timer 寄存器的 MMIO"></a>功能3：定时中断发生器可以<strong>正确产生中断信号</strong>，并且<strong>实现 Timer 寄存器的 MMIO</strong></h3><p>实现一个MMIO的定时中断发生器—timer</p><p>MMIO：该外设用来和CPU交互的寄存器一起编址，这样子CPU就可以通过访存指令来修改这些寄存器的值，从而实现CPU与外设交互。即内存映射。</p><p>没有总线时可以使用<strong>多路选择器（即现在阶段用多路选择器实现）</strong></p><p>内部逻辑：两个控制寄存器 <code>enable</code> 寄存器和 <code>limit</code> 寄存器。</p><ul><li><code>enable</code> 寄存器：控制定时中断发生器的使能，为false则不产生中断，映射到地址空间的逻辑地址为0x80000008.</li><li><code>limit</code> 寄存器：用来控制定时器的<strong>中断发生间隔</strong>。映射到地址空间逻辑地址：0x80000004。内部有个加一计数器，达到limit为标准的界限时，定时器会发生一次中断信号（enable使能）。注：产生中断信号的时长没有太大关系，但是至少应该大于一个 CPU 时钟周期，确保 CPU 能够正确捕捉到该信号即可。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/3ff93292-0ed1-4ab4-9067-d05f7ce5f71d/image.png" alt="image.png"></p><h3 id="任务4：CLINT-能够正确的响应中断并且在中断结束后回到原来的执行流（更多内容在前面中断概念处）"><a href="#任务4：CLINT-能够正确的响应中断并且在中断结束后回到原来的执行流（更多内容在前面中断概念处）" class="headerlink" title="任务4：CLINT 能够正确的响应中断并且在中断结束后回到原来的执行流（更多内容在前面中断概念处）"></a>任务4：CLINT 能够<strong>正确的响应中断</strong>并且<strong>在中断结束后回到原来的执行流（更多内容在前面中断概念处）</strong></h3><p><a href="https://www.notion.so/13c279ae70e5804f81ddd90e124a9031?pvs=21"></a></p><p>CLINT的一些理解概念：</p><ol><li><code>CLINT</code> 具有固定的优先级方案，但不支持给定特权级别内的嵌套中断（抢占）。 然而，较高的特权级别可能会抢占较低的特权级别。 <code>CLINT</code> 提供两种操作模式，<strong>直接模式</strong>和<strong>向量模式</strong>。<ul><li>在<strong>直接模式</strong>下，所有中断和异常都会捕获到 <code>mtvec.BASE</code>。</li><li>在<strong>向量模式</strong>下，异常trap到 <code>mtvec.BASE</code>，但中断将直接跳转到它们的向量表索引。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c90f1260-7c99-43fe-a793-12f91fc1e8de/image.png" alt="image.png"></p><ol><li><p>一些代码解释：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/014468d7-0c6f-4128-b775-3af358158014/image.png" alt="image.png"></p></li></ol><p>InterruptStatus对象：</p><ul><li>定义了中断状态的常量值</li><li>None表示<strong>没有中断</strong></li><li>Timer0表示<strong>计时器0中断</strong></li><li>Ret表示<strong>返回状态</strong></li></ul><p>InterruptEntry对象：</p><ul><li>定义了中断入口地址的常量值</li><li>Timer0表示计时器0中断入口地址</li></ul><p>InterruptState对象：</p><ul><li>定义了中断状态机的不同状态</li><li>Idle：空闲状态</li><li>SyncAssert：同步断言状态</li><li>AsyncAssert：异步断言状态</li><li>MRET：表示<strong>从中断返回的状态</strong></li></ul><p>CSRState对象：</p><ul><li>定义了CSR状态机的不同状态。</li><li><code>Idle</code>: 空闲状态，值为 <code>0x0</code>。</li><li><code>Traping</code>: 陷入状态，值为 <code>0x1</code>。</li><li><code>Mret</code>: 从中断返回状态，值为 <code>0x2</code>。</li></ul><ol><li>mstatus寄存器和mcause寄存器</li></ol><p>mstatus指令结构：（我们使用到的是32位的</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/ac86d63c-db93-450c-af66-afca0d8b3780/image.png" alt="image.png"></p><p>mcause指令相关：</p><p>可能出现的机器级异常代码</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/352d620c-634d-4c50-bdf5-ebe48e1b9965/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/f6c30f66-840f-4f01-8bb3-dd88c86f1b68/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/dccae40f-4b27-4782-9a55-5e52cb8e85b2/image.png" alt="image.png"></p><p>mtvec</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/101d1622-416f-43d9-85f1-c51130896ea7/image.png" alt="image.png"></p><h1 id="Lab3流水线CPU"><a href="#Lab3流水线CPU" class="headerlink" title="Lab3流水线CPU"></a>Lab3流水线CPU</h1><h2 id="内容简介："><a href="#内容简介：" class="headerlink" title="内容简介："></a>内容简介：</h2><ul><li><strong>竞争冒险</strong>的处理是流水线 CPU 设计的难点和关键所在。</li><li>设计一个简单的三级流水线 CPU（IF、ID 和 EX 三级），它只涉及<strong>分支和跳转指令</strong>带来的控制冒险，然后，我们再将三级流水线 CPU 的 EX 级<strong>继续切分为 EX、MEM 和 WB</strong>，形成经典的<strong>五级流水线</strong>，这样做带来的数据冒险需要使用<strong>阻塞和转发技术</strong>进行处理；最后，我们将<strong>分支和跳转提前到 ID 阶段，进一步缩短分支延迟。</strong></li><li>参考资料：计组黑书4.5-4.8节</li><li>学习：<ul><li>使用流水线设计缩短关键路径</li><li>正确处理流水线阻塞与清空</li><li>使用转发逻辑减少流水线阻塞</li></ul></li></ul><h2 id="流水线寄存器："><a href="#流水线寄存器：" class="headerlink" title="流水线寄存器："></a>流水线寄存器：</h2><blockquote><p>缓存作用，切分组合逻辑，缩短关键路径。（存储该阶段产生的各种信息和数据。</p></blockquote><p>基本功能：</p><ul><li>在每一个时钟周期，根据复位（流水线清空）或阻塞（流水线暂停）的状态，将寄存器内容情况、保持或设置为新的值。输出则为其中保存的值。</li><li>为了方便复用，我们可以定义一个带参数的 <code>PipelineRegister</code> 模块，用来实现<strong>不同数据位宽</strong>的流水线寄存器。</li></ul><h3 id="task0：补充完成PipelineRegister-scala"><a href="#task0：补充完成PipelineRegister-scala" class="headerlink" title="task0：补充完成PipelineRegister.scala"></a>task0：补充完成PipelineRegister.scala</h3><ul><li><code>stall</code> 和 <code>flush</code> 分别为流水线寄存器的阻塞和清空信号，<code>in</code> 和 <code>out</code> 分别为要写入寄存器的值和寄存器的当前值。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/fe542da7-c626-465f-b174-a1ee4cbf654d/image.png" alt="image.png"></p><ul><li>解释：我们要存储结果，并且下一个阶段有可能还要用到前面那个阶段的状态信息，所以要用寄存器来传递、存储。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/98781a7b-ca69-4696-9949-fd8e6da27fc3/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9205658e-ebfb-4015-857f-cbd9e11ccd76/image.png" alt="image.png"></p><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table><thead><tr><th>特性</th><th>Scala 变量 (<code>var</code>)</th><th>Chisel 寄存器 (<code>Reg</code>)</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>软件变量，临时存储值</td><td>硬件寄存器，存储状态</td></tr><tr><td><strong>硬件生成</strong></td><td>不生成硬件</td><td>生成硬件寄存器</td></tr><tr><td><strong>值的更新</strong></td><td>随程序执行更新</td><td>时钟边沿更新</td></tr><tr><td><strong>硬件复位</strong></td><td>不支持复位行为</td><td>可设置复位值 (<code>RegInit</code>)</td></tr><tr><td><strong>用途</strong></td><td>软件逻辑辅助计算</td><td>描述硬件逻辑和状态存储</td></tr></tbody></table><h1 id="三级流水线"><a href="#三级流水线" class="headerlink" title="三级流水线"></a>三级流水线</h1><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/77588407-9a56-4bfd-a311-c27e63aa638b/image.png" alt="image.png"></p><ul><li>两组流水线寄存器：<code>IF2ID</code> 和 <code>ID2EX</code> 划分出三个阶段。（已写好）<ul><li>取指（Instruction Fetch，IF）：根据 PC 中的指令地址从内存中取出指令码；</li><li>译码（Instruction Decode，ID）：将指令码解码为控制信号并从寄存器组中读取操作数；</li><li>执行（Execute，EX）：包括 ALU 运算、访问内存和结果写回。</li></ul></li></ul><h2 id="处理竞争冒险"><a href="#处理竞争冒险" class="headerlink" title="处理竞争冒险"></a>处理竞争冒险</h2><h3 id="解决控制冒险—清空"><a href="#解决控制冒险—清空" class="headerlink" title="解决控制冒险—清空"></a>解决控制冒险—清空</h3><ul><li>由于所有数据处理都在EX阶段，不会出现数据冲突，无需考虑。我们只需处理程序跳转（beq指令等）带来的控制冒险。<ul><li>EX执行到跳转指令</li><li>EX端执行到分支指令且分支成立</li><li>发生中断，接收到CLINT发来的中断信号 <code>InterruptAssert</code> 。相当于在EX指令至上叠加了跳转指令，要丢弃之前的—IF和ID</li></ul></li><li>无论哪种情况，都是由 EX 段向 IF 段发送跳转信号 <code>jump_flag</code> 和跳转的目标地址 <code>jump_address</code>，但在 <code>jump_address</code> 写入 PC 并从该处取出指令前，流水线的 IF 和 ID 段已经各有两条不需要执行的指令，好在这两条指令的结果还没有写回，我们<strong>只需要清空对应的流水线寄存器，把它们变成两条空指令即可</strong>。</li><li>我们用一个控制单元来检测控制冒险并清空流水线，模块定义在 <code>src/main/scala/riscv/core/threestage/Control.scala</code>，为了避免此题过于简单（呵呵，我们没有提供模块接口，请根据以上分析确定模块的输入输出，在 <code>// Lab3(Flush)</code> 处将代码补充完整，并在 <code>src/main/scala/riscv/core/threestage/CPU.scala</code> 的 <code>// Lab3(Flush)</code> 处补充相关连线，使其能够通过 <code>ThreeStageCPUTest</code> 测试。</li></ul><p>control：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/68544734-4bbe-4c2a-95a8-99741b0439af/image.png" alt="image.png"></p><p>如果传入了要跳转的信号，那我们控制器需要输出信号，确保能把IF和ID两个阶段清空</p><p>CPU：与control连线。</p><p>首先要保证输入信息传入；注意的是Interrupt_flag 信号的来源</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/5a7c860b-c017-4301-a7ae-9eed85779f86/image.png" alt="image.png"></p><h2 id="五级流水线"><a href="#五级流水线" class="headerlink" title="五级流水线"></a>五级流水线</h2><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/e53ad942-ff47-49fa-8379-667fa1a0649c/five_stage_pipelined_CPU_structure.png" alt="five_stage_pipelined_CPU_structure.png"></p><blockquote><p>注意，上面的 CPU 结构图是我们完成所有实验之后的结果，在完成“缩短分支延迟”实验之前，我们 CPU 的结构将与上图稍有不同。例如，我们紧接着讨论的五级流水线 CPU 在 EX 阶段判断程序是否发生跳转，而不是 ID 阶段。</p></blockquote><ul><li>使用阻塞的方式解决数据冒险（由于数据的处理不止在执行阶段了，所以会出现数据冒险），使用**旁路和将分支跳转提前到ID阶段（这两步选做）**进一步提升效率。</li></ul><h2 id="解决数据冒险：阻塞"><a href="#解决数据冒险：阻塞" class="headerlink" title="解决数据冒险：阻塞"></a>解决数据冒险：阻塞</h2><ul><li>当处于 ID 阶段的指令要读取的寄存器依赖于 EX 或 MEM 阶段的指令时，发生数据冒险。可以保持这IF和ID阶段状态不变，直到相关数据被放出来。</li><li>位于 ID 阶段的指令和位于 WB 阶段的指令之间不会发生数据冒险，这是因为我们的寄存器组模拟实现了 <strong>Double Pumping</strong> 功能，即 WB 阶段在前半个时钟周期向寄存器组写入数据，ID 阶段在后半个时钟周期从寄存器组读出数据（读写分离）。</li><li>值得注意的是，我们在阻塞 PC 和 IF2ID 寄存器以保持 IF 和 ID 阶段不变的同时，需要<strong>清空 ID2EX 寄存器</strong>以在 EX 阶段插入空指令（“气泡”），否则 ID 阶段的指令还是会进入 EX 阶段，这样就不是“阻塞”，而变成“重复”了。</li><li><code>jalr</code> 是跳转指令，虽然它后面两条指令依赖于它写入的寄存器，但是它们本就不应该紧接着被执行，而是应该被清空，所以在第 10 个时钟周期应该清空 IF2ID 和 ID2EX 寄存器，而不是阻塞。</li></ul><aside>💡<p>特别提示：除了以上讨论的情况之外，寄存器 <code>x0</code> 在 risc-v 中具有特殊作用，以它为目标寄存器的指令的结果将被丢弃，也就是说，只依赖于 <code>x0</code> 的指令并不需要阻塞。</p></aside><table><thead><tr><th><strong>情况</strong></th><th><strong>PC阻塞</strong></th><th><strong>IF2ID阻塞</strong></th><th><strong>ID2EX清空</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>数据冒险（ID依赖EX或MEM）</strong></td><td>是</td><td>是</td><td><strong>是</strong></td><td>保持当前指令状态，防止错误执行</td></tr><tr><td>数据冒险（ID依赖WB）</td><td>否</td><td>否</td><td>否</td><td>WB 阶段支持双抽泵，不需要阻塞</td></tr><tr><td>控制冒险（跳转指令如jalr）</td><td>否</td><td>是</td><td>是</td><td>跳转指令需要清空后续流水段，移除错误指令</td></tr><tr><td><strong>依赖寄存器x0</strong></td><td>否</td><td>否</td><td>否</td><td>x0结果总是0，无需阻塞</td></tr></tbody></table><h3 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑：</strong></h3><ol><li><strong>数据冒险检测（依赖判断）</strong>：<ul><li><strong>EX 阶段的寄存器写入</strong>：如果 ID 阶段的指令需要读取的寄存器（<code>rs1_id</code> 或 <code>rs2_id</code>）依赖 <strong>EX 阶段的目标寄存器</strong>（<code>rd_ex</code>），需要阻塞。</li><li><strong>MEM 阶段的寄存器写入</strong>：如果 ID 阶段的指令依赖 MEM 阶段的<strong>目标寄存器</strong>（<code>rd_mem</code>），需要阻塞。</li></ul></li><li><strong>清空信号</strong>：<ul><li><strong>控制冒险（跳转指令）</strong>：遇到跳转信号（<code>jump_flag</code>），需要清空 IF 和 ID 阶段的指令。</li></ul></li><li><strong>阻塞信号</strong>：<ul><li><strong>PC 阻塞与 IF 阶段阻塞</strong>：在数据冒险发生时，需要阻塞 PC 和 IF 阶段，保持当前指令不变。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/b390bac4-81eb-4f10-b142-8fff15dc4c84/image.png" alt="image.png"></p><h2 id="拓展：使用旁路（转发）减少阻塞"><a href="#拓展：使用旁路（转发）减少阻塞" class="headerlink" title="拓展：使用旁路（转发）减少阻塞"></a><strong>拓展：使用旁路（转发）减少阻塞</strong></h2><ul><li>用一个<strong>控制单元</strong>来处理流水线的阻塞和清空</li><li>用一个<strong>旁路单元</strong>来检测数据冒险并发出旁路控制信号</li><li>在执行单元中根据旁路单元的控制信号使用对应的旁路数据</li></ul><p>Control：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/d00468fd-4e0c-4ba0-8f3d-423913238ec5/image.png" alt="image.png"></p><p>Forwarding：检测数据冒险（看是否存在冲突），发出转发信号。看是与那个寄存器冲突。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/020768f4-d436-4200-b667-e990d2e82cfe/image.png" alt="image.png"></p><p>Execute：看CPU流程图，可以得知数据的来源有两类，直接得到（已经写回了的数据，直接从寄存器中得到），发生数据冒险的数据（看写到了哪个寄存器中，如果是ex2mem，则从mem转发，如果是mem2wb，就从wb转发</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/73fd5c72-194a-4538-ab08-de2d7e6b797d/image.png" alt="image.png"></p><h2 id="拓展：缩短分支延迟"><a href="#拓展：缩短分支延迟" class="headerlink" title="拓展：缩短分支延迟"></a><strong>拓展：缩短分支延迟</strong></h2><ul><li>往cpu中加入少量硬件，将分支&#x2F;跳转指令的执行从EX段提前到ID段，进而把程序跳转的损失减少到一个时钟周期</li></ul><p>Steps：</p><ul><li>把<strong>跳转</strong>的判断从EX段移到ID段</li><li>跳转的目标地址原本是在Ex段的ALU进行计算的，故我们要在ID段添加一个加法器来计算目标地址</li><li>添加<strong>额外的旁路逻辑</strong>，将前面指令的执行结果旁路到ID段给分支or跳转指令使用，如果所依赖的结果还没有产生，还需要进行阻塞</li></ul><h3 id="1-在-ID-段实现跳转判断"><a href="#1-在-ID-段实现跳转判断" class="headerlink" title="1. 在 ID 段实现跳转判断"></a>1. <strong>在 ID 段实现跳转判断</strong></h3><ul><li><p><strong>核心目标</strong>：将跳转判断逻辑（如条件跳转的比较）从 EX 段移到 ID 段。</p></li><li><p><strong>具体实现</strong>：</p><ol><li><strong>在 <code>InstructionDecode.scala</code> 中</strong>：<ul><li>定义额外的逻辑单元，用于在 ID 段进行分支条件的比较判断。</li><li>根据分支指令的操作码（opcode）和功能码（funct3），确定需要执行的比较操作（如 <code>==</code>, <code>&lt;</code>, <code>&gt;=</code> 等）。</li><li>添加对寄存器值（<code>rs1</code> 和 <code>rs2</code>）的读取和比较逻辑。</li></ul></li><li><strong>目标地址计算</strong>：<ul><li>添加一个加法器，计算跳转目标地址。跳转目标地址为：<code>PC + offset</code>，其中 <code>offset</code> 是指令中解析出的立即数（<code>imm</code>）。</li><li>在 ID 段，将 PC 和立即数相加生成跳转目标地址。</li></ul></li></ol></li><li><p><strong>示例代码</strong>（在 <code>InstructionDecode.scala</code> 中）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala<br>复制代码<br>when (isBranch) &#123;<br>  branchTarget := currentPC + imm<br>  branchTaken := (rs1Value === rs2Value) <span class="hljs-comment">// Example: BEQ condition</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>如果信号的值需要通过逻辑运算生成或在后续逻辑中被赋值，则需要使用 <code>Wire</code>。</p><hr><h3 id="2-添加旁路逻辑"><a href="#2-添加旁路逻辑" class="headerlink" title="2. 添加旁路逻辑"></a>2. <strong>添加旁路逻辑</strong></h3><ul><li><p><strong>核心目标</strong>：解决跳转判断所依赖的数据可能尚未生成的问题。</p></li><li><p><strong>具体实现</strong>：</p><ol><li>在 <code>Forwarding.scala</code> 中，扩展旁路逻辑，使得 ALU 或存储单元的输出能够在 ID 段被立即使用。</li><li>判断数据依赖的来源：<ul><li>如果依赖的数据在 EX 段，需要旁路 EX 段的 ALU 输出。</li><li>如果依赖的数据在 MEM 段，需要旁路 MEM 段的存储输出。</li></ul></li><li>阻塞处理：<ul><li>如果数据依赖尚未解决（例如还在加载数据），则插入气泡（阻塞流水线）。</li></ul></li></ol></li><li><p><strong>示例代码</strong>（在 <code>Forwarding.scala</code> 中）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala<br>复制代码<br>when (rs1Valid &amp;&amp; rs1Source === <span class="hljs-type">EX_STAGE</span>) &#123;<br>  rs1Value := exAluOutput<br>&#125;.elsewhen (rs1Valid &amp;&amp; rs1Source === <span class="hljs-type">MEM_STAGE</span>) &#123;<br>  rs1Value := memDataOutput<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="3-修改控制逻辑"><a href="#3-修改控制逻辑" class="headerlink" title="3. 修改控制逻辑"></a>3. <strong>修改控制逻辑</strong></h3><ul><li><p><strong>核心目标</strong>：更新 <code>Control.scala</code> 中的控制信号生成逻辑，以支持分支跳转在 ID 段的实现。</p></li><li><p><strong>具体实现</strong>：</p><ol><li>根据指令类型（分支&#x2F;跳转），生成额外的控制信号：<ul><li><code>branchTaken</code>：判断是否跳转。</li><li><code>branchTarget</code>：跳转的目标地址。</li></ul></li><li>在 ID 段判断后，如果确定分支成功，则向流水线发出控制信号清空后续指令（如插入气泡）。</li></ol></li><li><p><strong>示例代码</strong>（在 <code>Control.scala</code> 中）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala<br>复制代码<br>when (branchTaken) &#123;<br>  pcSrc := <span class="hljs-type">BRANCH_TARGET</span><br>  pipelineFlush := <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="4-测试竞争冒险"><a href="#4-测试竞争冒险" class="headerlink" title="4. 测试竞争冒险"></a>4. <strong>测试竞争冒险</strong></h3><ul><li><strong>核心目标</strong>：模拟和解决所有可能的竞争冒险情况。</li><li><strong>指导原则</strong>：<ul><li>测试分支跳转依赖前面指令的结果。例如：<ol><li><code>BEQ R1, R2, offset</code></li><li><code>ADD R1, R3, R4</code></li></ol></li><li>验证是否正确解决数据依赖问题。</li></ul></li><li><strong>测试数据冒险的关键</strong>：<ul><li>如果冒险可通过旁路解决，则确保旁路逻辑正常工作。</li><li>如果旁路无法解决，则检查阻塞是否正常。</li></ul></li></ul><h1 id="lab4：总线"><a href="#lab4：总线" class="headerlink" title="lab4：总线"></a>lab4：总线</h1><ul><li>CPU除了通过内存控制器访问内存以外，还可以通过<strong>总线</strong>访问外部设备。使用总线可以减少电路布线数量以及电路设计复杂度。避免CPU与外部直接连接。（具体的硬件操作则进一步抽象为读写硬件设备上的寄存器）</li></ul><p>在本实验中，你将学习到：</p><ul><li>AXI4-Lite <strong>总线协议原理</strong></li><li>使用<strong>状态机</strong>实现总线协议</li></ul><h2 id="总线前置知识："><a href="#总线前置知识：" class="headerlink" title="总线前置知识："></a>总线前置知识：</h2><blockquote><p>AXI4-Lite总线通信协议</p></blockquote><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/8ed1ed79-32e2-40bd-b47e-610a743bfed5/axi.png" alt="axi.png"></p><p>写地址通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/bd53bcaa-8b4a-4d82-8548-2cc7e7724220/image.png" alt="image.png"></p><p>写数据通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/1212ba2d-d2d2-4448-b215-48f548892a7f/image.png" alt="image.png"></p><p>写响应通道</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/de6abdd7-cddb-41de-80ec-f0674748aeef/image.png" alt="image.png"></p><p>读地址通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4b332481-15c3-4cae-9152-42f3f9f751a9/image.png" alt="image.png"></p><p>读数据通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/bc757076-2d7d-42b6-9a56-fc5623721789/image.png" alt="image.png"></p><p>状态机：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/158b0582-99d3-4e79-a174-8cfcf4599e93/axi-fsm.png" alt="axi-fsm.png"></p><ul><li>总线仲裁：所有设备在通信之前都要检测总线是都占用。**每一个设备则需要增加总线请求线以及总线授权线，连接到总线仲裁器。**在设备需要通过总线传输数据前，需要先通过总线请求线请求总线的访问权限。<strong>总线仲裁器则通过总线授权线来授予访问权限</strong>，从而避免设备之间的冲突。</li><li>总线交换机：类似于网络交换机的方式连接。不同对的设备之间可以通过交换机同时进行通信。</li></ul><h2 id="读操作："><a href="#读操作：" class="headerlink" title="读操作："></a>读操作：</h2><ol><li>IF发出取指信号，包括：读请求（valid）和读地址（pc），如果对应的主机处于空闲状态，则对本次读取做出响应（<strong>空闲→读请求状态</strong>），产生并<strong>发送读请求</strong>（ARVALID），<strong>读地址</strong>（ARADDR）</li><li>当 从机（slave）接收到读请求且处于空闲状态，则返回主机（master）读准备（ARREADY）—表示可以读取。（完成一次读地址的握手</li><li>从机（slave）开始准备需返回的数据（RDATA），读返回请求（RVALID），主机跳变到下一个<strong>读数据状态。</strong></li><li>当主机的RVALID和RREADY完成握手，主机得到目标数据，则产生读完成的信号（RREADY），把数据返还给取值模块，就完成了一次读操作，此时主机跳转回空闲状态。</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/6d60b960-c91b-441e-8ae1-95e5787c8d29/image.png" alt="image.png"></p><h2 id="写操作："><a href="#写操作：" class="headerlink" title="写操作："></a>写操作：</h2><blockquote><p>相比读多了一个接收<strong>写回复</strong>（如图）</p></blockquote><ol><li>有总线后的MMIO（已给）</li><li>把总线加到流水线上</li></ol><h2 id="实验任务：-1"><a href="#实验任务：-1" class="headerlink" title="实验任务："></a>实验任务：</h2><ol><li>完成主从设备内部的状态机（按照上面给的状态图）</li></ol><p>主从设备的状态机切换图在预备知识里面给出了，不需要自己去总结，实现所需的寄存器和模块输入输出接口已经给出，你<strong>只需要实现状态切换以及相应的握手信号</strong>。</p><h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p><a href="https://blog.csdn.net/weixin_45937291/article/details/129771811">https://blog.csdn.net/weixin_45937291/article/details/129771811</a></p><h3 id="实验指导："><a href="#实验指导：" class="headerlink" title="实验指导："></a>实验指导：</h3><p>实现 AXI4Lite 从设备模块</p><ol><li><strong>实现状态机</strong>：<ul><li>在每个状态中，根据相应的输入信号更新状态和输出信号。</li><li>例如，在 <code>ReadAddr</code> 状态中，等待 <code>ARVALID</code> 信号变高，并将 <code>ARREADY</code> 信号置高。</li><li>一旦地址被接受，将状态切换到 <code>ReadData</code> 并准备输出数据。</li></ul></li><li><strong>实现读写逻辑</strong>：<ul><li>在 <code>ReadData</code> 状态中，等待 <code>RREADY</code> 信号，输出 <code>RDATA</code> 和 <code>RRESP</code>。</li><li>在 <code>WriteAddr</code> 状态中，等待 <code>AWVALID</code> 信号，并将 <code>AWREADY</code> 信号置高。</li><li>在 <code>WriteData</code> 状态中，等待 <code>WVALID</code> 信号，并将写数据和写掩码存储到寄存器中。</li></ul></li><li><strong>实现响应逻辑</strong>：<ul><li>在 <code>WriteResp</code> 状态中，输出写响应信号 <code>BVALID</code> 和 <code>BRESP</code>。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/905731eb-29ea-45e5-a7ae-55ea468b63e8/image.png" alt="image.png"></p><p>实现 AXI4Lite 主设备模块</p><ol><li><strong>实现状态机</strong>：<ul><li>在每个状态中，根据相应的输出信号更新状态和输入信号。</li><li>例如，在 <code>ReadAddr</code> 状态中，输出 <code>ARVALID</code> 信号，并等待 <code>ARREADY</code> 信号变高。</li><li>一旦地址被接受，将状态切换到 <code>ReadData</code> 并准备接收数据。</li></ul></li><li><strong>实现读写逻辑</strong>：<ul><li>在 <code>ReadData</code> 状态中，等待 <code>RVALID</code> 信号，接收 <code>RDATA</code> 和 <code>RRESP</code>。</li><li>在 <code>WriteAddr</code> 状态中，输出 <code>AWVALID</code> 信号，并等待 <code>AWREADY</code> 信号变高。</li><li>在 <code>WriteData</code> 状态中，输出写数据和写掩码信号 <code>WSTRB</code>。</li></ul></li><li><strong>实现响应逻辑</strong>：<ul><li>在 <code>WriteResp</code> 状态中，等待 <code>BVALID</code> 信号，接收写响应信号 <code>BRESP</code>。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/d9d252c5-393d-457b-abcf-f370d89f2ab8/image.png" alt="image.png"></p><h3 id="ps-一些chisel的知识："><a href="#ps-一些chisel的知识：" class="headerlink" title="ps:一些chisel的知识："></a>ps:一些chisel的知识：</h3><ul><li>Bundle：用于将不同类型的信号划分为一组</li><li>Vec用于表示一个<strong>可索引的、相同类型的</strong>信号的集合</li><li><strong>&lt;&gt; 运算符</strong>：用于连接两个信号，类似于 Verilog 中的 <code>assign</code> 语句。</li></ul><h2 id="实验报告¶"><a href="#实验报告¶" class="headerlink" title="实验报告¶"></a>实验报告<a href="https://yatcpu.sysu.tech/labs/lab2-interrupt/#%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A">¶</a></h2><ol><li>简要概括不同测试用例的功能，描述它们分别从什么层面测试 CPU，以及使用了什么方法加载测试程序指令，以及测试用例的执行结果。</li><li>对于填空涉及到的信号，使用测试框架输出波形图，描述在执行不同指令时候对应的部件的关键信号的变化情况。</li><li>使用实验板上的 LED 或者数码管等外设，体现你的 CPU 可以响应定时器中断或者其他外部中断。</li><li>在完成实验的过程中，遇到的关于实验指导不明确或者其他问题，或者改进的建议。</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/31d55b13-b66a-44e0-a61a-e7ef62f59b8d/image.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_macro</title>
    <link href="/2025/02/19/Rust-macro/"/>
    <url>/2025/02/19/Rust-macro/</url>
    
    <content type="html"><![CDATA[<p>Rust 的宏系统分为两大类： <strong>声明宏</strong> （Declarative Macros）和 <strong>过程宏</strong> （Procedural Macros）。</p><hr><h2 id="1-宏的基本概念"><a href="#1-宏的基本概念" class="headerlink" title="1. 宏的基本概念"></a>1. 宏的基本概念</h2><h3 id="1-1-宏的作用"><a href="#1-1-宏的作用" class="headerlink" title="1.1 宏的作用"></a>1.1 宏的作用</h3><ul><li><strong>代码复用</strong> ：通过宏减少重复代码。</li><li><strong>代码生成</strong> ：在编译时生成代码，减少运行时开销。</li><li><strong>领域特定语言（DSL）</strong> ：通过宏创建自定义语法。</li></ul><h3 id="1-2-宏的分类"><a href="#1-2-宏的分类" class="headerlink" title="1.2 宏的分类"></a>1.2 宏的分类</h3><ul><li><strong>声明宏</strong> ：通过模式匹配生成代码，使用 <code>macro_rules!</code> 定义。</li><li><strong>过程宏</strong> ：更灵活，允许在编译时运行 Rust 代码生成代码，分为三类：</li><li><strong>自定义派生宏</strong> （Custom Derive Macros）：为结构体或枚举自动实现 trait。</li><li><strong>类属性宏</strong> （Attribute-like Macros）：为代码块添加自定义属性。</li><li><strong>类函数宏</strong> （Function-like Macros）：像函数一样调用的宏。</li></ul><hr><h2 id="2-声明宏（Declarative-Macros）"><a href="#2-声明宏（Declarative-Macros）" class="headerlink" title="2. 声明宏（Declarative Macros）"></a>2. 声明宏（Declarative Macros）</h2><h3 id="2-1-声明宏的定义"><a href="#2-1-声明宏的定义" class="headerlink" title="2.1 声明宏的定义"></a>2.1 声明宏的定义</h3><p>使用 <code>macro_rules!</code> 定义声明宏，语法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> macro_name &#123;<br>    (pattern1) =&gt; &#123; generated_code1 &#125;;<br>    (pattern2) =&gt; &#123; generated_code2 &#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>pattern</code>：匹配输入的语法模式。</li><li><code>generated_code</code>：生成的代码。</li></ul><h3 id="2-2-示例：简单的声明宏"><a href="#2-2-示例：简单的声明宏" class="headerlink" title="2.2 示例：简单的声明宏"></a>2.2 示例：简单的声明宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> say_hello &#123;<br>    () =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    say_hello!(); <span class="hljs-comment">// 输出：Hello, world!</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-模式匹配与捕获"><a href="#2-3-模式匹配与捕获" class="headerlink" title="2.3 模式匹配与捕获"></a>2.3 模式匹配与捕获</h3><p>声明宏支持多种模式匹配和捕获：</p><ul><li><strong>捕获变量</strong> ：<code>$var:type</code>，例如 <code>$x:expr</code> 捕获表达式。</li><li><strong>重复模式</strong> ：<code>$(...)*</code> 或 <code>$(...)+</code>，用于匹配重复的输入。</li></ul><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> create_vector &#123;<br>    ($($x:expr),*) =&gt; &#123;<br>        &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            $(v.<span class="hljs-title function_ invoke__">push</span>($x);)*<br>            v<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = create_vector!(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, v); <span class="hljs-comment">// 输出：[1, 2, 3]</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-过程宏（Procedural-Macros）"><a href="#3-过程宏（Procedural-Macros）" class="headerlink" title="3. 过程宏（Procedural Macros）"></a>3. 过程宏（Procedural Macros）</h2><p>过程宏更强大，允许在编译时运行 Rust 代码生成代码。过程宏需要单独放在一个 crate 中。</p><h3 id="3-1-自定义派生宏（Custom-Derive-Macros）"><a href="#3-1-自定义派生宏（Custom-Derive-Macros）" class="headerlink" title="3.1 自定义派生宏（Custom Derive Macros）"></a>3.1 自定义派生宏（Custom Derive Macros）</h3><p>派生宏用于为结构体或枚举自动实现 trait。</p><h3 id="3-1-1-定义派生宏"><a href="#3-1-1-定义派生宏" class="headerlink" title="3.1.1 定义派生宏"></a>3.1.1 定义派生宏</h3><p>使用 <code>#[proc_macro_derive]</code> 定义派生宏。</p><p>示例：实现一个简单的 <code>Hello</code> trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><span class="hljs-keyword">use</span> syn::&#123;parse_macro_input, DeriveInput&#125;;<br><br><span class="hljs-meta">#[proc_macro_derive(Hello)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_derive</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ast</span> = parse_macro_input!(input <span class="hljs-keyword">as</span> DeriveInput);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = &amp;ast.ident;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gen</span> = quote! &#123;<br>        <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">for</span> #name &#123;<br>            <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello</span>() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, I am &#123;&#125;&quot;</span>, <span class="hljs-built_in">stringify!</span>(#name));<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    gen.<span class="hljs-title function_ invoke__">into</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-2-使用派生宏"><a href="#3-1-2-使用派生宏" class="headerlink" title="3.1.2 使用派生宏"></a>3.1.2 使用派生宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> hello_macro::Hello;<br><br><span class="hljs-meta">#[derive(Hello)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    Person::<span class="hljs-title function_ invoke__">hello</span>(); <span class="hljs-comment">// 输出：Hello, I am Person</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-类属性宏（Attribute-like-Macros）"><a href="#3-2-类属性宏（Attribute-like-Macros）" class="headerlink" title="3.2 类属性宏（Attribute-like Macros）"></a>3.2 类属性宏（Attribute-like Macros）</h3><p>类属性宏允许为代码块添加自定义属性。</p><h3 id="3-2-1-定义类属性宏"><a href="#3-2-1-定义类属性宏" class="headerlink" title="3.2.1 定义类属性宏"></a>3.2.1 定义类属性宏</h3><p>使用 <code>#[proc_macro_attribute]</code> 定义类属性宏。</p><p>示例：定义一个属性宏，打印函数名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><span class="hljs-keyword">use</span> syn::&#123;parse_macro_input, ItemFn&#125;;<br><br><span class="hljs-meta">#[proc_macro_attribute]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">log_function</span>(_attr: TokenStream, item: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = parse_macro_input!(item <span class="hljs-keyword">as</span> ItemFn);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fn_name</span> = &amp;input.sig.ident;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gen</span> = quote! &#123;<br>        #input<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Function &#x27;&#123;&#125;&#x27; was called.&quot;</span>, <span class="hljs-built_in">stringify!</span>(#fn_name));<br>    &#125;;<br><br>    gen.<span class="hljs-title function_ invoke__">into</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-使用类属性宏"><a href="#3-2-2-使用类属性宏" class="headerlink" title="3.2.2 使用类属性宏"></a>3.2.2 使用类属性宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> log_macro::log_function;<br><br><span class="hljs-meta">#[log_function]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">my_function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Doing something...&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">my_function</span>(); <span class="hljs-comment">// 输出：Function &#x27;my_function&#x27; was called.</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-类函数宏（Function-like-Macros）"><a href="#3-3-类函数宏（Function-like-Macros）" class="headerlink" title="3.3 类函数宏（Function-like Macros）"></a>3.3 类函数宏（Function-like Macros）</h3><p>类函数宏像函数一样调用，但可以接受任意输入。</p><h3 id="3-3-1-定义类函数宏"><a href="#3-3-1-定义类函数宏" class="headerlink" title="3.3.1 定义类函数宏"></a>3.3.1 定义类函数宏</h3><p>使用 <code>#[proc_macro]</code> 定义类函数宏。</p><p>示例：定义一个类函数宏，生成一个简单的函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><br><span class="hljs-meta">#[proc_macro]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_function</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gen</span> = quote! &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">generated_function</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is a generated function!&quot;</span>);<br>        &#125;<br>    &#125;;<br><br>    gen.<span class="hljs-title function_ invoke__">into</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-2-使用类函数宏"><a href="#3-3-2-使用类函数宏" class="headerlink" title="3.3.2 使用类函数宏"></a>3.3.2 使用类函数宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> make_function::make_function;<br><br>make_function!();<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">generated_function</span>(); <span class="hljs-comment">// 输出：This is a generated function!</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>ai总结</li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_smart_pointer</title>
    <link href="/2025/02/19/Rust-smart-pointer/"/>
    <url>/2025/02/19/Rust-smart-pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针是一类数据结构，它们表现类似指针，但是也拥有额外的元数据和功能。</p><ul><li><strong>引用计数</strong> （ <em>reference counting</em> ）智能指针类型。这种指针允许数据有多个所有者，它会记录所有者的数量，当没有所有者时清理数据。</li><li>在 Rust 中因为引用和借用，普通引用和智能指针的一个额外的区别是引用是一类 <strong>只借用数据的指针</strong> ；相反，在大部分情况下，智能指针 <strong>拥有</strong> 它们指向的数据。</li></ul><p>常用的智能指针：</p><ul><li><code>Box&lt;T&gt;</code>，用于在堆上分配值</li><li><code>Rc&lt;T&gt;</code>，一个引用计数类型，其数据可以有多个所有者</li><li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCell&lt;T&gt;</code> 访问。（ <code>RefCell&lt;T&gt;</code> 是一个在运行时而不是在编译时执行借用规则的类型）。</li></ul><h2 id="使用Box-指向堆上的数据"><a href="#使用Box-指向堆上的数据" class="headerlink" title="使用Box &lt;T&gt;指向堆上的数据"></a>使用Box <code>&lt;T&gt;</code>指向堆上的数据</h2><p>box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。</p><h3 id="使用Box-在堆上储存数据"><a href="#使用Box-在堆上储存数据" class="headerlink" title="使用Box &lt;T&gt;在堆上储存数据"></a>使用Box <code>&lt;T&gt;</code>在堆上储存数据</h3><ul><li><code>let b = Box::new(5);</code></li></ul><h3 id="Box允许创建递归类型"><a href="#Box允许创建递归类型" class="headerlink" title="Box允许创建递归类型"></a>Box允许创建递归类型</h3><p> <strong>递归类型</strong> （ <em>recursive type</em> ）的值可以拥有另一个同类型的值作为其自身的一部分。</p><ul><li>cons list：<ul><li><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构，它由嵌套的列表组成。（类似于c++的广义表）</li><li>Box是指针，是可以知道大小的。</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Nil))))));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通过Deref-trait将智能指针当作常规引用处理"><a href="#通过Deref-trait将智能指针当作常规引用处理" class="headerlink" title="通过Deref trait将智能指针当作常规引用处理"></a>通过Deref trait将智能指针当作常规引用处理</h2><ul><li>实现 <code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong></li><li>解引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x;<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>像引用一样使用Box <code>&lt;T&gt;</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(x);<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将 <code>y</code> 设置为一个指向 <code>x</code> 值拷贝的 <code>Box&lt;T&gt;</code> 实例，而不是指向 <code>x</code> 值的引用。</li></ul><h2 id="Rc-引用计数智能指针"><a href="#Rc-引用计数智能指针" class="headerlink" title="Rc &lt;T&gt;引用计数智能指针"></a>Rc <code>&lt;T&gt;</code>引用计数智能指针</h2><p>如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p><ul><li>使用Rc <code>&lt;T&gt;</code>共享数据</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, Rc&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br>**<span class="hljs-keyword">use</span> std::rc::Rc;**<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">5</span>, Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">10</span>, Rc::<span class="hljs-title function_ invoke__">new</span>(Nil)))));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">4</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以调用 <code>a.clone()</code> 而不是 <code>Rc::clone(&amp;a)</code>，不过在这里 Rust 的习惯是使用 <code>Rc::clone</code>。</p><ul><li>克隆Rc <code>&lt;T&gt;</code>会增加引用计数</li></ul><ol><li><strong><code>Rc::clone</code></strong> ：</li></ol><ul><li><code>Rc::clone(&amp;sun)</code> 不会复制 <code>Sun</code> 实例，而是增加 <code>Rc</code> 的引用计数。</li><li>所有行星共享同一个 <code>Sun</code> 实例。</li></ul><ol><li><strong>引用计数</strong> ：</li></ol><ul><li>每次调用 <code>Rc::clone(&amp;sun)</code>，引用计数加 1。</li><li>每次调用 <code>drop</code>，引用计数减 1。</li></ul><ol><li><strong><code>drop</code> 的作用</strong> ：</li></ol><ul><li><code>drop</code> 用于手动释放所有权，减少引用计数。</li><li>当引用计数为 0 时，<code>Rc</code> 会自动释放内存。</li></ul><h2 id="cow"><a href="#cow" class="headerlink" title="cow:"></a>cow:</h2><h3 id="Cow-的核心思想是："><a href="#Cow-的核心思想是：" class="headerlink" title="Cow 的核心思想是："></a><code>Cow</code> 的核心思想是：</h3><ul><li>如果数据是 <strong>只读的</strong> ，直接 <strong>使用借用</strong> （<code>Borrowed</code>），避免复制。</li><li>如果数据 <strong>需要修改</strong> ，则 <strong>复制数据并拥有所有权</strong> （<code>Owned</code>）。</li></ul><h2 id="Cow-的常用方法"><a href="#Cow-的常用方法" class="headerlink" title="Cow 的常用方法"></a><code>Cow</code> 的常用方法</h2><h3 id="1-to-mut：获取可变引用"><a href="#1-to-mut：获取可变引用" class="headerlink" title="(1) to_mut：获取可变引用"></a>(1) <code>to_mut</code>：获取可变引用</h3><p>如果 <code>Cow</code> 是 <code>Borrowed</code>，则复制数据并转换为 <code>Owned</code>；如果已经是 <code>Owned</code>，则直接返回可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cow</span> = Cow::<span class="hljs-title function_ invoke__">Borrowed</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = cow.<span class="hljs-title function_ invoke__">to_mut</span>(); <span class="hljs-comment">// 复制数据并转换为 Owned</span><br>s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; world&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s); <span class="hljs-comment">// 输出 &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-into-owned：获取所有权"><a href="#2-into-owned：获取所有权" class="headerlink" title="(2) into_owned：获取所有权"></a>(2) <code>into_owned</code>：获取所有权</h3><p>将 <code>Cow</code> 转换为拥有所有权的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cow</span> = Cow::<span class="hljs-title function_ invoke__">Borrowed</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: <span class="hljs-type">String</span> = cow.<span class="hljs-title function_ invoke__">into_owned</span>(); <span class="hljs-comment">// 转换为 String</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s); <span class="hljs-comment">// 输出 &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-is-borrowed-和-is-owned：检查状态"><a href="#3-is-borrowed-和-is-owned：检查状态" class="headerlink" title="(3) is_borrowed 和 is_owned：检查状态"></a>(3) <code>is_borrowed</code> 和 <code>is_owned</code>：检查状态</h3><ul><li><code>is_borrowed</code>：检查是否是 <code>Borrowed</code>。</li><li><code>is_owned</code>：检查是否是 <code>Owned</code>。</li></ul><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> cow = Cow::Borrowed(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">assert</span>!(cow.<span class="hljs-keyword">is</span><span class="hljs-number">_</span>borrowed());<br><span class="hljs-keyword">assert</span>!(!cow.<span class="hljs-keyword">is</span><span class="hljs-number">_</span>owned());<br></code></pre></td></tr></table></figure><h2 id="使用Drop-Trait运行清理代码"><a href="#使用Drop-Trait运行清理代码" class="headerlink" title="使用Drop Trait运行清理代码"></a>使用Drop Trait运行清理代码</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Drop</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>drop方法在值离开作用域时<strong>自动调用</strong></p><p>也可以手动调用drop()来清理代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = MyStruct &#123; name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;x&quot;</span>) &#125;;<br>    <span class="hljs-title function_ invoke__">drop</span>(x); <span class="hljs-comment">// 手动调用 drop</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x has been dropped&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Drop与所有权"><a href="#Drop与所有权" class="headerlink" title="Drop与所有权"></a>Drop与所有权</h3><ul><li>当一个值的所有权转移时，drop不会立即调用，只有在<strong>值离开作用域时</strong>才会调用</li><li>如果值被移动（如传递给函数），drop会在新作用域结束时调用</li></ul><h2 id="Drop与Copy"><a href="#Drop与Copy" class="headerlink" title="Drop与Copy"></a>Drop与Copy</h2><p>二者不能同时实现</p><ul><li><code>Copy</code> trait 表示类型可以通过位复制来复制值，而 <code>Drop</code> 表示类型需要清理操作。</li><li>如果类型实现了 <code>Drop</code>，Rust 会阻止你实现 <code>Copy</code>，因为复制可能会<strong>导致资源被多次释放。</strong></li></ul><h2 id="RefCell-和内部可变模式"><a href="#RefCell-和内部可变模式" class="headerlink" title="RefCell &lt;T&gt;和内部可变模式"></a>RefCell <code>&lt;T&gt;</code>和内部可变模式</h2><ul><li><strong>内部可变性</strong>是rust中的一个设计模式，它允许你 <strong>即使在有不可变引用时也可以改变数据</strong> 。</li><li>该模式在数据结构中使用 <code>unsafe</code> 代码来模糊rust通常的可变性和借用规则。不安全代码表明我们在<strong>手动检查</strong>这些规则而不是让编译器替我们检查。</li></ul><h3 id="通过-RefCell在运行时检查借用规则"><a href="#通过-RefCell在运行时检查借用规则" class="headerlink" title="通过 RefCell&lt;T&gt;在运行时检查借用规则"></a>通过 <code>RefCell&lt;T&gt;</code>在运行时检查借用规则</h3><ul><li>不同于 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 代表其数据的唯一的所有权。</li></ul><p>如下为选择 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p><ul><li><code>Rc&lt;T&gt;</code> 允许相同数据 <strong>有多个所有者</strong> ；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li><li><code>Box&lt;T&gt;</code> 允许在编译时执行不可变或可变借用检查；<code>Rc&lt;T&gt;</code>仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code> 允许在运行时执行不可变或可变借用检查。</li><li>因为 <code>RefCell&lt;T&gt;</code> 允许在运行时执行可变借用检查，所以我们可以在即便 <code>RefCell&lt;T&gt;</code> 自身是不可变的情况下修改其内部的值。</li></ul><h3 id="内部可变性：不可变值的可变借用"><a href="#内部可变性：不可变值的可变借用" class="headerlink" title="内部可变性：不可变值的可变借用"></a>内部可变性：不可变值的可变借用</h3><p>借用规则的一个推论是当有一个不可变值时，不能可变地借用它。</p><ul><li><strong>mock对象</strong><ul><li><strong>mock 对象</strong> 是特定类型的 <strong>测试替身</strong> ，它们记录测试过程中发生了什么以便可以断言操作是正确的。</li></ul></li></ul><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><code>borrow()</code>：获取一个不可变引用（<code>Ref&lt;T&gt;</code>）。如果已经有可变引用，会 panic。</li><li><code>borrow_mut()</code>：获取一个可变引用（<code>RefMut&lt;T&gt;</code>）。如果已经有其他引用（可变或不可变），会 panic。</li><li><code>try_borrow()</code> 和 <code>try_borrow_mut()</code>：与 <code>borrow()</code> 和 <code>borrow_mut()</code> 类似，但不会 panic，而是返回 <code>Result</code>。</li></ul><h2 id="Arc-：-Atomic-Reference-Counting-（原子引用计数）"><a href="#Arc-：-Atomic-Reference-Counting-（原子引用计数）" class="headerlink" title="Arc &lt;T&gt;： Atomic Reference Counting （原子引用计数）"></a>Arc <code>&lt;T&gt;</code>： <strong>Atomic Reference Counting</strong> （原子引用计数）</h2><ol><li><strong>引用计数</strong> ：<code>Arc&lt;T&gt;</code> 会跟踪指向同一数据的引用数量。每次克隆 <code>Arc&lt;T&gt;</code> 时，引用计数会增加；当 <code>Arc&lt;T&gt;</code> 被丢弃时，引用计数会减少。当引用计数为 0 时，数据会被释放。</li><li><strong>线程安全</strong> ：<code>Arc&lt;T&gt;</code> 是线程安全的，因为它的引用计数操作是原子的（atomic），这意味着多个线程可以安全地共享同一个 <code>Arc&lt;T&gt;</code>。</li><li><strong>不可变性</strong> ：<code>Arc&lt;T&gt;</code> 本身是不可变的。如果需要修改内部数据，通常需要与 <code>Mutex&lt;T&gt;</code> 或 <code>RwLock&lt;T&gt;</code> 结合使用。</li></ol><h3 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><code>new(value: T) -&gt; Arc&lt;T&gt;</code>：创建一个新的 <code>Arc&lt;T&gt;</code>。</li><li><code>clone(&amp;self) -&gt; Arc&lt;T&gt;</code>：<strong>克隆</strong> <code>Arc&lt;T&gt;</code>，增加引用计数。</li><li><code>strong_count(&amp;self) -&gt; usize</code>：返回当前 <strong>强引用计数</strong> 。</li><li><code>downgrade(&amp;self) -&gt; Weak&lt;T&gt;</code>：创建一个 <strong>弱引用</strong> （<code>Weak&lt;T&gt;</code>），<strong>不会增加引用计数。</strong></li><li><code>try_unwrap(this: Arc&lt;T&gt;) -&gt; Result&lt;T, Arc&lt;T&gt;&gt;</code>：如果引用计数为 1，则返回内部数据；否则返回 <code>Arc&lt;T&gt;</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_iter</title>
    <link href="/2025/02/19/Rust-iter/"/>
    <url>/2025/02/19/Rust-iter/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h2><ul><li>迭代器是rust用于遍历集合的一种抽象，提供了一种统一的方式来访问集合中的元素，而不需要关心集合的具体实现</li><li>rust的迭代器是<strong>惰性</strong>的，只会在真正需要时才回进行计算</li></ul><h2 id="迭代器的核心trait：Iterator"><a href="#迭代器的核心trait：Iterator" class="headerlink" title="迭代器的核心trait：Iterator"></a>迭代器的核心trait：Iterator</h2><h3 id="Iterator-trait的定义："><a href="#Iterator-trait的定义：" class="headerlink" title="Iterator trait的定义："></a><code>Iterator</code> trait的定义：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&#123;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<span class="hljs-comment">//迭代器产生的值的类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<span class="hljs-comment">//获取下一个元素 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建迭代器："><a href="#创建迭代器：" class="headerlink" title="创建迭代器："></a>创建迭代器：</h2><ul><li><code>iter()</code>：生成一个<strong>不可变引用</strong>的迭代器。</li><li><code>iter_mut()</code>：生成一个<strong>可变引用</strong>的迭代器。</li><li><code>into_iter()</code>：生成一个<strong>获取所有权</strong>的迭代器。</li></ul><h2 id="使用迭代器："><a href="#使用迭代器：" class="headerlink" title="使用迭代器："></a>使用迭代器：</h2><p>常用的方法：</p><ol><li><code>map</code> ：对每个元素进行<strong>转换</strong></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">map</span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, f: F) <span class="hljs-punctuation">-&gt;</span> Map&lt;<span class="hljs-keyword">Self</span>, F&gt;<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnMut</span>(<span class="hljs-keyword">Self</span>::Item) <span class="hljs-punctuation">-&gt;</span> B,<br></code></pre></td></tr></table></figure><p>map方法接受一个闭包f，该闭包会对迭代器中的每个元素进行转换， <strong>返回一个新的迭代器</strong> ，产生转换后的值</p><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>=<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">doubled</span>:<span class="hljs-type">Vec</span>&lt;_&gt;=v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x*<span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;,doubled);</span><br></code></pre></td></tr></table></figure><ul><li>由于返回的是一个迭代器，需要使用 <code>collect()</code> 方法来将迭代器转换成集合</li><li><code>Vec&lt;_&gt;</code>：<code>_</code> 是一个占位符，表示让 Rust 编译器推断集合的类型。</li></ul><ol><li><p><code>filter</code> ：过滤元素</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">filter</span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) <span class="hljs-punctuation">-&gt;</span> Filter&lt;<span class="hljs-keyword">Self</span>, P&gt;<br><span class="hljs-keyword">where</span><br>    P: <span class="hljs-title function_ invoke__">FnMut</span>(&amp;<span class="hljs-keyword">Self</span>::Item) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>,<br></code></pre></td></tr></table></figure><p>filter方法接受一个闭包，该闭包会对每个元素进行判断，如果闭包返回true，则保留，否则丢弃；</p><p>返回一个新的得带起，只包含满足闭包的元素</p><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">evens</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|&amp;x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, evens); <span class="hljs-comment">// 输出 [2, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><code>fold</code> ：累积计算</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fold</span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, init: B, f: F) <span class="hljs-punctuation">-&gt;</span> B<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnMut</span>(B, <span class="hljs-keyword">Self</span>::Item) <span class="hljs-punctuation">-&gt;</span> B,<br></code></pre></td></tr></table></figure><p>fold方法接受一个初始值init和一个闭包f；闭包会对每个元素进行累积计算；返回最终的累积结果</p><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span>: <span class="hljs-type">i32</span> = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">fold</span>(<span class="hljs-number">0</span>, |acc, &amp;x| acc + x);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sum); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure></li><li><p><code>collect</code> ：将迭代器转换为集合</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">collect</span>&lt;B&gt;(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> B<br><span class="hljs-keyword">where</span><br>    B: FromIterator&lt;<span class="hljs-keyword">Self</span>::Item&gt;,<br></code></pre></td></tr></table></figure><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">doubled</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|&amp;x| x * <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, doubled); <span class="hljs-comment">// 输出 [2, 4, 6]</span><br></code></pre></td></tr></table></figure></li><li><p><code>enumerate</code> ：获取索引和值<br>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, index, value);<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 0: a</span><br><span class="hljs-comment">// 1: b</span><br><span class="hljs-comment">// 2: c</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_包/Crate</title>
    <link href="/2025/02/19/Rust-%E5%8C%85-Crate/"/>
    <url>/2025/02/19/Rust-%E5%8C%85-Crate/</url>
    
    <content type="html"><![CDATA[<h1 id="使用包、Crate和模块管理不断增长的项目"><a href="#使用包、Crate和模块管理不断增长的项目" class="headerlink" title="使用包、Crate和模块管理不断增长的项目"></a>使用包、Crate和模块管理不断增长的项目</h1><ul><li><strong>包</strong> （ <em>Packages</em> ）：Cargo 的一个功能，它允许你构建、测试和分享 crate。</li><li><strong>Crates</strong> ：一个模块的树形结构，它形成了库或二进制项目。</li><li><strong>模块</strong> （ <em>Modules</em> ）和  <strong>use</strong> ：允许你控制作用域和路径的私有性。</li><li><strong>路径</strong> （ <em>path</em> ）：一个命名例如结构体、函数或模块等项的方式。</li><li>crate是rust在编译时的最小代码单位。如果使用rustc来编译，编译器依然会将这个文件认作一个crate。</li><li>crate的两种形式：二进制项和库</li><li><em>包</em> （ <em>package</em> ）是提供一系列功能的一个或者多个 crate。</li></ul><h2 id="定义模块来控制作用域和私有域"><a href="#定义模块来控制作用域和私有域" class="headerlink" title="定义模块来控制作用域和私有域"></a>定义模块来控制作用域和私有域</h2><h3 id="工作方式："><a href="#工作方式：" class="headerlink" title="工作方式："></a>工作方式：</h3><p>从crate根节点开始（寻找需要被编译的代码）→声明模块→声明子模块</p><ul><li><strong>声明模块</strong> : 在 crate 根文件中，你可以声明一个新模块；比如，你用 <code>mod garden;</code>声明了一个叫做 <code>garden</code>的模块。编译器会在下列路径中寻找模块代码：</li><li>内联，在大括号中，当 <code>mod garden</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src&#x2F;garden.rs</em></li><li>在文件 <em>src&#x2F;garden&#x2F;mod.rs</em></li><li><strong>声明子模块</strong> : 在除了 crate 根节点以外的其他文件中，你可以定义子模块。比如，你可能在<em>src&#x2F;garden.rs</em>中定义了 <code>mod vegetables;</code>。编译器会在以父模块命名的目录中寻找子模块代码：</li><li>内联，在大括号中，当 <code>mod vegetables</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src&#x2F;garden&#x2F;vegetables.rs</em></li><li>在文件 <em>src&#x2F;garden&#x2F;vegetables&#x2F;mod.rs</em></li><li>模块中的 <strong>代码路径</strong> ：举例而言，一个 garden vegetables 模块下的 <code>Asparagus</code>类型可以在 <code>crate::garden::vegetables::Asparagus</code>被找到。</li><li>公有（要加pub）和私有</li><li><strong>使用use关键字引入</strong> <code>use crate::garden::vegetables::Asparagus;</code></li></ul><h2 id="引用模块项目的路径"><a href="#引用模块项目的路径" class="headerlink" title="引用模块项目的路径"></a>引用模块项目的路径</h2><ul><li>绝对路径：从crate根开始</li><li>相对路径：从当前模块开始，以 <code>self</code>、<code>super</code> 或定义在当前模块中的标识符开头。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    <span class="hljs-comment">// 绝对路径</span><br>    crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br><br>    <span class="hljs-comment">// 相对路径</span><br>    front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="super开始的相对路径"><a href="#super开始的相对路径" class="headerlink" title="super开始的相对路径"></a>super开始的相对路径</h3><p>通过在路径的开头使用 <code>super</code> ，从父模块开始构建相对路径，而不是从当前模块或者 crate 根开始。</p><h3 id="使用as关键字提供新的名称"><a href="#使用as关键字提供新的名称" class="headerlink" title="使用as关键字提供新的名称"></a>使用as关键字提供新的名称</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> **<span class="hljs-keyword">as</span>** IoResult;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function1</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function2</span>() <span class="hljs-punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用pub-use重导出名称"><a href="#使用pub-use重导出名称" class="headerlink" title="使用pub use重导出名称"></a>使用pub use重导出名称</h3><ul><li>使用 <code>use</code> 关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外还是私有的。</li><li>将 <code>pub</code> 和 <code>use</code> 合起来使用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="嵌套路径来消除大量的use行"><a href="#嵌套路径来消除大量的use行" class="headerlink" title="嵌套路径来消除大量的use行"></a>嵌套路径来消除大量的use行</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// --snip--</span><br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-comment">// --snip--</span><br><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// --snip--</span><br><span class="hljs-keyword">use</span> std::&#123;cmp::Ordering, io&#125;;<br><span class="hljs-comment">// --snip--</span><br><br></code></pre></td></tr></table></figure><h3 id="通过glob运算符将所有的公有定义引入作用域"><a href="#通过glob运算符将所有的公有定义引入作用域" class="headerlink" title="通过glob运算符将所有的公有定义引入作用域"></a>通过glob运算符将所有的公有定义引入作用域</h3><p><code>use std::collections::*;</code></p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_String</title>
    <link href="/2025/02/19/Rust-String/"/>
    <url>/2025/02/19/Rust-String/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h1><ul><li>string和&amp;str是两种不同的字符串类型，主要区别在于所有权和可变性</li><li>String<ul><li>拥有所有权</li><li>是可变的，在堆上分配内存</li></ul></li><li>&amp;str<ul><li>字符串切片—slice，通常是对string或字符串字面量的引用。不具有所有权</li><li>不可变的</li></ul></li></ul><h2 id="新建字符串"><a href="#新建字符串" class="headerlink" title="新建字符串"></a>新建字符串</h2><ul><li>和cpp等类似，string被实现为一个带有一些额外保证、限制和功能的字节vector封装</li></ul><p>新建：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s0</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<span class="hljs-comment">//由于string是可变的，前面要有mut关键字</span><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">data</span>=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span>=data.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-comment">//3</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-comment">//4</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a>更新字符串</h2><ul><li>使用push_str()或push()来附加</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; world&quot;</span>);<br></code></pre></td></tr></table></figure><ol><li><code>push_str()</code>采用 <strong>字符串slice</strong> ，不需要获得参数的所有权。例如：</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-string">&quot;world&quot;</span>;<br>s1.<span class="hljs-title function_ invoke__">push_str</span>(s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;s2&#125;&quot;</span>);<span class="hljs-comment">//可以通过编译！s2并没有失效</span><br></code></pre></td></tr></table></figure><ol><li><code>push()</code> 获取<strong>单个字符</strong>作为参数附加到String中。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;h&quot;</span>);<br>s.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;i&#x27;</span>);<br></code></pre></td></tr></table></figure><ol><li>使用 <code>+</code> 或 <code>format!</code> 宏 拼接字符串</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;wow&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>=s1 + **&amp;s2**;**<span class="hljs-comment">//此处s1被“移动”了，不能再使用了；s2仍然可以使用**</span><br></code></pre></td></tr></table></figure><ul><li>&amp;String可以强制转换成&amp;str</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;You&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;are&quot;</span>)l<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;right&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>=<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;s1&#125; &#123;s2&#125; &#123;s3&#125;&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;s&#125;&quot;</span>);<br></code></pre></td></tr></table></figure><p>可以用于连接多个复杂字符串并返回；有点类似于println!</p><ul><li>rust的字符串不支持索引</li><li>每个 Unicode 标量值需要两个字节存储</li></ul><h2 id="字符串slice"><a href="#字符串slice" class="headerlink" title="字符串slice"></a>字符串slice</h2><p>可以创建slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=&amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><p>在 Rust 中，字符串是以 UTF-8 编码的，因此遍历字符串时需要注意字符和字节的区别。Rust 提供了多种方法来遍历字符串的不同部分，具体取决于你需要操作的是字符、字节还是更复杂的字形簇（grapheme clusters）。</p><hr><h3 id="1-遍历-Unicode-标量值（字符）"><a href="#1-遍历-Unicode-标量值（字符）" class="headerlink" title="1. 遍历 Unicode 标量值（字符）"></a>1. <strong>遍历 Unicode 标量值（字符）</strong></h3><p>使用 <code>chars()</code> 方法可以将字符串按 Unicode 标量值（即 Rust 中的 <code>char</code> 类型）分割，并逐个遍历。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Зд&quot;</span>.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;c&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">З<br>д<br><br></code></pre></td></tr></table></figure><ul><li><strong>适用场景</strong> ：当你需要处理单个 Unicode 字符时。</li><li><strong>注意</strong> ：<code>chars()</code> 返回的是 Unicode 标量值，而不是字形簇（例如，某些字符可能由多个 Unicode 标量值组成，如 <code>é</code> 可以是 <code>e</code> 和 <code>´</code> 的组合）。</li></ul><hr><h3 id="2-遍历原始字节"><a href="#2-遍历原始字节" class="headerlink" title="2. 遍历原始字节"></a>2. <strong>遍历原始字节</strong></h3><p>使用 <code>bytes()</code> 方法可以遍历字符串的原始字节（UTF-8 编码的字节序列）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Зд&quot;</span>.<span class="hljs-title function_ invoke__">bytes</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;b&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">208<br>151<br>208<br>180<br><br></code></pre></td></tr></table></figure><ul><li><strong>适用场景</strong> ：当你需要处理字符串的底层字节表示时。</li><li><strong>注意</strong> ：UTF-8 编码中，一个 Unicode 标量值可能由多个字节组成（例如，<code>З</code> 由两个字节 <code>208</code> 和 <code>151</code> 组成）。</li></ul><hr><h3 id="3-遍历字形簇（Grapheme-Clusters）"><a href="#3-遍历字形簇（Grapheme-Clusters）" class="headerlink" title="3. 遍历字形簇（Grapheme Clusters）"></a>3. <strong>遍历字形簇（Grapheme Clusters）</strong></h3><p>字形簇是用户感知的“字符”，可能由多个 Unicode 标量值组成。例如，<code>é</code> 可以是一个字形簇，但它可能由 <code>e</code> 和 <code>´</code> 两个 Unicode 标量值组成。</p><p>Rust 标准库没有直接支持字形簇的操作，但可以通过第三方库（如 <code>unicode-segmentation</code>）来实现。</p><h3 id="使用-unicode-segmentation-库"><a href="#使用-unicode-segmentation-库" class="headerlink" title="使用 unicode-segmentation 库"></a>使用 <code>unicode-segmentation</code> 库</h3><p>首先，在 <code>Cargo.toml</code> 中添加依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">unicode-segmentation</span> = <span class="hljs-string">&quot;1.10&quot;</span><br><br></code></pre></td></tr></table></figure><p>然后，使用 <code>graphemes()</code> 方法遍历字形簇：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> unicode_segmentation::UnicodeSegmentation;<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">g</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.<span class="hljs-title function_ invoke__">graphemes</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;g&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">न<br>म<br>स्<br>ते<br><br></code></pre></td></tr></table></figure><ul><li><strong>适用场景</strong> ：当你需要处理用户感知的“字符”时（例如，文本渲染或输入处理）。</li><li><strong>注意</strong> ：字形簇的处理比字符和字节更复杂，因此需要依赖第三方库。</li></ul><hr><h3 id="4-遍历字符串的其他方法"><a href="#4-遍历字符串的其他方法" class="headerlink" title="4. 遍历字符串的其他方法"></a>4. <strong>遍历字符串的其他方法</strong></h3><ul><li><strong>按行遍历</strong> ：使用 <code>lines()</code> 方法可以将字符串按行分割。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;hello\\\\nworld&quot;</span>.<span class="hljs-title function_ invoke__">lines</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;line&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>按单词遍历</strong> ：使用 <code>split_whitespace()</code> 方法可以将字符串按空白字符分割。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;hello world&quot;</span>.<span class="hljs-title function_ invoke__">split_whitespace</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;word&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方法</th><th>返回类型</th><th>适用场景</th><th>注意事项</th></tr></thead><tbody><tr><td><code>chars()</code></td><td><code>char</code></td><td>处理单个 Unicode 标量值</td><td>不适用于字形簇</td></tr><tr><td><code>bytes()</code></td><td><code>u8</code></td><td>处理字符串的原始字节</td><td>一个字符可能由多个字节组成</td></tr><tr><td><code>graphemes()</code>（第三方）</td><td>字形簇</td><td>处理用户感知的“字符”</td><td>需要 <code>unicode-segmentation</code>库</td></tr><tr><td><code>lines()</code></td><td>字符串切片</td><td>按行分割字符串</td><td>适用于多行文本</td></tr><tr><td><code>split_whitespace()</code></td><td>字符串切片</td><td>按空白字符分割字符串</td><td>适用于单词分割</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_Notes</title>
    <link href="/2025/02/10/Rust-Notes/"/>
    <url>/2025/02/10/Rust-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Resources："><a href="#Resources：" class="headerlink" title="Resources："></a>Resources：</h1><p><a href="https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html">https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html</a></p><h1 id="导学阶段："><a href="#导学阶段：" class="headerlink" title="导学阶段："></a>导学阶段：</h1><ul><li>rust的更新和卸载：<ul><li>更新：<code>rustup update</code></li><li>卸载：<code>rustup self uninstall</code></li></ul></li></ul><h2 id="Hello-World！第一个rust程序："><a href="#Hello-World！第一个rust程序：" class="headerlink" title="Hello World！第一个rust程序："></a>Hello World！第一个rust程序：</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一些基础知识："><a href="#一些基础知识：" class="headerlink" title="一些基础知识："></a>一些基础知识：</h2><ul><li><p>函数的定义：</p><ul><li>如main函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要有fn作为函数的基本标志，其余类似于c++</p><p>ps：语句也需要有分号</p></li><li><p>调用Rust宏：如果看到了 <code>!</code> 说明调用了宏而不是普通函数。</p></li></ul><h2 id="包管理器Cargo"><a href="#包管理器Cargo" class="headerlink" title="包管理器Cargo"></a>包管理器Cargo</h2><blockquote><p>可以帮助我们构建代码，下载依赖库并编译这些库</p></blockquote><ol><li>使用cargo创建项目：<code>cargo new xxx</code></li></ol><p>会创建一个文件夹，里面包含了一个src文件夹和两个文件</p><ul><li>如果没有使用cargo开始项目，我们可以将其转换成cargo项目；<ul><li>将项目代码移入src目录</li><li>创建一个合适的cargo.toml文件（可以使用 cargo init命令）</li></ul></li></ul><ol><li><p>构建并运行cargo项目</p><ol><li>构建项目：<code>cargo build</code> —可以看到生成的可执行文件落在了debug文件夹下。</li><li>运行：可以使用具体位置来运行，也可以直接输入 <code>cargo run</code> 来运行。推荐后者</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/88683d38-8c7e-4b4a-92dd-43c2040fe6ce/image.png" alt="image.png"></p></li><li><p>快速检查代码确保其可以编译：<code>cargo check</code></p></li><li><p>发布构建：可以使用 <code>cargo build --release</code> 来优化编译项目。生成结果在target&#x2F;release下</p></li></ol><h2 id="小例子：猜数游戏"><a href="#小例子：猜数游戏" class="headerlink" title="小例子：猜数游戏"></a>小例子：猜数游戏</h2><ol><li>作用域引入；e.g: <code>use std::io;</code></li><li><strong>变量</strong>存储用户输入：可变的变量和不可变的变量<ol><li>使用let来创建变量：<ol><li>可变：<code>let mut var = String::new();</code></li><li>不可变：<code>let var = 5;</code></li></ol></li></ol></li><li>println!(”You guess:{}”,guess);这里的{}是一个占位符，用于打印变量的值，逗号后面是打印的表达式列表；</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;x&#125; and y + 2 = &#123;&#125;&quot;</span>, y + <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>会打印出 <code>x = 5 and y + 2 = 12</code></p><ol><li>使用<strong>crate</strong>来增加更多功能<ol><li>crate 是一组 Rust 源代码文件。</li><li><code>rand</code> crate 是一个 <em>库 crate</em>，库 crate 可以包含任意能被其他程序使用的代码，但是无法独立执行。</li><li>在我们使用 <code>rand</code> 编写代码之前，需要修改 <em>Cargo.toml</em> 文件，引入一个 <code>rand</code> 依赖。</li></ol></li><li>cargo.lock<ol><li>当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 <em>Cargo.lock</em> 文件。当将来构建项目时，Cargo 会发现 <em>Cargo.lock</em> 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 <code>0.8.5</code> 直到你显式升级，多亏有了 <em>Cargo.lock</em> 文件。由于 <em>Cargo.lock</em> 文件对于“可重复构建”非常重要，因此它通常会和项目中的其余代码一样纳入到版本控制系统中。</li></ol></li><li>更新crate到新版本：使用 <code>cargo update</code><br>，会忽略cargo.lock文件，并计算出所有符合cargo.toml声明的最新版本。接下来把这些版本写入cargo.lock中。</li><li>Cargo 有一个很棒的功能是：运行 <code>cargo doc --open</code> 命令来构建所有本地依赖提供的文档，并在浏览器中打开。</li></ol><h2 id="常见编程概念"><a href="#常见编程概念" class="headerlink" title="常见编程概念"></a>常见编程概念</h2><h3 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h3><ol><li>变量<strong>默认</strong>是<strong>不可改变的</strong>。当变量不可变时，一旦值被绑定一个名称上，就不能改变这个值。</li></ol><p><img src="attachment:d36497e2-b2c3-4196-ac77-eac508ff047c:image.png" alt="image.png"></p><p>如果我们对同一个不可变的变量赋值两次，会出现报错。</p><p>但如果我们修改一下，改成let mut x&#x3D;5；这样子是可变的变量，就可以赋值多次。</p><p><img src="attachment:9a16ddaf-d30a-44c3-b87c-f696a04a71b4:image.png" alt="image.png"></p><p><img src="attachment:e53bd69f-3268-4fe3-8087-a3ed10f1f452:image.png" alt="image.png"></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>常量也是绑定到一个名称的不允许改变的值。（q：常量和不可变量的区别？<ul><li>不允许对常量使用mut。常量总是不可变的。</li><li>声明常量使用const，而不是let，并且 <em>必须</em> 注明<strong>值的类型</strong>。</li><li>常量可以在任何作用域中声明，包括全局作用域</li><li>常量只能被设置为<strong>常量表达式</strong>，而不可以是其他任何只能在运行时计算出的值</li></ul></li></ul><p>下面是一个声明常量的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="hljs-type">u32</span> = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>定义一个与之前变量同名的新变量。就会把前面的变量隐藏。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>标量和复合</p><p><strong>标量类型：</strong></p><ul><li><p>整数类型：i8, i16, i32, i64, i128 和 u8, u16, u32, u64, u128（i表示有符号，u表示无符号）</p><ul><li>可以使用_来分隔数字，方便读数</li></ul><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr><tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr><tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr><tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (单字节字符)(仅限于 <code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><ul><li><p>溢出处理：</p><ul><li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li><li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li><li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li><li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">wrapping_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 0</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">checked_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 None</span><br><span class="hljs-keyword">let</span> (result, overflowed) = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">overflowing_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 (0, true)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">saturating_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 255</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>浮点数类型：f32, f64。</p><ul><li>默认类型是 <code>f64</code></li></ul></li><li><p>布尔类型：bool，值只能是true或false（可以显示或者隐式表示）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// with explicit type annotation</span><br></code></pre></td></tr></table></figure></li><li><p>字符类型：char，表示单个Unicode标量值</p></li></ul><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><blockquote><p>将多个值组合成一个类型。元组和数组</p></blockquote><p>元组：多个其他类型的值组合进一个符合类型的主要方式。长度固定：一旦声明，长度不会增大或缩小。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>tup变量绑定到整个元组上，使用<strong>模式匹配</strong>来解构元组值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    **<span class="hljs-keyword">let</span> (x, y, z) = tup;**<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;y&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将一个元组拆成x,y,z就叫做解构。</p><p>也可以使用 <code>.</code> 后跟值的索引来直接访问他们。</p><p>如：tup.0;tup.1这样子。（索引从0开始）</p><p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。</p><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><blockquote><p>每个元素类型必须相同。数组长度也是固定的。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-comment">//数据类型;数量</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<span class="hljs-comment">//初始值;元素个数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>索引访问</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><p>在fn后面输入函数名和一对圆括号来定义函数。大括号告诉编译器函数体的开始和结尾。</p></li><li><p>rust<strong>不关心函数定义所在的位置</strong>；可以在main之前也可以在之后。</p></li><li><p>参数：</p><ol><li>在函数签名中必须<strong>声明每个参数的类型</strong>。</li></ol></li><li><p>语句和表达式</p><ol><li>语句：执行一些操作但不返回值的指令</li><li>表达式：计算并产生一个值。</li><li>表达式的结尾没有分号，如果加上分号就会变成语句。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br>    x + <span class="hljs-number">1</span>     <span class="hljs-comment">//这里没有分号。</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>具有返回值的函数：不对返回值命名，但在箭头后声明他的类型。 可以使用return和指定值提前返回。否则函数会隐式地<strong>返回最后的表达式（保证最后是一个表达式，而不是语句）</strong></p></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">five</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p><strong>if表达式：</strong></p><ul><li>if后面直接跟一个表达式，不需要加括号，表达式之后再加大括号</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">5</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was true&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was false&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>rust不会在比较的时候将整数转换为布尔值</p><ul><li>在let语句中使用if：<code>let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;</code></li></ul><p><strong>使用循环重复执行：</strong></p><ul><li>loop循环：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;again!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从循环返回值：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>    counter += <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>        **<span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<span class="hljs-comment">//在break后面输入返回值**</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>循环标签：在多个循环之间消除歧义</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-symbol">&#x27;counting_up</span>: <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count = &#123;count&#125;&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">remaining</span> = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;remaining = &#123;remaining&#125;&quot;</span>);<br>            <span class="hljs-keyword">if</span> remaining == <span class="hljs-number">9</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> count == <span class="hljs-number">2</span> &#123;<br>                <span class="hljs-keyword">break</span> <span class="hljs-symbol">&#x27;counting_up</span>;<br>            &#125;<br>            remaining -= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        count += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;End count = &#123;count&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>while条件循环</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> number != <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;number&#125;!&quot;</span>);<br><br>    number -= <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>for遍历集合</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> a &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the value is: &#123;element&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">number</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">4</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;number&#125;!&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;LIFTOFF!!!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>翻转range</p><h1 id="阶段一："><a href="#阶段一：" class="headerlink" title="阶段一："></a>阶段一：</h1><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><blockquote><p>让 Rust 无需垃圾回收（garbage collector）即可保障内存安全</p></blockquote><ol><li>所有权是rust用于管理内存的一组规则。区别于其他语言的管理方式（垃圾回收机制or程序员亲自分配和释放内存），rust采用<strong>通过所有权系统管理内存</strong>，编译器在编译时会根据一系列的规则进行检查，如果违反了这些规则，程序就不能编译。</li><li>栈中的所有数据都必须占用已知且固定的大小，在编译时大小位置或大小可能变化的数据，要改为存储在堆上。向堆中放入数据时，你要请求一定大小的空间。内存分配器在堆上找到合适空位后，标记并返回表示该地址的指针，这个指针可以存储在栈上。</li><li>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的</li><li>所有权规则：<ol><li>Rust 中的每一个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li><li>值在任一时刻<strong>有且只有一个所有者</strong>。</li><li>当<strong>所有者（变量）离开作用域</strong>，这个<strong>值将被丢弃</strong>。</li></ol></li></ol><p>ps: String类型</p><ol><li>获取：let s&#x3D;String::from(”hello”);</li><li>在字符串后追加字面值：s.push_str(”,world!”);</li></ol><p>string类型可变，但是值不可变；string类型向堆申请内存。</p><h3 id="变量与数据交互的方式（一）：移动"><a href="#变量与数据交互的方式（一）：移动" class="headerlink" title="变量与数据交互的方式（一）：移动"></a><strong>变量与数据交互的方式（一）：移动</strong></h3><ul><li>多个变量可以采取不同的方式与同一数据进行交互</li><li>当s1赋值给s2后，s1就会失效。也就是s1被移动到了s2。（避免了二次释放）</li></ul><h3 id="变量与数据交互的方式（二）：克隆"><a href="#变量与数据交互的方式（二）：克隆" class="headerlink" title="变量与数据交互的方式（二）：克隆"></a>变量与数据交互的方式（二）：克隆</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>**copy trait：**如果一个类型实现了copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用</p><p>任何一组<strong>简单标量值</strong>的组合都可以实现 <code>Copy</code> ：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul><h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><ul><li>将值传递给函数与变量赋值的原理相似，向函数传递值可能会移动或者复制。如果是可copy的，就是复制进去，原变量仍有效。但如果是移动进去，原变量无效了。</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);             <span class="hljs-comment">// s 的值移动到函数里 ...</span><br>                                    <span class="hljs-comment">// ... 所以到这里不再有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);                  <span class="hljs-comment">// x 应该移动函数里，</span><br>                                    <span class="hljs-comment">// 但 i32 是 Copy 的，</span><br>                                    <span class="hljs-comment">// 所以在后面可继续使用 x</span><br><br>&#125; <span class="hljs-comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br>  <span class="hljs-comment">// 没有特殊之处</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <span class="hljs-comment">// some_string 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;some_string&#125;&quot;</span>);<br>&#125; <span class="hljs-comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span><br>  <span class="hljs-comment">// 占用的内存被释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <span class="hljs-comment">// some_integer 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;some_integer&#125;&quot;</span>);<br>&#125; <span class="hljs-comment">// 这里，some_integer 移出作用域。没有特殊之处</span><br></code></pre></td></tr></table></figure><h2 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h2><ul><li>返回值也可以转移所有权</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();         <span class="hljs-comment">// gives_ownership 将返回值</span><br>                                        <span class="hljs-comment">// 转移给 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 进入作用域</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="hljs-comment">// s2 被移动到</span><br>                                        <span class="hljs-comment">// takes_and_gives_back 中，</span><br>                                        <span class="hljs-comment">// 它也将返回值移给 s3</span><br>&#125; <span class="hljs-comment">// 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br>  <span class="hljs-comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;             <span class="hljs-comment">// gives_ownership 会将</span><br>                                             <span class="hljs-comment">// 返回值移动给</span><br>                                             <span class="hljs-comment">// 调用它的函数</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;yours&quot;</span>); <span class="hljs-comment">// some_string 进入作用域。</span><br><br>    some_string                              <span class="hljs-comment">// 返回 some_string </span><br>                                             <span class="hljs-comment">// 并移出给调用的函数</span><br>                                             <span class="hljs-comment">// </span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <span class="hljs-comment">// a_string 进入作用域</span><br>                                                      <span class="hljs-comment">// </span><br><br>    a_string  <span class="hljs-comment">// 返回 a_string 并移出给调用的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><blockquote><p><strong>不获取所有权</strong>就可以使用值的功能。</p></blockquote><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(**&amp;s1**);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: **&amp;<span class="hljs-type">String</span>**) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在传参的时候也要显式地表明是引用传参</li></ul><p>解引用：<code>*</code></p><p><strong>创建一个引用的行为，称为借用</strong></p><ul><li>（默认）不允许修改引用的值。</li></ul><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><ul><li>类似的，我们通过添加 <code>mut</code> 来声明是可变的。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">change</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change</span>(some_string: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    some_string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。</li><li>不能在同一时间多次将 <code>s</code> 作为可变变量借用。</li><li>我们 <strong>也</strong> 不能在拥有不可变引用的同时拥有可变引用。</li><li>可以避免数据竞争。</li></ul><p><strong>总的来说，就是我们可以同时拥有多个不可变引用，但是不可以在拥有不可变引用时拥有可变引用（不能同时使用）；也不可以同时拥有多个可变引用。</strong></p><h3 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h3><p>在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器<strong>确保数据不会在其引用之前离开作用域。</strong></p><h2 id="Slice类型"><a href="#Slice类型" class="headerlink" title="Slice类型"></a>Slice类型</h2><p><em>slice</em> 允许你引用集合中<strong>一段连续的元素序列</strong>，而不用引用整个集合。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..];<br></code></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="vector："><a href="#vector：" class="headerlink" title="vector："></a>vector：</h2><blockquote><p>类似于array，但长度可以改变，存储在heap中。存储的数据类型要相同</p></blockquote><h3 id="创建vector"><a href="#创建vector" class="headerlink" title="创建vector"></a>创建vector</h3><ul><li>调用 <code>Vec::new()</code> 函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> : <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure><p>C++：<code>vector&lt;int&gt; v;</code></p><p>在没有显式的给定初始值的时候，我们需要显式地指出vector要存储的数据类型。可以使用 <code>vec!</code> 宏，会根据我们提供的值来创建一个新的vector</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>=<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="更新vector"><a href="#更新vector" class="headerlink" title="更新vector"></a>更新vector</h2><p>向vector中添加新元素，可以使用 <code>push()</code> 方法；</p><p>比如：<code>v.push(4);</code></p><p>**但是！**需要注意的是，同之前讨论的任何变量一样，如果想要改变他的值，必须要使用 <code>mut</code> 关键字使其可变！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span>=<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//这样子才是可以通过编译的</span><br></code></pre></td></tr></table></figure><h2 id="读取vector的元素"><a href="#读取vector的元素" class="headerlink" title="读取vector的元素"></a>读取vector的元素</h2><ul><li>通过索引读取</li><li>使用 <code>get()</code> 方法</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>= <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">third</span>:&amp;<span class="hljs-type">i32</span>=&amp;v[<span class="hljs-number">2</span>];<span class="hljs-comment">//这里相当于索引引用？</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;third&#125;&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">third</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt;=v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">match</span> third&#123;<br><span class="hljs-title function_ invoke__">Some</span>(third)=&gt;<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;third&#125;&quot;</span>)，<br><span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no third element.&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是索引引用，程序员需要保证一定不会越界，否则程序会崩溃且报错；</p><p>但是如果是get方法，则可以产生一个无法获取的打印信息；</p><ul><li>不可以在拥有vector中项的引用的同时向其增加一个元素</li></ul><p>在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p><h2 id="遍历vector中的元素"><a href="#遍历vector中的元素" class="headerlink" title="遍历vector中的元素"></a>遍历vector中的元素</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;i&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>    *i += <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举：存储多种类型"><a href="#枚举：存储多种类型" class="headerlink" title="枚举：存储多种类型"></a>枚举：存储多种类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SpreadsheetCell</span> &#123;<br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">row</span> = <span class="hljs-built_in">vec!</span>[<br>    SpreadsheetCell::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">3</span>),<br>    SpreadsheetCell::<span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;blue&quot;</span>)),<br>    SpreadsheetCell::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">10.12</span>),<br>];<br><br></code></pre></td></tr></table></figure><h2 id="丢弃vector时也会丢弃所有元素"><a href="#丢弃vector时也会丢弃所有元素" class="headerlink" title="丢弃vector时也会丢弃所有元素"></a>丢弃vector时也会丢弃所有元素</h2><h2 id="一些函数："><a href="#一些函数：" class="headerlink" title="一些函数："></a>一些函数：</h2><ol><li><strong>可变引用</strong>：<code>iter_mut()</code> 生成的引用是可变的，允许你修改集合中的元素。</li><li><strong><code>v.iter()</code></strong>:<ul><li>返回一个<strong>不可变引用</strong>的迭代器（<code>Iterator&lt;Item = &amp;T&gt;</code>）。</li><li>这意味着你可以遍历集合中的每个元素，但不能修改它们。</li></ul></li><li><strong><code>map(|element| &#123; ... &#125;)</code></strong>:<ul><li><code>map</code> 是一个<strong>高阶函数</strong>，接受一个<strong>闭包</strong>（<code>|element| &#123; ... &#125;</code>）作为参数。</li><li>闭包会对迭代器中的每个元素（<code>element</code>）进行处理，并返回一个新的值。</li><li>这里的 <code>element</code> 是集合中元素的不可变引用（<code>&amp;T</code>）。</li></ul></li><li><strong><code>collect()</code></strong>:<ul><li>将 <code>map</code> 处理后的结果收集到一个新的集合中（如 <code>Vec&lt;T&gt;</code>）。</li><li><code>collect()</code> 的返回类型取决于上下文，通常需要显式指定类型或通过类型推断确定。</li></ul></li></ol><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="定义与实例化"><a href="#定义与实例化" class="headerlink" title="定义与实例化"></a>定义与实例化</h2><ul><li>结构体的每一部分可以是不同类型；</li><li>结构体比元组更加灵活，<strong>不需要依赖顺序</strong>来指定或访问实例中的值</li></ul><p>定义方式与c++类似；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Name</span>&#123;<br>var1:type1,<br>var2:type2,<br>var3:type3,<br>&#125;<br></code></pre></td></tr></table></figure><p>在大括号中，定义每一部分数据结构的名字和类型，我们称为<strong>字段</strong></p><ul><li>实例化：</li></ul><p>创建一个实例，需要以结构体的名字开头，接着在大括号中使用 <code>key:value</code> 键-值对的形式提供字段。实例中字段顺序不需要和他们在结构体声明中的顺序一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;;<br>     <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user2</span> = User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;;<br>    user2.email = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;anotheremail@example.com&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>.</code> 来获取对应的值或者修改对应的值</li><li><strong>注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。</strong></li></ul><h3 id="字段初始化简写语法"><a href="#字段初始化简写语法" class="headerlink" title="字段初始化简写语法"></a><strong>字段初始化简写语法</strong></h3><ul><li>如果在创建一个新实例的时候，我们哟啊将email字段的值设置为传入参数email的值，不需要显式地说明，他们可以直接对应</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        username: username,<br>        email: email,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//简化后：</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        **username,<br>        email,**<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a><strong>结构体更新语法</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//原版：</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// --snip--</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>        active: user1.active,<br>        username: user1.username,<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>        sign_in_count: user1.sign_in_count,<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//简化后：</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// --snip--</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>        **..user1**<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是利用了<strong>移动</strong>。所以后续不能再使用user1了</p><p>但是如果我们丢username和email这种不是很轻松复制的变量都进行修改，那么就可以利用<strong>克隆</strong>，这样子user1仍然可用</p><h3 id="使用没有命名字段的元组结构来创建不同的类型"><a href="#使用没有命名字段的元组结构来创建不同的类型" class="headerlink" title="使用没有命名字段的元组结构来创建不同的类型"></a>使用没有命名字段的元组结构来创建不同的类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = <span class="hljs-title function_ invoke__">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="没有任何字段的类单元结构体"><a href="#没有任何字段的类单元结构体" class="headerlink" title="没有任何字段的类单元结构体"></a>没有任何字段的类单元结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlwaysEqual</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">subject</span> = AlwaysEqual;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a>方法语法</h1><p><strong>方法</strong>（method）与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们<strong>在结构体的上下文中被定义</strong>（或者是枚举或 trait 对象的上下文，将分别在<a href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html">第六章</a>和<a href="https://kaisery.github.io/trpl-zh-cn/ch18-02-trait-objects.html">第十八章</a>讲解），并且它们<strong>第一个参数总是 <code>self</code></strong>，它代表调用该方法的结构体实例。</p><h2 id="定义方法："><a href="#定义方法：" class="headerlink" title="定义方法："></a>定义方法：</h2><p>impl代表实例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关联函数：</p><p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_learning</title>
    <link href="/2025/02/08/OS-learning/"/>
    <url>/2025/02/08/OS-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter1：操作系统接口"><a href="#chapter1：操作系统接口" class="headerlink" title="chapter1：操作系统接口"></a>chapter1：操作系统接口</h1><p><strong>操作系统的工作是：</strong></p><ul><li>将<strong>计算机资源在多个程序之间共享</strong>，并给程序提供一系列比硬件本身更有用的服务</li><li><strong>管理并抽象</strong>底层硬件。（如word不用关心自己使用的是哪种硬盘）</li><li>多路复用硬件，让多个程序“看起来”是同时运行的。</li><li>给程序间提供一种受控的交互方式，使得程序之间可以共享数据、共同工作</li></ul><p>操作系统通过<strong>接口</strong>向用户程序提供服务。接口设计依赖于少量的机制，通过这些机制的组合提供强大、通用的功能。</p><ul><li><em>kernel</em>(内核)：为运行的程序提供服务的一种特殊程序。每个运行着的程序叫做进程，<strong>每个进程的内存中存储指令、数据和堆栈</strong>。一个计算机可以<strong>拥有多个进程</strong>，但是只能有一个内核。</li><li>每当进程需要调用内核时，它会触发一个<em>system call</em>（系统调用），system call进入内核执行相应的服务然后返回。</li><li>shell 是一个普通的程序，它接受用户输入的命令并且执行它们。不是内核的一部分。</li><li>xv6内核提供了Unix传统系统调用的一部分。</li></ul><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>fork()</strong></td><td><strong>创建进程</strong></td></tr><tr><td>exit()</td><td>结束当前进程；0代表以正常状态退出，1代表以非正常状态退出</td></tr><tr><td>wait()</td><td>等待子进程结束;等待子进程退出，返回子进程PID;没有子程序则返回-1</td></tr><tr><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr><td>getpid()</td><td>获得当前进程 pid</td></tr><tr><td><strong>sleep(n)</strong></td><td><strong>睡眠 n 秒</strong></td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读&#x2F;写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>dup(fd)</td><td>复制 fd</td></tr><tr><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p</td></tr><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><h2 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h2><ol><li>xv6进程由两部分组成：<strong>用户内存空间</strong>（指令，数据，堆栈）+ <strong>仅对内核可见</strong>的进程状态</li><li>分时特性：在可用CPU之间不断切换。当一个进程不在执行时，xv6保存它的CPU寄存器，当他们再次被执行时恢复这些寄存器的值。</li><li>内核将每个<strong>进程</strong>和一个<strong>PID</strong>（process identifier）关联起来</li><li>一个进程可以通过调用fork()来创建新进程；创建生成的是<strong>子进程</strong>，其内容同创建它的进程（父进程）一样。</li></ol><ul><li><code>fork</code> 函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">int pid;<br>pid = fork();<br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>    pid = <span class="hljs-title function_ invoke__">wait</span>();<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br>    <span class="hljs-title function_ invoke__">exit</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O和文件描述符"><a href="#I-O和文件描述符" class="headerlink" title="I&#x2F;O和文件描述符"></a>I&#x2F;O和文件描述符</h2><ul><li><strong>文件描述符</strong>是一个整数，它代表了一个进程<strong>可以读写的被内核管理的对象</strong>。</li><li>获取方式：打开文件、目录、设备或创建一个管道pipe或复制已经存在的文件描述符。</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是一个小的内核缓冲区，它以<strong>文件描述符对</strong>的形式提供给进程，一个用于<strong>写操作</strong>，一个用于<strong>读操作</strong>。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。</p><ul><li>管道会进行自我清扫</li><li>管道可以传输任意长度的数据</li><li>管道允许同步</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>xv6 文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>read接受三个参数</p><ul><li>第一个参数：文件描述符，指向一个之前打开的文件。<ul><li>shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到console的输出。</li></ul></li><li>第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据。</li><li>第三个参数是代码想读取的最大长度。</li></ul><h1 id="Lab0-实验搭建"><a href="#Lab0-实验搭建" class="headerlink" title="Lab0 实验搭建"></a>Lab0 实验搭建</h1><ul><li>使用wsl2。（在debian12中进行）</li></ul><ol><li>安装编译器（突然意识到，之前计组实验好像安装过了，所以直接使用）</li><li>安装QEMU</li><li>下载xv6并编译</li></ol><p>遇到的问题：在 <code>make qemu</code>时出现了死循环错误。解决办法：修改makefile，将 <code>CFLAGS := -Wall -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie</code> 注释掉。</p><p>其余的直接安装官方步骤进行就可以了。</p><h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="sleep的实现"><a href="#sleep的实现" class="headerlink" title="sleep的实现"></a>sleep的实现</h2><ol><li>在user文件夹下新建sleep.c文件</li><li>研究一下其他函数文件是怎么实现的</li></ol><ul><li>如何传递命令行参数</li><li>头文件需要引用哪一些</li></ul><p>例子：echo.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, argv[i], <span class="hljs-built_in">strlen</span>(argv[i]));<br>    <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt; argc)&#123;<br>      <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>直接使用同款头文件就行了</p><ul><li>#include “user&#x2F;user.h”这里涵盖了sleep()等系统调用函数</li><li>#include “kernel&#x2F;types.h” 是一些数据类型</li><li>获取参数：int main(int argc, char *argv[])<ul><li>argc是参数个数</li><li>argv是输入的字符串</li></ul></li><li>将字符串转为int–atoi函数</li></ul><ol start="3"><li>写完sleep.c之后，要将它添加到makefile文件，一同编译出来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">UPROGS=\<br><span class="hljs-variable">$U</span>/_cat\<br><span class="hljs-variable">$U</span>/_echo\<br><span class="hljs-variable">$U</span>/_forktest\<br><span class="hljs-variable">$U</span>/_grep\<br><span class="hljs-variable">$U</span>/_init\<br><span class="hljs-variable">$U</span>/_kill\<br><span class="hljs-variable">$U</span>/_ln\<br><span class="hljs-variable">$U</span>/_ls\<br><span class="hljs-variable">$U</span>/_mkdir\<br><span class="hljs-variable">$U</span>/_rm\<br><span class="hljs-variable">$U</span>/_sh\<br><span class="hljs-variable">$U</span>/_stressfs\<br><span class="hljs-variable">$U</span>/_usertests\<br><span class="hljs-variable">$U</span>/_grind\<br><span class="hljs-variable">$U</span>/_wc\<br><span class="hljs-variable">$U</span>/_zombie\<br><span class="hljs-variable">$U</span>/_sleep\<br></code></pre></td></tr></table></figure></li><li>然后再编译 <code>make qemu</code>，成功后，调用sleep函数就可以了</li></ol><h2 id="pingpong的实现"><a href="#pingpong的实现" class="headerlink" title="pingpong的实现"></a>pingpong的实现</h2><ol><li>理解管道（pipe）<ul><li>管道是一种半双工的通信机制，允许两个进程进行通信。管道有两个文件描述符：<ul><li>p[0]：用于读取数据</li><li>p[1]：用于写入数据</li></ul></li></ul></li><li>使用pipe()创建管道；此处需要创建<strong>两个管道</strong>，一个用于<strong>父级向子级发送一个字节</strong>；一个用于<strong>父级从子级读取字节</strong></li><li>read(fd, buf, n)：从文件中读 n 个字节到 buf</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>    pipe(p1);<br>    pipe(p2);<br>    <span class="hljs-type">int</span> pid;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR:fork failed!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<span class="hljs-comment">//子进程： 父进程从子进程读取数据--开启父进程的写，关闭读；开启子进程的读，关闭写</span><br>        close(p1[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭子进程的写</span><br>        close(p2[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭父进程的读</span><br>        read(p1[<span class="hljs-number">0</span>],buf, <span class="hljs-number">1</span>);<span class="hljs-comment">//从子进程的读口读出1个字节到buf</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:received ping\n&quot;</span>, getpid());<br>        write(p2[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//向父进程的写口，写入一个字节</span><br>        close(p1[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭子进程的读口</span><br>        close(p2[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭父进程的写口</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//正常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//父进程：父进程写入子进程--开启父进程读口和子进程写口；关闭父进程写口和子进程读口</span><br>        close(p1[<span class="hljs-number">0</span>]);<br>        close(p2[<span class="hljs-number">1</span>]);<br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>        read(p2[<span class="hljs-number">0</span>], buf, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:received pong\n&quot;</span>,getpid());<br>        close(p1[<span class="hljs-number">1</span>]);<br>        close(p2[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p><strong>&#x3D;&gt;素数筛法</strong><br>素数筛法是一种经典的算法，用于找出一定范围内的所有素数。它的基本思想是：</p><ul><li>从 2 开始，将当前数标记为素数。</li><li>将该数的所有倍数标记为非素数。</li><li>移动到下一个未被标记的数，重复上述过程。<br>在并发版本中，每个素数会由一个独立的进程处理，并通过管道将筛选后的数字传递给下一个进程。</li></ul><p><strong>&#x3D;&gt;并发版本的思路</strong><br>在并发版本中，每个素数对应一个进程，进程之间通过管道通信：</p><ol><li>第一个进程：生成数字 2 到 35，并将它们写入管道。</li><li>后续进程：</li></ol><ul><li>从管道中读取第一个数字，这个数字就是当前进程负责的素数。</li><li>打印这个素数。</li><li>继续读取后续的数字，筛选掉当前素数的倍数，将剩余的数字写入下一个管道。</li><li>创建一个新的子进程来处理下一个素数。</li></ul><ol start="3"><li>终止条件：</li></ol><ul><li>当没有更多数字需要处理时，进程退出。</li></ul><p>&#x3D;&gt;需要两个管道，一个用于筛选得到新的一组数据，另一个用于接收新一组的数据，进一步进行筛选；<br>直到达到限制</p><p>&#x3D;&gt;文件描述符的管理：<br>每个进程需要关闭不需要的文件描述符，以避免资源耗尽。<br>父进程在创建子进程后，需要关闭子进程使用的管道端。</p><p>&#x3D;&gt;进程的递归创建：<br>每个素数对应一个进程，进程之间通过管道连接，形成一条链。</p><p>&#x3D;&gt;终止条件：<br>当管道中没有更多数字时，进程退出。<br>主进程需要等待所有子进程退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>&#123;<br>    <span class="hljs-type">int</span> num;<br>   <span class="hljs-comment">//read(fd, &amp;num, sizeof(num));//读取第一个数，作为素数</span><br>    <span class="hljs-keyword">if</span> (read(fd, &amp;num, <span class="hljs-keyword">sizeof</span>(num)) == <span class="hljs-number">0</span>) &#123;<br>        close(fd);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 读取失败，退出</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, num);<span class="hljs-comment">//打印目标语句</span><br>    <span class="hljs-comment">//筛选掉当前素数的倍数</span><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//递归</span><br>        close(p[<span class="hljs-number">1</span>]);<br>        sieve(p[<span class="hljs-number">0</span>]);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//筛选</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span>(read(fd,&amp;n,<span class="hljs-keyword">sizeof</span>(n))&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(n%num!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//不是当前素数的倍数，保留</span><br>                <span class="hljs-comment">//传入到下一个</span><br>                write(p[<span class="hljs-number">1</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(n));<br>            &#125;<br>        &#125;<br>        close(fd);<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<span class="hljs-comment">//等待子进程退出</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//child process</span><br>        close(p[<span class="hljs-number">1</span>]);<br>        sieve(p[<span class="hljs-number">0</span>]);<span class="hljs-comment">//从子进程读口获取新一组数据</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//parent process</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>;i++)&#123;<br>            write(p[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(i));<span class="hljs-comment">//2-35</span><br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">while</span> (wait(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find的实现"><a href="#find的实现" class="headerlink" title="find的实现"></a>find的实现</h2><ol><li><p>阅读ls.c文件，了解如何获取目录信息</p><ul><li>dirent：读取目录项<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> dirent &#123;<br>    <span class="hljs-built_in">ushort</span> inum;    <span class="hljs-comment">// i-node 号，指向文件系统中的 i-node</span><br>    <span class="hljs-built_in">char</span> name[DIRSIZ];  <span class="hljs-comment">// 文件/目录名（不含路径）</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li>stat：获取文件属性<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> stat &#123;<br>    <span class="hljs-built_in">int</span> dev;     <span class="hljs-comment">// 设备号</span><br>    <span class="hljs-built_in">uint</span> ino;    <span class="hljs-comment">// i-node 号</span><br>    <span class="hljs-built_in">short</span> type;  <span class="hljs-comment">// 文件类型 (T_DIR=目录, T_FILE=普通文件)</span><br>    <span class="hljs-built_in">short</span> nlink; <span class="hljs-comment">// 硬链接数</span><br>    <span class="hljs-built_in">uint</span> size;   <span class="hljs-comment">// 文件大小</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><strong><code>dirent</code> 结构本身不会告诉你文件是目录还是普通文件</strong> ，要用 <code>stat()</code> 查询。</li></ul></li><li><p>读取目录：</p><ul><li>用read()读取目录项<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;.&quot;</span>,O_RDONLY);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><span class="hljs-keyword">while</span>(read(fd,&amp;de,<span class="hljs-keyword">sizeof</span>(de))==<span class="hljs-keyword">sizeof</span>(de))&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;File:%s\n&quot;</span>,de.name);<br>&#125;<br>close(fd);<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>获取文件属性</li></ol></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">struct <span class="hljs-keyword">stat</span> st;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">stat</span>(<span class="hljs-string">&quot;filename&quot;</span>, &amp;st) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Size: <span class="hljs-variable">%d</span>, Type: <span class="hljs-variable">%d</span>\n&quot;</span>, st.size, st.type);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="xargs的实现"><a href="#xargs的实现" class="headerlink" title="xargs的实现"></a>xargs的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-comment">// 读取一行输入，存储到 buffer</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read_line</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> max_size)</span> &#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <br>    <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, &amp;c, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 从标准输入读取一个字符</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123; <span class="hljs-comment">// 行结束</span><br>            buffer[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 以 NULL 结尾</span><br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; max_size - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 防止溢出</span><br>            buffer[i++] = c;<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-keyword">return</span> i &gt; <span class="hljs-number">0</span> ? i : <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回读取的字节数，如果是 EOF 则返回 -1</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: xargs &lt;command&gt; [args ...]\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">512</span>]; <span class="hljs-comment">// 存储输入行</span><br>    <span class="hljs-type">char</span> *exec_argv[MAXARG]; <span class="hljs-comment">// exec() 参数数组</span><br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// 复制原始命令参数（跳过 xargs 本身）</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc - <span class="hljs-number">1</span> &amp;&amp; i &lt; MAXARG - <span class="hljs-number">1</span>; i++) &#123;<br>        exec_argv[i] = argv[i + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (read_line(buffer, <span class="hljs-keyword">sizeof</span>(buffer)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= MAXARG - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xargs: too many arguments\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        exec_argv[i] = buffer;  <span class="hljs-comment">// 把读取到的行作为新参数</span><br>        exec_argv[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">// exec 需要 NULL 终止</span><br><br>        <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>            exec(exec_argv[<span class="hljs-number">0</span>], exec_argv);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xargs: exec failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// 等待子进程完成</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
