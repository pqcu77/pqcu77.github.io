<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java_oop</title>
    <link href="/2025/11/10/Java-oop/"/>
    <url>/2025/11/10/Java-oop/</url>
    
    <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="面向对象编程（OOP）"><a href="#面向对象编程（OOP）" class="headerlink" title="面向对象编程（OOP）"></a>面向对象编程（OOP）</h2><p>面向过程–自己掌控整个过程<br>面向对象–关注的是完成这件事的对象，而无需知道过程。</p><ul><li>面向过程是流程化的，一步一步，上一步做完了，再做下一步。</li><li>面向对象是模块化的，我做我的，你做你的，我需要你做的话，我就告诉你一声。我不需要知道你到底怎么做，只看功劳不看苦劳。</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>我们之前学习过了cpp，所以对面向对象、类等这些知识点还是相对熟悉的。</p><p>创建java对象时，需要使用new关键字。创建类对象也需要</p><ul><li>所有对象在创建的时候都会在堆内存中分配空间</li><li>创建对象时需要一个<code>main()</code>方法作为入口，<code>main()</code>方法可以在当前类中，也可以在另一个类中。</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dadoudou</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        System.out.println(person.name);<br>        System.out.println(person.age);<br>        System.out.println(person.sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>与cpp不同的是，java作为一门纯粹的面向对象语言，它强制要求<strong>所有代码</strong>（包括<strong>程序的入口点</strong>）都必须封装在类中。</li></ul><p>如果万物皆对象，都需要先创建对象实例才能调用方法，那第一个main方法是怎么被调用的呢？</p><ul><li>我们通过 <code>static</code> 关键字解决！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Restaurant</span> &#123; <span class="hljs-comment">// 这是一个“饭店”（类）</span><br>    <span class="hljs-comment">// main方法是这个饭店的一个“特殊外卖窗口”，它不属于某个具体的厨师（实例）</span><br>    <span class="hljs-comment">// 这个窗口是饭店自带的，不需要先雇厨师就能使用。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;餐厅开业了！&quot;</span>);<br>        <span class="hljs-comment">// 现在，我们可以在内部创建“厨师”对象了</span><br>        <span class="hljs-type">Chef</span> <span class="hljs-variable">chef1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chef</span>(<span class="hljs-string">&quot;王师傅&quot;</span>);<br>        chef1.cook(<span class="hljs-string">&quot;麻婆豆腐&quot;</span>); <span class="hljs-comment">// 调用实例方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chef</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chef</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">// 这是一个实例方法，属于具体的“厨师”对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cook</span><span class="hljs-params">(String dish)</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;正在烹饪: &quot;</span> + dish);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>static 意味着这个方法是属于类本身的，而不是属于由这个类创建出来的某个具体对象。</p><p>实际开发中，我们通常不在当前类中直接创建对象并使用它，而是放在使用对象的类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 微信搜「沉默王二」，回复关键字 PDF</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dadoudou</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始化类中变量的方法"><a href="#初始化类中变量的方法" class="headerlink" title="初始化类中变量的方法"></a>初始化类中变量的方法</h3><p>方法一：直接通过引用变量来赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        person.name = <span class="hljs-string">&quot;沉默王二&quot;</span>;<br>        person.age = <span class="hljs-number">18</span>;<br>        person.sex = <span class="hljs-number">1</span>;<br>        <br>        System.out.println(person.name);<br>        System.out.println(person.age);<br>        System.out.println(person.sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：通过方法初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 沉默王二，一枚有趣的程序员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(String n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> s)</span> &#123;<br>        name = n;<br>        age = a;<br>        sex = s;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        person.initialize(<span class="hljs-string">&quot;沉默王二&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>);<br><br>        System.out.println(person.name);<br>        System.out.println(person.age);<br>        System.out.println(person.sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：通过构造方法初始化<br>直接把要初始化变量的值当作参数传入，并赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 沉默王二，一枚有趣的程序员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;沉默王二&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">1</span>);<br><br>        System.out.println(person.name);<br>        System.out.println(person.age);<br>        System.out.println(person.sex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在cpp中我们一般使用的就是方法3，java也是如此。</p><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>万物皆对象。万物指的是java中的所有类，这些类都是Object类的<strong>子类</strong><br><img src="/img/file-20251110173202651.png"></p><h4 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>用于返回对象的哈希码<br>按照约定，相等的对象必须具有相等的哈希码，如果重写了equals方法，就要重写hashCode方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> Objects.hash(name,age);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子生成，相等的对象就会有相同的哈希码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br></code></pre></td></tr></table></figure><p>用于比较两个对象的内存地址是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>但我们一般会重写，修改成比较两个对象的值是否相等。</p><ul><li>根据类里的对象来设置，一般是一个个比较</li></ul><h4 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h4><p>默认实现只做浅拷贝，且类必须实现Cloneable接口。<br>Object 本身没有实现 Cloneable 接口，所以在不重写 clone 方法的情况下直接直接调用该方法会发生 CloneNotSupportedException 异常。</p><h4 id="对象转字符串"><a href="#对象转字符串" class="headerlink" title="对象转字符串"></a>对象转字符串</h4><p><code>public String toString()</code>：返回对象的字符串表示。默认实现返回<code>类名@哈希码</code>的十六进制表示，但通常会被重写以返回更有意义的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多线程调度"><a href="#多线程调度" class="headerlink" title="多线程调度"></a>多线程调度</h4><p>每个对象都可以调用Object 的 wait&#x2F;notify 方法来实现等待&#x2F;通知机制</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>一开始不知道要初始化的类是什么，所以没办法用new关键字直接创造对象。</p><p>反射的缺点：</p><ul><li>破坏封装</li><li>性能开销</li></ul><p>反射的优点：</p><ul><li>开发通用框架：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。</li><li>动态代理：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。</li><li>注解：注解本身只是起到一个标记符的作用，它需要利用反射机制，根据标记符去执行特定的行为。</li></ul><p><code>public final native Class&lt;?&gt; getClass()</code>：用于获取对象的类信息，如类名。比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetClassDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&gt; aClass = p.getClass();<br>        System.out.println(aClass.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p><code>protected void finalize() throws Throwable</code>：当垃圾回收器决定回收对象占用的内存时调用此方法。</p><h1 id="package包"><a href="#package包" class="headerlink" title="package包"></a>package包</h1><p>java中我们使用package来解决名字冲突</p><ul><li>一个类总是属于某个包，类名只是一个简写，真正的完整类名是 <code>包名.类名</code></li></ul><p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p><blockquote><p>[!NOTE]<br>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p></blockquote><p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p><h2 id="包的作用域"><a href="#包的作用域" class="headerlink" title="包的作用域"></a>包的作用域</h2><p>包作用域是指：当一个类、接口、成员没有显式地使用任何访问修饰符时，它所拥有的访问权限。</p><p>位于同一个包的类，可以访问包作用域的字段和方法。<br>不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。</p><p>把一个类定义在包下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <span class="hljs-comment">// 包作用域: void hello() &#123; System.out.println(&quot;Hello!&quot;); &#125; &#125;</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.hello(); <span class="hljs-comment">// 可以调用，因为Main和Person在同一个包</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子就将Person和Main都定义在hello下了。<br>main可以直接访问person类，它们位于同一包作用域下。</p><h3 id="导入包："><a href="#导入包：" class="headerlink" title="导入包："></a>导入包：</h3><h4 id="直接写出完整类名"><a href="#直接写出完整类名" class="headerlink" title="直接写出完整类名"></a>直接写出完整类名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        mr.jun.<span class="hljs-type">Arrays</span> <span class="hljs-variable">arrays</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">mr</span>.jun.Arrays();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很麻烦</p><h4 id="使用-import-语句"><a href="#使用-import-语句" class="headerlink" title="使用 import 语句"></a>使用 <code>import</code> 语句</h4><p>导入类后写简单类名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入完整类名:</span><br><span class="hljs-keyword">import</span> mr.jun.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Arrays</span> <span class="hljs-variable">arrays</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arrays</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>import时可以使用通用标识符，直接将这个包下的所有class都导入进来，但是不包含子包的class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">package</span> ming;<br><br><span class="hljs-comment">// 导入mr.jun包的所有class:</span><br><span class="hljs-keyword">import</span> mr.jun.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Arrays</span> <span class="hljs-variable">arrays</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arrays</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是不推荐这种写法，导入多个包后，很难看出类属于哪个包</p><p>还有一种<code>import static</code>的语法，它可以导入一个类的静态字段和静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> main;<br><br><span class="hljs-comment">// 导入System类的所有静态字段和静态方法:</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 相当于调用System.out.println(…)</span><br>        out.println(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没怎么见过这个方法</p><p>在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是<strong>完整类名</strong>，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是<strong>简单类名</strong>，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><p>这里我们知道，在编写class时，编译器会自动帮我们import：</p><ul><li>import当前package的其他class</li><li><code>import java.lang.*</code></li></ul><p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Java 变量就好像一个容器，可以保存程序在运行过程中的值，它在声明的时候会定义对应的<a href="https://javabetter.cn/basic-grammar/basic-data-type.html">数据类型</a>（Java 分为两种数据类型：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>）<br>变量按照作用域的范围又可分为三种类型：<u>局部变量，成员变量和静态变量</u>。</p><p>局部变量：</p><ul><li>在栈上分配</li><li>没有默认值，被声明后必须经过初始化才可以使用</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。</li></ul><p>声明成员变量时的注意事项：</p><ul><li>成员变量声明在一个类中，但在方法、构造方法和语句块之外。</li><li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li><li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁。</li><li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</li><li>成员变量可以声明在使用前或者使用后。</li><li>访问修饰符可以修饰成员变量。</li><li>成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</li></ul><p>静态变量：</p><ul><li>静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。</li><li>无论一个类创建了多少个对象，类<strong>只拥有静态变量的一份拷贝</strong>。</li><li>静态变量除了被声明为常量外很少使用。</li><li>静态变量储存在<strong>静态存储区</strong>。</li><li>静态变量在程序开始时创建，在程序结束时销毁。</li><li>与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li><li>静态变量的默认值和实例变量相似。</li><li>静态变量还可以在静态语句块中初始化。</li></ul><p>常量：</p><ul><li>代表常数，便于修改（例如：圆周率的值，<code>final double PI = 3.14</code>）</li><li>增强程序的可读性（例如：常量 UP、DOWN 用来代表上和下，<code>final int UP = 0</code>）</li></ul><p>java要求常量名必须大写</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>只有方法被调用时，它才会执行。Java 中最有名的方法当属 <code>main()</code> 方法，这是程序的入口。</p><p>如何声明方法</p><ul><li>方法的声明反映了方法的可见性（public、private、protected、default）、返回类型（int、void…）、方法名和参数<br><img src="/img/file-20251111132238566.png"><br>访问权限：</li><li>public：该方法可以被所有类访问。</li><li>private：该方法只能在定义它的类中访问。</li><li>protected：该方法可以被同一个包中的类，或者不同包中的子类访问。</li><li>default：如果一个方法没有使用任何访问权限修饰符，那么它是 package-private 的，意味着该方法只能被同一个包中的类可见。</li></ul><h2 id="方法的种类"><a href="#方法的种类" class="headerlink" title="方法的种类"></a>方法的种类</h2><ul><li>标准类库方法</li><li>用户自定义方法</li></ul><h3 id="预先定义方法"><a href="#预先定义方法" class="headerlink" title="预先定义方法"></a>预先定义方法</h3><p>Java 提供了大量预先定义好的方法供我们调用，也称为标准类库方法，或者内置方法。</p><h3 id="用户自定义方法"><a href="#用户自定义方法" class="headerlink" title="用户自定义方法"></a>用户自定义方法</h3><p>当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li>实例方法：没有static关键字修饰的，但是在类中有声明的方法。</li><li>调用这种方法之前，必须创建类的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 微信搜「沉默王二」，回复关键字 PDF</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceMethodExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">InstanceMethodExample</span> <span class="hljs-variable">instanceMethodExample</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceMethodExample</span>();<br>        System.out.println(instanceMethodExample.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例方法有两种特殊类型：</p><ul><li>getter 方法</li><li>setter 方法</li></ul><p>getter 方法用来<strong>获取私有变量</strong>（private 修饰的字段）的值，setter 方法用来<strong>设置私有变量</strong>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 沉默王二，一枚有趣的程序员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(<span class="hljs-type">int</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getter 方法以 get 开头，setter 方法以 set 开头。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>有 <a href="https://javabetter.cn/oo/static.html">static 关键字</a>修饰的方法就叫做静态方法。<br>StaticMethodExample 类中，mian 和 add 方法都是静态方法，不同的是，main 方法是程序的入口。当我们调用静态方法的时候，就不需要 new 出来类的对象，就可以直接调用静态方法了，一些工具类的方法都是静态方法，比如说 hutool 工具类库，里面有大量的静态方法可以直接调用。</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>没有方法体的方法被称为抽象方法，它总是在<a href="https://javabetter.cn/oo/abstract.html">抽象类</a>中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用 abstract 关键字创建抽象方法和抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 微信搜「沉默王二」，回复关键字 PDF</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDemo</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类继承抽象类之后，必须重写抽象方法</p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>允许方法接受<strong>零个或多个</strong>指定类型的参数。它使用省略号(<code>...</code>)表示，实际上是一个语法糖，底层仍然是数组。<br><img src="/img/file-20251112110143755.png"></p><ul><li>尽量不要使用可变参数，如果要用的话，可变参数需要在列表最后一位</li><li><strong>当使用可变参数的时候，实际上是先创建了一个数组，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法</strong>。</li></ul><h1 id="native本地方法"><a href="#native本地方法" class="headerlink" title="native本地方法"></a>native本地方法</h1><h2 id="JNI：Java-Native-Interface"><a href="#JNI：Java-Native-Interface" class="headerlink" title="JNI：Java Native Interface"></a>JNI：Java Native Interface</h2><p>一般情况下，我们完全可以使用 Java 语言编写程序，但某些情况下，Java 可能满足不了需求，或者不能更好的满足需求，比如：</p><ul><li>①、标准的 Java 类库不支持。</li><li>②、我们已经用另一种语言，比如说 C&#x2F;C++ 编写了一个类库，如何用 Java 代码调用呢？</li><li>③、某些运行次数特别多的方法，为了加快性能，需要用更接近硬件的语言（比如汇编）编写。</li></ul><p>JNI 的缺点：</p><ul><li>①、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。</li><li>②、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了 Java 和 C&#x2F;C++ 之间的耦合性。<br><a href="https://javabetter.cn/oo/native-method.html#_2%E3%80%81%E7%94%A8-c-%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95">手把手教你用 C语言实现 Java native 本地方法 | 二哥的Java进阶之路</a></li></ul><p>native 用来修饰方法，用 native 声明的方法表示该方法的实现在外部定义，可以用任何语言去实现它，比如说 C&#x2F;C++。 简单地讲，一个 native Method 就是一个 Java 调用非 Java 代码的接口。</p><p>native 语法：</p><ul><li>①、修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。</li><li>②、不能用 abstract 修饰，也没有方法体，也没有左右大括号。</li><li>③、返回值可以是任意类型</li></ul><p>“三妹，你学的不错嘛。”我对三妹的学习能力感到非常的欣慰，“<strong>我们在日常编程中看到 native 修饰的方法，只需要知道这个方法的作用是什么，至于别的就不用管了，操作系统会给我们实现，初学的时候也不需要太过深入</strong>。”</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>Java 有两种类型的构造方法：<strong>无参构造方法和有参构造方法</strong>。</p><h2 id="创建构造方法的规则"><a href="#创建构造方法的规则" class="headerlink" title="创建构造方法的规则"></a>创建构造方法的规则</h2><ul><li>构造方法的名字必须和类名一样；</li><li>构造方法没有返回类型，包括 void；</li><li>构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。</li></ul><p>构造方法不能被子类继承，所以用final和abstract关键字修饰没有也意义<br>构造方法用于初始化一个对象，所以用static关键字修饰没有意义<br>多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">class_name</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">class_name</span><span class="hljs-params">()</span>&#123;&#125;    <span class="hljs-comment">// 默认无参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ciass_name</span><span class="hljs-params">([paramList])</span>&#123;&#125;    <span class="hljs-comment">// 定义有参数列表的构造方法</span><br>    …<br>    <span class="hljs-comment">// 类主体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果写成了 <code>void Demo()</code> ，这并不是构造方法，而是会看作普通方法</p><h2 id="默认构造方法"><a href="#默认构造方法" class="headerlink" title="默认构造方法"></a>默认构造方法</h2><p>如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。<br>无参构造方法是可以缺省的，我们开发者并不需要显式的声明无参构造方法</p><h2 id="有参构造方法"><a href="#有参构造方法" class="headerlink" title="有参构造方法"></a>有参构造方法</h2><p>有参构造方法可以为不同的对象提供不同的值。当然，也可以提供相同的值。</p><h2 id="重载构造方法"><a href="#重载构造方法" class="headerlink" title="重载构造方法"></a>重载构造方法</h2><ul><li>可以用于应对不同的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 沉默王二，一枚有趣的程序员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverloadingConstrutorPerson</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverloadingConstrutorPerson</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverloadingConstrutorPerson</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;姓名 &quot;</span> + name + <span class="hljs-string">&quot; 年龄 &quot;</span> + age + <span class="hljs-string">&quot; 性别 &quot;</span> + sex);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">OverloadingConstrutorPerson</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OverloadingConstrutorPerson</span>(<span class="hljs-string">&quot;沉默王二&quot;</span>,<span class="hljs-number">18</span>, <span class="hljs-number">1</span>);<br>        p1.out();<br><br>        <span class="hljs-type">OverloadingConstrutorPerson</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OverloadingConstrutorPerson</span>(<span class="hljs-string">&quot;沉默王三&quot;</span>,<span class="hljs-number">16</span>);<br>        p2.out();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法主要是用于初始化对象的字段，并没有返回类型<br>构造方法的调用是隐式的，通过编译器完成<br><img src="/img/file-20251112115609928.png"></p><h1 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h1><p>复制一个对象可以通过下面三种方式完成：</p><ul><li>通过构造方法</li><li>通过对象的值</li><li>通过 Object 类的 <code>clone()</code> 方法</li></ul><h2 id="通过构造方法"><a href="#通过构造方法" class="headerlink" title="通过构造方法"></a>通过构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyConstrutorPerson</span><span class="hljs-params">(CopyConstrutorPerson person)</span> &#123; <br><span class="hljs-built_in">this</span>.name = person.name; <span class="hljs-built_in">this</span>.age = person.age; <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">CopyConstrutorPerson</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyConstrutorPerson</span>(<span class="hljs-string">&quot;沉默王二&quot;</span>,<span class="hljs-number">18</span>);<br>p1.out();<br><br><span class="hljs-type">CopyConstrutorPerson</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyConstrutorPerson</span>(p1);<br>p2.out();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里直接将对象p1作为参数传递给构造函数。（我们在前面重载了这个构造方法，使得可以通过这个方法来实现。</p><h2 id="通过对象的值"><a href="#通过对象的值" class="headerlink" title="通过对象的值"></a>通过对象的值</h2><p>很粗暴，直接一个个赋值</p><h2 id="通过Object类的-clone-方法"><a href="#通过Object类的-clone-方法" class="headerlink" title="通过Object类的 clone() 方法"></a>通过Object类的 <code>clone()</code> 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 沉默王二，一枚有趣的程序员</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClonePerson</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClonePerson</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;姓名 &quot;</span> + name + <span class="hljs-string">&quot; 年龄 &quot;</span> + age);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">ClonePerson</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClonePerson</span>(<span class="hljs-string">&quot;沉默王二&quot;</span>,<span class="hljs-number">18</span>);<br>        p1.out();<br><br>        <span class="hljs-type">ClonePerson</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (ClonePerson) p1.clone();<br>        p2.out();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <code>clone()</code> 方法复制对象的时候，ClonePerson 必须先实现 Cloneable 接口的 <code>clone()</code> 方法，然后再调用 <code>clone()</code> 方法（<code>ClonePerson p2 = (ClonePerson) p1.clone()</code>）</p><ul><li>但这里应该是浅拷贝</li></ul><h1 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h1><p>在 Java 中，提供了四种访问权限控制：</p><ul><li>默认访问权限（包访问权限）</li><li>public</li><li>private</li><li>protected<br>和cpp几乎一模一样</li></ul><h1 id="代码初始化块"><a href="#代码初始化块" class="headerlink" title="代码初始化块"></a>代码初始化块</h1><p>代码初始化块用于初始化一些成员变量</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="定义抽象类"><a href="#定义抽象类" class="headerlink" title="定义抽象类"></a>定义抽象类</h2><p>定义的时候需要用到关键字 <code>abstract</code> 。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractPlayer</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类的特征"><a href="#抽象类的特征" class="headerlink" title="抽象类的特征"></a>抽象类的特征</h2><p>抽象类<strong>不可以实例化</strong>（即不能new）<br>但可以有子类，子类通过 <code>extends</code> 关键字来继承抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">abstractFather</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个类定义了一个或多个抽象方法，那这个类必须是抽象类。也就是说，只要类中定义了抽象方法，就一定是抽象类。</p><ul><li>普通类不可以定义抽象方法</li><li>抽象类中可以定义抽象方法也可以定义普通方法。抽象方法没有方法体。</li></ul><p>抽象类派生的子类必须实现父类中定义的抽象方法。（除非子类也是抽象类）</p><h2 id="抽象类的应用场景"><a href="#抽象类的应用场景" class="headerlink" title="抽象类的应用场景"></a>抽象类的应用场景</h2><h3 id="第一种场景：代码复用"><a href="#第一种场景：代码复用" class="headerlink" title="第一种场景：代码复用"></a>第一种场景：代码复用</h3><ul><li>共享通用代码，避免重复代码。<br>比如抽象类中定义了普通方法（有方法体），例如sleep()方法中打印 <code>是个人都要睡觉</code>。这样子子类可以直接继承复用。</li></ul><h3 id="第二种场景：子类实现API"><a href="#第二种场景：子类实现API" class="headerlink" title="第二种场景：子类实现API"></a>第二种场景：子类实现API</h3><p>抽象类中给出动物叫的API，子类继承时填写方法体。<br>比如之前我们在cpp学习过程中写过的动物叫，小狗就是汪汪叫，小猫就是喵喵叫等。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>java中可以通过两种形式来达到抽象的目的，一个是抽象类，一个是接口</li></ul><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>接口通过 <code>interface</code> 关键字来定义，它可以包含一些常量和方法。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Electronic</span> &#123;<br>    <span class="hljs-comment">// 常量</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">LED</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LED&quot;</span>;<br><br>    <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getElectricityUse</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnergyEfficient</span><span class="hljs-params">(String electtronicType)</span> &#123;<br>        <span class="hljs-keyword">return</span> electtronicType.equals(LED);<br>    &#125;<br><br>    <span class="hljs-comment">// 默认方法</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDescription</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;电子&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其反编译后的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Electronic</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElectricityUse</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnergyEfficient</span><span class="hljs-params">(String electtronicType)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> electtronicType.equals(<span class="hljs-string">&quot;LED&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printDescription</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;\u7535\u5B50&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LED</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LED&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到接口中的所有变量或方法都会自动加上 <code>public</code> 关键字</p><ul><li><p>接口中定义的变量会在编译的时候自动加上 <code>public static final</code> 修饰符。也就是说变量在接口里就是一个常量。<br>Every field declaration in the body of an interface is implicitly public, static, and final.</p></li><li><p>没有使用 <code>private</code> <code>default</code>或者 <code>static</code> 关键字修饰的方法是隐式抽象的。在编译的时候会自动加上 <code>public abstract</code> 修饰符。</p></li><li><p>java8开始，接口中允许有静态方法</p></li><li><p>default方法就是<u>接口中定义的、有具体实现</u>的方法。它允许接口在不破坏现有实现的情况下，添加新的方法。<br>允许在接口中定义默认方法的理由很充分，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 <code>default</code> 方法的帮助下，我们就必须挨个对实现类进行修改。</p></li></ul><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><ul><li>接口不允许直接实例化。需要定义一个类去实现接口。<br>例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Electronic</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElectricityUse</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了Computer类来实现Electronic接口<br>再进行实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Electronic e=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Computer</span>();<br></code></pre></td></tr></table></figure><ul><li>接口可以为空,既可以不定义变量，也可以不定义方法。</li><li>不要在定义接口的时候使用final关键字。因为接口就是为了让子类实现的，而 final 阻止了这种行为。</li><li>接口的抽象方法不能是private,protected或者final</li><li>接口的变量是隐式的public static final，值无法变</li></ul><h2 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h2><ul><li><p>使某些类具有我们想要的功能。实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。</p><ul><li>Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。</li></ul></li><li><p>Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。<br><img src="/img/file-20251113210152064.png"></p></li><li><p>实现多态</p><ul><li>1、要有继承关系，比如说 Circle 和 Square 都实现了 Shape 接口。</li><li>2、子类要重写父类的方法，Circle 和 Square 都重写了 <code>name()</code> 方法。</li><li>3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。</li></ul></li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul><li>在类里定义类</li><li>成员内部类、局部内部类、匿名内部类和静态内部类</li></ul><h2 id="成员内部类：在类里嵌套一个类。"><a href="#成员内部类：在类里嵌套一个类。" class="headerlink" title="成员内部类：在类里嵌套一个类。"></a>成员内部类：在类里嵌套一个类。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wanger</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangxiaoer</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">81</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员内部类可以访问外部类的所有成员属性。<br>外部类要访问内部类需要先创建一个成员内部类对象，再通过对象来访问。<br>如果要在静态方法里访问成员内部类，需要先创建外部类，再创建外部类的成员内部类对象，进而访问成员内部类的成员。</p><h2 id="局部内部类：在方法或者作用域里定义的类"><a href="#局部内部类：在方法或者作用域里定义的类" class="headerlink" title="局部内部类：在方法或者作用域里定义的类"></a>局部内部类：在方法或者作用域里定义的类</h2><p>局部内部类的生命周期仅限于作用域内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangsan</span> &#123;<br>    <span class="hljs-keyword">public</span> Wangsan <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wangxiaosan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Wangsan</span>&#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Wangxiaosan</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul><li>在创建对象的同时定义类体，没有显式的类名。通常用于实现接口或继承类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName());<br>            &#125;<br>        &#125;);<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><ul><li>不能有构造器也不能是抽象类。</li><li>访问外部变量需要final</li></ul><p><img src="/img/file-20251114192102264.png"></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul><li>静态内部类：用static关键词修饰的定义在类里的类。<br>不允许访问外部类中非static的变量和方法。</li></ul><p>使用内部类还能够为我们带来如下特性：</p><ul><li>1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li><li>2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li><li>3、创建内部类对象的时刻并不依赖于外部类对象的创建。</li><li>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li><li>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li></ul><h1 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h1><p>封装和cpp几乎一模一样</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>java的继承用到的关键字是 <code>extends</code> </p><ul><li>java中的继承是单一继承，一个子类只能拥有一个父类，所以extends只能继承一个类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">sonClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fatherClass</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>子类继承父类后，就拥有父类的<u>非私有</u>的<strong>属性和方法</strong>。</p><p><code>implements</code> 关键字：可以变相使java拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 implements 接口<span class="hljs-number">1</span>, 接口<span class="hljs-number">2</span>, ..., 接口n &#123;<br>    <span class="hljs-comment">// 必须实现所有接口的抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（接口中的方法不能具体定义，只能声明，所以继承接口必须重写接口内的方法）<br>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义多个接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 一个类实现多个接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperDuck</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Swimmable</span>, Flyable, Runnable &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SuperDuck</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;正在游泳&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;正在飞翔&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;正在奔跑&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自己的特有方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAbilities</span><span class="hljs-params">()</span> &#123;<br>        swim();<br>        fly();<br>        run();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SuperDuck</span> <span class="hljs-variable">duck</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperDuck</span>(<span class="hljs-string">&quot;超级鸭&quot;</span>);<br>        duck.showAbilities();<br>        <br>        <span class="hljs-comment">// 也可以按接口类型使用</span><br>        <span class="hljs-type">Swimmable</span> <span class="hljs-variable">swimmer</span> <span class="hljs-operator">=</span> duck;<br>        <span class="hljs-type">Flyable</span> <span class="hljs-variable">flyer</span> <span class="hljs-operator">=</span> duck;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runner</span> <span class="hljs-operator">=</span> duck;<br>        <br>        swimmer.swim();<br>        flyer.fly();<br>        runner.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就相当于继承了多个类</p><h3 id="this-和-super"><a href="#this-和-super" class="headerlink" title="this 和 super"></a>this 和 super</h3><p><strong>this 表示当前对象，是指向自己的引用。</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.属性 <span class="hljs-comment">// 调用成员变量，要区别成员变量和局部变量</span><br><span class="hljs-keyword">this</span>.() <span class="hljs-comment">// 调用本类的某个方法</span><br><span class="hljs-keyword">this</span>() <span class="hljs-comment">// 表示调用本类构造方法（无参）</span><br><span class="hljs-keyword">this</span>(参数) <span class="hljs-comment">// 表示调用本类有参构造方法</span><br></code></pre></td></tr></table></figure><p><strong>super 表示父类对象，是指向父类的引用。</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">super.属性 <span class="hljs-comment">// 表示父类对象中的成员变量</span><br>super.方法() <span class="hljs-comment">// 表示父类对象中定义的方法</span><br>super() <span class="hljs-comment">// 表示调用父类构造方法</span><br></code></pre></td></tr></table></figure><p><strong>子类的构造过程必须调用其父类的构造方法：</strong> Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。</p><ul><li>如果子类的构造方法中没有显示地调用父类构造方法，则系统默认调用父类无参数的构造方法。</li></ul><h3 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h3><p>方法重写就是把方法重新实现一次<br>方法重载是方法名相同，参数不一致。调用时会根据传递的参数进行选择。</p><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>通过子类对象（小范围）实例化父类对象（大范围），也就是将子类对象赋值给父类类型的引用变量。</p><ul><li>自动转换<br><img src="/img/file-20251114193600623.png"><br>父类引用变量指向子类对象后，只能使用父类已声明的方法，如果方法被重写，就会执行子类的方法。</li></ul><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>通过父类对象实例化子类对象（将父类对象赋值给子类对象）</p><ul><li>需要手动强制转换<br><img src="/img/file-20251114200502935.png"></li></ul><p>在 Java 继承中，父子类初始化先后顺序为：</p><ol><li>父类中静态成员变量和静态代码块</li><li>子类中静态成员变量和静态代码块</li><li>父类中普通成员变量和代码块，父类的构造方法</li><li>子类中普通成员变量和代码块，子类的构造方法</li></ol><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>Java 的多态是指在面向对象编程中，同一个类的对象在不同情况下表现出来的不同行为和状态。</p><ul><li>子类可以继承父类的字段和方法，子类对象可以直接使用父类中的方法和字段（私有的不行）。</li><li>子类可以重写从父类继承来的方法，使得子类对象调用这个方法时表现出不同的行为。</li><li>可以将子类对象赋给父类类型的引用，这样就可以通过父类类型的引用调用子类中重写的方法，实现多态。</li></ul><h3 id="多态和重载的区别"><a href="#多态和重载的区别" class="headerlink" title="多态和重载的区别"></a>多态和重载的区别</h3><p>多态是动态多态，发生在运行时。通过继承和方法重写的方式实现。<br>重载是静态多态，发生在编译时。是同一类中的同名方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物发出声音&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;喵喵喵！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolymorphismExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 多态：编译时类型为Animal，运行时类型为具体子类</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();  <span class="hljs-comment">// 向上转型</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();  <span class="hljs-comment">// 向上转型</span><br>        <br>        animal1.makeSound();  <span class="hljs-comment">// 输出：汪汪汪！（运行时决定）</span><br>        animal2.makeSound();  <span class="hljs-comment">// 输出：喵喵喵！（运行时决定）</span><br>        <br>        <span class="hljs-comment">// 实际运行的方法由对象真实类型决定</span><br>        demonstratePolymorphism(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());  <span class="hljs-comment">// 汪汪汪！</span><br>        demonstratePolymorphism(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>());  <span class="hljs-comment">// 喵喵喵！</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 多态方法：可以处理任何Animal子类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demonstratePolymorphism</span><span class="hljs-params">(Animal animal)</span> &#123;<br>        animal.makeSound();  <span class="hljs-comment">// 动态绑定，运行时确定具体实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>多态是通过向上转型实现的，让不同类型的对象可以对同一方法调用做出不同的响应</strong>。</p><h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><ul><li>方便在没有创建对象的情况下进行调用。属于类的方法，而不是对象的方法。</li><li>通过 <code>类名.方法名</code> 来调用</li></ul><p>静态变量：被整个类共用的变量。<br>如果是普通变量，是每个对象都有一个变量。</p><p>静态方法有以下这些特征。</p><ul><li>静态方法属于这个类而不是这个类的对象；</li><li>调用静态方法的时候不需要创建这个类的对象；</li><li>静态方法可以访问静态变量。</li></ul><h1 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h1><p>用于判断对象是否符合指定的类型。<br>我们使用 instanceof 比较的目的，也就是希望如果结果为 true 的时候能进行类型转换。</p><h1 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h1><p><strong>1）确保类是 final 的</strong>，不允许被其他类继承*。<br><strong>2）确保所有的成员变量（字段）是 final 的</strong>，这样的话，它们就只能在构造方法中初始化值，并且不会在随后被修改。<br><strong>3）不要提供任何 setter 方法</strong>。<br><strong>4）如果要修改类的状态，必须返回一个新的对象</strong>。</p><h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><p>注解提供了一系列数据用来<strong>装饰程序代码</strong>（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的运行效果没有直接影响，由编译器决定该执行哪些操作。</p><p>注解的生命周期</p><ul><li>SOURCE：在源文件中有效，被编译器丢弃。</li><li>CLASS：在编译器生成字节码文件中有效，在运行时会被处理类文件的jvm丢弃</li><li>RUNTIME：在运行时有效。允许程序通过反射的方式访问注解，并根据注解的定义执行相应的代码。</li></ul><p>截止到 Java 9，注解的类型一共有 11 种，定义在 ElementType 枚举中。<br>1）TYPE：用于类、接口、注解、枚举<br>2）FIELD：用于字段（类的成员变量），或者枚举常量<br>3）METHOD：用于方法<br>4）PARAMETER：用于普通方法或者构造方法的参数<br>5）CONSTRUCTOR：用于构造方法<br>6）LOCAL_VARIABLE：用于变量<br>7）ANNOTATION_TYPE：用于注解<br>8）PACKAGE：用于包<br>9）TYPE_PARAMETER：用于泛型参数<br>10）TYPE_USE：用于声明语句、泛型或者强制转换语句中的类型<br>11）MODULE：用于模块</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wsl-终端美化</title>
    <link href="/2025/11/09/wsl-%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/"/>
    <url>/2025/11/09/wsl-%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>使用到的是oh-my-zsh<br>感觉这个上手还是比较快的。<br>参考的教程：<br><a href="https://blog.openreplay.com/zh/%E8%87%AA%E5%AE%9A%E4%B9%89-terminal-oh-my-zsh-themes-plugins/">使用 Oh My Zsh 主题和插件自定义您的终端</a><br><a href="https://www.haoyep.com/posts/zsh-config-oh-my-zsh/">zsh 安装与配置，使用 oh-my-zsh 美化终端 | Leehow的小站</a><br>主题预览：<br><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes"><a href="https://learnku.com/articles/53567">oh-my-zsh 主题样式列表 | 计算机科学论坛</a></a><br>官网：（也有安装教程）<br><a href="https://ohmyz.sh/">Oh My Zsh - a delightful &amp; open source framework for Zsh</a><br><img src="/img/file-20251109133514219.png"></p><p>安装主题前，需要安装 <code>ZSH</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install zsh<br></code></pre></td></tr></table></figure><p>验证安装结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">~# zsh -v<br>zsh 5.8.1 (x86_64-ubuntu-linux-gnu)<br></code></pre></td></tr></table></figure><p>将其设置为默认shell（注意不要使用sudo）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">chsh -s $(which zsh)<br></code></pre></td></tr></table></figure><p>接着开始安装oh my zsh<br>任选一个进行安装：</p><table><thead><tr><th>Method</th><th>Command</th></tr></thead><tbody><tr><td><strong>curl</strong></td><td><code>sh -c &quot;$(curl -fsSL https://install.ohmyz.sh/)&quot;</code></td></tr><tr><td><strong>wget</strong></td><td><code>sh -c &quot;$(wget -O- https://install.ohmyz.sh/)&quot;</code></td></tr><tr><td><strong>fetch</strong></td><td><code>sh -c &quot;$(fetch -o - https://install.ohmyz.sh/)&quot;</code></td></tr><tr><td>国内curl<a href="https://gitee.com/pocmon/ohmyzsh">镜像</a></td><td><code>sh -c &quot;$(curl -fsSL https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)&quot;</code></td></tr><tr><td>国内wget<a href="https://gitee.com/pocmon/ohmyzsh">镜像</a></td><td><code>sh -c &quot;$(wget -O- https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh)&quot;</code></td></tr></tbody></table><p>安装好之后我们可以加入一些插件</p><p>添加插件的方法：</p><ul><li>手动安装</li><li>将插件名添加到 <code>.zshrc</code> 里</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">plugins</span><span class="hljs-operator">=</span>(git plugin-name)<br></code></pre></td></tr></table></figure><p>插件配置和更新</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/.oh-my-zsh/</span>custom<span class="hljs-regexp">/plugins/</span>plugin-name git pull<br></code></pre></td></tr></table></figure><p>对于内置插件，使用oh my zsh的更新机制：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">omz update</span><br></code></pre></td></tr></table></figure><p>如果您的 shell 变慢，监控插件加载时间：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">time zsh -i -c <span class="hljs-keyword">exit</span><br>```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               <br>如果启动时间超过 <span class="hljs-number">1</span>-<span class="hljs-number">2</span> 秒，考虑删除未使用的插件或切换到更轻量的替代方案。<br><br>**zsh-autosuggestions** 基于您的历史记录提供智能命令补全。当您输入时，它以灰色文本建议命令。按右箭头键接受建议。<br><br>安装它：<br><br></code></pre></td></tr></table></figure><p>git clone <a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-autosuggestions</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-strong">**zsh-syntax-highlighting**</span> 在您输入时为命令着色，使发现拼写错误和理解命令结构更容易。<br><br>安装它：<br><br></code></pre></td></tr></table></figure><p>git clone <a href="https://github.com/zsh-users/zsh-syntax-highlighting.git">https://github.com/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~&#x2F;.oh-my-zsh&#x2F;custom}&#x2F;plugins&#x2F;zsh-syntax-highlighting</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><br><br># 自定义主题<br>### 自定义主题创建<br><br>通过复制现有主题创建自定义主题：<br><br></code></pre></td></tr></table></figure><p>cp ~&#x2F;.oh-my-zsh&#x2F;themes&#x2F;robbyrussell.zsh-theme ~&#x2F;.oh-my-zsh&#x2F;custom&#x2F;themes&#x2F;mytheme.zsh-theme</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>编辑主题文件以自定义颜色、布局和信息显示。基本主题结构：<br><br></code></pre></td></tr></table></figure><p>PROMPT&#x3D;’%{$fg[cyan]%}%n%{$reset_color%}:%{$fg[green]%}%c%{$reset_color%}$(git_prompt_info) %# ‘<br>ZSH_THEME_GIT_PROMPT_PREFIX&#x3D;” git:(%{$fg[red]%}”<br>ZSH_THEME_GIT_PROMPT_SUFFIX&#x3D;”%{$reset_color%}”<br>ZSH_THEME_GIT_PROMPT_DIRTY&#x3D;”%{$fg[blue]%}) %{$fg[yellow]%}✗%{$reset_color%}”<br>ZSH_THEME_GIT_PROMPT_CLEAN&#x3D;”%{$fg[blue]%})”</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>设置您的自定义主题：<br><br></code></pre></td></tr></table></figure><p>ZSH_THEME&#x3D;”mytheme”</p><pre><code class="hljs"></code></pre>]]></content>
    
    
    <categories>
      
      <category>wsl配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wsl配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C2Rust</title>
    <link href="/2025/11/09/C2Rust/"/>
    <url>/2025/11/09/C2Rust/</url>
    
    <content type="html"><![CDATA[<p>传统的C2Rust是一个整体的、流水线式的过程。我们将这个过程拆解成多个独立的子任务，每个子任务由一个专门的专家智能体负责。</p><h1 id="考虑agent角色定位"><a href="#考虑agent角色定位" class="headerlink" title="考虑agent角色定位"></a>考虑agent角色定位</h1><h2 id="项目分析与预处理agent"><a href="#项目分析与预处理agent" class="headerlink" title="项目分析与预处理agent"></a>项目分析与预处理agent</h2><p><strong>(Project Analysis &amp; Preprocessing Agent)</strong></p><ul><li>负责<strong>理解整个C项目</strong>的结构</li><li>任务：<ul><li>解析Makefile，CmakeLists.txt或其他建构系统，识别源文件、头文件、编译标志</li><li>运行C预处理器（如clang -E），将宏展开、处理条件编译，生成一个纯净的C代码版本，供后续智能体使用</li><li>构建项目的依赖图，了解文件之间的相互关系</li></ul></li></ul><h2 id="C语言语法与AST解析专家"><a href="#C语言语法与AST解析专家" class="headerlink" title="C语言语法与AST解析专家"></a>C语言语法与AST解析专家</h2><p> <strong>(C Syntax &amp; AST Parsing Agent)</strong><br> - 将预处理后的C代码转换成AST（抽象语法树）<br> - 任务：<br> - 使用clang&#x2F;llvm的库（libclang）来解析C代码，生成精确的AST<br> - 将AST序列化成一种通用格式，方便其他智能体消费和查询，而无需每个智能体都重新解析<br> - 提供一个查询接口，允许其他智能体查询特定节点的信息（如类型，变量，函数定义等）</p><h2 id="类型系统转换专家"><a href="#类型系统转换专家" class="headerlink" title="类型系统转换专家"></a>类型系统转换专家</h2><p><strong>(Type System Translation Agent)</strong></p><ul><li>负责将C语言的类型映射到Rust</li><li>任务：<ul><li>基本类型映射：<code>int-&gt;i32,char*-&gt;*mut i8</code>…</li><li>符合类型转换<ul><li><code>struct</code> -&gt; <code>struct</code> 或 <code>#[repr(C)] struct</code>。</li><li><code>union</code> -&gt; <code>union</code> 或 <code>#[repr(C)] union</code>。</li><li><code>enum</code> -&gt; <code>enum</code>。</li></ul></li><li>函数指针转换<code>void (*)(int)</code> -&gt; <code>Option&lt;unsafe extern &quot;C&quot; fn(i32)&gt;</code>。</li><li>管理类型的全局上下文，确保在整个项目中类型定义的一致性</li></ul></li></ul><h2 id="函数与逻辑转换专家"><a href="#函数与逻辑转换专家" class="headerlink" title="函数与逻辑转换专家"></a>函数与逻辑转换专家</h2><p><strong>(Function &amp; Logic Translation Agent)</strong></p><ul><li>将C函数的函数体和控制流翻译成等效的rust代码</li><li>任务<ul><li>逐个翻译函数</li><li>转换表达式、赋值语句和函数调用</li><li>处理控制流：<code>for</code> 循环、<code>while</code> 循环、<code>if-else</code> 分支、<code>switch-case</code> 到 Rust 的 <code>match</code>。</li><li>特殊情况处理：如goto语句，在rust中通常要重构成循环或loop+break</li></ul></li></ul><h2 id="内存与指针安全专家"><a href="#内存与指针安全专家" class="headerlink" title="内存与指针安全专家"></a>内存与指针安全专家</h2><p><strong>(Memory &amp; Pointer Safety Agent)</strong><br>！！！核心</p><ul><li>负责处理所有与指针和内存相关的操作，并尽可能生成安全的 Rust 代码。</li></ul><p>任务：</p><ul><li>指针翻译：将 C 的指针操作（解引用 <code>*</code>, 取地址 <code>&amp;</code>）翻译成 Rust 的裸指针（<code>*mut T</code>, <code>*const T</code>）。</li><li>unsafe块生成：所有裸指针操作、外部函数调用、union字段访问都必须被包裹在unsafe块中。</li><li>生命周期和所有权分析：尝试分析简单的指针使用模式，并将其重构为 Rust 的引用（<code>&amp;T</code>, <code>&amp;mut T</code>）或智能指针（<code>Box&lt;T&gt;</code>）。这是一个非常具有挑战性的任务，可以作为系统的长期优化目标。</li><li>处理 <code>malloc</code>&#x2F;<code>free</code>，将其转换为 Rust 的内存管理方式，或保留为 FFI 调用。</li></ul><h2 id="Rust代码生成与格式化专家"><a href="#Rust代码生成与格式化专家" class="headerlink" title="Rust代码生成与格式化专家"></a>Rust代码生成与格式化专家</h2><p><strong>(Rust Code Generation &amp; Formatting Agent)</strong></p><ul><li>将其他智能体生成的中间表示（IR）或翻译片段整合成最终的、格式正确的 <code>.rs</code> 文件。<br>任务：</li><li>根据类型专家和函数专家的输出，生成 Rust 的 <code>struct</code>, <code>enum</code>, <code>fn</code> 定义。</li><li>将所有代码片段组合成一个完整的、可编译的 Rust 模块。</li><li>自动插入必要的 <code>use</code> 语句和 <code>extern crate</code>。</li><li>调用 <code>rustfmt</code> 对生成的代码进行格式化，保证代码风格统一。</li><li>生成 <code>Cargo.toml</code> 文件，包括依赖项和构建配置</li></ul><h2 id="编排与协调核心"><a href="#编排与协调核心" class="headerlink" title="编排与协调核心"></a>编排与协调核心</h2><ul><li>作为所有智能体的“大脑”或“项目经理”，负责调度和协调它们的工作流程。</li><li><strong>任务</strong>:<ul><li>接收用户输入的 C 项目路径。</li><li>按顺序调用各个专家智能体：<ol><li>启动 <strong>项目分析专家</strong> 获取编译单元和标志。</li><li>对每个编译单元，调用 <strong>AST解析专家</strong> 生成 AST。</li><li>调用 <strong>类型专家</strong> 建立全局类型映射表。</li><li>并行或串行地让 <strong>函数与逻辑专家</strong> 和 <strong>内存安全专家</strong> 合作翻译所有函数。</li><li>最后，让 <strong>代码生成专家</strong> 汇总所有结果，输出最终的 Rust 项目。</li></ol></li><li>管理智能体之间的数据流，例如将 AST 传递给类型专家和函数专家。</li></ul></li></ul><h1 id="定义工作流程（workflow）"><a href="#定义工作流程（workflow）" class="headerlink" title="定义工作流程（workflow）"></a>定义工作流程（workflow）</h1><ul><li>输入：用户提供一个C语言项目</li><li>阶段一：分析（analysis）<ul><li><strong>Orchestrator</strong> 启动 <strong>Project Analysis Agent</strong>。</li><li><strong>Project Analysis Agent</strong> 分析构建系统，确定要编译的文件列表和编译选项</li></ul></li><li>阶段二：解析（parsing）<ul><li><strong>Orchestrator</strong> 对每个 C 文件，指示 <strong>AST Parsing Agent</strong> 生成并存储 AST。</li><li>所有 AST 形成一个可供查询的“知识库”。</li></ul></li><li>阶段三：翻译（translation）<ul><li><strong>Orchestrator</strong> 首先调用 <strong>Type System Agent</strong> 遍历所有 AST，建立一个全局的类型转换映射。</li><li>然后，<strong>Orchestrator</strong> 遍历所有函数定义，让 <strong>Function &amp; Logic Agent</strong> 和 <strong>Memory Safety Agent</strong> 协同工作，将函数体翻译成 Rust 代码的中间表示。这两个智能体需要频繁通信，例如函数专家处理一个赋值语句，如果涉及指针，就需要咨询内存安全专家如何生成 <code>unsafe</code> 代码。</li></ul></li><li>阶段四：生成（generation）<ul><li><strong>Orchestrator</strong> 收集所有翻译完成的类型和函数片段。</li><li><strong>Code Generation Agent</strong> 将这些片段组合成 <code>.rs</code> 文件，生成 <code>Cargo.toml</code>，并运行 <code>rustfmt</code>。</li></ul></li><li>输出：一个结构完整、可以尝试用 <code>cargo build</code> 编译的 Rust 项目。</li></ul><p>智能体框架可以考虑采用现有的，如LangChain，AutoGen等</p>]]></content>
    
    
    <categories>
      
      <category>C2Rust</category>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java_basic</title>
    <link href="/2025/11/03/Java-basic/"/>
    <url>/2025/11/03/Java-basic/</url>
    
    <content type="html"><![CDATA[<p><a href="https://javabetter.cn/home.html#java%E6%A0%B8%E5%BF%83">二哥的Java进阶之路x沉默王二 | 二哥的Java进阶之路</a></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>JDK、JRE和JVM分别都是什么？<br>JDK：开发java应用程序的软件环境<br>JRE：运行java应用的软件环境<br>JVM：java的虚拟机，屏蔽了不同os的差异性。可以一次编译，到处运行</p><p>顺便学到了用chocolate来安装！不用再手动设置path了！</p><p>.class文件和.java源代码的关系？</p><ul><li>.class是字节码文件，是经过javac编译后的文件，是交给jvm执行的文件。</li><li>.java是源代码<br><img src="/img/6dfd654c-c1a1-4baa-b275-b020e32a3fa2.png"><br>可以通过<code>javac Main.java</code> 这个命令来讲.java编译成.class</li></ul><p>可以使用java命令运行字节码：如 <code>java Main</code></p><ul><li>字节码由JVM逐条解释执行</li><li>部分字节码可能由JIT编译为机器指令直接执行</li></ul><p>逐条执行是JVM的基本执行模式。在这种模式下，Java 虚拟机会逐条读取字节码文件中的指令，并将其解释为对应的底层操作。</p><ul><li>优点：实现简单，启动速度快，但效率低</li></ul><p>JIT即时编译：在 JIT 模式下，Java 虚拟机会在运行时将频繁执行的字节码编译为本地机器码，这样就可以直接在硬件上运行，而不需要再次解释。</p><ul><li>需要注意的是，JIT 编译器并不会编译所有的字节码，而是根据一定的策略，仅编译被频繁调用的代码段（热点代码）。</li><li>优点：执行效率高，编译热点代码，动态优化</li></ul><p>现代的JVM通常会结合这两种执行方法，在程序运行初期，采用前者，减少启动时间；随着程序的运行，JVM会识别出热点代码并采用JIT 编译器讲其编译为本地机器码，从而提高程序的执行效率（混合模式）</p><ul><li>为了跨平台，java源代码首先编译成字节码。<br><img src="/img/df51559e-14dc-46b2-86d5-1d1166c9effd.png"></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>java是一种<strong>静态类型</strong>的编程语言，也就是说所有变量必须在使用前声明好，且必须先制定并变量的类型和名称。（cpp也是静态类型的编程语言）</p><ul><li>基本数据类型<ul><li>boolean、char、byte、short、int、long、float 和 double</li></ul></li><li>引用数据类型<ul><li>数组、class、接口<br>  <img src="/img/cc124996-8a43-4148-b132-5952676ed124.png"><br>  变量：局部变量（必须先初始化）、成员变量和静态变量（后两个可以不进行初始化，因为它们会有一个默认值）</li></ul></li><li>比如int，成员变量和静态变量如果没有进行初始化，值会为0.</li></ul><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>不确定</td></tr><tr><td>char</td><td>‘\u0000’</td><td>2 字节</td></tr><tr><td>byte</td><td>0</td><td>1 字节</td></tr><tr><td>short</td><td>0</td><td>2 字节</td></tr><tr><td>int</td><td>0</td><td>4 字节</td></tr><tr><td>long</td><td>0L</td><td>8 字节</td></tr><tr><td>float</td><td>0.0f</td><td>4 字节</td></tr><tr><td>double</td><td>0.0</td><td>8 字节</td></tr></tbody></table><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>boolean：ture,false<br>情况1：</li><li>对于单独使用的boolean，JVM没有提供专用的字节码指令，而是使用int相关的istore来处理，<strong>此时的boolean占用4bytes</strong></li><li>但作为数组使用的boolean类型，JVM会按照byte的指令来处理，<strong>此时的boolean占用1byte</strong></li></ul><p>情况2：布尔具体占用的大小是不确定的，取决于 JVM 的具体实现。</p><p>单个boolean变量：<br>对象头占用了12bytes</p><ul><li><strong>OFFSET 0 - 4</strong>：对象头的一部分，包含对象的标记字段（Mark Word），用于存储对象的哈希码、GC 状态等。</li><li><strong>OFFSET 4 - 8</strong>：对象头的另一部分，通常是指向类元数据的指针（Class Pointer）。</li><li><strong>OFFSET 8 - 12</strong>：对象头的最后一部分，包含锁状态或其他信息。</li><li>实际的boolean值占用1byte（offset12-13）</li><li>为了满足 8 字节的对齐要求（HotSpot JVM 默认的对象对齐方式），有 3 个字节的填充。<strong>OFFSET 13 - 16</strong>。<br>所以尽管boolean的值只需要1byte，但实际上占用了16bytes</li></ul><p>boolean数组：假设<code>arr[10]</code><br>同样的，对象头占用了12bytes</p><ul><li><strong>OFFSET 0 - 4</strong>：对象头的一部分，包含对象的标记字段（Mark Word）。</li><li><strong>OFFSET 4 - 8</strong>：对象头的另一部分，包含指向类元数据的指针（Class Pointer）。</li><li><strong>OFFSET 8 - 12</strong>：对象头的最后一部分，通常包含数组的长度信息。<br><strong>数组长度</strong> 占用了 4 个字节，此处是 10，<strong>OFFSET 12 - 16</strong>。<br>实际的boolean值值占用了1byte,offset:16-26<br>同时要凑够2的幂次</li></ul><blockquote><p>[!NOTE]<br>对象头主要由mark word（标记字段）和klass pointer（类型指针）组成</p></blockquote><p>由于其他的和cpp很类似，所以跳过。</p><h3 id="包装器类型（wrapper-types）"><a href="#包装器类型（wrapper-types）" class="headerlink" title="包装器类型（wrapper types）"></a>包装器类型（wrapper types）</h3><ul><li>java中的一种特殊类型，用于将基本数据类型转换为对应的<strong>对象类型</strong></li></ul><p>Java 提供了以下包装器类型，与基本数据类型一一对应：</p><ul><li>Byte（对应 byte）</li><li>Short（对应 short）</li><li>Integer（对应 int）</li><li>Long（对应 long）</li><li>Float（对应 float）</li><li>Double（对应 double）</li><li>Character（对应 char）</li><li>Boolean（对应 boolean）</li></ul><p>e.g:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Integer 包装器类型</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">integerValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">42</span>);<br>System.out.println(<span class="hljs-string">&quot;整数值: &quot;</span> + integerValue);<br><br><span class="hljs-comment">// 将字符串转换为整数</span><br><span class="hljs-type">String</span> <span class="hljs-variable">numberString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">parsedNumber</span> <span class="hljs-operator">=</span> Integer.parseInt(numberString);<br>System.out.println(<span class="hljs-string">&quot;整数值: &quot;</span> + parsedNumber);<br><br><span class="hljs-comment">// 使用 Character 包装器类型</span><br><span class="hljs-type">Character</span> <span class="hljs-variable">charValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>System.out.println(<span class="hljs-string">&quot;字符: &quot;</span> + charValue);<br><br><span class="hljs-comment">// 检查字符是否为数字</span><br><span class="hljs-type">char</span> <span class="hljs-variable">testChar</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;9&#x27;</span>;<br><span class="hljs-keyword">if</span> (Character.isDigit(testChar)) &#123;<br>System.out.println(<span class="hljs-string">&quot;字符是个数字.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li>对于接口类型的引用变量来说，没有办法直接new一个。<ul><li>只能new一个实现它的类的对象</li></ul></li></ul><ol><li>变量名指向<strong>存储对象的内存地址</strong>（在<strong>栈</strong>上）</li><li>内存地址指向的对象存储在<strong>堆</strong>上 （动态的）</li></ol><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>一般发生在求值、做运算的时候，比如double和int，一般会往大的转（类型自动提升）。</p><ul><li>自动类型转换只发生在兼容类型之间。</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">byte</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">short</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br><span class="hljs-function"><span class="hljs-title">char</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br></code></pre></td></tr></table></figure><p>需要注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>这里的50虽然是int，但是在赋值给b的时候，（如果这个赋值在byte类型的取值范围内）编译器会做隐式转换。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>需要我们显式地指定要执行的转换。</li></ul><p>一般出现在：</p><ul><li>较大数据类型转换为较小的数据类型（可能导致精度丢失）</li><li>将浮点数转换为整数</li><li>将字符类型转换为数值类型</li></ul><p>注意：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> a = <span class="hljs-number">1500000000</span>, b = <span class="hljs-number">1500000000</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = a + b;<br><span class="hljs-built_in">long</span> sum1 = a + b;<br><span class="hljs-built_in">long</span> sum2 = (<span class="hljs-built_in">long</span>)a + b;<br><span class="hljs-built_in">long</span> sum3 = (<span class="hljs-built_in">long</span>)(a + b);<br></code></pre></td></tr></table></figure><ul><li><code>int sum = a + b;</code> 这一条，由于int a和int b相加会超过范围，导致越界，变成负数</li><li>第二条，虽然最后赋值到long sum1，但是在右边计算的时候，两个int相加依然在int范围内，计算出结果之后，结果再赋值给long（这个时候转换不会越界–long比int范围更大）</li><li>第三条，由于这里a先转换为了long，所以b也会呗转换为long，在右边不会发生越界。</li><li>第四条，由于我们先计算了括号里的(a+b)再把结果转换为long，所以会越界，其实和第二条是差不多的。</li></ul><p>结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">-<span class="hljs-number">1294967296</span><br>-<span class="hljs-number">1294967296</span><br><span class="hljs-number">3000000000</span><br>-<span class="hljs-number">1294967296</span><br></code></pre></td></tr></table></figure><h2 id="基本数据类型缓存池（IntegerCache）"><a href="#基本数据类型缓存池（IntegerCache）" class="headerlink" title="基本数据类型缓存池（IntegerCache）"></a>基本数据类型缓存池（IntegerCache）</h2><p>看下下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">18</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">18</span>);<br>System.out.println(x == y);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">18</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">18</span>);<br>System.out.println(z == k);<br><br><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">300</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">300</span>);<br>System.out.println(m == p);<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>首先我们需要注意，java中<code>==</code>对于<strong>基本类型</strong>比较的是<strong>值</strong>，但是对于<strong>引用类型</strong>比较的是<strong>内存地址</strong></p></blockquote><p>现在再来看，由于 <code>new Integer()</code> 会创建一个新的对象，所以这里的x和y指向的内存地址一定是不同的（所以这里会打印false）<br>而 <code>Integer.valueOf()</code> 会使用<strong>缓存</strong>，对于 <u>-128~127</u>的整数，<strong>返回缓存中的同一个对象</strong>。所以这里18在范围内，返回的是同一个对象，但是300不在范围内，valueOf会创建新的Integer对象，所以m、p指向不同的对象。</p><p>最后的输出情况：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">false</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>具有常量缓存池的类型（注意：float和double没有–浮点数范围太大了）</p><table><thead><tr><th>数据类型</th><th>缓存池范围</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Character</td><td>\u0000 - \u007F</td></tr><tr><td>Boolean</td><td>True、False</td></tr></tbody></table><ul><li>valueOf的源码:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;=IntegerCache.low &amp;&amp; i &lt;=IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，如果超出范围，会调用new来创建</p><p>断言（asseert）–调试工具，用于检查程序逻辑<br>（默认关闭）需要手动启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在运行Java程序时加上 -ea 参数</span><br>java -ea AssertTest<br><br><span class="hljs-comment"># 或者启用所有系统的断言</span><br>java -enableassertions AssertTest<br></code></pre></td></tr></table></figure><p>assert：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">assert</span> 条件表达式;<br><span class="hljs-keyword">assert</span> 条件表达式 : <span class="hljs-string">&quot;错误信息&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>包括：算术运算符、关系运算符、位运算符、逻辑运算符、赋值运算符、三元运算符</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul><li>也就是 <code>+ - * / %</code> 和 <code>++,--</code></li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul><li><code>==,!=,&lt;,&gt;,&lt;=,&gt;=,</code></li></ul><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><ul><li><code>&amp;,|,^,~,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</code></li></ul><p>与cpp不同的是：<br><code>&gt;&gt;&gt;</code>：按位右移补零，<strong>左操作数的值</strong>按<strong>右操作数指定的位数</strong>右移，移动得到的空位以0填充<br><img src="/img/file-20251104112030191.png"><br>左移相当于乘2，右移相当于除以2</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑与运算符（<code>&amp;&amp;</code>）：多个条件中只要有一个为 false 结果就为 false。<br>逻辑或运算符（<code>||</code>）：多个条件只要有一个为 true 结果就为 true。<br>逻辑非运算符（<code>!</code>）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。<br>单逻辑与运算符（<code>&amp;</code>）：很少用，因为不管第一个条件为 true 还是 false，<strong>依然会检查第二个</strong>。<br>单逻辑或运算符（<code>|</code>）：<strong>也会检查第二个条件</strong>。</p><ul><li><code>&amp;&amp;</code> 和 <code>&amp;</code> 用法差不多，但是前者会导致短路，而后者不会（性能差一点）</li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>这个很常见</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>和cpp一样<br>e.g:<br><code>int min=(a&lt;b)?a:b;</code></p><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>简单看了一下和cpp几乎一样<br>pass</p><ul><li>有点忘记(用于遍历数组或集合)</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(元素类型 元素 : 数组或集合)</span></span>&#123;  <br><span class="hljs-comment">// 要执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尝试写一下"><a href="#尝试写一下" class="headerlink" title="尝试写一下"></a>尝试写一下</h2><ol><li>实现翻转</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>  <br>        Scanner scanner=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);  <br>        System.out.print(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>);  <br>        <span class="hljs-type">int</span> a=scanner.nextInt();  <br>        <span class="hljs-type">int</span> b;  <br>        b=reverse(a);  <br>        System.out.println(b);  <br>        scanner.close();  <br>    &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;  <br>        <span class="hljs-type">int</span> rev=<span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-type">int</span> pop=x%<span class="hljs-number">10</span>;  <br>            x/=<span class="hljs-number">10</span>;  <br>            rev=pop+rev*<span class="hljs-number">10</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> rev;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>但是我这个版本并没有做溢出检查，所以最好是在计算前检查是否会溢出，即补充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在计算前检查是否会溢出 if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)) return 0; if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; Integer.MIN_VALUE % 10)) return 0;</span><br></code></pre></td></tr></table></figure><h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>声明：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] anArray;<br><span class="hljs-comment">//or</span><br><span class="hljs-built_in">int</span> anArray[];<br></code></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span>[] anArray=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span>[] anArray=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li>数组是一个对象（上面使用了new）<br>访问数组</li></ul><h3 id="可变参数数组"><a href="#可变参数数组" class="headerlink" title="可变参数数组"></a>可变参数数组</h3><p>java中，可变参数用于将<strong>任意数量的参数</strong>传递给方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统数组方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(String[] args)</span><br><br><span class="hljs-comment">// 可变参数方式（更简洁）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(String... args)</span><br></code></pre></td></tr></table></figure><ul><li>必须使用 <code>...</code> 表示，必须是参数列表中的最后一个参数（在方法内部被当作数组处理）</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span>&#123;  <br>        <span class="hljs-type">int</span> total=<span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)&#123;  <br>            total+=num;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> total;  <br>    &#125;  <br>  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        System.out.println(sum());  <br>        System.out.println(sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>));  <br>        System.out.println(sum(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>));  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组和List"><a href="#数组和List" class="headerlink" title="数组和List"></a>数组和List</h3><ul><li>list封装了很多常用的方法，可以把数组转换成List来使用这些方法。</li></ul><p>转换方法：</p><ol><li>遍历数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>List&lt;Integer&gt; aList=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e:arr)&#123;<br>aList.add(e);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>通过Arrays类的 <code>asList()</code> 方法：</li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">Integer</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">aList</span><span class="hljs-operator">=</span><span class="hljs-built_in">Arrays</span><span class="hljs-operator">.</span><span class="hljs-variable">asList</span><span class="hljs-punctuation">(</span><span class="hljs-variable">arr</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><ul><li>Arrays.asList的参数需要是Integer数组</li><li>所以我们需要把原本的arr转换。<br>(1) 方法一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; aList1=Array.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>(2) 方法二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; aList2=Arrays.stream(arr).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ul><li>先将数组转换为Stream（IntStream–基本int类型的流）<ul><li>如果 <code>anArray</code>是 <code>int[]</code>，得到的是 <code>IntStream</code></li><li>如果 <code>anArray</code>是 <code>Integer[]</code>，得到的是 <code>Stream&lt;Integer&gt;</code></li></ul></li><li>然后将int转换为Integer（包装）</li><li>最后收集为List</li></ul><p>Arrays.asList()返回的是Arrays类的内部类ArrayList，不是我们常用的 <code>java.util.ArrayList</code>：</p><ul><li>不支持add(),remove()等修改大小的操作</li><li>支持get(),set()等读取操作<br>如果要把这种内部类转换为我们常用的类：</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">real</span>=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">Array</span>.asList(arr));<br></code></pre></td></tr></table></figure><h3 id="数组的查找与排序"><a href="#数组的查找与排序" class="headerlink" title="数组的查找与排序"></a>数组的查找与排序</h3><p>java也有<code>sort()</code>方法</p><ul><li>升序</li><li>实现了 Comparable 接口的对象按照 <code>compareTo()</code> 的排序</li></ul><p>使用例子：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span>[] arr=new int[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-attribute">Arrays</span>.sort(arr);<br></code></pre></td></tr></table></figure><p><img src="/img/file-20251104152827350.png"><br>要注意这里打印，</p><ul><li>不能像python一样直接print(arr);如果直接print(arr)会输出arr的地址，而不是里面的值。<br><img src="/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-11-04%20152713.png"></li><li>顺便认识一下这个地址打印出来的格式<ul><li><code>[</code> 表示一维数组，<code>[[</code> 表示二维数组</li><li><code>I</code> 表示数组元素类型是int</li><li><code>@</code> 是分隔符</li><li>剩下的部分是对象的哈希码（十六进制）</li></ul></li></ul><p>部分排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] yetAnotherArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;Z&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br>Arrays.sort(yetAnotherArray, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <br>            Comparator.comparing(String::toString).reversed());<br><span class="hljs-comment">// 结果：[A, Z, E, B, C]</span><br></code></pre></td></tr></table></figure><p>这里对1-3进行排序<br><code>Comparator.comparing(String::toString).reversed()</code>：自定义比较器</p><p>比较器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正常顺序：A→Z</span><br>Comparator&lt;String&gt; normal = Comparator.comparing(String::toString);<br><br><span class="hljs-comment">// 反转顺序：Z→A  </span><br>Comparator&lt;String&gt; reversed = normal.reversed();<br><br><span class="hljs-comment">// 相当于：</span><br>Comparator&lt;String&gt; reversed = (s1, s2) -&gt; s2.compareTo(s1);<br></code></pre></td></tr></table></figure><p>java中还提供了二分查找 <code>Arrays.binarySearch()</code>方法，参数是一个数组和需要查找的元素。</p><h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><ul><li><code>Arrays.copyOfRange()</code>用于复制数组</li><li>其底层调用的是<code>System.arraycopy()</code>方法–native方法</li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span>[][] oddNumbers = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>String类的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>String类是<strong>final</strong>的（即不可被继承、不可重写）</li><li>Serializeable接口：可以序列化</li><li>Comparable接口：定义了一些比较方法，比如比较两个字符串是否相等，使用<code>compareTo()</code>–可以比较值</li><li>实现了 <code>CharSequence</code> 接口（String,StringBuffer,StringBuilder都实现了)</li></ul><p>String也定义了 <code>equals(Object obj)</code>，用于判断两个字符串的<strong>内容</strong>是否完全相同</p><ul><li>实现思路：先判断是否是同一个对象-&gt;检查obj是否是String类的实例（不是则强制转换）-&gt;检查字符串长度-&gt;遍历比较每个字符</li></ul><p><code>compareTo(Str anotherStr)</code>:定义自然顺序。判断一个字符串在字典序上是大于、等于还是小于另一个字符串。（返回值：0，负整数，正整数）</p><blockquote><p>[!NOTE]<br>String底层为什么由char数组优化为byte数组？</p><ul><li>为了节省内存！<br>优化为byte[] 之后，引入了编码标志(coder)来智能选择存储方式。</li><li>有两种编码方式（LATIN1（只包含拉丁字母，1byte）和UTF-16（非拉丁字符，2bytes））</li></ul></blockquote><h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hash; <span class="hljs-comment">// 缓存字符串的哈希码</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash; <span class="hljs-comment">// 从缓存中获取哈希码</span><br>    <span class="hljs-comment">// 如果哈希码未被计算过（即为 0）且字符串不为空，则计算哈希码</span><br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> val[] = value; <span class="hljs-comment">// 获取字符串的字符数组</span><br><br>        <span class="hljs-comment">// 遍历字符串的每个字符来计算哈希码</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>            h = <span class="hljs-number">31</span> * h + val[i]; <span class="hljs-comment">// 使用 31 作为乘法因子</span><br>        &#125;<br>        hash = h; <span class="hljs-comment">// 缓存计算后的哈希码</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> h; <span class="hljs-comment">// 返回哈希码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>31倍哈希法</li></ul><h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p>用于提取子串。</p><ul><li>实现思路：检查是否越界，不越界则创建一个新的对象（new String(value,begin,subLen);)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex)</span> &#123;<br>    <span class="hljs-comment">// 检查起始索引是否小于 0，如果是，则抛出 StringIndexOutOfBoundsException 异常</span><br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-comment">// 计算子字符串的长度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> value.length - beginIndex;<br>    <span class="hljs-comment">// 检查子字符串长度是否为负数，如果是，则抛出 StringIndexOutOfBoundsException 异常</span><br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-comment">// 如果起始索引为 0，则返回原字符串；否则，创建并返回新的字符串</span><br>    <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-built_in">this</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;  <br><span class="hljs-keyword">import</span> java.util.Arrays;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;  <br>        String str=<span class="hljs-string">&quot;hello world&quot;</span>;  <br>        <span class="hljs-comment">// 截取片段  </span><br>        String sub1=str.substring(<span class="hljs-number">6</span>,<span class="hljs-number">11</span>);  <br>        System.out.println(sub1);  <br>        <span class="hljs-comment">//截取前缀or后缀  </span><br>        String sub2=str.substring(<span class="hljs-number">6</span>);  <br>        String sub3=str.substring(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);  <br>        System.out.println(sub2);  <br>        System.out.println(sub3);  <br>  <br>        <span class="hljs-comment">//处理字符串中的空格和分隔符  </span><br>        String str2=<span class="hljs-string">&quot;   hello,   world!   &quot;</span>;  <br>        <span class="hljs-comment">// 去掉字符串开头和结尾的空格  </span><br>        String trimmed=str2.trim();  <br>        System.out.println(trimmed);  <br>        <span class="hljs-comment">//将字符串按空格分隔成单词数组  </span><br>        String[] words=trimmed.split(<span class="hljs-string">&quot;\\s+&quot;</span>);  <br>        <span class="hljs-comment">// 提取出第一个词  </span><br>        String firstWord=words[<span class="hljs-number">0</span>];  <br>        System.out.println(firstWord);  <br>  <br>        <span class="hljs-comment">// 处理字符串中的数字和符号  </span><br>        String str3=<span class="hljs-string">&quot;123-345-987&quot;</span>;  <br>        <span class="hljs-comment">// 将字符串按照连字符&quot;-&quot;分隔成多个部分  </span><br>        String[] parts=str.split(<span class="hljs-string">&quot;-&quot;</span>);  <br>        <span class="hljs-comment">//提取其中一个来看看  </span><br>        String lastNum=parts[parts.length-<span class="hljs-number">1</span>];  <br>        System.out.println(lastNum);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs terminal">world<br>world<br>hello<br>hello,   world!<br>hello,<br>hello world<br></code></pre></td></tr></table></figure><p>PS:<br><code>trimmed.split(&quot;\\s+&quot;);</code><br>这里的<code>\\s+</code>是在进行正则匹配，<code>\s</code> 表示的是任意空白字符（空格、tab、换行、回车），<code>+</code>（量词），前面的元素出现一次or多次。</p><ul><li>由于 <code>\s</code> 是转义字符，所以这里要多加一个反斜杠</li></ul><h3 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法"></a>indexOf方法</h3><ul><li>用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(<span class="hljs-type">char</span>[] source, <span class="hljs-type">int</span> sourceOffset, <span class="hljs-type">int</span> sourceCount, <span class="hljs-type">char</span>[] target, <span class="hljs-type">int</span> targetOffset, <span class="hljs-type">int</span> targetCount, <span class="hljs-type">int</span> fromIndex)</span>；<br></code></pre></td></tr></table></figure><h3 id="String-类的其他方法"><a href="#String-类的其他方法" class="headerlink" title="String 类的其他方法"></a>String 类的其他方法</h3><p>①、比如说 <code>length()</code> 用于返回字符串长度。<br>②、比如说 <code>isEmpty()</code> 用于判断字符串是否为空。<br>③、比如说 <code>charAt()</code> 用于返回指定索引处的字符。<br>④、比如说 <code>valueOf()</code> 用于将其他类型的数据转换为字符串。<br>valueOf实际上调用的是包装器类的<code>toString</code>方法，比如说整数转为字符串用的是Integer类的 <code>toString</code><br>⑥、比如说 <code>getBytes()</code> 用于返回字符串的字节数组，可以指定编码方式<br>⑦、比如说 <code>trim()</code> 用于去除字符串两侧的空白字符<br>⑧、比如说 <code>toCharArray()</code> 用于将字符串转换为字符数组。</p><blockquote><p>[!NOTE]<br>需要注意的是，接口和抽象类是不可以实例化的，具体类可以。<br>比如说，Map，List，Set是接口，不可以<code>// Map&lt;String, Integer&gt; map = new Map&lt;&gt;(); // ❌ 错误！</code><br>但是HashMap,ArrayList,HashSet是具体类，可以 <code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // ✅ 正确</code></p></blockquote><p>java字符串是不可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>&#125;<br></code></pre></td></tr></table></figure><p>string类的数据存储在 <code>char[]</code> 数组里，这个数组被final修饰了，说明只要初始化了，值就固定了。</p><ul><li>保证了String对象的安全性</li><li>保证哈希值不会频繁变更</li><li>可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。</li></ul><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>Q1：下面这行代码创建了几个对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;二哥&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>乍一看好像只创建了一个对象，但实际上创建了两个对象。</li></ul><p>使用new关键字创建一个字符串对象时，JVM会先在字符串常量池中查找是否存在，如果有就不会在字符串常量池中创建这个对象了，直接在堆里创建一个字符串对象，然后将堆里的这个对象地址返回赋值给变量s</p><p>如果没有，先在字符串常量池中创建一个字符串对象，然后在堆里创建一个对象，最后将堆里的这个字符串对象的地址返回赋值给s</p><ul><li>总之，最后两个地方会存在这个对象，一个是字符串常量池，另一个是堆。返回进行赋值的总是堆里的这个对象。<br><img src="/img/file-20251105193008056.png"></li></ul><p>通常情况下，我们会采用双引号的方式来创建字符串对象，而不是通过new。这样子就不会像上面一样创建两个对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;三妹&quot;</span>;<br></code></pre></td></tr></table></figure><p>当执行上述指令时，JVM会先在字符串常量池中查找有没有这个字符串对象，如果有就不创建任何对象，直接将字符串常量池这个对象地址返回，赋给变量s；如果没有就在字符串常量池中创建这个对象，然后将这个对象地址返回。<br><img src="/img/file-20251105193354539.png"></p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;二哥&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;二哥&quot;</span>);<br></code></pre></td></tr></table></figure><p>这两行代码会创建3个对象！<br>首先new一定会创建一个，其次最开始在字符串常量池中不存在，则会再创一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;三妹&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;三妹&quot;</span>;<br></code></pre></td></tr></table></figure><p>这两行代码只会创建1个对象！</p><h4 id="字符串常量池在内存中的什么位置？"><a href="#字符串常量池在内存中的什么位置？" class="headerlink" title="字符串常量池在内存中的什么位置？"></a>字符串常量池在内存中的什么位置？</h4><p>java7之前，位于<strong>永久代</strong>内存区。主要用来存储字符串常量。（永久代是 Java 堆（Java Heap）的一部分，用于存储类信息、方法信息、常量池信息等静态数据。）</p><ul><li>永久代时java堆的一个子区域</li><li>永久代中存储的静态数据与堆中存储的对象实例和数组是分开的，它们有不同的生命周期和分配方式。</li></ul><p>java7之后，字符串常量池移动到堆中。<br><img src="/img/file-20251105193812668.png"></p><p>java8之后，永久代被取消了，由元空间取代。（元空间时本机内存区域，和jvm内存区域是分开的）<br><img src="/img/file-20251105193835887.png"></p><h4 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h4><p>我们上面提到：<br><code>String</code>类型的常量池比较特殊。它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li><li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;二哥三妹&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1 == s2);<br></code></pre></td></tr></table></figure><p>例子，这里 <code>intern()</code>方法会从<strong>字符串常量池</strong>中查找这个字符串是否存在，存在那么s2的地址就会来自字符串常量池的那个对象。<br>但是s1的地址是堆上那个对象的地址，所以它们的地址不同，会返回false<br><img src="/img/file-20251105194706319.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;二哥&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;三妹&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1 == s2);<br></code></pre></td></tr></table></figure><p>但是这段会输出true<br>第一行会在字符串常量池中创建两个对象，然后在堆上创建两个匿名对象“二哥”，“三妹”，最后还有一个“二哥三妹”的对象。s1引用的是“二哥三妹”这个对象。</p><p>第二行代码，会在字符串常量池查找“二哥三妹”这个对象是否存在，发现并不存在，但堆上已经存在了，所以字符串常量池中保存的是对上的这个对象的引用！</p><p>所以s1和s2的地址相同。<br><img src="/img/file-20251105195024019.png"></p><h2 id="StringBuilder和StringBuffer"><a href="#StringBuilder和StringBuffer" class="headerlink" title="StringBuilder和StringBuffer"></a>StringBuilder和StringBuffer</h2><p>由于字符串是不可变的（之前提到过有final），所以当遇到字符串拼接时，需要考虑性能问题（不能毫无顾虑生产太多string对象，对珍贵的内存造成不必要的压力）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>str = str + <span class="hljs-string">&quot; World&quot;</span>; <span class="hljs-comment">// 创建了一个新的 String 对象</span><br></code></pre></td></tr></table></figure><p>第二行代码看起来是修改了str，但实际上发生了三件事：</p><ul><li>创建了一个新的String对象</li><li>将变量str的引用指向这个对象</li><li>原来的“Hello”对象会等待垃圾回收器回收</li></ul><p>这两个类都是可变的字符序列，也就是可以对同一个对象进行修改，而不会创建新的对象。<br>这两个类有相同的API</p><ul><li><code>append()</code>: 在末尾追加内容。</li><li><code>insert()</code>: 在指定位置插入内容    </li><li><code>delete()</code>: 删除指定范围内的字符。</li><li><code>reverse()</code>: 反转字符序列。</li><li><code>toString()</code>: 转换为不可变的 <code>String</code>对象。</li></ul><p>它们之间的唯一区别是：<br>StringBuffer有线程安全，但是StringBuilder没有。</p><ul><li>StringBuffer的方法都由 <code>synchronized</code> 关键字修饰。可以适用于多线程环境，即多个线程可以同时操作同一个对象。</li><li>StringBuilder 方法没有同步，适用于单线程环境。</li></ul><p>我们之前学计组的时候学到，多线程环境下，我们做一些操作需要保证“原子性”，所以很多时候会去上锁。那这个上锁的过程会导致了性能比较低。</p><p>所以在单线程情况下，我们最好使用StringBuilder，避免加没必要的锁</p><p>其实有时候我们会无意中使用到了StringBuilder。由于java时一门解释性语言，在编译的时候，编译器会帮我们做很多优化。<br>比如在做字符串拼接时（使用 <code>+</code> ），编译器会把他变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原本：</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hihi&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;oioioi&quot;</span>)<br><span class="hljs-comment">// 解释为：</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;hihi&quot;</span>).apend(<span class="hljs-string">&quot;oioioi&quot;</span>).toString();<br></code></pre></td></tr></table></figure><h2 id="判断字符串相等"><a href="#判断字符串相等" class="headerlink" title="判断字符串相等"></a>判断字符串相等</h2><p>两种办法，一个是使用 <code>.equal()</code> 方法，另一个是使用 <code>==</code> 操作符<br>它们的区别是：</p><ul><li><code>.equal()</code> 方法用于比较两个对象的内容是否相等，也就是值是否相等</li><li><code>==</code> 方法用于判断两个对象的地址是否相等<br>但是！Object类的 <code>.equal()</code> 方法默认采用 <code>==</code> 操作符进行比较。如果子类没有重写这个方法，那这两个效果是一样的。<br>字符串里我们更希望判断值是否相等，所以String类重写了这个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">aString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-keyword">if</span> (coder() == aString.coder()) &#123;<br>            <span class="hljs-keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)<br>                    : StringUTF16.equals(value, aString.value);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断是否是对象本身（使用 <code>==</code> 来判断地址是否相等）<br>如果不是：</p><ul><li><code>if (anObject instanceof String) &#123;</code>进行类型检查，看是否是String类）</li><li>检查完之后，如果是就可以将其显示转换为tring类。</li><li><code>if (coder() == aString.coder()) &#123;</code>编码格式检查，用于比较两个字符串的内部编码相同。</li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小萝莉&quot;</span>).equals(<span class="hljs-string">&quot;小萝莉&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出true，因为内容是相同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小萝莉&quot;</span>) == <span class="hljs-string">&quot;小萝莉&quot;</span><br></code></pre></td></tr></table></figure><p>输出false，因为这里比较的是地址<br>左边是在堆中创建的对象，右边是在字符串常量池中创建的对象。</p><ul><li>我们之前学到，new String这样子会导致在堆和字符串常量池中都创建对象，<strong>最后返回的是堆上的对象的地址</strong>。右边的方法会先在字符串常量池中查找是否存在这样子的对象，<strong>如果存在返回字符串常量池里的对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小萝莉&quot;</span>) == <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小萝莉&quot;</span>)<br></code></pre></td></tr></table></figure><p>返回false。<br>new出来的对象地址不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;小萝莉&quot;</span> == <span class="hljs-string">&quot;小萝莉&quot;</span><br></code></pre></td></tr></table></figure><p>返回true<br>跟我们刚刚说的一样，返回的都是字符串常量池里的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;小萝莉&quot;</span> == <span class="hljs-string">&quot;小&quot;</span> + <span class="hljs-string">&quot;萝莉&quot;</span><br></code></pre></td></tr></table></figure><p>返回的还是true<br>“由于‘小’和‘萝莉’都在字符串常量池，所以<strong>编译器在遇到‘+’操作符的时候将其自动优化为“小萝莉”</strong>，所以返回 true。”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小萝莉&quot;</span>).intern() == <span class="hljs-string">&quot;小萝莉&quot;</span><br></code></pre></td></tr></table></figure><p><code>new String(&quot;小萝莉&quot;)</code> 在执行的时候，会先在字符串常量池中创建对象，然后再在堆中创建对象；<br>执行 <code>intern()</code> 方法的时候发现字符串常量池中已经有了‘小萝莉’这个对象，所以就直接返回字符串常量池中的对象引用了，那再与字符串常量池中的‘小萝莉’比较，当然会返回 true 了。</p><p>这里 <code>intern()</code>方法会从<strong>字符串常量池</strong>中查找这个字符串是否存在。</p><p>判断字符串对象是否相等的其他方法</p><ul><li><code>Objects.equals()</code><br>这个方法的好处是不需要在调用之前判空<br>使用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Objects.equals(<span class="hljs-string">&quot;小萝莉&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小&quot;</span> + <span class="hljs-string">&quot;萝莉&quot;</span>)) <span class="hljs-comment">// --&gt; true</span><br>Objects.equals(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小&quot;</span> + <span class="hljs-string">&quot;萝莉&quot;</span>)); <span class="hljs-comment">// --&gt; false</span><br>Objects.equals(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// --&gt; true</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>a.equals(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;小&quot;</span> + <span class="hljs-string">&quot;萝莉&quot;</span>)); <span class="hljs-comment">// throw exception</span><br></code></pre></td></tr></table></figure><ul><li>String类的 <code>.contentEquals()</code><br>这个方法可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较</li></ul><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h2><p>循环体内拼接字符串最好用 <code>StringBuilder</code> 的 <code>append()</code> 方法而不是 + 操作符，因为在循环体里如果采用 + 操作符，会产生大量的StringBuilder对象，会占用很多内存空间，并让JVM不停地进行垃圾回收。</p><p>还有一些方法：</p><ul><li>String.concat拼接字符串</li><li>String.join<br>可以将第一个参数作为字符串连接符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;王二&quot;</span>, <span class="hljs-string">&quot;太特么&quot;</span>, <span class="hljs-string">&quot;有趣了&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出：王二-太特么-有趣了</p><h2 id="拆分字符串split"><a href="#拆分字符串split" class="headerlink" title="拆分字符串split()"></a>拆分字符串split()</h2><p>注意：split的参数是<strong>正则表达式</strong>！<br>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：想按点号分割 IP 地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.1.1&quot;</span>;<br>String[] wrongParts = ip.split(<span class="hljs-string">&quot;.&quot;</span>); <span class="hljs-comment">// 结果为空数组！</span><br><br>System.out.println(wrongParts.length); <span class="hljs-comment">// 输出：0</span><br>System.out.println(Arrays.toString(wrongParts)); <span class="hljs-comment">// 输出：[]</span><br></code></pre></td></tr></table></figure><p>因为 <code>.</code> 在正则表达式中表示任意字符，需要转义</p><p>需要修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确做法：转义特殊字符</span><br>String[] correctParts1 = ip.split(<span class="hljs-string">&quot;\\.&quot;</span>); <span class="hljs-comment">// 两个反斜杠转义</span><br>String[] correctParts2 = ip.split(<span class="hljs-string">&quot;[.]&quot;</span>); <span class="hljs-comment">// 或用字符类</span><br><span class="hljs-comment">// 结果：[192, 168, 1, 1]</span><br></code></pre></td></tr></table></figure><p>还有一个要注意的：<br>空字符串会被丢弃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a,,b,,,c&quot;</span>;<br>String[] parts = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>System.out.println(parts.length); <span class="hljs-comment">// 输出：3</span><br>System.out.println(Arrays.toString(parts)); <span class="hljs-comment">// 输出：[a, b, c]</span><br></code></pre></td></tr></table></figure><p>这里的多个分隔符被当作一个分隔符了</p><p>如果确实需要保留空字符串，可以这样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] partsWithEmpty = str.split(<span class="hljs-string">&quot;,&quot;</span>, -<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 结果：[a, &quot;&quot;, b, &quot;&quot;, &quot;&quot;, c]</span><br></code></pre></td></tr></table></figure><p>这个-1属于limit参数。<br><code>split(regex, limit)</code>的 limit 参数行为复杂：</p><table><thead><tr><th>limit 值</th><th>行为描述</th><th>示例 <code>&quot;a,b,c,,,&quot;.split(&quot;,&quot;, limit)</code></th></tr></thead><tbody><tr><td><code>limit &gt; 0</code></td><td>最多分成 limit 个部分</td><td><code>limit=2</code>→ <code>[&quot;a&quot;, &quot;b,c,,,&quot;]</code></td></tr><tr><td><code>limit = 0</code></td><td><strong>默认行为</strong>，丢弃末尾空字符串</td><td><code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></td></tr><tr><td><code>limit &lt; 0</code></td><td>不限制次数，保留所有空字符串</td><td><code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]</code></td></tr></tbody></table><p>正则表达式：<br><a href="https://github.com/cdoco/learn-regex-zh">cdoco&#x2F;learn-regex-zh: :cn: 翻译: 学习正则表达式的简单方法</a><br>常用的正则表达式：<br><a href="https://github.com/cdoco/common-regex">cdoco&#x2F;common-regex: :jack_o_lantern: 常用正则表达式 - 收集一些在平时项目开发中经常用到的正则表达式。</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Happy-Llm</title>
    <link href="/2025/08/21/happy-llm/"/>
    <url>/2025/08/21/happy-llm/</url>
    
    <content type="html"><![CDATA[<p>  相关资料：<br>  <a href="https://datawhalechina.github.io/happy-llm/#/">Happy-LLM</a></p><h1 id="Chapter1-NLP基础概念"><a href="#Chapter1-NLP基础概念" class="headerlink" title="Chapter1 NLP基础概念"></a>Chapter1 NLP基础概念</h1><p>什么是NLP（自然语言处理）？</p><ul><li>它专注于让计算机能够理解、解释、操纵和生成人类语言</li><li>一般分为两大类任务：NLU（自然语言理解）和NLG（自然语言生成）</li></ul><h2 id="NLP任务"><a href="#NLP任务" class="headerlink" title="NLP任务"></a>NLP任务</h2><p>这些任务包括但不限于<strong>中文分词、子词切分、词性标注、文本分类、实体识别、关系抽取、文本摘要、机器翻译以及自动问答</strong>系统的开发。</p><h3 id="中文分词CWS"><a href="#中文分词CWS" class="headerlink" title="中文分词CWS"></a>中文分词CWS</h3><p>中文词相对于英文单词没有明显的分隔（无法直接通过空格来确定词的边界）</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">英文输入：The <span class="hljs-keyword">cat</span> sits <span class="hljs-keyword">on</span> the <span class="hljs-keyword">mat</span>.<br>英文切割输出：[The | <span class="hljs-keyword">cat</span> | sits | <span class="hljs-keyword">on</span> | the | <span class="hljs-keyword">mat</span>]<br>中文输入：今天天气真好，适合出去游玩.<br>中文切割输出：[<span class="hljs-string">&quot;今天&quot;</span>, <span class="hljs-string">&quot;天气&quot;</span>, <span class="hljs-string">&quot;真&quot;</span>, <span class="hljs-string">&quot;好&quot;</span>, <span class="hljs-string">&quot;，&quot;</span>, <span class="hljs-string">&quot;适合&quot;</span>, <span class="hljs-string">&quot;出去&quot;</span>, <span class="hljs-string">&quot;游玩&quot;</span>, <span class="hljs-string">&quot;。&quot;</span>]<br></code></pre></td></tr></table></figure><p>中文分词的方法：</p><ul><li>基于规则的分词方法<ul><li>人工制定一系列规则来切分、</li><li>虽然这种方法很简单，类似于模式匹配</li><li>但是中华文化博大精深，很难穷尽，容易出现错误，维护成本高</li></ul></li><li>基于统计的分词方法<ul><li>利用大量标注好的文本数据，通过统计学方法学习词语的边界</li><li>比如：苹的苹经常和果一起出现</li><li><strong>N-gram模型</strong>：基于上下文信息来判断词的边界</li><li><strong>隐马尔可夫模型（HMM）</strong>：假设词的内部状态（如词的开始、中间、结束）是一个马尔可夫过程，通过状态转移概率来切分词语。</li><li><strong>条件随机场（CRF）</strong>：考虑整个句子的上下文信息，通过条件概率来确定词的边界。</li></ul></li><li>基于深度学习的分词方法<ul><li><strong>循环神经网络（RNN）及其变体（如LSTM、GRU）</strong>：能够处理序列数据，适合文本这种序列化的输入。</li><li><strong>Transformer架构</strong>：通过自注意力机制捕捉文本中的长距离依赖关系，如BERT模型可以用于分词任务。</li></ul></li><li>组合</li></ul><h3 id="子词切分"><a href="#子词切分" class="headerlink" title="子词切分"></a>子词切分</h3><p>子词切分（Subword Segmentation）是 NLP 领域中的一种常见的文本预处理技术，旨在将词汇进一步分解为更小的单位，即子词。</p><h3 id="词性标注"><a href="#词性标注" class="headerlink" title="词性标注"></a>词性标注</h3><p>词性标注（Part-of-Speech Tagging，POS Tagging）是 NLP 领域中的一项基础任务，它的目标是为文本中的每个单词分配一个词性标签，如名词、动词、形容词等。</p><h2 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h2><p>向量空间模型是NLP领域中一个基础且强大的文本表示方法<br>向量空间模型通过将文本（包括单词、句子、段落或整个文档）转换为高维空间中的向量来实现文本的数学化表示。</p><p>缺点：<br>数据稀疏性和维数灾难问题</p><ul><li>一句话中的词语数相比词汇表是很小很小的，导致了词向量特别稀疏。</li><li>同时词汇表很大–维数很大</li></ul><h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><h3 id="N-gram模型"><a href="#N-gram模型" class="headerlink" title="N-gram模型"></a>N-gram模型</h3><ul><li>基于统计的语言模型</li><li>N-gram模型的核心思想是基于马尔可夫假设，即一个词的出现概率仅依赖于它前面的N-1个词。</li></ul><h3 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h3><ul><li>词嵌入技术<br>它是一种基于神经网络NNLM的语言模型，旨在通过学习<strong>词与词之间的上下文</strong>关系来生成词的密集向量表示</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Curriculum Learning</title>
    <link href="/2025/07/31/Learning/"/>
    <url>/2025/07/31/Learning/</url>
    
    <content type="html"><![CDATA[<p>由于最近参加了腾讯开悟的ai比赛，学习过程中接触了课程学习（CL）这个概念，故在此记录一下。</p><p>课程学习时一种训练策略，通过模仿人的学习过程，先让模型从容易的样本开始学习，然后逐渐进阶到复杂的样本和知识。</p><p>在比赛中，我们可以通过设立三个阶段来让智能体逐步学习策略，比如：第一阶段——让智能体学会走到终点，第二阶段——让智能体学会捡宝箱并走到终点，第三阶段——让智能体必须捡完所有的宝箱并在规定时间走到终点。</p><p>同时这个过程中我们也可以通过修改环境设置来进行不同的训练。</p><p>有效性分析：</p><ol><li>模型优化角度</li></ol><p>CL可以首先优化比较平滑的问题，然后逐渐优化到不太平滑的问题。</p><p>从一个比较平滑的目标开始，很容易找到全局最小值，并在整个训练过程中跟踪局部最小值。另外，从更容易的目标中学习到的局部最小值具有更好的泛化能力，更有可能近似于全局最小值。</p><p><img src="/img/v2-55903ae517343c36372d26bcd71bfb96_1440w.jpg"></p><ol start="2"><li>数据分布角度</li></ol><p>训练和测试分布之间存在着噪声或错误标注的训练数据引起的误差。</p><p>CL本质上是将目标分布下的预期风险上界最小化，这个上界表明，我们可以通过CL的核心思想来处理将 Ptarget(x) 上的预期风险最小化的任务：根据课程设置逐步抽取相对容易的样本，并将这些样本的经验风险最小化。</p><p><a href="https://zhuanlan.zhihu.com/p/362351969">(16 封私信 &#x2F; 42 条消息) 一篇综述带你全面了解课程学习(Curriculum Learning) - 知乎</a><br>2. Attention机制（注意力机制）<br>注意力机制的核心思想源于对人类视觉注意力的模拟，即在面对复杂信息时，人脑能够有选择性地聚焦于最关键的部分，而忽略不相关的信息。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>RL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB_Lec4</title>
    <link href="/2025/07/30/DB-Lec4/"/>
    <url>/2025/07/30/DB-Lec4/</url>
    
    <content type="html"><![CDATA[<p>·<br><a href="https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/buffer-pools">Buffer Pools | open-courses</a><br>Lecture5: Storage Models &amp; Compression</p><ul><li><input checked="" disabled="" type="checkbox"> read 11.2 &amp; 13.6</li><li><input disabled="" type="checkbox"> project1:<a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">https://15445.courses.cs.cmu.edu/fall2022/project1/</a></li><li><input disabled="" type="checkbox"> hw2: <a href="https://15445.courses.cs.cmu.edu/fall2022/files/hw2-clean.pdf">hw2-clean.pdf</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLM</title>
    <link href="/2025/07/28/LLM/"/>
    <url>/2025/07/28/LLM/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/datawhalechina/self-llm">datawhalechina&#x2F;self-llm: 《开源大模型食用指南》针对中国宝宝量身打造的基于Linux环境快速微调（全参数&#x2F;Lora）、部署国内外开源大模型（LLM）&#x2F;多模态大模型（MLLM）教程</a></p><p>大模型（LLM）狭义上指基于深度学习算法进行训练的自然语言处理（NLP）模型，主要应用于自然语言理解和生成等领域，广义上还包括机器视觉（CV）大模型、多模态大模型和科学计算大模型等。</p><ul><li>学习实现国内外主流开源LLM的部署、使用与微调教程</li></ul><h1 id="Qwen1-5"><a href="#Qwen1-5" class="headerlink" title="Qwen1.5"></a>Qwen1.5</h1><h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p>通过指令下载模型到缓存文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># model_download.py</span><br><span class="hljs-keyword">from</span> modelscope <span class="hljs-keyword">import</span> snapshot_download<br><br>model_dir = snapshot_download(<span class="hljs-string">&#x27;qwen/Qwen1.5-7B-Chat&#x27;</span>, cache_dir=<span class="hljs-string">&#x27;/root/autodl-tmp&#x27;</span>, revision=<span class="hljs-string">&#x27;master&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="代码准备"><a href="#代码准备" class="headerlink" title="代码准备"></a>代码准备</h2><p>在autodl-tmp路径下新建api.py文件，并输入以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM, GenerationConfig<br><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 设置设备参数</span><br>DEVICE = <span class="hljs-string">&quot;cuda&quot;</span>  <span class="hljs-comment"># 使用CUDA</span><br>DEVICE_ID = <span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-comment"># CUDA设备ID，如果未设置则为空</span><br>CUDA_DEVICE = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;DEVICE&#125;</span>:<span class="hljs-subst">&#123;DEVICE_ID&#125;</span>&quot;</span> <span class="hljs-keyword">if</span> DEVICE_ID <span class="hljs-keyword">else</span> DEVICE  <span class="hljs-comment"># 组合CUDA设备信息</span><br><br><span class="hljs-comment"># 清理GPU内存函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">torch_gc</span>():<br>    <span class="hljs-keyword">if</span> torch.cuda.is_available():  <span class="hljs-comment"># 检查是否可用CUDA</span><br>        <span class="hljs-keyword">with</span> torch.cuda.device(CUDA_DEVICE):  <span class="hljs-comment"># 指定CUDA设备</span><br>            torch.cuda.empty_cache()  <span class="hljs-comment"># 清空CUDA缓存</span><br>            torch.cuda.ipc_collect()  <span class="hljs-comment"># 收集CUDA内存碎片</span><br><br><span class="hljs-comment"># 创建FastAPI应用</span><br>app = FastAPI()<br><br><span class="hljs-comment"># 处理POST请求的端点</span><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">request: Request</span>):<br>    <span class="hljs-keyword">global</span> model, tokenizer  <span class="hljs-comment"># 声明全局变量以便在函数内部使用模型和分词器</span><br>    json_post_raw = <span class="hljs-keyword">await</span> request.json()  <span class="hljs-comment"># 获取POST请求的JSON数据</span><br>    json_post = json.dumps(json_post_raw)  <span class="hljs-comment"># 将JSON数据转换为字符串</span><br>    json_post_list = json.loads(json_post)  <span class="hljs-comment"># 将字符串转换为Python对象</span><br>    prompt = json_post_list.get(<span class="hljs-string">&#x27;prompt&#x27;</span>)  <span class="hljs-comment"># 获取请求中的提示</span><br><br>    messages = [<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;You are a helpful assistant.&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt&#125;<br>    ]<br><br>    <span class="hljs-comment"># 调用模型进行对话生成</span><br>    input_ids = tokenizer.apply_chat_template(messages,tokenize=<span class="hljs-literal">False</span>,add_generation_prompt=<span class="hljs-literal">True</span>)<br>    model_inputs = tokenizer([input_ids], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(<span class="hljs-string">&#x27;cuda&#x27;</span>)<br>    generated_ids = model.generate(model_inputs.input_ids,max_new_tokens=<span class="hljs-number">512</span>)<br>    generated_ids = [<br>        output_ids[<span class="hljs-built_in">len</span>(input_ids):] <span class="hljs-keyword">for</span> input_ids, output_ids <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(model_inputs.input_ids, generated_ids)<br>    ]<br>    response = tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]<br>    now = datetime.datetime.now()  <span class="hljs-comment"># 获取当前时间</span><br>    time = now.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)  <span class="hljs-comment"># 格式化时间为字符串</span><br>    <span class="hljs-comment"># 构建响应JSON</span><br>    answer = &#123;<br>        <span class="hljs-string">&quot;response&quot;</span>: response,<br>        <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-string">&quot;time&quot;</span>: time<br>    &#125;<br>    <span class="hljs-comment"># 构建日志信息</span><br>    log = <span class="hljs-string">&quot;[&quot;</span> + time + <span class="hljs-string">&quot;] &quot;</span> + <span class="hljs-string">&#x27;&quot;, prompt:&quot;&#x27;</span> + prompt + <span class="hljs-string">&#x27;&quot;, response:&quot;&#x27;</span> + <span class="hljs-built_in">repr</span>(response) + <span class="hljs-string">&#x27;&quot;&#x27;</span><br>    <span class="hljs-built_in">print</span>(log)  <span class="hljs-comment"># 打印日志</span><br>    torch_gc()  <span class="hljs-comment"># 执行GPU内存清理</span><br>    <span class="hljs-keyword">return</span> answer  <span class="hljs-comment"># 返回响应</span><br><br><span class="hljs-comment"># 主函数入口</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 加载预训练的分词器和模型</span><br>    model_name_or_path = <span class="hljs-string">&#x27;/root/autodl-tmp/qwen/Qwen1.5-7B-Chat&#x27;</span><br>    tokenizer = AutoTokenizer.from_pretrained(model_name_or_path, use_fast=<span class="hljs-literal">False</span>)<br>    model = AutoModelForCausalLM.from_pretrained(model_name_or_path, device_map=<span class="hljs-string">&quot;auto&quot;</span>, torch_dtype=torch.bfloat16)<br><br>    <span class="hljs-comment"># 启动FastAPI应用</span><br>    <span class="hljs-comment"># 用6006端口可以将autodl的端口映射到本地，从而在本地使用api</span><br>    uvicorn.run(app, host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">6006</span>, workers=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 在指定端口和主机上启动应用</span><br></code></pre></td></tr></table></figure><p>但是很可惜，我没有gpu，所以我需要做出相应的修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM, GenerationConfig<br><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 设置设备参数</span><br>DEVICE = <span class="hljs-string">&quot;cpu&quot;</span>  <span class="hljs-comment"># 使用CUDA</span><br>DEVICE_ID = <span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-comment"># CUDA设备ID，如果未设置则为空</span><br>CUDA_DEVICE = DEVICE  <span class="hljs-comment"># 组合CUDA设备信息</span><br><br><span class="hljs-comment"># 清理GPU内存函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">torch_gc</span>():<br><span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 创建FastAPI应用</span><br>app = FastAPI()<br><br><span class="hljs-comment"># 处理POST请求的端点</span><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">request: Request</span>):<br>    <span class="hljs-keyword">global</span> model, tokenizer  <span class="hljs-comment"># 声明全局变量以便在函数内部使用模型和分词器</span><br>    json_post_raw = <span class="hljs-keyword">await</span> request.json()  <span class="hljs-comment"># 获取POST请求的JSON数据</span><br>    json_post = json.dumps(json_post_raw)  <span class="hljs-comment"># 将JSON数据转换为字符串</span><br>    json_post_list = json.loads(json_post)  <span class="hljs-comment"># 将字符串转换为Python对象</span><br>    prompt = json_post_list.get(<span class="hljs-string">&#x27;prompt&#x27;</span>)  <span class="hljs-comment"># 获取请求中的提示</span><br><br>    messages = [<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;You are a helpful assistant.&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt&#125;<br>    ]<br><br>    <span class="hljs-comment"># 调用模型进行对话生成</span><br>    input_ids = tokenizer.apply_chat_template(messages,tokenize=<span class="hljs-literal">False</span>,add_generation_prompt=<span class="hljs-literal">True</span>)<br>    model_inputs = tokenizer([input_ids], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(<span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    generated_ids = model.generate(model_inputs.input_ids,max_new_tokens=<span class="hljs-number">512</span>)<br>    generated_ids = [<br>        output_ids[<span class="hljs-built_in">len</span>(input_ids):] <span class="hljs-keyword">for</span> input_ids, output_ids <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(model_inputs.input_ids, generated_ids)<br>    ]<br>    response = tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]<br>    now = datetime.datetime.now()  <span class="hljs-comment"># 获取当前时间</span><br>    time = now.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)  <span class="hljs-comment"># 格式化时间为字符串</span><br>    <span class="hljs-comment"># 构建响应JSON</span><br>    answer = &#123;<br>        <span class="hljs-string">&quot;response&quot;</span>: response,<br>        <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-string">&quot;time&quot;</span>: time<br>    &#125;<br>    <span class="hljs-comment"># 构建日志信息</span><br>    log = <span class="hljs-string">&quot;[&quot;</span> + time + <span class="hljs-string">&quot;] &quot;</span> + <span class="hljs-string">&#x27;&quot;, prompt:&quot;&#x27;</span> + prompt + <span class="hljs-string">&#x27;&quot;, response:&quot;&#x27;</span> + <span class="hljs-built_in">repr</span>(response) + <span class="hljs-string">&#x27;&quot;&#x27;</span><br>    <span class="hljs-built_in">print</span>(log)  <span class="hljs-comment"># 打印日志</span><br>    torch_gc()  <span class="hljs-comment"># 执行GPU内存清理</span><br>    <span class="hljs-keyword">return</span> answer  <span class="hljs-comment"># 返回响应</span><br><br><span class="hljs-comment"># 主函数入口</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 加载预训练的分词器和模型</span><br>model_name_or_path = <span class="hljs-string">&#x27;/root/autodl-tmp/qwen/Qwen1.5-0.5B-Chat&#x27;</span><br>    tokenizer = AutoTokenizer.from_pretrained(model_name_or_path, use_fast=<span class="hljs-literal">False</span>)<br>model = AutoModelForCausalLM.from_pretrained(model_name_or_path).to(<span class="hljs-string">&quot;cpu&quot;</span>)<br><br>    <span class="hljs-comment"># 启动FastAPI应用</span><br>    <span class="hljs-comment"># 用6006端口可以将autodl的端口映射到本地，从而在本地使用api</span><br>    uvicorn.run(app, host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, port=<span class="hljs-number">6006</span>, workers=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 在指定端口和主机上启动应用</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入所需的库</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM, GenerationConfig<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><br><span class="hljs-comment"># 在侧边栏中创建一个标题和一个链接</span><br><span class="hljs-keyword">with</span> st.sidebar:<br>    st.markdown(<span class="hljs-string">&quot;## Qwen1.5 LLM&quot;</span>)<br>    <span class="hljs-string">&quot;[开源大模型食用指南 self-llm](https://github.com/datawhalechina/self-llm.git)&quot;</span><br>    <span class="hljs-comment"># 创建一个滑块，用于选择最大长度，范围在0到1024之间，默认值为512</span><br>    max_length = st.slider(<span class="hljs-string">&quot;max_length&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">512</span>, step=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 创建一个标题和一个副标题</span><br>st.title(<span class="hljs-string">&quot;💬 Qwen1.5 Chatbot&quot;</span>)<br>st.caption(<span class="hljs-string">&quot;🚀 A streamlit chatbot powered by Self-LLM&quot;</span>)<br><br><span class="hljs-comment"># 定义模型路径</span><br>mode_name_or_path = <span class="hljs-string">&#x27;/root/autodl-tmp/qwen/Qwen1.5-0.5B-Chat&#x27;</span><br><br><span class="hljs-comment"># 定义一个函数，用于获取模型和tokenizer</span><br><span class="hljs-meta">@st.cache_resource</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model</span>():<br>    <span class="hljs-comment"># 从预训练的模型中获取tokenizer</span><br>    tokenizer = AutoTokenizer.from_pretrained(mode_name_or_path, use_fast=<span class="hljs-literal">False</span>)<br>    <span class="hljs-comment"># 从预训练的模型中获取模型，并设置模型参数</span><br>    model = AutoModelForCausalLM.from_pretrained(mode_name_or_path, torch_dtype=torch.bfloat16,  device_map=<span class="hljs-string">&quot;auto&quot;</span>)<br>  <br>    <span class="hljs-keyword">return</span> tokenizer, model<br><br><span class="hljs-comment"># 加载Qwen1.5-4B-Chat的model和tokenizer</span><br>tokenizer, model = get_model()<br><br><span class="hljs-comment"># 如果session_state中没有&quot;messages&quot;，则创建一个包含默认消息的列表</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;messages&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:<br>    st.session_state[<span class="hljs-string">&quot;messages&quot;</span>] = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;有什么可以帮您的？&quot;</span>&#125;]<br><br><span class="hljs-comment"># 遍历session_state中的所有消息，并显示在聊天界面上</span><br><span class="hljs-keyword">for</span> msg <span class="hljs-keyword">in</span> st.session_state.messages:<br>    st.chat_message(msg[<span class="hljs-string">&quot;role&quot;</span>]).write(msg[<span class="hljs-string">&quot;content&quot;</span>])<br><br><span class="hljs-comment"># 如果用户在聊天输入框中输入了内容，则执行以下操作</span><br><span class="hljs-keyword">if</span> prompt := st.chat_input():<br>    <span class="hljs-comment"># 将用户的输入添加到session_state中的messages列表中</span><br>    st.session_state.messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt&#125;)<br>    <span class="hljs-comment"># 在聊天界面上显示用户的输入</span><br>    st.chat_message(<span class="hljs-string">&quot;user&quot;</span>).write(prompt)<br>    <br>    <span class="hljs-comment"># 构建输入     </span><br>    input_ids = tokenizer.apply_chat_template(st.session_state.messages,tokenize=<span class="hljs-literal">False</span>,add_generation_prompt=<span class="hljs-literal">True</span>)<br>    model_inputs = tokenizer([input_ids], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(<span class="hljs-string">&#x27;cuda&#x27;</span>)<br>    generated_ids = model.generate(model_inputs.input_ids, max_new_tokens=<span class="hljs-number">512</span>)<br>    generated_ids = [<br>        output_ids[<span class="hljs-built_in">len</span>(input_ids):] <span class="hljs-keyword">for</span> input_ids, output_ids <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(model_inputs.input_ids, generated_ids)<br>    ]<br>    response = tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 将模型的输出添加到session_state中的messages列表中</span><br>    st.session_state.messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: response&#125;)<br>    <span class="hljs-comment"># 在聊天界面上显示模型的输出</span><br>    st.chat_message(<span class="hljs-string">&quot;assistant&quot;</span>).write(response)<br>    <span class="hljs-comment"># print(st.session_state)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB_Lec3</title>
    <link href="/2025/07/24/DB-Lec3/"/>
    <url>/2025/07/24/DB-Lec3/</url>
    
    <content type="html"><![CDATA[<h1 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h1><p>查询处理步骤：<br><img src="/img/file-20250724111216632.png"></p><h1 id="顺序索引"><a href="#顺序索引" class="headerlink" title="顺序索引"></a>顺序索引</h1><p>聚集索引：包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码对应的索引称为聚集索引</p><ul><li>聚集索引页称为主索引<br>非聚集索引：搜索码指定的顺序与文件中记录的物理顺序不同的索引</li></ul><p>稠密索引和稀疏索引</p><ul><li>稠密索引是指文件中的每个搜索码值都有一个索引项。<ul><li>在稠密聚集索引中，索引项包括搜索吗值以及指向具有搜索码值的第一条数据记录的指针。</li><li>有相同搜索码值的其余记录顺序地存储在第一条数据记录之后</li></ul></li><li>稀疏索引：只为搜索码的某些值建立索引项。<ul><li>只有当关系按搜索码排列顺序存储时才能使用稀疏索引&#x3D;&gt;只有索引是聚集索引时才能使用稀疏索引<br><img src="/img/file-20250726154131427.png"></li></ul></li></ul><p>多级索引</p><ul><li>节约存储空间</li></ul><h1 id="数据库存储基础"><a href="#数据库存储基础" class="headerlink" title="数据库存储基础"></a>数据库存储基础</h1><h2 id="存储层次与设备类型"><a href="#存储层次与设备类型" class="headerlink" title="存储层次与设备类型"></a>存储层次与设备类型</h2><ul><li>和计组、os中讲述的类似<br><strong>存储层次</strong>：金字塔</li><li>靠近CPU的存储设备速度最快、容量最小、价格最高（如寄存器、高速缓存）</li><li>离CPU越远的存储设备速度越慢、容量越大、价格越低（如内存、SSD、HDD）<br><img src="/img/file-20250727113023975.png"></li></ul><p><strong>易失性设备（内存）</strong>：</p><ul><li>断电后数据丢失</li><li>支持字节寻址的快速随机访问    </li><li>典型代表：DRAM</li></ul><p><strong>非易失性设备（磁盘）</strong>：</p><ul><li>断电后数据保留</li><li>块&#x2F;页寻址（通常4KB页大小）   </li><li>传统上更适合顺序访问    </li><li>包括SSD和HDD，课程中统称为”磁盘”</li></ul><p><strong>新兴技术</strong>：</p><ul><li>持久内存（如Intel Optane）：接近DRAM速度+磁盘持久性（但未广泛使用）</li><li>NVMe SSD：使用改进接口的传统NAND闪存，提供更快传输速度、</li></ul><h2 id="面向磁盘的DBMS架构"><a href="#面向磁盘的DBMS架构" class="headerlink" title="面向磁盘的DBMS架构"></a>面向磁盘的DBMS架构</h2><p>传统的DBMS架构属于面向磁盘的架构，所以DBMS中一般都有磁盘管理模块，主要负责数据在非易失与易失的存储器之间移动</p><p><strong>核心概念</strong>：</p><ul><li><p>数据库完全存储在磁盘上（保证非易失，且量大）</p></li><li><p>数据组织为固定大小的页（第一个页是目录页–页表）</p></li><li><p>缓冲池管理数据在磁盘和内存间的移动</p></li><li><p>执行引擎通过缓冲池访问数据页<br><strong>磁盘延迟对比</strong></p></li><li><p>如果L1缓存访问需要1秒：</p><ul><li>SSD访问需要4.4小时    </li><li>HDD访问需要3.3周</li></ul></li><li><p>为什么需要将数据在不同的存储器之间移动？</p><ul><li>磁盘管理模块的存在是为了同时获得易失性存储器的性能和非易失性存储器的容量，让DBMS的数据看起来像在内存中一样</li></ul></li><li><p>为什么要自己来做数据移动的管理，而非利用 OS 自带的磁盘管理模块？</p><ul><li>DBMS 比 OS 拥有更多、更充分的知识来决定数据移动的时机和数量</li><li>将 dirty pages 按正确地顺序写到磁盘</li><li>根据具体情况预获取数据</li><li>定制化缓存置换（buffer replacement）策略</li></ul></li></ul><h2 id="DBMS与OS的关系"><a href="#DBMS与OS的关系" class="headerlink" title="DBMS与OS的关系"></a>DBMS与OS的关系</h2><p><strong>关键区别</strong></p><ul><li>DBMS需要管理超过内存大小的数据库</li><li>不能因磁盘I&#x2F;O导致整个系统停滞</li><li>类似虚存概念，但是DBMS需要更多控制</li></ul><p>为什么不使用mmap</p><ul><li>写入操作不可靠</li><li>遇到页错误时进程会被阻塞</li><li>DBMS比OS更了解数据访问模式</li></ul><p><img src="/img/file-20250727105355167.png"></p><h2 id="文件存储与页组织"><a href="#文件存储与页组织" class="headerlink" title="文件存储与页组织"></a>文件存储与页组织</h2><p><strong>基本概念</strong></p><ul><li>数据库存储为磁盘文件，OS把它们当做普通文件</li><li>只有DBMS能解释文件内容</li><li>存储管理器负责文件管理和页组织（DBMS不会自己造文件系统）</li></ul><p><strong>数据库页</strong></p><ul><li>固定大小块</li><li>包含不同数据类型</li><li>三种页概念<ul><li>硬件页（通常4KB）</li><li>OS页（通常4KB）</li><li>数据库页（1-16KB）</li></ul></li></ul><p>不同DBMS管理pages的方式不同</p><ul><li>堆文件组织<ul><li>heap file 指的是一个无序的 pages 集合，pages 管理模块需要记录哪些 pages 已经被使用，而哪些 pages 尚未被使用。</li></ul></li><li>顺序文件组织</li><li>哈希文件组织</li></ul><p><strong>页标识与存储</strong></p><ul><li>唯一页ID</li><li>可能使用间接层映射页ID到文件路径和偏移量</li><li>固定大小页简化工程实现</li></ul><p><strong>原子写入保证</strong></p><ul><li>硬件页大小决定原子写入单位</li><li>数据库页大于硬件页时，需要额外机制保证崩溃安全</li></ul><h2 id="堆文件组织"><a href="#堆文件组织" class="headerlink" title="堆文件组织"></a>堆文件组织</h2><p><strong>堆文件概念</strong></p><ul><li>无序页集合</li><li>元组随机存储</li></ul><p><strong>两种定位方式</strong></p><ul><li><p>链表</p><ul><li>头页包含<strong>空闲页</strong>和<strong>数据页</strong>指针</li><li>查找特定页需要顺序扫描<br>pages管理模块维护一个header page，后者维护两个page列表–空闲页表和数据页表<br><img src="/img/file-20250727114008290.png"></li></ul></li><li><p>页目录</p><ul><li>特殊页记录数据页位置和空闲空间</li><li>更高效的随机访问</li></ul></li></ul><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>链表</td><td>简单实现</td><td>O(n)查找复杂度</td></tr><tr><td>目录</td><td>O(1)查找</td><td>需要额外空间维护目录</td></tr></tbody></table><h2 id="页布局与元组存储"><a href="#页布局与元组存储" class="headerlink" title="页布局与元组存储"></a>页布局与元组存储</h2><p><strong>页头部信息</strong></p><ul><li>页大小、校验和、DBMS版本   </li><li>事务可见性信息   </li><li>自包含信息（某些系统如Oracle需要）</li></ul><p><strong>数据记录方式</strong></p><ul><li><p>Tuple-oriented：记录数据本身</p><ul><li>在header中记录tuple的个数，然后不断往下append即可<br><img src="/img/file-20250727114307238.png"></li></ul></li><li><p>缺点：</p><ul><li>一旦出现删除操作，每次插入就要遍历一次，寻找空位，否则会出现空间浪费</li><li>无法处理变长的数据记录</li></ul></li><li><p>slotted pages</p><ul><li>header中的slot array记录每个slot的信息，如大小、位移等</li><li>新增记录时，在slot array中新增一条记录，记录着改记录的入口地址。slot array 与 data 从 page 的两端向中间生长，二者相遇时，就认为这个 page 已经满了</li><li>删除记录时：假设删除 tuple <code>#3</code>，可以将 slot array 中的第三条记录删除，并将 tuple #4 及其以后的数据都都向下移动，填补 tuple #3 的空位。而这些细节对于 page 的使用者来说是透明的</li><li>处理定长和变长 tuple 数据都游刃有余<br><img src="/img/file-20250727114600712.png"></li></ul></li><li><p>Log-structured：记录数据的操作日志</p><ul><li>只存储日志记录<img src="/img/file-20250727114648782.png"></li><li>每次记录新的操作日志即可，增删改的操作都很快，但有得必有失，在查询场景下，就需要遍历 page 信息来生成数据才能返回查询结果。为了加快查询效率，通常会对操作日志在记录 id 上建立索引，如下图所示：<img src="/img/file-20250727114709340.png"></li><li>写快，读慢</li></ul></li></ul><p><strong>两种主要布局方式</strong></p><ul><li>槽式页<ul><li>最常用</li><li>头部记录<strong>已用槽数</strong>、<strong>最后使用槽偏移</strong></li><li>槽数组记录<strong>每个元组的起始位置</strong></li><li><strong>元组</strong>从页尾向前增长，<strong>槽数组</strong>从页头向后增长</li></ul></li><li>日志结构<ul><li>只存储<strong>修改日志</strong>而非直接存储元组</li><li>通过<strong>反向扫描日志</strong>重建元组</li><li><strong>写入快</strong>但<strong>读取可能慢</strong></li><li>需要<strong>定期压缩</strong>（形成SSTables）</li><li>存在<strong>写放大</strong>问题<br><strong>元组布局</strong></li></ul></li><li>头部：可见性信息、NULL位图</li><li>数据：按创建表时指定的顺序存储属性</li><li>唯一标识符：通常为page_id+offset&#x2F;slot<br><img src="/img/file-20250727114916548.png"></li></ul><p>存储时：<br><img src="/img/file-20250727114927359.png"></p><p>数据库支持的数据类型包含</p><ul><li>INTEGER&#x2F;BIGINT&#x2F;SMALLINT&#x2F;TINYINT</li><li>FLOAT&#x2F;REAL vs. NUMERIC&#x2F;DECIMAL</li><li>VARCHAR&#x2F;VARBINARY&#x2F;TEXT&#x2F;BLOB</li><li>TIME&#x2F;DATE&#x2F;TIMESTAMP</li></ul><p>FLOAT&#x2F;REAL&#x2F;DOUBLE<br>vs<br>NUMERIC&#x2F;DECIMAL</p><p>float,real,double类型的数字按照IEEE-754标准存储，都是固定精度的，无法保证精确度要求很高的计算的正确性；<br>如果希望允许数据精确到任意精度，则可以使用numeric&#x2F;decimal类型类存储，它们就像varchar一般，长度不定。</p><ul><li>大部分的DBMSs不允许一个tuple中的数据超过一个page大小，如果实在要存储这样子的large values，就会使用overflow或者Toast page<br><img src="/img/file-20250730101357684.png"></li><li>一些 DBMSs 甚至允许你在外部存储二进制大文件，即 BLOB，但 DBMSs 一般不会负责管理外部文件，没有 durability protections 和 transaction protections，而且数据库的 dump 操作不会对外部文件起作用，转移数据时需要单独处理。</li></ul><p><strong>反规范化数据</strong>：</p><ul><li>预连接相关表到同一页</li><li>加快读取（减少页加载）但增加更新成本</li></ul><h1 id="数据库存储高级主题"><a href="#数据库存储高级主题" class="headerlink" title="数据库存储高级主题"></a>数据库存储高级主题</h1><h2 id="日志结构存储详解"><a href="#日志结构存储详解" class="headerlink" title="日志结构存储详解"></a>日志结构存储详解</h2><p>传统槽式页设计问题：</p><ul><li>碎片化：删除元组产生页内空隙（页内碎片）</li><li>无用磁盘I&#x2F;O：必须读取整个块获取单个元组</li><li>随机磁盘I&#x2F;O：更新分散在不同位置效率低</li></ul><p>日志结构存储特点</p><ul><li>仅追加写入，无覆盖</li><li>存储数据库修改日志而非直接存储元组</li><li>通过索引快速定位记录（如LSM树）</li><li>定期压缩减少读取开销</li></ul><h3 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h3><p>除了数据本身，DBMS还需要存储数据的<strong>元数据</strong>，即数据字典。</p><blockquote><p>[!NOTE]<br>元数据——关于数据的数据<br>用来描述数据的特征、背景、结构或管理方式，但本身并不是数据的具体内容<br>元数据是数据的’tag’<br>作用：</p><ul><li>解释数据</li><li>组织数据</li><li>管理数据</li></ul></blockquote><ul><li>table, columns, indexes, views</li><li>users, permissions</li><li>internal statistics</li></ul><p>查询元数据，我们之前做hw1时使用过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">.tables;<br>.schema student;<br></code></pre></td></tr></table></figure><h2 id="OLTP-OLAP"><a href="#OLTP-OLAP" class="headerlink" title="OLTP&amp;OLAP"></a>OLTP&amp;OLAP</h2><p>OLTP：联机事务处理Online Transaction Processing<br>OLAP：联机分析处理Online Analytical Processing</p><ul><li><p><strong>OLTP</strong>：主要用于日常业务事务处理，如银行转账、订单创建、库存管理等，支持高并发、实时的小规模数据增删改操作，确保事务的ACID特性（原子性、一致性、隔离性、持久性）。</p></li><li><p><strong>OLAP</strong>：用于复杂的数据分析和决策支持，如生成报表、趋势分析、市场预测等，基于数据仓库多维模型（如星型或雪花模型），支持多维数据查询（如切片、切块、钻取等），侧重于历史数据和大数据量的聚合分析。</p></li></ul><h2 id="数据存储模型"><a href="#数据存储模型" class="headerlink" title="数据存储模型"></a>数据存储模型</h2><p>关系数据模型将数据的attributes组合成tuple，将结构相似的tuple组合成relation，但是没有指定他们的存储方式</p><p>常见的数据存储模型：</p><ul><li>行存储 N-ary Storage Model (NSM)<br><img src="/img/file-20250730102955196.png"></li></ul><p><img src="/img/file-20250730103007582.png"></p><p>NSM的优缺点<br>优点：</p><ul><li><p>高效插入、更新、删除，涉及表中小部分tuples</p></li><li><p>有利于需要整个tuple的查询</p></li><li><p>列存储 Decomposition Storage Model (DSM)<br>列存储会将所有tuples的单个attribute连续地存储在一个page中<br><img src="/img/file-20250730165329023.png"><br>如何跟踪每个 tuple 的不同 attributes？可能的解决方案有：</p></li></ul><ol><li>Fixed-length Offsets：每个 attribute 都是定长的，直接靠 offset 来跟踪（常用）</li><li>Embedded Tuple Ids：在每个 attribute 前面都加上 tupleID<br><img src="/img/file-20250730165651095.png"><br>总结一下，DSM 的优缺点如下：</li></ol><ul><li>Advantages<ul><li>减少 I&#x2F;O 操作</li><li>更好的查询处理和数据压缩支持</li></ul></li><li>Disadvantages<ul><li>涉及少量 tuples、多数 attributes 的查询低效</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DB_Lec2</title>
    <link href="/2025/07/18/DB-Lec2/"/>
    <url>/2025/07/18/DB-Lec2/</url>
    
    <content type="html"><![CDATA[<ul><li><input checked="" disabled="" type="checkbox"> slide</li><li><input checked="" disabled="" type="checkbox"> books-chap3&#x2F;4</li><li><input checked="" disabled="" type="checkbox"> notes</li><li><input checked="" disabled="" type="checkbox"> hw</li></ul><h1 id="Lecture2"><a href="#Lecture2" class="headerlink" title="Lecture2"></a>Lecture2</h1><p>| intermediate SQL</p><p>什么是SQL (Structured Query Language)？</p><ul><li>读作Sequel</li><li>SQL是一种用于管理和操作关系型数据库的标准语言</li><li>用于与数据库交互：查询数据、插入数据、更新数据、删除数据、创建和修改数据库结构</li></ul><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><strong>查询语句</strong></td><td>检索数据</td><td><code>SELECT name FROM users;</code></td></tr><tr><td><strong>插入语句</strong></td><td>插入新记录</td><td><code>INSERT INTO users(name) VALUES(&#39;Alice&#39;);</code></td></tr><tr><td><strong>更新语句</strong></td><td>修改已有记录</td><td><code>UPDATE users SET age = 25 WHERE name = &#39;Alice&#39;;</code></td></tr><tr><td><strong>删除语句</strong></td><td>删除记录</td><td><code>DELETE FROM users WHERE age &lt; 18;</code></td></tr><tr><td><strong>定义语句</strong></td><td>创建&#x2F;修改数据库结构（DDL）</td><td><code>CREATE TABLE users(id INT, name TEXT);</code></td></tr><tr><td>这是<strong>声明式语言</strong>，只需要说明你需要什么数据，不需要指定如何拿到</td><td></td><td></td></tr></tbody></table><ul><li><p>MySQL和SQLite是DBMS，用于创建、管理、操作数据库</p></li><li><p>SQL is based on <strong>bags</strong> not set<br>bags和set的区别是bags允许有重复的键</p></li></ul><h2 id="SQL数据定义"><a href="#SQL数据定义" class="headerlink" title="SQL数据定义"></a>SQL数据定义</h2><h3 id="SQL基本类型："><a href="#SQL基本类型：" class="headerlink" title="SQL基本类型："></a>SQL基本类型：</h3><p><img src="/img/file-20250719104929350.png"></p><h3 id="基本模式定义"><a href="#基本模式定义" class="headerlink" title="基本模式定义"></a>基本模式定义</h3><p>使用 <code>create table</code> 命令定义SQL关系，例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">create table</span> department<br>(dept_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>),<br>building <span class="hljs-type">varchar</span>(<span class="hljs-number">15</span>),<br>budget <span class="hljs-type">numeric</span>(<span class="hljs-number">12</span>,<span class="hljs-number">2</span>),<br><span class="hljs-keyword">primary key</span> (dept_name));<br></code></pre></td></tr></table></figure><p>create table命令还指明了dept_name属性是department关系的<strong>主码</strong><br>create table命令的通用形式：<br><img src="/img/file-20250719105304123.png"><br>r是关系名，$A_i$是关系r模式中的一个属性名，$D_i$是属性$A_i$的域，即$D_i$制定了$A_i$的类型以及可选的约束，用于限制所允许的$A_i$取指的集合<br>主要使用的完整性约束：</p><ul><li>primary key：声明表述属性构成关系的主码。主码属性必须非空且唯一——没有一个元组在主码属性上取空值，关系中也没有两个元组在所有主码属性上取指相同。</li><li>foreign key：声明表示关系中任意元组在属性上的取指必须对应于关系s中某元组在主码属性上的取值</li><li>not null：表明属性上不允许空值<br><img src="/img/file-20250719105810542.png"></li></ul><h2 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h2><p>查询：基本结构由三个子句构成–<code>select</code>、<code>from</code>、<code>where</code></p><h3 id="单关系查询"><a href="#单关系查询" class="headerlink" title="单关系查询"></a>单关系查询</h3><p>e.g:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> <span class="hljs-type">name</span> <br><span class="hljs-keyword">from</span> instructor;<br></code></pre></td></tr></table></figure><p>去掉重复的</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> dept_name<br><span class="hljs-keyword">from</span> instructor;<br></code></pre></td></tr></table></figure><p>显式指明保留所有</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">select</span> <span class="hljs-attribute">all</span> dept_name<br><span class="hljs-selector-tag">from</span> instructor;<br></code></pre></td></tr></table></figure><p>同时，select子句还可以含有+、-、* 、&#x2F; 运算符的算数表达式<br><img src="/img/file-20250719110324488.png"></p><p>where 子句允许我们只选出那些在from子句的结果关系中<strong>满足特定谓词的元组</strong><br><img src="/img/file-20250719110411787.png"></p><h3 id="多关系查询"><a href="#多关系查询" class="headerlink" title="多关系查询"></a>多关系查询</h3><p>例子：<br><img src="/img/file-20250719110513245.png"></p><p>总述：<br><img src="/img/file-20250719110650934.png"><br><img src="/img/file-20250719110759538.png"></p><p>自然连接：<br><img src="/img/file-20250719111000907.png"><br><img src="/img/file-20250719111040388.png"><br>其中每个$E_i$可以是单个关系或一个包含自然连接的表达式</p><p>更名：as<br>字符串运算：<br><img src="/img/file-20250719111211574.png"><br>例子：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> dept_name<br><span class="hljs-keyword">from</span> department<br><span class="hljs-keyword">where</span> building <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%Watson%&#x27;</span><br></code></pre></td></tr></table></figure><p>属性说明：<code>*</code>可以用在select子句中表示所有的属性</p><p>显式次序，<code>order by</code><br><img src="/img/file-20250720153144731.png"></p><p><code>LIMIT &lt; count &gt; [offset]</code><br>用于限制返回元组的数量<br><img src="/img/file-20250720153345540.png"></p><p>LIMIT 10 则会限制只返回前10条符合条件的记录</p><p>LIMIT 20 OFFSET 10 表示跳过前面10条记录，返回接下来的20条</p><p>集合运算<br>聚集函数：以值的一个<strong>集合为输入</strong>、<strong>返回单个值</strong>的函数。<br><img src="/img/file-20250719111600887.png"><br>group by：<br><img src="/img/file-20250719172538091.png"><br><img src="/img/file-20250719172530098.png"></p><h2 id="中级SQL"><a href="#中级SQL" class="headerlink" title="中级SQL"></a>中级SQL</h2><h3 id="连接表达式"><a href="#连接表达式" class="headerlink" title="连接表达式"></a>连接表达式</h3><p>连接就是将一个或多个表的列合并起来，并产生一个新的表。</p><p>连接条件：</p><ul><li>自然连接–join…using子句</li><li><strong>自然连接（Natural Join）</strong> 是 SQL 中的一种连接方式，它会<strong>自动根据两个表中所有同名且类型相同的列</strong>来进行连接，不需要手动指定连接条件</li><li>on条件允许在参与连接的关系上设置通用的谓词，出现在连接表达式的末尾<br>例子：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> *<br><span class="hljs-keyword">from</span> student <span class="hljs-keyword">join</span> takes <span class="hljs-keyword">on</span> student.ID=takes.ID;<br></code></pre></td></tr></table></figure><p>on条件表明：如果一个来自student的元组和一个来自takes的元组在ID上的取值相同，那么他们是匹配的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> Score;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Student.id, name, age, course, score<br><span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">JOIN</span> Score<br><span class="hljs-keyword">ON</span> Student.id <span class="hljs-operator">=</span> Score.id;<br></code></pre></td></tr></table></figure><p>on条件可以表示任何SQL谓词，从而使用on条件的连接表达式就可以表示比自然连接更为丰富的连接条件</p><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><ul><li><p>左外连接：只保留出现在左外连接运算后之前（左边）的关系中的元组</p></li><li><p>右外连接：只保留出现在右外连接运算后之后（右边边）的关系中的元组</p></li><li><p>全外链接：保留出现在两个关系中的元组</p></li><li><p><strong>内连接</strong>只返回“两个表中都匹配的”数据。</p></li><li><p><strong>外连接</strong>则会返回<strong>至少在一个表中存在的数据</strong>，即：<br>➤ 先做内连接找出匹配的行，<br>➤ 然后保留“未匹配上的一侧表的行”，并用 <code>NULL</code> 填充缺失部分。</p></li></ul><table><thead><tr><th>类型</th><th>说明</th><th>典型用途</th></tr></thead><tbody><tr><td>LEFT JOIN</td><td>保留左表所有数据，右表匹配或为 NULL</td><td>主表为左侧，比如“所有学生”</td></tr><tr><td>RIGHT JOIN</td><td>保留右表所有数据，左表匹配或为 NULL</td><td>主表为右侧，比如“所有工资”</td></tr><tr><td>FULL OUTER JOIN</td><td>保留两边所有数据，不匹配填 NULL</td><td>汇总所有记录</td></tr></tbody></table><p>内连接：inner join</p><ul><li>join子句中没有使用outer前缀，默认是内连接</li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图可以理解为一个<strong>虚拟表</strong>，它是<strong>基于一个或多个表的查询结果</strong>创建的</p><ul><li>视图本事不存储数据，而是存储一个SQL查询语句的逻辑定义<br>视图&#x3D;保存的SQL查询</li></ul><h3 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h3><p>使用 <code>create view</code> 命令定义视图<br><code>create view v as &lt; query expression &gt;</code><br>&lt; query expression &gt; 可以是任何合法的查询表达式，v表示视图名<br><img src="/img/file-20250719160500302.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">view</span> physics_fall_2009 <span class="hljs-keyword">as</span><br><span class="hljs-keyword">select</span> course.course_id, sec_id, building, room_number<br><span class="hljs-keyword">from</span> course, section<br><span class="hljs-keyword">where</span> course.course_id <span class="hljs-operator">=</span> section.course_id<br>  <span class="hljs-keyword">and</span> course.dept_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Physics&#x27;</span><br>  <span class="hljs-keyword">and</span> section.semester <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Fall&#x27;</span><br>  <span class="hljs-keyword">and</span> section.year <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2009&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h4 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h4><p>特定数据库系统允许存储视图关系，但它们保证：如果用于定义视图的实际关系改变，视图也跟着修改，这样子的视图称为物化视图</p><table><thead><tr><th>项目</th><th>普通视图（View）</th><th>物化视图（Materialized View）</th></tr></thead><tbody><tr><td>是否存储数据</td><td>❌ 不存储，只保存查询逻辑</td><td>✅ 存储查询结果（像一张表）</td></tr><tr><td>性能</td><td>查询时重新执行原 SQL</td><td>查询时读取已保存的数据，性能更高</td></tr><tr><td>是否自动更新</td><td>✅ 总是最新</td><td>❌ 默认不自动更新，需要手动或定时刷新</td></tr><tr><td>是否实时</td><td>✅ 实时</td><td>❌ 非实时，取决于刷新策略</td></tr></tbody></table><h3 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h3><p>SQL视图可更新：</p><ul><li>from子句中只有一个数据库关系</li><li>select子句只包含关系的属性名，不包含任何表达式、聚集或distinct声明</li><li>任何没有出现在select子句中的属性可以取空值</li><li>查询中不含有group nby或having子句<br>允许update、insert和delete</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务由查询和（或）更新语句的序列组成<br>SQL标准规定当一条SQL语句被执行，就隐式地开始了一个事务<br><strong>事务</strong>是数据库中的一个操作单元，<strong>由一组 SQL 语句组成，要么全部执行成功，要么全部失败回滚</strong>。</p><p>特性：<br>原子性、一致性、隔离性、持久性</p><h3 id="DATE和TIME"><a href="#DATE和TIME" class="headerlink" title="DATE和TIME"></a>DATE和TIME</h3><p>例子：<br>查询今天的日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> NOW();<br></code></pre></td></tr></table></figure><p>然后就会返回今天的日期</p><p>利用一些数据库定义的函数，可以得到某天到某天之间的日期差，等等</p><h3 id="NESTED-QUERIES-内部查询"><a href="#NESTED-QUERIES-内部查询" class="headerlink" title="NESTED QUERIES 内部查询"></a>NESTED QUERIES 内部查询</h3><p>嵌套查询就是在一个 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code> 语句中，<strong>再写一个完整的 SELECT 查询</strong>，用来提供中间结果或条件。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> sid <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> sid<br>    <span class="hljs-keyword">FROM</span> enrolled<br>    <span class="hljs-keyword">WHERE</span> cid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;CS101&#x27;</span><br>);<br></code></pre></td></tr></table></figure><p>即，先查出上了CS101的学生编号，再查询他们的名字<br>Nested Query Results Expressions:<br>• ALL: Must satisfy expression for all rows in sub-query.<br>• ANY: Must satisfy expression for at least one row in sub-query.<br>• IN: Equivalent to &#x3D;ANY(). SELECT * FROM course<br>• EXISTS: At least one row is returned.</p><table><thead><tr><th>关键词</th><th>作用</th><th>举例说明</th></tr></thead><tbody><tr><td><code>ALL</code></td><td>与所有子查询结果比较</td><td><code>x &gt; ALL(...)</code>：大于全部</td></tr><tr><td><code>ANY</code></td><td>与任一子查询结果比较</td><td><code>x &gt; ANY(...)</code>：大于其中一个</td></tr><tr><td><code>IN</code></td><td>是否出现在子查询结果中</td><td><code>x IN (...)</code> 等价于 <code>x = ANY(...)</code></td></tr><tr><td><code>EXISTS</code></td><td>子查询是否返回至少一行</td><td>有记录就为 TRUE</td></tr></tbody></table><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>窗口函数时一种对一组相关记录（窗口）进行计算的函数，它不会像普通的聚合函数那样把多行变成一行，而是保留原来的行数并添加新列。 </p><p>Common Table Expressions（CTE）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> 临时表名 <span class="hljs-keyword">AS</span> (<br>    子查询<br>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 临时表名;<br></code></pre></td></tr></table></figure><h2 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h2><ul><li>学习如何通过通用程序设计语言来访问SQL<ul><li>通过拓展SQL语言来支持程序的操作</li><li>数据库中执行程序语言中定义的函数</li></ul></li><li>触发器：用于说明当特定事件发生时自动执行的操作</li><li>递归查询和高级聚集特性</li></ul><h3 id="使用程序设计语言访问数据库"><a href="#使用程序设计语言访问数据库" class="headerlink" title="使用程序设计语言访问数据库"></a>使用程序设计语言访问数据库</h3><p>原因：</p><ul><li>SQL没有提供通用程序设计语言那样的表达能力，不能表达所有查询要求</li><li>非声明性的动作都不能用SQL实现</li></ul><p>实现：</p><ul><li>动态SQL：通用程序设计语言可以通过函数或者方法来连接数据库服务器并与之交互。<ul><li>在运行时以字符串形式构建SQL查询，提交查询，如何把结果存入程序变量中，每次一个元组</li></ul></li><li>嵌入式SQL：嵌入式SQL语句必须在编译时全部确定，并交给预处理器</li></ul><p>嵌入式SQL：<br><img src="/img/file-20250724102243905.png"></p><h1 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>The first homework is to construct a set of SQL queries for analysing a dataset that will be provided to you. For this, you will look into <a href="https://www.imdb.com/interfaces/">IMDB data</a>. This homework is an opportunity to: (1) learn basic and certain advanced SQL features, and (2) get familiar with using a full-featured DBMS, <a href="https://www.sqlite.org/">SQLite</a>, that can be useful for you in the future.</p><p>第一个作业是构建一组 SQL 查询，用于分析将提供给您的数据集。为此，您将研究 <a href="https://www.imdb.com/interfaces/">IMDB 数据</a>。这个家庭作业是一个机会：（1） 学习基本和某些高级 SQL 功能，以及 （2） 熟悉使用功能齐全的 <a href="https://www.sqlite.org/">DBMS SQLite</a>，这对您将来可能很有用。</p><p>作业共包含10道题，满分100分。对于每个问题，您需要构建一个 SQL 查询，从 SQLite DBMS 获取所需的数据。完成问题可能需要大约 6-8 小时。</p><p>提交：<br>使用将用于每个问题的空 SQL 文件创建占位符提交文件夹：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ mkdir placeholder<br>$ cd placeholder<br>$ touch <span class="hljs-string">\</span><br>  q1_sample.sql <span class="hljs-string">\</span><br>  q2_sci_fi.sql <span class="hljs-string">\</span><br>  q3_oldest_people.sql <span class="hljs-string">\</span><br>  q4_crew_appears_most.sql <span class="hljs-string">\</span><br>  q5_decade_ratings.sql <span class="hljs-string">\</span><br>  q6_cruiseing_altitude.sql <span class="hljs-string">\</span><br>  q7_year_of_thieves.sql <span class="hljs-string">\</span><br>  q8_kidman_colleagues.sql <span class="hljs-string">\</span><br>  q9_9th_decile_ratings.sql <span class="hljs-string">\</span><br>  q10_house_of_the_dragon.sql<br>$ cd ..<br></code></pre></td></tr></table></figure><p>填写查询后，您可以通过运行以下命令来压缩文件夹：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ zip -<span class="hljs-keyword">j </span><span class="hljs-keyword">submission.zip </span>placeholder<span class="hljs-comment">/*.sql</span><br></code></pre></td></tr></table></figure><p>该标志允许您压缩 zip 文件中的所有 SQL 查询，而不提供路径信息。除非您这样做，否则评分脚本将<strong>无法</strong>正常工作。<code>-j</code></p><p>指示：</p><ol><li><p>设置SQLite<br>选择在Linux上安装SQLite3<br>发现现在的ubuntu linux几乎都自带了SQLite3，检查了一下，确实存在。<br><img src="/img/file-20250720165942906.png"><br>过了一会发现，这个是安装在python虚拟环境下的sqlite3，所以打算重新安装。</p></li><li><p>成功打开sqlite3和课程提供的数据库</p></li><li><p>发现数据库中有六个表</p></li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">sqlite&gt; .<span class="hljs-keyword">table</span><br>akas      crew      episodes  people    ratings   titles<br></code></pre></td></tr></table></figure><ol start="4"><li>在SQLite中使用命令，创建索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX ix_people_name <span class="hljs-keyword">ON</span> people (name);<br><span class="hljs-keyword">CREATE</span> INDEX ix_titles_type <span class="hljs-keyword">ON</span> titles (type);<br><span class="hljs-keyword">CREATE</span> INDEX ix_titles_primary_title <span class="hljs-keyword">ON</span> titles (primary_title);<br><span class="hljs-keyword">CREATE</span> INDEX ix_titles_original_title <span class="hljs-keyword">ON</span> titles (original_title);<br><span class="hljs-keyword">CREATE</span> INDEX ix_akas_title_id <span class="hljs-keyword">ON</span> akas (title_id);<br><span class="hljs-keyword">CREATE</span> INDEX ix_akas_title <span class="hljs-keyword">ON</span> akas (title);<br><span class="hljs-keyword">CREATE</span> INDEX ix_crew_title_id <span class="hljs-keyword">ON</span> crew (title_id);<br><span class="hljs-keyword">CREATE</span> INDEX ix_crew_person_id <span class="hljs-keyword">ON</span> crew (person_id);<br></code></pre></td></tr></table></figure><p>查看每张表的结构（schema）：使用命令 <code>.schema $TABLE_NAME</code><br>比如：<br><code>.schema akas</code> 就可以看到</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlite<span class="hljs-operator">&gt;</span> .schema akas<br><span class="hljs-keyword">CREATE TABLE</span> akas (<br>  title_id <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- REFERENCES titles (title_id),</span><br>  title <span class="hljs-type">VARCHAR</span>,<br>  region <span class="hljs-type">VARCHAR</span>,<br>  <span class="hljs-keyword">language</span> <span class="hljs-type">VARCHAR</span>,<br>  types <span class="hljs-type">VARCHAR</span>,<br>  attributes <span class="hljs-type">VARCHAR</span>,<br>  is_original_title <span class="hljs-type">INTEGER</span><br>);<br><span class="hljs-keyword">CREATE</span> INDEX ix_akas_title_id <span class="hljs-keyword">ON</span> akas (title_id);<br><span class="hljs-keyword">CREATE</span> INDEX ix_akas_title <span class="hljs-keyword">ON</span> akas (title);<br></code></pre></td></tr></table></figure><p>检查完之后就可以开始构造SQL查询了</p><p>模板：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 说明：选择列，过滤条件，排序方式，分组逻辑</span><br><span class="hljs-keyword">SELECT</span><br>    column1,<br>    column2,<br>    ...<br><span class="hljs-keyword">FROM</span><br>    table_name<br><span class="hljs-keyword">WHERE</span><br>    <span class="hljs-keyword">condition</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>    column1  <span class="hljs-comment">-- 如果需要聚合（可选）</span><br><span class="hljs-keyword">HAVING</span><br>    condition_on_group  <span class="hljs-comment">-- 分组后筛选（可选）</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>    column1 <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span><br>LIMIT<br>    N;  <span class="hljs-comment">-- 限制结果条数（可选）</span><br></code></pre></td></tr></table></figure><p>Q1：q1_sample<br>此查询的目的是确保 您的输出格式与我们的自动评分脚本的格式完全匹配。</p><p>详：列出按字母顺序排序的所有类别名称。<br><strong>答案</strong>：以下是正确的 SQL 查询和预期输出<br><img src="/img/file-20250720172505438.png"><br>将查询的sql语句粘贴到文件中即可。</p><p>Q2 [5 分] （q2_sci_fi）：<br>找到运行时间最长的 10 部“科幻”作品。<br>详：打印作品的标题、首播日期和运行时间。 列出运行时的列应以字符串 “ （mins）” 为后缀， 例如，如果 <code>runtime_mins</code> 值为 ‘12’，则应输出 <code>12 (mins)</code> 。Note a work is <code>Sci-Fi</code> even if it is categorized in multiple genres, as long as <code>Sci-Fi</code> is one of the genres.<br>您的第一行应如下所示：<br><code>Cicak-Man 2: Planet Hitam|2008|999 (mins)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    primary_title,<br>    premiered,<br>    runtime_minutes <span class="hljs-operator">||</span> <span class="hljs-string">&#x27; (mins)&#x27;</span> <span class="hljs-keyword">AS</span> runtime_mins<br><span class="hljs-keyword">FROM</span> titles<br><span class="hljs-keyword">WHERE</span> genres <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Sci-Fi%&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> runtime_minutes <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">10</span>;<br><br></code></pre></td></tr></table></figure><p><img src="/img/file-20250721104536521.png"></p><p>Q3 [5 分] （q3_oldest_people）：<br>确定数据集中出生于 1900 年或之后的最年长的人。 您应该假设一个没有已知死亡年份的人还活着。</p><p>详：打印每个人的姓名和年龄。人们应该 按年龄的复合值排序，其次是他们的名字 按字母顺序排列。返回前 20 个结果。<br>输出的格式应为：<code>NAME|AGE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">as</span> NAME,<span class="hljs-built_in">COALESCE</span>(died, <span class="hljs-number">2022</span>)<span class="hljs-operator">-</span>born <span class="hljs-keyword">AS</span> AGE<br><span class="hljs-keyword">FROM</span> people<br><span class="hljs-keyword">WHERE</span> born<span class="hljs-operator">&gt;=</span><span class="hljs-number">1900</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> AGE <span class="hljs-keyword">DESC</span>,NAME <span class="hljs-keyword">ASC</span><br>LIMIT <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/image-20250721110747212.png"></p><p>Q4 [10 分] （q4_crew_appears_most）：<br>查找最常以船员身份出现的人。</p><p>详：打印20人的姓名和出场次数 最多的船员出场次数按出场次数排序 以下降的方式。<br>您的输出应如下所示：<code>NAME|NUM_APPEARANCES</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> crew (<br>  title_id <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- REFERENCES titles (title_id),</span><br>  person_id <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- REFERENCES people (person_id),</span><br>  category <span class="hljs-type">VARCHAR</span>,<br>  job <span class="hljs-type">VARCHAR</span>,<br>  characters <span class="hljs-type">VARCHAR</span><br>);<br><span class="hljs-keyword">CREATE TABLE</span> people (<br>  person_id <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  name <span class="hljs-type">VARCHAR</span>,<br>  born <span class="hljs-type">INTEGER</span>,<br>  died <span class="hljs-type">INTEGER</span><br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> people.name <span class="hljs-keyword">AS</span> NAME, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> NUM_APPEARANCES<br><span class="hljs-keyword">FROM</span> crew<br><span class="hljs-keyword">JOIN</span> people <span class="hljs-keyword">ON</span> crew.person_id <span class="hljs-operator">=</span> people.person_id<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> crew.person_id, people.name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> NUM_APPEARANCES <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/image-20250721113629379.png" alt="image-20250721113629379"></p><p>问题 5 [10 分] （q5_decade_ratings）：</p><p>计算每十年内容评级的有趣统计数据。</p><p>**详：**获取平均评分（四舍五入到小数点后两位）、最高评分、 最小评级，以及每个十年的发布次数。排除尚未首映（即首映的位置 <code>NULL</code> ）。打印相关 decade 以更奇特的格式构建一个如下所示的字符串：<code>1990s</code> .按降序的平均评分对几十年进行排序 时尚，其次是十年，上升，断绝关系。<br>输出的格式应为：<code>DECADE|AVG_RATING|TOP_RATING|MIN_RATING|NUM_RELEASES</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>  <span class="hljs-built_in">CAST</span>((premiered <span class="hljs-operator">/</span> <span class="hljs-number">10</span>) <span class="hljs-operator">*</span> <span class="hljs-number">10</span> <span class="hljs-keyword">AS</span> TEXT) <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;s&#x27;</span> <span class="hljs-keyword">AS</span> DECADE,<br>  ROUND(<span class="hljs-built_in">AVG</span>(rating), <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> AVG_RATING,<br>  <span class="hljs-built_in">MAX</span>(rating) <span class="hljs-keyword">AS</span> TOP_RATING,<br>  <span class="hljs-built_in">MIN</span>(rating) <span class="hljs-keyword">AS</span> MIN_RATING,<br>  <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> NUM_RELEASES<br><span class="hljs-keyword">FROM</span> titles<br><span class="hljs-keyword">JOIN</span> ratings <span class="hljs-keyword">ON</span> titles.title_id <span class="hljs-operator">=</span> ratings.title_id<br><span class="hljs-keyword">WHERE</span> premiered <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> DECADE<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> AVG_RATING <span class="hljs-keyword">DESC</span>, DECADE <span class="hljs-keyword">ASC</span>;<br><br></code></pre></td></tr></table></figure><p><img src="/img/image-20250721162839308.png" alt="image-20250721162839308"></p><p>COUNT(*)：统计符合条件的所有行数，无论这些行中有没有NULL值</p><p>FROM只写了titles是因为，我通过自然连接，把ratings的信息给并过来了，他们合成一个表，所以就只用写titles</p><p>问题 6 [10 分] （q6_cruiseing_altitude）：</p><p>找出由出生于 1962 年、名字中包含 “Cruise” 的人参与的、最受欢迎（投票数最多）的作品。</p><p>**详：**获得得票最多且剧组中有一人的作品 他们的名字中带有“Cruise”，出生于 1962 年。返回 工作和投票数，并仅按顺序列出前 10 名结果 从多到最少的选票。确保输出的格式如下：<code>Top Gun|408389</code></p><p>查询逻辑：</p><ul><li>从people表中找出所有名字里含Cruise且出生于1962年的人</li><li>再找出这些人参与的作品，到crew表中得到title_id</li><li>到ratings表中得到投票数，到titles表中找到作品名</li><li>按照投票数降序排列，取前10名</li><li>格式<code>Top Gun|408389</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>titles.primary_title,<br>ratings.votes<br><span class="hljs-keyword">FROM</span> people<br><span class="hljs-keyword">JOIN</span> crew <span class="hljs-keyword">ON</span> people.person_id <span class="hljs-operator">=</span> crew.person_id<br><span class="hljs-keyword">JOIN</span> ratings <span class="hljs-keyword">ON</span> crew.title_id<span class="hljs-operator">=</span>ratings.title_id<br><span class="hljs-keyword">JOIN</span> titles <span class="hljs-keyword">ON</span> crew.title_id<span class="hljs-operator">=</span>titles.title_id<br><span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Cruise%&#x27;</span> <span class="hljs-keyword">AND</span> born <span class="hljs-operator">=</span> <span class="hljs-number">1962</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ratings.votes <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/image-20250721121833680.png"></p><p>问题7 [15分] （q7_year_of_thieves）：</p><p>列出与“Army of Thieves”同年首播的作品数量。</p><p>**详：**仅打印作品总数。答案应该包括 “Army of Thieves”本身。对于这个问题，通过<code>title_id</code>确定不同的作品，而不是他们的名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> titles (<br>  title_id <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  type <span class="hljs-type">VARCHAR</span>,<br>  primary_title <span class="hljs-type">VARCHAR</span>,<br>  original_title <span class="hljs-type">VARCHAR</span>,<br>  is_adult <span class="hljs-type">INTEGER</span>,<br>  premiered <span class="hljs-type">INTEGER</span>,<br>  ended <span class="hljs-type">INTEGER</span>,<br>  runtime_minutes <span class="hljs-type">INTEGER</span>,<br>  genres <span class="hljs-type">VARCHAR</span><br>);<br></code></pre></td></tr></table></figure><p>查询步骤：</p><ul><li><p>先得到Army of Thieves的播放年份</p></li><li><p>然后查询与这个年份同一年播放的所有作品的title_id</p></li><li><p>数一下</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> title_id)<br><span class="hljs-keyword">FROM</span> titles<br><span class="hljs-keyword">WHERE</span> premiered <span class="hljs-operator">=</span> (<br>    <span class="hljs-keyword">SELECT</span> premiered <span class="hljs-keyword">FROM</span> titles <span class="hljs-keyword">WHERE</span> primary_title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Army of Thieves&#x27;</span><br>);<br></code></pre></td></tr></table></figure><p><img src="/img/image-20250721122737926.png"></p><p>问题8 [15分] （q8_kidman_colleagues）：</p><p>找出曾与 Nicole Kidman 合作出演（出演同一部作品）的所有演员和女演员的名字。</p><p>输出格式要求如下：</p><ul><li>只输出 <code>name</code>（不包含 id 或其他字段）；</li><li>按字母表排序；</li><li>不允许重复（所以需要用 <code>DISTINCT</code>）；</li><li><strong>包含 Nicole Kidman 本人</strong>！</li></ul><p>判断某人是否在某部作品中“出演”，需要看 <code>crew</code> 表里的 <code>category</code> 字段；</p><p>其中，“actor” 和 “actress” 是两种不同的角色标签；</p><p>所以你必须同时找 category &#x3D; ‘actor’ <strong>和</strong> category &#x3D; ‘actress’ 的人（不能只找其中一种）；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> crew (<br>  title_id <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- REFERENCES titles (title_id),</span><br>  person_id <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- REFERENCES people (person_id),</span><br>  category <span class="hljs-type">VARCHAR</span>,<br>  job <span class="hljs-type">VARCHAR</span>,<br>  characters <span class="hljs-type">VARCHAR</span><br>);<br><span class="hljs-keyword">CREATE TABLE</span> people (<br>  person_id <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  name <span class="hljs-type">VARCHAR</span>,<br>  born <span class="hljs-type">INTEGER</span>,<br>  died <span class="hljs-type">INTEGER</span><br>);<br></code></pre></td></tr></table></figure><p>查询逻辑：</p><ol><li>在people表中得到Nicole Kidman的person_id</li><li>然后在crew表中找到与Nicole Kidman有相同的title_id的人，查看他是actor还是actress，回到people找到人名</li><li>我们可以通过自然连接把people表和crew表连接起来</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> p.name<br><span class="hljs-keyword">FROM</span> people p<br><span class="hljs-keyword">JOIN</span> crew c <span class="hljs-keyword">ON</span> p.person_id <span class="hljs-operator">=</span> c.person_id<br><span class="hljs-keyword">WHERE</span> c.title_id <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> c2.title_id<br>    <span class="hljs-keyword">FROM</span> crew c2<br>    <span class="hljs-keyword">JOIN</span> people p2 <span class="hljs-keyword">ON</span> c2.person_id <span class="hljs-operator">=</span> p2.person_id<br>    <span class="hljs-keyword">WHERE</span> p2.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Nicole Kidman&#x27;</span> <span class="hljs-keyword">AND</span> p2.born <span class="hljs-operator">=</span> <span class="hljs-number">1967</span><br>)<br><span class="hljs-keyword">AND</span> (c.category <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;actor&#x27;</span> <span class="hljs-keyword">OR</span> c.category <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;actress&#x27;</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> p.name;<br></code></pre></td></tr></table></figure><p>这里要注意的是NK可能参演了多部作品，这个时候title_id是用 <code>IN</code> 而不能用等号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlite<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> p.name<br><span class="hljs-keyword">FROM</span> people p<br><span class="hljs-keyword">JOIN</span> crew c <span class="hljs-keyword">ON</span> p.person_id <span class="hljs-operator">=</span> c.person_id<br><span class="hljs-keyword">WHERE</span> c.title_id <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> c2.title_id<br>    <span class="hljs-keyword">FROM</span> crew c2<br>    <span class="hljs-keyword">JOIN</span> people p2 <span class="hljs-keyword">ON</span> c2.person_id <span class="hljs-operator">=</span> p2.person_id<br>    <span class="hljs-keyword">WHERE</span> p2.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Nicole Kidman&#x27;</span> <span class="hljs-keyword">AND</span> p2.born <span class="hljs-operator">=</span> <span class="hljs-number">1967</span><br>)<br><span class="hljs-keyword">AND</span> (c.category <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;actor&#x27;</span> <span class="hljs-keyword">OR</span> c.category <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;actress&#x27;</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> p.name;<br>Betty Gilpin<br>Casey Affleck<br>Colin Farrell<br>Crista Flanagan<br>Danny Huston<br>Dennis Miller<br>Donald Sutherland<br>Ed Mantell<br>Fionnula Flanagan<br>Flora <span class="hljs-keyword">Cross</span><br>Fredrik Skavlan<br>Gus Mercurio<br>Halle Berry<br>Harris Yulin<br>J.K. Simmons<br>Jackson Bond<br>James Corden<br>Jason Bateman<br>Javier Bardem<br>Jesper Christensen<br>John Lithgow<br>Julianne Moore<br>Kai Lewins<br>Kyle Mooney<br>Lisa Flanagan<br>Liz Burch<br>Mahershala Ali<br>Maria Tran<br>Mark Strong<br>Nicholas Eadie<br>Nicole Kidman<br>Paul Bettany<br>Pauline Chan<br>Robert Pattinson<br>Russell Crowe<br>Sam Neill<br>Shailene Woodley<br>Sherie Graham<br>Simon Baker<br>Stellan Skarsgård<br>Tom Cruise<br>Valerie Yu<br>Veronica Lang<br>Will Ferrell<br></code></pre></td></tr></table></figure><p>问题 9 [15 分] （q9_9th_decile_ratings）：</p><p>找出所有 <strong>出生于 1955 年</strong> 的人，获取他们的名字，以及他们职业生涯中参与过的电影的 <strong>平均评分</strong>。</p><p>输出这些人中<strong>职业平均评分位于第 9 分位数（decile）的人</strong>的名字和平均评分。</p><p><strong>详：<strong>计算 1955 年出生的每个人的平均评分 只有他们参与过的</strong>电影</strong>。计算每个分位数 使用 <a href="https://www.sqlitetutorial.net/sqlite-window-functions/sqlite-ntile/">NTILE（10）</a> 的个人平均评分。<br>确保您的输出格式如下（将平均评分四舍五入为 最接近的百分之一，结果应按复合值 他们的评级降序，其次是他们的名字，按字母顺序排列）：<code>Stanley Nelson|7.13</code><br>**注意：**您应该在处理平均职业后取分位数个人的电影评级。换句话说，找到那些拥有职业生涯电影的平均评分在所有人的第 9 个十分位数。</p><p>查询步骤：</p><ul><li>找到所有出身于1955年的人，获取名字（people表）、职业生涯中演过的电影（crew表）的平均评分（ratings表)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> people (<br>  person_id <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  name <span class="hljs-type">VARCHAR</span>,<br>  born <span class="hljs-type">INTEGER</span>,<br>  died <span class="hljs-type">INTEGER</span><br>);<br><span class="hljs-keyword">CREATE TABLE</span> crew (<br>  title_id <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- REFERENCES titles (title_id),</span><br>  person_id <span class="hljs-type">VARCHAR</span>, <span class="hljs-comment">-- REFERENCES people (person_id),</span><br>  category <span class="hljs-type">VARCHAR</span>,<br>  job <span class="hljs-type">VARCHAR</span>,<br>  characters <span class="hljs-type">VARCHAR</span><br>);<br><span class="hljs-keyword">CREATE TABLE</span> ratings (<br>  title_id <span class="hljs-type">VARCHAR</span> <span class="hljs-keyword">PRIMARY KEY</span>, <span class="hljs-comment">-- REFERENCES titles (title_id),</span><br>  rating <span class="hljs-type">FLOAT</span>,<br>  votes <span class="hljs-type">INTEGER</span><br>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name , ROUND(average_rating, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> <br>        p.name,<br>        <span class="hljs-built_in">AVG</span>(r.rating) <span class="hljs-keyword">AS</span> average_rating,<br>        <span class="hljs-built_in">NTILE</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(r.rating) <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> decile<br>    <span class="hljs-keyword">FROM</span> people p<br>    <span class="hljs-keyword">JOIN</span> crew c <span class="hljs-keyword">ON</span> p.person_id <span class="hljs-operator">=</span> c.person_id<br>    <span class="hljs-keyword">JOIN</span> ratings r <span class="hljs-keyword">ON</span> c.title_id <span class="hljs-operator">=</span> r.title_id<br>    <span class="hljs-keyword">WHERE</span> p.born <span class="hljs-operator">=</span> <span class="hljs-number">1955</span><br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> p.person_id, p.name<br>)<br><span class="hljs-keyword">WHERE</span> decile <span class="hljs-operator">=</span> <span class="hljs-number">9</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> average_rating <span class="hljs-keyword">DESC</span>, name <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><p>内层查询先计算每个人的平均评分和所在十分位 <code>decile</code>；</p><p>外层查询只筛选第 9 十分位 (<code>decile = 9</code>)；</p><p>拼接输出格式为 <code>名字|评分</code>，评分四舍五入保留两位小数；</p><p>问题10 [15分] （q10_house_of_the_dragon）：</p><p>请将《House of the Dragon》这部剧的所有独特标题（title）拼接成一个按字母顺序排列、逗号 + 空格分隔的单个字符串csv。</p><ul><li><p>查找 TV 节目名称为 <code>&quot;House of the Dragon&quot;</code> 的所有标题（包括被翻译&#x2F;配音后的标题，即 dubbed titles）。</p></li><li><p>去重，区分大小写（<code>&quot;foo&quot;</code> 和 <code>&quot;Foo&quot;</code> 被视为不同）。</p></li><li><p>按<strong>字母升序</strong>排列这些标题。</p></li><li><p>使用 <strong>逗号 + 空格（<code>, </code>）</strong> 作为分隔符，将所有标题拼接成一个字符串返回。</p></li><li><p>推荐使用 <strong>递归 CTE（WITH RECURSIVE）</strong> 实现字符串拼接。</p></li><li><p>最终输出是一个<strong>单行字符串</strong>，如：<code>foo, Hello World, zzz</code></p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span><br><span class="hljs-comment">-- Step 1: 获取所有和 House of the Dragon 对应的 title_id</span><br>target_titles <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> title_id<br>  <span class="hljs-keyword">FROM</span> titles<br>  <span class="hljs-keyword">WHERE</span> primary_title <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;House of the Dragon&#x27;</span><br>),<br><span class="hljs-comment">-- Step 2: 获取所有不同语言的翻译标题，并排序</span><br>sorted_titles <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> akas.title<br>  <span class="hljs-keyword">FROM</span> akas<br>  <span class="hljs-keyword">JOIN</span> target_titles <span class="hljs-keyword">ON</span> akas.title_id <span class="hljs-operator">=</span> target_titles.title_id<br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> akas.title<br>),<br><span class="hljs-comment">-- Step 3: 给每个标题加上行号</span><br>numbered_titles <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> () <span class="hljs-keyword">AS</span> rn, title<br>  <span class="hljs-keyword">FROM</span> sorted_titles<br>),<br><span class="hljs-comment">-- Step 4: 使用递归拼接字符串</span><br>agg(rn, title_str) <span class="hljs-keyword">AS</span> (<br>  <span class="hljs-keyword">SELECT</span> rn, title <span class="hljs-keyword">FROM</span> numbered_titles <span class="hljs-keyword">WHERE</span> rn <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br>  <span class="hljs-keyword">SELECT</span> n.rn, a.title_str <span class="hljs-operator">||</span> <span class="hljs-string">&#x27;, &#x27;</span> <span class="hljs-operator">||</span> n.title<br>  <span class="hljs-keyword">FROM</span> agg a<br>  <span class="hljs-keyword">JOIN</span> numbered_titles n <span class="hljs-keyword">ON</span> n.rn <span class="hljs-operator">=</span> a.rn <span class="hljs-operator">+</span> <span class="hljs-number">1</span><br>)<br><span class="hljs-comment">-- 最终结果：只保留最后一行（拼接完成的）</span><br><span class="hljs-keyword">SELECT</span> title_str<br><span class="hljs-keyword">FROM</span> agg<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> rn <span class="hljs-keyword">DESC</span><br>LIMIT <span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Databases</title>
    <link href="/2025/07/17/databases/"/>
    <url>/2025/07/17/databases/</url>
    
    <content type="html"><![CDATA[<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ol><li><a href="https://github.com/PKUFlyingPig/cs-self-learning/blob/master/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/15445.md">cs-self-learning&#x2F;docs&#x2F;数据库系统&#x2F;15445.md at master · PKUFlyingPig&#x2F;cs-self-learning</a></li><li><a href="https://15445.courses.cs.cmu.edu/spring2023/schedule.html">Schedule | CMU 15-445&#x2F;645 :: Intro to Database Systems (Spring 2023)</a></li></ol><p>由于2022的有对应的网课， 我觉得使用2022的配套练习会比较合适。<br><a href="https://15445.courses.cs.cmu.edu/fall2022/schedule.html">Schedule | CMU 15-445&#x2F;645 :: Intro to Database Systems (Fall 2022)</a><br>other year:<a href="https://15445.courses.cs.cmu.edu/fall2025/">CMU 15-445 :: Intro to Database Systems (Fall 2025)</a><br>discord Channel:<br><a href="https://discord.com/channels/724929902075445281/752529819148877904">Discord | #welcome | CMU 15-445&#x2F;645 (unofficial)</a></p><p><a href="https://zhuanlan.zhihu.com/p/623770086">(16 封私信 &#x2F; 42 条消息) 2022 CMU-15445 全总结 - 知乎</a><br><a href="https://blog.csdn.net/twentyonepilots/article/details/120868216">CMU15-445 数据库实验全满分通过笔记 2021 Fall bustub-cmudb lab_github cmu 15-445 2021-CSDN博客</a><br><a href="https://zhenghe.gitbook.io/open-courses/cmu-15-445-645-database-systems/relational-data-model">Relational Data Model | open-courses</a></p><h1 id="Lecture1"><a href="#Lecture1" class="headerlink" title="Lecture1"></a>Lecture1</h1><p>此课程重点是如何构建数据库，而不是如何使用数据库。</p><p>非官方学生通过这个来评测<br><img src="/img/file-20250717214232397.png"></p><p>测评：<a href="https://www.gradescope.com/courses/425272">15-445&#x2F;645 (Non-CMU) Dashboard | Gradescope</a></p><p>什么是数据库？<br>数据库是组织化的、相互关联的数据集合。<br>e.g:创建一个数字音乐商店数据库，包含艺术家和专辑信息。</p><p>关系模型：</p><ul><li>关系模型：基于关系的数据库抽象，避免维护开销。</li><li>三个组成部分：<ul><li>结构：定义数据库的关系及其内容。</li><li>完整性：确保数据库内容满足约束条件。</li><li>操作：<strong>访问和修改</strong>数据库内容的编程接口。</li></ul></li><li>关系是一个无序的集合，包含代表实体的属性关系</li><li>主键：唯一表示关系中的一个元组</li><li>外键：指定一个关系中的属性必须映射到另一个关系中的元组</li></ul><p>关系代数：</p><ul><li><strong>关系代数</strong>：用于检索和操作关系中的元组的基本操作。</li><li><strong>操作符</strong>：<ul><li><strong>选择（σ）</strong>：根据条件筛选元组。</li><li><strong>投影（π）</strong>：选择特定的属性。</li><li><strong>并集（∪）</strong>：合并两个关系的元组。</li><li><strong>交集（∩）</strong>：找出两个关系中共有的元组。</li><li><strong>差集（–）</strong>：找出第一个关系中有而第二个关系中没有的元组。</li><li><strong>笛卡尔积（×）</strong>：生成两个关系中所有可能的元组组合。</li><li><strong>连接（⋈）</strong>：根据共同属性组合两个关系的元组。</li></ul></li><li><strong>额外操作符</strong>：重命名（ρ）、赋值（←）、去重（δ）、聚合（γ）、排序（τ）和除法（÷）。</li></ul><h2 id="Notes1："><a href="#Notes1：" class="headerlink" title="Notes1："></a>Notes1：</h2><h3 id="FlatFile-Strawman"><a href="#FlatFile-Strawman" class="headerlink" title="FlatFile Strawman"></a>FlatFile Strawman</h3><p>数据库经常以CSV(comma-separated value)文件的形式存储，由DBMS进行管理。每次应用程序要读取或者更新记录时，都必须解析文件</p><p>以数字音乐商店的例子，会有两个文件，一是艺术家，二是专辑。</p><p>每个实体都有自己的属性集，所以在每个文件中，不同的记录都用新的<strong>行</strong>来划分，而一条记录中的每个相应属性都用<strong>逗号</strong>隔开</p><p>e.g:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Wu</span>-Tang Clan, <span class="hljs-number">1992</span>, USA <br><span class="hljs-attribute">Notorious</span> BIG, <span class="hljs-number">1992</span>, USA <br><span class="hljs-attribute">GZE</span>, <span class="hljs-number">1990</span>, USA<br></code></pre></td></tr></table></figure><p>Flat File：</p><ul><li>Data Integrity 数据完整性</li><li>Implementation 实现</li><li>Durability 持久性<br><img src="/img/file-20250718112528744.png"></li></ul><h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><p>DBMS(database management system): a software that allows applications to store and analyze infomation in a database</p><ul><li>允许增删查改</li><li><strong>Data model：</strong><br>数据模型是描述数据库中数据的概念的集合。</li><li><strong>Schema：</strong><br>模式是对基于数据模型的特定数据集合的描述。</li></ul><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>The relational model defines a database abstraction based on relations to <strong>avoid maintenance overhead</strong>. It has three key points:<br>• Store database in simple <strong>data structures</strong> (relations).<br>• Access data through <strong>high-level language</strong>, DBMS figures out best execution strategy.<br>• Physical storage left up to the DBMS implementation.</p><ul><li>用简单的数据结构保存，用高级语言来访问，让DBMS来执行最优策略以及处理物理层存储</li></ul><p>关系模型定义的三个概念:</p><ul><li>Structure：关系定义和内容。也就是关系具有的属性以及可以有的值。</li><li>Integrity：确保数据库的内容满足约束条件。比如：年份必须是数字。</li><li>Manipulation:如何访问和修改数据库的内容。</li></ul><p>关系是一组无序的集合。因为是无序的，所以DBMS可以用它想要的任何方式存储它们，并允许优化。<br>元组指的是关系中的一组属性值<br>A relation with <strong>n attributes</strong> is called an <strong>n-ary relation</strong>、</p><h3 id="键–Key"><a href="#键–Key" class="headerlink" title="键–Key"></a>键–Key</h3><ul><li><p>A relation’s primary key uniquely identifies a single tuple.<br>一个关系的<strong>primary key</strong>唯一的定义了单个元组。很多DBMSs都支持autogenerated keys，所以程序就不需要手动增加了，但primary key还是在某些DBMSs是需要的。</p></li><li><p>Primary key：唯一的定义了单个元组。</p></li><li><p>Foreign key：指定一个关系中的属性必须映射到另一个关系中的元组。</p></li></ul><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><ul><li>Procedural: The query specifies the (high-level) strategy the DBMS should use to find the desired result based on sets &#x2F; bags. (relational algebra)<br>过程化DML：要求用户指定需要什么数据以及如何获得数据</li><li>Non-Procedural (Declarative): The query specifies only what data is wanted and not how to find it. (relational calculus)<br>声明式DML：只要求指定需要什么数据</li></ul><h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>一组基本操作，用于检索和操作关系中的图元。（跟离散数学关系比较大）</p><ul><li><strong>操作符</strong>：<ul><li><strong>选择（σ）</strong>：根据条件筛选元组。</li><li><strong>投影（π）</strong>：选择特定的属性。</li><li><strong>并集（∪）</strong>：合并两个关系的元组。</li><li><strong>交集（∩）</strong>：找出两个关系中共有的元组。</li><li><strong>差集（–）</strong>：找出第一个关系中有而第二个关系中没有的元组。</li><li><strong>笛卡尔积（×）</strong>：生成两个关系中所有可能的元组组合。</li><li><strong>连接（⋈）</strong>：根据共同属性组合两个关系的元组。</li></ul></li></ul><p>书本内容：</p><h2 id="chap1"><a href="#chap1" class="headerlink" title="chap1"></a>chap1</h2><p>数据库管理系统（DBMS）由一个互相关联的<strong>数据的集合</strong>和一组用以<strong>访问这些数据的程序</strong>组成。<u>这个数据集合称为数据库。<br></u></p><p>文件系统存储组织信息的弊端：</p><ul><li>数据的冗余和不一致：可能出现重复存储，这种冗余可能进一步导致不一致性</li><li>数据访问困难</li><li>数据孤立：数据分散在不同文件中</li><li>完整性问题</li><li>原子性问题</li><li>并发访问异常</li><li>安全性问题</li></ul><h3 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h3><p>数据库给用户提供数据的抽象视图。<br>数据库可以分为三个层次：物理层、逻辑层和视图层<br><strong>物理层</strong>描述了数据是如何存储的<br><strong>逻辑层</strong>描述了数据库中存储什么数据以及数据之间的关系<br><strong>视图层</strong>只描述整个数据库的某个部分</p><ul><li>视图层有多个视图，每个用户只需要访问数据库的一部分，通过划分视图来简化用户与系统的交互。</li></ul><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>数据模型：描述数据、数据联系、数据语义以及一致性约束的概念工具集合<br>数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式</p><p>数据模型可以分为四类：</p><ul><li><strong>关系模型</strong>：用表的集合来表示数据和数据间的联系。是基于记录的模型的一种。</li><li>实体-联系模型</li><li>基于对象的数据模型</li><li>半结构化数据模型</li></ul><h3 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h3><p>数据库系统提供<u>数据定义语言</u>来定义数据库模式，以及<u>数据操纵语言</u>来表达数据库的查询和更新</p><h4 id="数据操纵语言DML"><a href="#数据操纵语言DML" class="headerlink" title="数据操纵语言DML"></a>数据操纵语言DML</h4><p>使得用户可以访问或操纵数据，进行增删查改<br>过程化DML：要求用户指定需要什么数据以及如何获得数据<br>声明式DML：只要求指定需要什么数据</p><h4 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h4><p>用于定义数据库模式的实现细节</p><p>关系数据库<br>关系数据库基于关系模型。</p><h1 id="Project-0"><a href="#Project-0" class="headerlink" title="Project 0"></a>Project 0</h1><p>需要实现一个基于并发Trie（字典树）的键值存储系统。</p><h2 id="项目要求："><a href="#项目要求：" class="headerlink" title="项目要求："></a>项目要求：</h2><ol><li>单线程Trie实现<ul><li>实现 <code>TrieNode</code> 类：表示Trie中的单个节点，存储一个字符和子节点映射</li><li>实现 <code>TrieNodeWithValue</code> 类：继承自 <code>TrieNOde</code> ，表示存储值的终端节点</li><li>实现 <code>Trie</code> 类：支持插入、删除和查找操作</li></ul></li><li>并发Trie实现<ul><li>使用读写锁实现线程安全</li><li>查找操作获取读锁，插入和删除操作获得写锁</li></ul></li></ol><h2 id="关键概念理解"><a href="#关键概念理解" class="headerlink" title="关键概念理解"></a>关键概念理解</h2><p>Trie字典树，例如存储”HELLO”、”HAT”和”HAVE”<br><img src="/img/file-20250726102623185.png"><br> 需要实现的功能：</p><ul><li>插入操作<ul><li>沿着键的字符便利Trie，必要时创建新节点</li><li>处理三种情况<ul><li>终端节点不存在–创建新终端节点</li><li>节点存在但不是终端节点–转换为终端节点</li><li>已经是终端节点–返回失败（不允许重复键）</li></ul></li></ul></li><li>删除操作<ul><li>找到键对应的终端节点</li><li>将 <code>is_end_</code> 标志为false</li><li>递归删除没有子节点的空节点</li></ul></li><li>查找操作<ul><li>遍历Trie找到终端节点</li><li>检查值类型是否匹配</li><li>使用dynamic_cast检查类型</li></ul></li></ul><h2 id="实现建议"><a href="#实现建议" class="headerlink" title="实现建议"></a>实现建议</h2><ul><li>分步实现<ul><li>先完成单线程版本，再添加并发支持</li><li>仔细处理unique_ptr的所有权</li></ul></li><li>并发控制<ul><li>使用读写锁保护根节点</li><li>查找使用读锁，插入&#x2F;删除使用写锁</li><li>确保在函数返回前释放锁</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kaiwu</title>
    <link href="/2025/07/12/kaiwu/"/>
    <url>/2025/07/12/kaiwu/</url>
    
    <content type="html"><![CDATA[<h1 id="学习期"><a href="#学习期" class="headerlink" title="学习期"></a>学习期</h1><ul><li>熟悉平台以及了解项目</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /data/projects/gorge_walk_v2/log/learner<br></code></pre></td></tr></table></figure><h2 id="初赛："><a href="#初赛：" class="headerlink" title="初赛："></a>初赛：</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>训练智能体，在地图中不断探索中学习移动策略，减少碰撞障碍物，以最少的步数<strong>从起点走到终点</strong>，可能会有附属任务——<strong>收集宝箱</strong>。</p><h3 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>峡谷漫步使用<code>64*64</code>的网格化的地图（智能体每步移动的距离是一网格），地图中包含<strong>起点</strong>、<strong>终点</strong>、<strong>道路</strong>、<strong>障碍物</strong>和<strong>宝箱</strong>等元素。</p><table><thead><tr><th align="center">元素</th><th>说明</th></tr></thead><tbody><tr><td align="center"><strong>英雄</strong></td><td>环境中存在英雄单位，智能体可以控制英雄在地图中进行移动。本环境采用鲁班作为英雄角色。</td></tr><tr><td align="center"><strong>起点</strong></td><td>任务开始时，英雄单位在起点出现。</td></tr><tr><td align="center"><strong>终点</strong></td><td>任务设置的目的地，当英雄抵达终点时，任务结束。</td></tr><tr><td align="center"><strong>道路</strong></td><td>英雄可以在道路中通过前、后、左、右四个方向移动进行试探，每次移动的距离是一个网格。</td></tr><tr><td align="center"><strong>障碍物</strong></td><td>英雄遇到障碍物时无法继续前进，需要调整方向开启新的探索。</td></tr><tr><td align="center"><strong>宝箱</strong></td><td>如果用户给任务配置了宝箱，则智能体可以通过控制英雄拾取宝箱增加积分，每个宝箱获得100积分，地图中共有10个可配置宝箱的点位。</td></tr><tr><td align="center"><strong>视野范围</strong></td><td>智能体的视野范围是以自己为中心，5*5范围内的所有格子。</td></tr></tbody></table><h3 id="规则介绍"><a href="#规则介绍" class="headerlink" title="规则介绍"></a>规则介绍</h3><p>总积分 &#x3D; 终点积分 + 步数积分 + 宝箱积分</p><ul><li><strong>终点积分</strong>：到达终点即获得<strong>150</strong>积分。</li><li><strong>步数积分</strong>：<strong>(最大步数 - 完成步数) * 奖励系数0.2</strong>。任务设置有最大步数，当智能体到达终点时，根据最大步数和任务完成步数计算步数积分。</li><li><strong>宝箱积分</strong>：每获得一个宝箱，即可增加<strong>100</strong>积分。</li></ul><p>注意：若在<strong>最大步数</strong>内没有走到终点（包括最大步数），则判定为任务超时。<strong>超时任务的总积分为0</strong>。</p><p>本赛题需选手自备算力，下载客户端后在本地进行训练。为提升体验，学习期阶段支持单机和分布式训练模式。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>训练启动时，可选择如下算法：</p><ul><li>dynamic_programming</li><li>monte_carlo</li><li>sarsa</li><li>q_learning</li><li>diy</li></ul><p>可选训练模式：</p><ul><li>单机</li><li>分布式</li></ul><p>整体训练思路参考：</p><ol><li>第一阶段，让agent学会走路，到达终点（宝箱奖励为0，终点奖励在引导智能体决策）；</li><li>第二阶段，在智能体学会走路的基础上，尝试收集宝箱（靠近宝箱的奖励，获取宝箱的奖励，终点奖励减少）</li><li>第三阶段，强化智能体收集宝箱的能力（奖励中设置在未全部收集到宝箱时终点奖励为0）</li></ol><p>实现分阶段训练的方法：</p><p>训练的整体流程是在train_workflow.py中控制的，可以利用workflow函数中的epoch来划分训练的各个阶段（具体如何划分大家自行确定）</p><p>奖励设计思路：<br>1.针对上面的三个阶段设计了三个不同的奖励体系<br>2.宝箱奖励的设计非常重要（宝箱奖励的变化不仅反映是否拿到宝箱，还可以反映出闪现的使用情况，buff的使用情况），好的宝箱奖励设计决定了智能体是否是个优秀的迷宫探索者<br>3.在设计宝箱奖励时重点要关注奖励边界变化（重点：收集到宝箱的瞬间一定要考虑周全，pluto佬也提到这点）</p><p>训练设置：常规的八个随机宝箱，收敛时间在16个小时以上</p><p>可以参考的一些指南：<br><a href="https://aiarena.tencent.com/community/d/168-xue-xi-qi-xia-gu-man-bu-kai-fa-zhi-nan-de-zhu-jie-yi-qian-liang-bu-fen">学习期峡谷漫步开发指南的注解（一）（前两部分） - 腾讯开悟社区平台</a><br><a href="https://aiarena.tencent.com/community/d/170-xue-xi-qi-xia-gu-man-bu-kai-fa-zhi-nan-de-zhu-jie-er-hou-liang-bu-fen">学习期峡谷漫步开发指南的注解（二）（后两部分） - 腾讯开悟社区平台</a></p><p>实现：</p><ol><li>首先先实现在没有宝箱的情况下的DQN算法，同时补充完代码</li><li>然后在1的基础上进行优化，让机器人学会找宝箱</li><li>最后优化找宝箱</li></ol><p>实现Step1<br>重新理解一下代码结构：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stylus">📦 根目录<br>├── 📂 agent<br>│   ├── 📂 algorithm<br>│       └── 📄 __init__<span class="hljs-selector-class">.py</span><br>│       └── 📄 algorithm<span class="hljs-selector-class">.py</span><br>│   ├── 📂 conf<br>│       └── 📄 __init__<span class="hljs-selector-class">.py</span><br>│       └── 📄 conf<span class="hljs-selector-class">.py</span><br>│       └── 📄 train_env_conf<span class="hljs-selector-class">.toml</span><br>│   ├── 📂 feature<br>│       └── 📄 __init__<span class="hljs-selector-class">.py</span><br>│       └── 📄 definition<span class="hljs-selector-class">.py</span><br>│       └── 📄 preprocessor<span class="hljs-selector-class">.py</span><br>│   ├── 📂 model<br>│       └── 📄 __init__<span class="hljs-selector-class">.py</span><br>│       └── 📄 model<span class="hljs-selector-class">.py</span><br>│   ├── 📂 workflow<br>│       └── 📄 __init__<span class="hljs-selector-class">.py</span><br>│       └── 📄 train_workflow<span class="hljs-selector-class">.py</span><br>│   ├── 📄 __init__<span class="hljs-selector-class">.py</span><br>│   └── 📄 agent<span class="hljs-selector-class">.py</span><br>├── 📂 conf<br>│   ├── 📄 __init__<span class="hljs-selector-class">.py</span><br>│   ├── 📄 configure_app<span class="hljs-selector-class">.toml</span><br>├── 📂 log<br>└── 📄 train_test.py<br></code></pre></td></tr></table></figure><p><strong>algorithm</strong>主要是agent的实现，包含训练和预训练。<br>官方解释：<a href="https://doc.aiarena.tencent.com/competition/gorgewalk_v2/1.0.0/guidebook/taa-rl-fw/rl_agent/algorithm/">算法开发 - 腾讯开悟</a><br>其中learn方法是实现强化学习优化算法的核心方法。函数的输入是训练样本数据，我们要基于不同的算法完成相关实现，包括优化方法、损失计算等。</p><p><strong>feature</strong> 特征相关，主要包含用户自定义的数据结构和数据处理方法，以及特征和奖励的计算，详情见实现特征处理和样本处理<br><a href="https://doc.aiarena.tencent.com/competition/gorgewalk_v2/1.0.0/guidebook/taa-rl-fw/rl_agent/feature/">特征处理 - 腾讯开悟</a><br><strong>model</strong>模型相关，由于峡谷漫步的4个算法都未使用到神经网络模型，故文件夹为空<br><strong>config.py</strong>该算法下的配置，用户可以任意增加配置或修改配置，但注意：SAMPLE_DIM是开悟框架使用配置，不允许删除</p><p><strong>train_workflow.py</strong>（强化学习的训练流程，详情见强化学习训练流程开发）<br><a href="https://doc.aiarena.tencent.com/competition/gorgewalk_v2/1.0.0/guidebook/taa-rl-fw/rl_agent/workflow/">工作流开发 - 腾讯开悟</a><br>可能这里可以设置其他笔记里提到的分阶段开发？</p><p>conf：配置文件，感觉还是有点不知道怎么修改配置<br>train_test.py 测试代码正确性，保证先通过这里再去提交模型</p><p>开发流程：<br>part1：环境<br>环境接受到智能体的行动，然后给出反馈<br>part2：智能体<br>智能体接受到新的环境信息，通过神经网络或者计算做出决策，把动作给到环境<br>part3：样本池和算法<br>每次的环境信息变化和智能体行动都会被打包成帧数据，存储起来，一局游戏是一个样本，组成样本池后供应给算法来计算奖励，修正智能体的行为</p><p>（至于多久修正一次智能体，一次用多少样本，一个样本用多少次这是基础设置负责的（也就是<strong>conf</strong>）；怎么修正，修正多大程度是由算法决定的）</p><p>首先我在model里实现一个model类，也就是实现神经网络。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-comment"># Copyright © 1998 - 2025 Tencent. All Rights Reserved.</span><br><span class="hljs-comment">###########################################################################</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Author: Tencent AI Arena Authors</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> kaiwu_agent.utils.common_func <span class="hljs-keyword">import</span> attached<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MLPBlock</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_dim, hidden_dims, output_dim</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        layers = []<br>        last_dim = input_dim<br>        <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> hidden_dims:<br>            layers.append(nn.Linear(last_dim, h))<br>            layers.append(nn.ReLU())<br>            last_dim = h<br>        layers.append(nn.Linear(last_dim, output_dim))<br>        <span class="hljs-variable language_">self</span>.model = nn.Sequential(*layers)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.model(x)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, image_shape=(<span class="hljs-params"><span class="hljs-number">6</span>, <span class="hljs-number">51</span>, <span class="hljs-number">51</span></span>), flat_dim=<span class="hljs-number">64</span>, action_shape=<span class="hljs-number">8</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        c, h, w = image_shape<br><br>        <span class="hljs-comment"># 卷积层部分（提取地图图像特征）</span><br>        <span class="hljs-variable language_">self</span>.conv = nn.Sequential(<br>            nn.Conv2d(c, <span class="hljs-number">32</span>, kernel_size=<span class="hljs-number">5</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">2</span>),  <span class="hljs-comment"># -&gt; [32, 26, 26]</span><br>            nn.BatchNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br><br>            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>),  <span class="hljs-comment"># -&gt; [64, 13, 13]</span><br>            nn.BatchNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br><br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>),  <span class="hljs-comment"># -&gt; [64, 7, 7]</span><br>            nn.ReLU()<br>        )<br><br>        conv_out_dim = <span class="hljs-number">64</span> * <span class="hljs-number">7</span> * <span class="hljs-number">7</span><br><br>        <span class="hljs-comment"># 全连接部分（融合 conv + 其他一维特征）</span><br>        <span class="hljs-variable language_">self</span>.q_net = nn.Sequential(<br>            nn.Linear(conv_out_dim + flat_dim, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">256</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">256</span>, action_shape)<br>        )<br><br>        <span class="hljs-variable language_">self</span>.target_q_net = nn.Sequential(<br>            nn.Linear(conv_out_dim + flat_dim, <span class="hljs-number">512</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">256</span>),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">256</span>, action_shape)<br>        )<br><br>        <span class="hljs-variable language_">self</span>.update_target()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, image, flat_feature</span>):<br>        batch = image.shape[<span class="hljs-number">0</span>]<br>        conv_feat = <span class="hljs-variable language_">self</span>.conv(image).view(batch, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># 展平</span><br>        x = torch.cat([conv_feat, flat_feature], dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 拼接上其他特征</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.q_net(x)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>(<span class="hljs-params">self, image, flat_feature</span>):<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            batch = image.shape[<span class="hljs-number">0</span>]<br>            conv_feat = <span class="hljs-variable language_">self</span>.conv(image).view(batch, -<span class="hljs-number">1</span>)<br>            x = torch.cat([conv_feat, flat_feature], dim=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.target_q_net(x)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_target</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.target_q_net.load_state_dict(<span class="hljs-variable language_">self</span>.q_net.state_dict())<br><br></code></pre></td></tr></table></figure><p>然后实现agent.py<br>基础Agent类的五个接口，按照具体代码示例的顺序，我做个逻辑的简单解释。</p><ol><li>learn：挨个提取各个值之后计算 Q 值的更新量 delta，使用学习率和更新量来改变对应Q值表的对应值（二重索引）</li><li>predict：就是存了一下状态，然后用一个函数处理，引入一个随机概率，最后返回行动的列表。</li><li>exploit：依然存一下状态，直接处理，然后返回行动列表。</li><li>save_model：定义一个路径，保存self的Q函数，日志记录一下保存成功。</li><li>load_model：定义个路径，加载模型，存个日志，没加载成功就存个日志并退出整个程序。</li></ol><h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><p>参考了精华帖中提到的一些优化，先看看能不能写出一版新的。<br><a href="https://aiarena.tencent.com/community/d/542-jing-hua-tie-hai-xuan-jie-duan-xing-zong-jie">【精华贴】海选阶段性总结 - 腾讯开悟社区平台</a><br>首先修改model.py，修改其中的神经网络，根据精华帖中提到的，加入maxpool，batchnorm，残差连接等使得训练更稳定</p><h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><p>典型修改流程</p><ol><li><p>先修正配置文件：<br>修改 conf.py，保证奖励权重字典正确。<br>调试环境数据入口</p></li><li><p>修改&#x2F;调试 feature_process.py、agent.py，保证观测数据结构和内容正确。<br>调试reward_process</p></li><li><p>修改 reward_process.py，加日志、异常处理，保证 reward_sum 正确计算。<br>检查reward传递链路</p></li><li><p>修改 algorithm.py、learner.py，保证 reward 字段被正确采样、传递到训练流程、上报监控。<br>监控代码检查</p></li><li><p>修改 monitor_proxy_process.py、prometheus_utils.py，保证 reward 字段正确上报。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>ai</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF_learning</title>
    <link href="/2025/07/11/CTF-learning/"/>
    <url>/2025/07/11/CTF-learning/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ctf-wiki.org/introduction/resources/">学习资源 - CTF Wiki</a><br><a href="https://www.ctfhub.com/#/skilltree">CTFHub</a></p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li>一般情况下flag拥有固定格式为<code>flag&#123;xxxxx&#125;</code>，有些比赛会把flag关键词替换，例如我们CTFHub平台的flag为<code>ctfhub&#123;xxxxx&#125;</code>，利用固定格式来反推flag也是一种常见的解题思路</li></ul><h2 id="竞赛模式："><a href="#竞赛模式：" class="headerlink" title="竞赛模式："></a>竞赛模式：</h2><p><a href="https://writeup.ctfhub.com/Skill/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/mmJYyc569kAXHvfam4qont.html">竞赛模式 | CTFHub</a></p><h3 id="Jeopardy-解题"><a href="#Jeopardy-解题" class="headerlink" title="Jeopardy-解题"></a>Jeopardy-解题</h3><p>题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击以及 Misc 安全杂项 这五个类别，个别比赛会根据题目类型进行扩展。</p><h1 id="Have-a-try"><a href="#Have-a-try" class="headerlink" title="Have a try"></a>Have a try</h1><p>CTFHub|HTTP协议<br><img src="/img/file-20250711210848823.png"><br><strong>HTTP 请求方法是什么？</strong><br>HTTP 协议中定义了常见的请求方法，比如：</p><ul><li><p><code>GET</code>（获取数据）</p></li><li><p><code>POST</code>（提交数据） </p></li><li><p><code>PUT</code>（上传文件）    </p></li><li><p><code>DELETE</code>（删除资源）   </p></li><li><p>等等（如题目中提到的 <code>OPTIONS</code>、<code>HEAD</code>、<code>TRACE</code>、<code>CONNECT</code>）。<br>但题目要求你用的方法<strong>不在这些标准方法里</strong>，比如可能是 <code>CTFHUB</code>、<code>FLAG</code> 这种自定义方法。</p></li><li><p>方法1：用curl工具（命令行工具）</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">curl -X <span class="hljs-built_in">CTFHUB</span> http:<span class="hljs-comment">//题目网址/</span><br></code></pre></td></tr></table></figure><p><code>-X</code> 参数可以指定任意 HTTP 方法（如 <code>CTFHUB</code>）。<br>其中，<code>-v</code>参数用于输出通信的整个过程，包括端口连接和 HTTP request 头信息，让我们可以清晰地看到请求的详细情况。-X参数用于指定 HTTP 请求的方法。在本题中，我们需要将请求方法指定为 “CTFHUB”。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">curl -v -<span class="hljs-keyword">X</span> CTFHUB http://challenge-<span class="hljs-number">4</span>c532e941e569c86.<span class="hljs-keyword">sandbox</span>.ctfhub.<span class="hljs-keyword">com</span>:<span class="hljs-number">10800</span>/<span class="hljs-built_in">index</span>.php<br></code></pre></td></tr></table></figure><ul><li>方法2：burp抓包</li></ul><h2 id="HTTP临时重定向"><a href="#HTTP临时重定向" class="headerlink" title="HTTP临时重定向"></a>HTTP临时重定向</h2><p>HTTP 临时重定向（状态码 302 Found）是HTTP协议中一种常见的重定向方式，它告诉客户端请求的资源暂时<strong>位于另一个URI下</strong>，客户端应当<strong>使用GET方法向这个新URI发起请求</strong>。</p><p>工作原理</p><ol><li>客户端向服务器发送请求</li><li>服务器返回302状态码和Location头部</li><li>客户端自动向Location指定的新地址发起GET请求</li></ol><p>解题步骤：</p><ol><li>识别重定向<ul><li>使用浏览器开发者工具查看网络请求</li><li>使用curl -v URL 查看详细请求&#x2F;相应</li><li>注意响应中的302 Found状态码和Location头部</li></ul></li><li>绕过重定向限制</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">curl -L <span class="hljs-built_in">URL</span>  <span class="hljs-comment"># 自动跟随重定向</span><br>curl -i <span class="hljs-built_in">URL</span>  <span class="hljs-comment"># 显示原始响应(不跟随重定向)</span><br></code></pre></td></tr></table></figure><ol start="3"><li>分析重定向逻辑：<ul><li>检查重定向是否有规律</li><li>查看是否有重定向循环</li><li>检查cookie或session对重定向的影响</li></ul></li></ol><p><img src="/img/file-20250711211831850.png"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">curl -v http://challenge-bc8c3e1ba08f24e1.<span class="hljs-keyword">sandbox</span>.ctfhub.<span class="hljs-keyword">com</span>:<span class="hljs-number">10800</span>/<span class="hljs-built_in">index</span>.php<br></code></pre></td></tr></table></figure><h2 id="Cookie欺骗、认证、伪造"><a href="#Cookie欺骗、认证、伪造" class="headerlink" title="Cookie欺骗、认证、伪造"></a>Cookie欺骗、认证、伪造</h2><ol><li>Cookie基础分析<br>先试用curl或浏览器查看cookie设置</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">curl <span class="hljs-punctuation">-</span>v http<span class="hljs-punctuation">:</span><span class="hljs-comment">//target.com/login</span><br></code></pre></td></tr></table></figure><p>常见Cookie安全属性：</p><ul><li><code>HttpOnly</code> - 阻止JavaScript访问</li><li><code>Secure</code> - 仅HTTPS传输</li><li><code>SameSite</code> - 限制跨站请求</li><li><code>Expires/Max-Age</code> - 控制有效期</li></ul><ol start="2"><li>Cookie欺骗攻击<br>方法1：直接修改Cookie值</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">curl</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;user=admin&quot;</span> http:<span class="hljs-comment">//target.com/dashboard</span><br></code></pre></td></tr></table></figure><p>方法2：布尔型cookie欺骗</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment"># 尝试各种布尔值变体</span><br><span class="hljs-symbol">curl</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;admin=true&quot;</span> http:<span class="hljs-comment">//target.com/admin</span><br><span class="hljs-symbol">curl</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;admin=1&quot;</span> http:<span class="hljs-comment">//target.com/admin</span><br><span class="hljs-symbol">curl</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;admin=on&quot;</span> http:<span class="hljs-comment">//target.com/admin</span><br></code></pre></td></tr></table></figure><p>方法3：数字型Cookie递增</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &#123;0..9&#125;; <span class="hljs-keyword">do</span><br>  curl -b <span class="hljs-string">&quot;role=<span class="hljs-variable">$i</span>&quot;</span> http://target.com/admin | grep flag<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><ol start="3"><li>cookie认证绕过<br>方法1：删除Cookie测试</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> -v http://target.com/admin<br><span class="hljs-comment"># 不发送任何Cookie看响应</span><br></code></pre></td></tr></table></figure><p>方法2：空值Cookie测试</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">curl</span> -<span class="hljs-keyword">b</span> <span class="hljs-string">&quot;session=&quot;</span> http:<span class="hljs-comment">//target.com/admin</span><br></code></pre></td></tr></table></figure><p>方法3：常见Cookie名称爆破</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> cookie <span class="hljs-keyword">in</span> session token auth userid; <span class="hljs-keyword">do</span><br>  curl -b <span class="hljs-string">&quot;<span class="hljs-variable">$cookie</span>=admin&quot;</span> http://target.com/admin<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><ol start="4"><li>Cookie 伪造攻击<br>方法1：JWT令牌攻击</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">#解码JWT<br>echo <span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.xxxx&quot;</span> | <span class="hljs-type">jq</span> -R &#x27;<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;.&quot;</span>) | <span class="hljs-type">.[0</span>],.[<span class="hljs-number">1</span>] | <span class="hljs-type">@base64d</span>&#x27;<br></code></pre></td></tr></table></figure><p>方法2：Flask session伪造</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> URLSafeTimedSerializer<br>secret_key = <span class="hljs-string">&#x27;guessme&#x27;</span>  <span class="hljs-comment"># 尝试常见密钥</span><br>serializer = URLSafeTimedSerializer(secret_key)<br><span class="hljs-built_in">print</span>(serializer.dumps(&#123;<span class="hljs-string">&#x27;user&#x27;</span>:<span class="hljs-string">&#x27;admin&#x27;</span>&#125;))<br></code></pre></td></tr></table></figure><p>方法3：查看cookie编码方式</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Base64解码示例</span><br>echo <span class="hljs-string">&quot;dXNlcj1ndWVzdA==&quot;</span> | base64 -d<br><span class="hljs-comment"># URL解码示例</span><br>echo <span class="hljs-string">&quot;%7B<span class="hljs-variable">%2</span>2user<span class="hljs-variable">%2</span>2%3A<span class="hljs-variable">%2</span>2test<span class="hljs-variable">%2</span>2<span class="hljs-variable">%7D</span>&quot;</span> | python -c <span class="hljs-string">&quot;import sys, urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/file-20250711212530125.png"><br>先尝试了cookie欺骗：<br><img src="/img/file-20250711212557235.png"><br>发现布尔型欺骗可以得到flag</p><h2 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h2><p>在<a href="https://zh.wikipedia.org/wiki/HTTP" title="HTTP">HTTP</a>中，<strong>基本认证</strong>（英语：Basic access authentication）是允许<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E4%BB%A3%E7%90%86" title="用户代理">http用户代理</a>（如：<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88%E5%99%A8" title="网页浏览器">网页浏览器</a>）在请求时，提供 <a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E5%90%8D" title="用户名">用户名</a> 和 <a href="https://zh.wikipedia.org/wiki/%E5%8F%A3%E4%BB%A4" title="密码">密码</a> 的一种方式。</p><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><ol><li>客户端访问受保护资源</li><li>服务器返回401 Unauthorized，包含<code>WWW-Authenticate: Basic</code>头</li><li>客户端弹出登录框，用户输入凭据</li><li>浏览器将用户名密码用Base64编码后发送<code>Authorization: Basic &lt;credentials&gt;</code></li><li>服务器验证通过后返回资源</li></ol><h3 id="识别基本认证"><a href="#识别基本认证" class="headerlink" title="识别基本认证"></a>识别基本认证</h3><p>使用curl检测</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">curl</span> -v http://target.com/protected<br><span class="hljs-comment"># 会返回401和WWW-Authenticate头</span><br></code></pre></td></tr></table></figure><p>响应特征</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">401</span> Unauthorized<br><span class="hljs-attribute">WWW-Authenticate</span><span class="hljs-punctuation">: </span>Basic realm=&quot;Restricted Area&quot;<br></code></pre></td></tr></table></figure><p>常见的攻击方法：</p><p>方法1：暴力破解</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 使用hydra暴力破解</span><br>hydra -L users.txt -P passwords.txt target.com http-<span class="hljs-keyword">get</span> /<span class="hljs-keyword">protected</span><br></code></pre></td></tr></table></figure><p>方法2：Base64解码&#x2F;编码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解码发现的凭证</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;dXNlcm5hbWU6cGFzc3dvcmQ=&quot;</span> | <span class="hljs-built_in">base64</span> -d<br><br><span class="hljs-comment"># 编码自定义凭证</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;admin:secret&quot;</span> | <span class="hljs-built_in">base64</span><br></code></pre></td></tr></table></figure><p>方法3：直接发送认证头</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 使用已知凭据</span><br>curl <span class="hljs-punctuation">-</span>H <span class="hljs-string">&quot;Authorization: Basic YWRtaW46c2VjcmV0&quot;</span> http<span class="hljs-punctuation">:</span><span class="hljs-comment">//target.com/protected</span><br><br><span class="hljs-meta"># 或使用curl的-u参数</span><br>curl <span class="hljs-punctuation">-</span>u admin<span class="hljs-punctuation">:</span>secret http<span class="hljs-punctuation">:</span><span class="hljs-comment">//target.com/protected</span><br></code></pre></td></tr></table></figure><p>通过暴力破解后找到答案</p><p><img src="/img/image-20250711215126386.png" alt="image-20250711215126386"></p><h2 id="查看phpinfo"><a href="#查看phpinfo" class="headerlink" title="查看phpinfo"></a>查看phpinfo</h2><p><img src="/img/file-20250712153206167.png"><br>解题方法，点击查看之后搜索页面中的 <code>ctfhub&#123;</code> 即可找到。</p>]]></content>
    
    
    <categories>
      
      <category>Plans</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Plans</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS-Lab9-Update</title>
    <link href="/2025/06/18/OS-lab9-update/"/>
    <url>/2025/06/18/OS-lab9-update/</url>
    
    <content type="html"><![CDATA[<h1 id="Project1-malloc-free的实现"><a href="#Project1-malloc-free的实现" class="headerlink" title="Project1 malloc&#x2F;free的实现"></a>Project1 malloc&#x2F;free的实现</h1><p>方案二：参考实现</p><ul><li>参考、复现、测试并详细分析以下实现思路和代码（<strong>70分</strong>）。</li><li>加分项（<strong>30分</strong>）：下面的代码没有做线程&#x2F;进程同步和互斥处理，因此是线程不安全的。同学们可以加入进行同步互斥的代码，以保证动态内存分配时的线程安全。</li></ul><p>动态内存分配机制包含内存分配和内存释放</p><p>lab7以“页”为粒度来进行动态内存分配<br>现在我们希望通过malloc&#x2F;free来实现以字节为粒度进行动态内存分配</p><p>一个任意长度的内存分配单元是不好管理的。所以虽然我们实现以字节为粒度的动态分配，但我们分配的内存单元是固定的，是一些固定长度（$2^N$ ）<br>要分配大小为size个字节的内存时，找到合适的N：<br>-$2^{N−1}&lt;size≤2^N$<br>也就是<strong>从小到大搜索</strong>，找到第一个恰好不小于size的arena。找到这样一个arena后，我们便<strong>返回</strong>arena的<strong>起始地址</strong>作为分配的结果<br>如果没有arena能包含size个字节时，我们分配连续的M个页，同样返回起始地址：</p><ul><li>$(M−1)×4096&lt;size≤M×4096$</li></ul><p>首先需要定义arena的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ArenaType</span></span><br><span class="hljs-class">&#123;</span><br>    ARENA_16,<br>    ARENA_32,<br>    ARENA_64,<br>    ARENA_128,<br>    ARENA_256,<br>    ARENA_512,<br>    ARENA_1024,<br>    ARENA_MORE<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于我们是基于页内存分配来分配出arena，因此我们要做的事将arena划分为一个个arena。<br>为了方便管理，<strong>同一个页</strong>中划分出来的arena的大小相同。然后在页的开头保存一些元信息，其中包含可分配的arena的数量和大小（或者说arena的类型）等。<br>![[file-20250611145140978.png]]</p><p>留出保存元信息的空间大小，剩下的才是可以划分的区域：</p><ul><li>$4096-sizeof(Arena)$<br>然后进行划分，并返回第一个arena的起始地址，剩余的arena被放入一个双向链表中，作为空闲的arena。</li><li>这个链表可以放置到每一个空闲的arena中，就无需开辟新空间了。<br>![[file-20250611145452529.png]]<br>空闲的arena链表：<br>![[file-20250611145507111.png]]<br>然后每一种arena都会有一条这样子的链表：<br>![[file-20250611145528760.png]]</li></ul><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>先定义arena.h文件，存放相关数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ARENA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARENA_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ArenaType</span></span><br><span class="hljs-class">&#123;</span><br>    ARENA_16,<br>    ARENA_32,<br>    ARENA_64,<br>    ARENA_128,<br>    ARENA_256,<br>    ARENA_512,<br>    ARENA_1024,<br>    ARENA_MORE<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Arena</span></span><br><span class="hljs-class">&#123;</span><br>    ArenaType type; <span class="hljs-comment">// Arena的类型</span><br>    <span class="hljs-type">int</span> counter;  <span class="hljs-comment">// 如果是ARENA_MORE，则counter表明页的数量，</span><br>                    <span class="hljs-comment">// 否则counter表明该页中的可分配arena的数量</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在list.h中添加空闲链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryBlockListItem</span></span><br><span class="hljs-class">&#123;</span><br>    MemoryBlockListItem *previous, *next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>将字节分配管理器放在memory.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// MemoryManager是在内核态调用的内存管理对象</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteMemoryManager</span></span><br><span class="hljs-class">&#123;</span><br><br>private:<br>    <span class="hljs-comment">// 16, 32, 64, 128, 256, 512, 1024</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MEM_BLOCK_TYPES = <span class="hljs-number">7</span>;       <span class="hljs-comment">// 内存块的类型数目</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> minSize = <span class="hljs-number">16</span>;              <span class="hljs-comment">// 内存块的最小大小</span><br>    <span class="hljs-type">int</span> arenaSize[MEM_BLOCK_TYPES];             <span class="hljs-comment">// 每种类型对应的内存块大小</span><br>    MemoryBlockListItem *arenas[MEM_BLOCK_TYPES]; <span class="hljs-comment">// 每种类型的arena内存块的指针</span><br><br>public:<br>    ByteMemoryManager();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> *<span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;  <span class="hljs-comment">// 分配一块地址</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">void</span> *address)</span>; <span class="hljs-comment">// 释放一块地址</span><br><br>private:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">getNewArena</span><span class="hljs-params">(AddressPoolType type, <span class="hljs-type">int</span> index)</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在memory.cpp中定义ByteMemoryManager的相关方法</p><p>运行结果：<br>![[file-20250611175039508.png]]<br>发现只有用户线程中是正确的按照字节来分配，但是内核空间的分配依然是按页的。需要查找一下问题。<br>经过检查发现，是忘记在<code>extern &quot;C&quot; void setup_kernel()</code> 里添加   <code>kernelByteMemoryManager.initialize();</code>初始化！</p><p>修正过后：<br>![[1749866458182.png]]<br>然后让我们修改一下测试程序，尝试一下其他的分配块<br>![[file-20250614100303932.png]]</p><p>这里由于分配的是不同的arena，所以都是从x00开始分配。<br>![[file-20250614100821832.png]]</p><p>![[file-20250614101544750.png]]我们再测试一下对同一种arena来分配：<br>![[file-20250614102217285.png]]<br>测试结果如下：<br>![[img&#x2F;file-20250614102235104.png]]</p><p>结果是符合的。</p><h2 id="实现同步互斥"><a href="#实现同步互斥" class="headerlink" title="实现同步互斥"></a>实现同步互斥</h2><p>加入进行同步互斥的代码，以保证动态内存分配时的线程安全。</p><ul><li>通过信号量来实现。</li></ul><p>同步互斥未实现时出现的问题：<br>当我们调用malloc()为线程分配动态内存时，需要从空闲链表中获取一个arena，此时系统会执行：</p><ol><li>找到一页新内存页，将其划分为多个arena</li><li>选取第一个arena分配给房钱的线程</li><li>空闲链表还没更新完，而线程被中断，调度器切换到另一个线程</li><li>新线程也调用malloc()，空闲链表未更新，系统认为没有空闲arena，又重新走了一遍分配流程，又返回了同一个arena地址。</li><li>两个线程拿到同一块地址，出现问题。</li></ol><p>此时发生的问题就是两个线程同时访问临界区（空闲链表作为共享资源，多个线程在访问），内存的分配非原子操作。</p><p>我们可以通过设置信号量来实现，在分配arena之前P一下，然后在分配完成之后再V一下，保证同一时间只有一个线程访问或修改空闲链表。</p><p>未开启信号量测试：<br>代码：</p><ul><li>同时我们在过程中添加时间延迟来创造线程切换的可能。<br>![[file-20250618145119390.png]]<br>从图中可以看到，我们关闭信号量时，两个不同的arena分配到了同一块地方！</li></ul><p>开启信号量来测试：<br>![[file-20250618144951538.png]]<br>可以看见这两个线程都正确地获取了arena。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab9</title>
    <link href="/2025/06/11/OS-lab9/"/>
    <url>/2025/06/11/OS-lab9/</url>
    
    <content type="html"><![CDATA[<h1 id="Project1-malloc-free的实现"><a href="#Project1-malloc-free的实现" class="headerlink" title="Project1 malloc&#x2F;free的实现"></a>Project1 malloc&#x2F;free的实现</h1><p>方案二：参考实现</p><ul><li>参考、复现、测试并详细分析以下实现思路和代码（<strong>70分</strong>）。</li><li>加分项（<strong>30分</strong>）：下面的代码没有做线程&#x2F;进程同步和互斥处理，因此是线程不安全的。同学们可以加入进行同步互斥的代码，以保证动态内存分配时的线程安全。</li></ul><p>动态内存分配机制包含内存分配和内存释放</p><p>lab7以“页”为粒度来进行动态内存分配<br>现在我们希望通过malloc&#x2F;free来实现以字节为粒度进行动态内存分配</p><p>一个任意长度的内存分配单元是不好管理的。所以虽然我们实现以字节为粒度的动态分配，但我们分配的内存单元是固定的，是一些固定长度（$2^N$ ）<br>要分配大小为size个字节的内存时，找到合适的N：</p><ul><li>$2^{N−1}&lt;size≤2^N$<br>也就是<strong>从小到大搜索</strong>，找到第一个恰好不小于size的arena。找到这样一个arena后，我们便<strong>返回</strong>arena的<strong>起始地址</strong>作为分配的结果<br>如果没有arena能包含size个字节时，我们分配连续的M个页，同样返回起始地址：</li><li>$(M−1)×4096&lt;size≤M×4096$</li></ul><p>首先需要定义arena的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ArenaType</span></span><br><span class="hljs-class">&#123;</span><br>    ARENA_16,<br>    ARENA_32,<br>    ARENA_64,<br>    ARENA_128,<br>    ARENA_256,<br>    ARENA_512,<br>    ARENA_1024,<br>    ARENA_MORE<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于我们是基于页内存分配来分配出arena，因此我们要做的事将页划分为一个个arena。<br>为了方便管理，<strong>同一个页</strong>中划分出来的arena的大小相同。然后在页的开头保存一些元信息，其中包含可分配的arena的数量和大小（或者说arena的类型）等。<br>![[file-20250611145140978.png]]</p><p>留出保存元信息的空间大小，剩下的才是可以划分的区域：</p><ul><li>$4096-sizeof(Arena)$<br>然后进行划分，并返回第一个arena的起始地址，剩余的arena被放入一个双向链表中，作为空闲的arena。</li><li>这个链表可以放置到每一个空闲的arena中，就无需开辟新空间了。<br>![[file-20250611145452529.png]]<br>空闲的arena链表：<br>![[file-20250611145507111.png]]<br>然后每一种arena都会有一条这样子的链表：<br>![[file-20250611145528760.png]]</li></ul><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>先定义arena.h文件，存放相关数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> ARENA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ARENA_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ArenaType</span></span><br><span class="hljs-class">&#123;</span><br>    ARENA_16,<br>    ARENA_32,<br>    ARENA_64,<br>    ARENA_128,<br>    ARENA_256,<br>    ARENA_512,<br>    ARENA_1024,<br>    ARENA_MORE<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Arena</span></span><br><span class="hljs-class">&#123;</span><br>    ArenaType type; <span class="hljs-comment">// Arena的类型</span><br>    <span class="hljs-type">int</span> counter;  <span class="hljs-comment">// 如果是ARENA_MORE，则counter表明页的数量，</span><br>                    <span class="hljs-comment">// 否则counter表明该页中的可分配arena的数量</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在list.h中添加空闲链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryBlockListItem</span></span><br><span class="hljs-class">&#123;</span><br>    MemoryBlockListItem *previous, *next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>将字节分配管理器放在memory.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// MemoryManager是在内核态调用的内存管理对象</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteMemoryManager</span></span><br><span class="hljs-class">&#123;</span><br><br>private:<br>    <span class="hljs-comment">// 16, 32, 64, 128, 256, 512, 1024</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MEM_BLOCK_TYPES = <span class="hljs-number">7</span>;       <span class="hljs-comment">// 内存块的类型数目</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> minSize = <span class="hljs-number">16</span>;              <span class="hljs-comment">// 内存块的最小大小</span><br>    <span class="hljs-type">int</span> arenaSize[MEM_BLOCK_TYPES];             <span class="hljs-comment">// 每种类型对应的内存块大小</span><br>    MemoryBlockListItem *arenas[MEM_BLOCK_TYPES]; <span class="hljs-comment">// 每种类型的arena内存块的指针</span><br><br>public:<br>    ByteMemoryManager();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> *<span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;  <span class="hljs-comment">// 分配一块地址</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">void</span> *address)</span>; <span class="hljs-comment">// 释放一块地址</span><br><br>private:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">getNewArena</span><span class="hljs-params">(AddressPoolType type, <span class="hljs-type">int</span> index)</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在memory.cpp中定义ByteMemoryManager的相关方法</p><p>运行结果：<br>![[file-20250611175039508.png]]<br>发现只有用户线程中是正确的按照字节来分配，但是内核空间的分配依然是按页的。需要查找一下问题。<br>经过检查发现，是忘记在<code>extern &quot;C&quot; void setup_kernel()</code> 里添加   <code>kernelByteMemoryManager.initialize();</code>初始化！</p><p>修正过后：<br>![[1749866458182.png]]<br>然后让我们修改一下测试程序，尝试一下其他的分配块<br>![[file-20250614100303932.png]]</p><p>这里由于分配的是不同的arena，所以都是从x00开始分配。<br>![[file-20250614100821832.png]]</p><p>![[file-20250614101544750.png]]我们再测试一下对同一种arena来分配：<br>![[file-20250614102217285.png]]<br>测试结果如下：<br>![[img&#x2F;file-20250614102235104.png]]<br>结果是符合的。</p><p>然后我们调用一下free来测试一下是否正确实现。<br>运行结果：<br>![[img&#x2F;file-20250618162455763.png]]<br>从图中可以看到，不管是在内核态还是在用户态，都可以正常释放，p4就会直接占据第一个空闲的arena。</p><h2 id="实现同步互斥"><a href="#实现同步互斥" class="headerlink" title="实现同步互斥"></a>实现同步互斥</h2><p>加入进行同步互斥的代码，以保证动态内存分配时的线程安全。</p><ul><li>通过信号量来实现。</li></ul><p>同步互斥未实现时出现的问题：<br>当我们调用malloc()为线程分配动态内存时，需要从空闲链表中获取一个arena，此时系统会执行：</p><ol><li>找到一页新内存页，将其划分为多个arena</li><li>选取第一个arena分配给房钱的线程</li><li>空闲链表还没更新完，而线程被中断，调度器切换到另一个线程</li><li>新线程也调用malloc()，空闲链表未更新，系统认为没有空闲arena，又重新走了一遍分配流程，又返回了同一个arena地址。</li><li>两个线程拿到同一块地址，出现问题。</li></ol><p>此时发生的问题就是两个线程同时访问临界区（空闲链表作为共享资源，多个线程在访问），内存的分配非原子操作。</p><p>我们可以通过设置信号量来实现，在分配arena之前P一下，然后在分配完成之后再V一下，保证同一时间只有一个线程访问或修改空闲链表。</p><p>未开启信号量测试：<br>代码：</p><ul><li>同时我们在过程中添加时间延迟来创造线程切换的可能。<br><img src="/img/file-20250618145119390.png"><br>从图中可以看到，我们关闭信号量时，两个不同的arena分配到了同一块地方！</li></ul><p>开启信号量来测试：<br><img src="/img/file-20250618144951538.png">可以看见这两个线程都正确地获取了arena。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai-Agent</title>
    <link href="/2025/06/09/ai-agent/"/>
    <url>/2025/06/09/ai-agent/</url>
    
    <content type="html"><![CDATA[<h1 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h1><h2 id="agent的定义："><a href="#agent的定义：" class="headerlink" title="agent的定义："></a>agent的定义：</h2><p>大模型时代的 <u>AI Agent &#x3D; LLM × （规划+记忆+工具）</u></p><p>Al Agent是一种能够感知环境、进行决策和执行动作的智能实体。</p><p>运行过程：接受用户输入 → 推理 + 记忆检索 → 工具调用 → 更新状态 → 再次行动</p><ul><li>接受外部输入:（例如用户查询）</li><li>结合短期和长期记忆进行推理：（例如利用 CoT、ReAct 等推理框架）</li><li>调用外部工具或数据库：（如检索增强生成 RAG、搜索引擎、API 接口等）</li><li>更新状态并决定下一步行动：（例如基于策略调整决策）</li><li>持续执行，直到任务完成或达到终止条件。<br>![[file-20250609163836448.png]]</li></ul><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><ul><li><strong>推理&#x2F;规划方法</strong>：包括 Prompting、CoT（思维链）、ReAct、ToT（思维树）、Reflection 等</li><li><strong>记忆机制</strong>：短期记忆（Working Memory）、长期记忆（Episodic&#x2F;Semantic Memory）等</li><li><strong>工具使用</strong>：RAG、搜索引擎、API（如天气、票价）、计算模块等</li></ul><h3 id="推理-规划"><a href="#推理-规划" class="headerlink" title="推理&#x2F;规划"></a>推理&#x2F;规划</h3><p>推理：从已知知识出发，进行思考分析和推到，得到新的结论或判断</p><p>规划：在特定目标或任务的引导下，设计和选择执行步骤的过程（划分出一些子目标）</p><p>提升推理、规划的方法：提示工程、改进模型or系统结构、改进学习范式</p><p>提示词工程：<br>通过精心设计的 prompt，我们可以引导语言模型进行<strong>分步骤思考</strong>、<strong>自我验证</strong>甚至<strong>反思决策</strong></p><p>CoT：</p><ul><li>逐步采样中间推理步骤<br>![[file-20250609164802513.png]]</li><li>计算最终答案<br>![[file-20250609164812232.png]]<br>CoT方法在提示词输入时，给出CoT的形式输入&lt;输入，思维链，输出&gt;示例</li></ul><p>self-consistency:</p><ul><li>k次思维链采样：<br>![[file-20250609164901767.png]]</li><li>多数投票选择最终答案<br>![[file-20250609164916459.png]]</li></ul><p>ToT：先分步骤，然后每个步骤多个结果，在每一步的多个结果中进行选择后再进行下一步，输出多个结果。（开销更大，效果好）<br>![[file-20250609165102709.png]]</p><p>至此，上面都没有使用到环境的反馈；下面的方法会考虑到环境反馈。</p><p>ReAct：（现在agent系统易出现）</p><p>ReAct执行流程：</p><ul><li>任务理解：首先对任务进行理解，提取关键信息。</li><li>推理阶段：对任务进行推理以生可能的解决方案或路径。</li><li>行动阶段：ReAct框架根据推理的结果采取实际的行动。。</li><li>反馈和调整：一旦采取行动后，系统会根据反馈调整策略。<br>![[file-20250609165250304.png]]</li></ul><p>Reflection：把agent执行流程建模为一个MDP过程<br>一种通过自我反思之前采取的action，获得一些反思后的experience，作为接下来行动的prompt。<br>![[file-20250609165558360.png]]</p><h3 id="记忆机制"><a href="#记忆机制" class="headerlink" title="记忆机制"></a>记忆机制</h3><p>可以建立知识库等。<br>![[file-20250609165731672.png]]</p><h3 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h3><p>openai：function call<br>下面就call了Temperature这个函数<br>![[file-20250609170120491.png]]</p><h2 id="Multi-agent"><a href="#Multi-agent" class="headerlink" title="Multi-agent"></a>Multi-agent</h2><p>![[file-20250609170408061.png]]</p><ul><li><strong>优势</strong>：<ul><li>职责分离、并行协作、可扩展性强   </li><li>可模拟合作&#x2F;竞争&#x2F;辩论关系</li></ul></li><li><strong>通信方式</strong>：<ul><li>合作、辩论、竞争</li></ul></li><li><strong>通信结构</strong>：<ul><li>层级&#x2F;中心化&#x2F;去中心化&#x2F;共享信息池</li></ul></li><li><strong>推荐框架</strong>：<ul><li>LangGraph（支持流程控制、图结构建模）</li><li>AutoGen（对话协作易用）</li><li>CrewAI（任务分配与团队协作</li><li>LlamaIndex（专注RAG与文档问答）</li></ul></li></ul><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>agent所处环境种类：</p><ul><li>sandbox</li><li>真实物理环境</li><li>无环境（无需环境或文本环境）</li></ul><p>agent profile来源：</p><ul><li>预定义（人工生成）</li><li>模型生成</li><li>根据<strong>真实数据集派生</strong>（例如，数据集中存在某一个虚拟人物的详细介绍，直接把这个赋予给agent）</li></ul><p>multi-agent的通信：<br>通信范式：</p><ul><li>合作</li><li>辩论</li><li>竞争</li></ul><p>通信结构：</p><ul><li>层级结构</li><li>去中心化结构</li><li>中心化结构</li><li>共享信息池<br>![[file-20250609170835134.png]]</li></ul><h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><p>![[file-20250609171055819.png]]<br>langAgent：状态机</p><p>AutoGen：开创性的多智能体<strong>对话式</strong>ai应用框架<br>![[file-20250609171501144.png]]<br>![[file-20250609171515308.png]]<br>![[file-20250609171520859.png]]<br>CrewAI：编排角色扮演、自主ai智能体框架<br>![[file-20250609171537987.png]]<br>![[file-20250609171525806.png]]<br>![[file-20250609171636066.png]]</p><p>LangGraph：基于图结构的智能体开发框架<br>![[file-20250609171711424.png]]<br>![[file-20250609171715931.png]]<br>![[file-20250609171729603.png]]</p><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><p>尝试利用开源的框架（推荐LangGraph、可以不造轮子）设计一个多智能体系统，要求：</p><ul><li><p>场景&#x2F;任务不限（任务求解、场景模拟、效率工具等）</p></li><li><p>包含Agent推理&#x2F;规划方法的实现（ToT、ReAct、Reflection 等）</p></li><li><p>设计2种以上记忆机制（长期记忆、短期记忆）</p></li><li><p>使用2种以上的工具（rag检索、搜索引擎、计算工具等）也可自己定义工具。</p></li><li><p>说明1：尽量在已有的框架下去设计这些要素，这样可以避免无用的劳动。</p></li><li><p>说明2：模型api的使用推荐：<br><a href="https://dashscope.console.aliyun.com/billing">https://dashscope.console.aliyun.com/billing</a></p></li></ul><p>多智能体系统中智能体数目&gt;&#x3D;4</p><ul><li>每个智能体的功能有良好定位</li><li>每个智能体应该有适宜的提示词适配自己的任务</li><li>智能体间分工和运行流程合理</li><li>在系统中应至少实现一种智能体的推理&#x2F;规划方法</li><li>在系统中设计智能体的长期记忆和短期记忆</li><li>在系统中至少使用两种类型以上的工具调用</li><li>请至少包含以上工作，成绩按照工作量和任务场景下的实现效果进行评判</li></ul><p>langGraph使用文档：<br><a href="https://langchain-ai.github.io/langgraph/concepts/why-langgraph/">概述</a><br>百炼：<br><a href="https://bailian.console.aliyun.com/?utm_content=se_1021227512#/home">百炼控制台</a></p><h1 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h1><p>ddl 2025 7月6日</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>旅游规划助手：从用户的模糊需求出发，生成详细可行的旅游行程，结合搜索、天气、预算等多方面信息，体现智能体之间的协同和推理能力</p><p>系统架构：</p><table><thead><tr><th>Agent名称</th><th>功能简介</th><th>使用的推理方法</th></tr></thead><tbody><tr><td>UserIntentAgent</td><td>理解用户需求（出发地、偏好、预算等）</td><td>ReAct</td></tr><tr><td>DestinationAgent</td><td>通过 RAG 检索 + 搜索引擎获取推荐目的地及热门景点</td><td>ReAct</td></tr><tr><td>ItineraryAgent</td><td>使用 Tree-of-Thought 规划行程（日程安排、景点组合）</td><td>ToT</td></tr><tr><td>InfoToolAgent</td><td>获取实时天气、票价、交通等外部信息</td><td>ReAct</td></tr><tr><td>BudgetPlannerAgent</td><td>分析成本并优化路线以满足预算（住宿、交通、门票等）</td><td>Reflection</td></tr><tr><td>SummaryAgent</td><td>汇总为旅行计划PDF或markdown文档，供用户保存</td><td>无（简单组合</td></tr></tbody></table><p>工具使用：</p><ul><li>RAG<ul><li>用于景点介绍、用户意图对话历史向量检索。</li></ul></li><li>搜索引擎工具<ul><li>实时获取票价、天气、景点开放时间。</li></ul></li><li>计算工具（LangChain Math工具链）<ul><li>计算预算、路线距离、时间总和等。</li></ul></li><li>自定义工具（天气查询API、自建票价API）</li></ul><p>记忆机制：</p><ul><li>短期记忆<ul><li>存储本轮对话内容、当前用户需求、暂存行程</li><li>用 LangChain 的 <code>ConversationBufferMemory</code> 管理。</li></ul></li><li>长期记忆<ul><li>存储用户历史偏好（城市、预算、交通方式等）</li><li>景点介绍、城市数据使用向量数据库（FAISS + RAG）</li><li>每个Agent访问记忆时有不同的过滤机制</li></ul></li></ul><h1 id="构建基本聊天机器人"><a href="#构建基本聊天机器人" class="headerlink" title="构建基本聊天机器人"></a>构建基本聊天机器人</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> -U langgraph langsmith<br></code></pre></td></tr></table></figure><p>尝试使用提供的与openai兼容的来调用并与大模型进行对话。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab8</title>
    <link href="/2025/05/21/OS-lab8/"/>
    <url>/2025/05/21/OS-lab8/</url>
    
    <content type="html"><![CDATA[<h1 id="从内核态到用户态"><a href="#从内核态到用户态" class="headerlink" title="从内核态到用户态"></a>从内核态到用户态</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>在本章中，我们首先会简单讨论<strong>保护模式下的特权级</strong>的相关内容。<strong>特权级保护</strong>是保护模式的特点之一，通过特权级保护，我们区分了内核态和用户态，从而限制用户态的代码对特权指令的使用或对资源的访问等。但是，用户态的代码有时不得不使用一些特权指令，如输入输出等。因此，我们介绍了<strong>系统调用</strong>的概念和如何通过<strong>中断</strong>来实现系统调用。通过系统调用，我们可以实现从用户态到内核态转移，然后在内核态下执行特权指令等，执行完成后返回到用户态。在实现了系统调用后，我们通过三步来创建了进程。这里，我们需要重点理解我们是如何通过分页机制来实现进程之间的虚拟地址空间的隔离。最后，我们介绍了fork&#x2F;wait&#x2F;exit的一种简洁的实现思路。</p><p>ddl：6月15日</p><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><h3 id="Assignment-1-系统调用"><a href="#Assignment-1-系统调用" class="headerlink" title="Assignment 1 系统调用"></a>Assignment 1 系统调用</h3><p>编写一个系统调用，然后在进程中调用之，根据结果回答以下问题。</p><ul><li>展现系统调用执行结果的正确性，结果截图并说说你的实现思路。</li><li>分析执行系统调用后的栈的变化情况。</li><li>说明TSS在系统调用执行过程中的作用</li></ul><p>实现getpid()：<br>实现思路是通过调用getpid，然后去到PCB中获取当前正在运行的进程，获取对应的pid然后返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//第3个系统调用, getpid</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;system call:getpid\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> asm_system_call(<span class="hljs-number">3</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">syscall_getpid</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 获取当前运行的进程并返回其PID</span><br>    PCB* currentProcess = programManager.running;<br>    <span class="hljs-keyword">if</span> (currentProcess) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;success!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> currentProcess-&gt;pid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 如果没有当前进程，返回错误值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250529215818360.png"><br>从运行结果中可以看到，我们成功地调用了getpid系统调用，然后成功进入到了内核态，并从PCB获取pid返回。</p><p>执行系统调用后的栈的变化情况：<br>设置断点：<br><img src="/img/file-20250529233953273.png"><br><img src="/img/file-20250529221256982.png"><br><img src="/img/file-20250529224841333.png"><br>看到在调用getpid之前，esp保存的是0x8048fd4，这是用户栈的位置；eax等都是0<br><img src="/img/file-20250529224806947.png"><br>ss保存的是0x3b，cs保存的是0x2b，eflags保存的是0x296</p><p>cs&#x3D;0010 1011<br>特权级CPL刨保存在cs的低2位上，也就是二进制：(11)–十进制（3）<br>说明我们现在处在用户态中。</p><p>调用getpid之后，我们会进入到内核态<br>这里esp的位置就是内核栈的位置<br><img src="/img/file-20250529225311662.png"><br>这里的cs&#x3D;0x20，CRL&#x3D;0，说明我们确实在内核态中。<br><img src="/img/file-20250529225250335.png"><br>单步进入，我们可以看到我们的栈往上移动了0x10，仍然处于内核态中。<br><img src="/img/file-20250529225458882.png"></p><p>TSS的功能：<br>目前TSS的作用仅限于为CPU提供<strong>0特权级栈</strong>所在的地址和段选择子（只用到esp0和ss0）<br>CPU从TSS中取出高特权级的段选择子和栈指针，分别送入ss和esp。<br>CPU通过读取TR寄存器中TSS的地址，从而读取到TSS的内容</p><p>设置断点，然后查看tss的内容<br><img src="/img/file-20250529234233693.png"><br><img src="/img/file-20250529234205512.png"><br>变化后：发现esp0的值是内核栈的地址空间。<br>说明tss的作用就是将0特权级的栈取出来送到ss和esp。<br><img src="/img/file-20250529234306427.png"></p><h3 id="Assignment-2-Fork的奥秘"><a href="#Assignment-2-Fork的奥秘" class="headerlink" title="Assignment 2 Fork的奥秘"></a>Assignment 2 Fork的奥秘</h3><p>实现fork函数，并回答以下问题。</p><ul><li>请根据<strong>代码逻辑和执行结果</strong>来分析fork实现的基本思路。</li><li>从子进程第一次被调度执行时开始，逐步跟踪子进程的执行流程一直到子进程从<code>fork</code>返回，根据gdb来分析子进程的<strong>跳转地址</strong>、<strong>数据寄存器</strong>和<strong>段寄存器</strong>的变化。同时，比较上述过程和父进程执行完<code>ProgramManager::fork</code>后的返回过程的异同。</li><li>请根据代码逻辑和gdb来解释fork是如何保证子进程的<code>fork</code>返回值是0，而父进程的<code>fork</code>返回值是子进程的pid。</li></ul><p>需要解决的四个问题：</p><ol><li><p>如何实现父子进程的代码段共享？<br>进程又划分了3GB~4GB的空间来实现内核共享，进程的代码天然就是共享的</p></li><li><p>如何使得父子进程从相同的返回点开始执行？<br>通过保存和恢复 <code>eip</code> 以及复制用户态栈，实现父子进程从同一返回点继续执行。</p></li></ol><p>实现机制：</p><ul><li>父进程暂停与eip保存。<ul><li>在 <code>ProgramStartProcess</code> 中保存了父进程的 <code>eip</code>，该 <code>eip</code> 实际上是 <code>asm_system_call_handler</code> 的返回地址。</li></ul></li><li>子进程eip恢复与跳转<ul><li>创建子进程后，通过 <code>asm_start_process</code> 启动子进程。</li><li><code>asm_start_process</code> 的最后会执行 <code>iret</code> 指令，将0特权级栈中保存的 <code>eip</code> （也就是父进程暂停时的返回地址）装载到子进程的 <code>eip</code> 中。</li><li>这样，子进程会从与父进程相同的返回点（即 <code>asm_system_call_handler</code> 的返回地址）开始执行。</li></ul></li><li>逐步返回与栈复制<ul><li>后续子进程会依次返回到 <code>asm_start_process</code>、<code>asm_system_call</code>，最终回到 <code>fork</code> 的调用点。</li><li>因为会复制父进程的3特权级（用户态）栈到子进程，3特权级栈中保存了父进程在执行 <code>int 0x80</code> 软中断后的逐步返回地址。</li><li>因此，父子进程的逐步返回地址完全一致。</li></ul></li></ul><ol start="3"><li><p>除代码段外，进程包含的资源有哪些？<br>进程包含的资源有0特权级栈，PCB、虚拟地址池、页目录表、页表及其指向的物理页。</p></li><li><p>如何实现进程的资源在进程之间的复制？<br>借助于内核空间的中转页。<br>首先在父进程的虚拟地址空间下将数据复制到中转页中，再切换到子进程的虚拟地址空间中，然后将中转页复制到子进程对应的位置。</p></li></ol><p>（1）fork实现的基本思路<br>见上文&amp;后文<br>（2）使用gdb跟踪逻辑<br>![[file-20250531234900823.png]]</p><p>![[file-20250531235408725.png]]</p><p>![[file-20250531235424121.png]]<br>这里处于用户态CRL&#x3D;3<br>![[file-20250531235504479.png]]<br>准备进入系统调用，这里将会调用进程管理器的fork函数<br>![[file-20250531235612819.png]]<br>![[file-20250531235624684.png]]<br>从地址空间和CRL&#x3D;0，可以看出进入了内核态。</p><p>这里准备进入复制函数<br>![[file-20250531235745309.png]]<br>复制进程中会复制0级栈，同时手动将子进程中的寄存器eax设置为0，同时设置子进程的PCB（大部分复制父进程）<br>复制用户虚拟地址池（与父进程共用）<br>复制父进程页表</p><p>fork返回时，父进程的eax会被设置为子进程的pid<br>iret指令完成了：</p><ul><li>从栈中弹出返回地址，将其放入程序计数器和代码段寄存器</li><li>如果CPU在保护模式下运行，会从栈中弹出EFLAGS的内容，将其恢复到标志寄存器中</li><li>处理优先级切换。</li></ul><p>（3）怎么保证父进程获得子进程pid和子进程返回0<br>内核空间创建子进程结构：</p><ul><li>fork时，内核会为子进程分配一个新的PCB和栈，并把父进程的大部分上下文复制给子进程</li></ul><p>专门设置fork返回值：<br>在内核空间，fork会有专门的代码逻辑，在父进程的返回路径上把eax设置为子进程的pid，在子进程的返回路径上把eax设置为0。让我们看看代码中如何实现这样子的设置：</p><p>我们在copyProcess的时候，有一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">// 设置子进程的返回值为0</span><br>    childpss-&gt;eax = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>而我们知道，在调用完函数，我们要获取返回值的时候，是会去读取eax的值。也就是说，如果我们后续没有修改子进程的eax，最后子进程fork返回的也就会是0。（确实我们后面也没有再去修改了）</p><p>父进程fork返回的pid，就是executeProcess创建的新子进程的pid，在fork返回时直接返回给父进程。然后内核会把这个返回值放到父进程的eax里。<br>![[file-20250601202918743.png]]</p><p>进入fork前：eax为0<br>![[file-20250601203229851.png]]<br>进入了之后，eax被设置为2</p><p>![[file-20250601203501156.png]]<br>![[file-20250601203527506.png]]<br>这里返回了pid，会保存到父进程的eax中，也就是子进程的pid。<br>![[file-20250601203702692.png]]<br>![[file-20250601203817217.png]]<br>可以看到确实返回的是2</p><p>这里我们将会进入到复制进程函数中，这里会设置子进程的eax为0。<br>![[file-20250601204107707.png]]<br>设置eax前：可以看到，由于我们直接复制了父进程的内容，会出现eax也跟着复制的情况。<br>![[file-20250601204607789.png]]<br>执行之后：<br>![[file-20250601204443027.png]]<br>可以看到设置为0了。<br>如图，确实如此。<br>![[file-20250601204008354.png]]</p><h3 id="Assignment-3-哼哈二将-wait-exit"><a href="#Assignment-3-哼哈二将-wait-exit" class="headerlink" title="Assignment 3 哼哈二将 wait &amp; exit"></a>Assignment 3 哼哈二将 wait &amp; exit</h3><p>实现wait函数和exit函数，并回答以下问题。</p><ul><li>请结合代码逻辑和具体的实例来分析exit的执行过程。</li><li>请分析进程退出后能够隐式地调用exit和此时的exit返回值是0的原因。</li><li>请结合代码逻辑和具体的实例来分析wait的执行过程。</li><li>如果一个父进程先于子进程退出，那么子进程在退出之前会被称为孤儿进程。子进程在退出后，从状态被标记为<code>DEAD</code>开始到被回收，子进程会被称为僵尸进程。请分析src&#x2F;6代码实例中，实现回收僵尸进程的有效方法。</li></ul><p>exit的实现原理：<br>结合代码分析：<br>直接看教程<br>结束一个进程只需要释放掉其所占用的物理页内存和占用的虚拟地址池空间，只保留一个PCB并将进程状态设置为0.</p><p>exit的实现实际上是通过<code>ProgramManager::exit</code>来完成的，总的来看，exit的实现主要分为三步。</p><ol><li>标记PCB状态为<code>DEAD</code>并放入返回值。</li><li>如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。否则不做处理。</li><li>立即执行线程&#x2F;进程调度。</li></ol><p>wait的实现原理：</p><p>分析进程退出后能隐式调用exit和此时的exit返回值是0的原因：<br>隐式调用exit：没有显示的调用exit()的时候，操作系统会自动的在返回时调用。</p><p>实现方法是：在进程的3特权级栈的顶部放入exit的地址和参数即可，当执行进程的函数退出后会主动跳转到exit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置进程返回地址</span><br><span class="hljs-type">int</span> *userStack = (<span class="hljs-type">int</span> *)interruptStack-&gt;esp;<br>userStack -= <span class="hljs-number">3</span>;<br>userStack[<span class="hljs-number">0</span>] = (<span class="hljs-type">int</span>)<span class="hljs-built_in">exit</span>;<br>userStack[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>userStack[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这段代码中，我们将3特权级栈中的栈顶处userStack[0]放入exit的地址，然后CPU会认为userStack[1]是exit的返回地址，userStack[2]是exit的参数。</p><p>请结合代码逻辑和具体的实例来分析wait的执行过程：<br>看教程</p><p>如果一个父进程先于子进程退出，那么子进程在退出之前会被称为孤儿进程。子进程在退出后，从状态被标记为<code>DEAD</code>开始到被回收，子进程会被称为僵尸进程。请分析src&#x2F;6代码实例中，实现回收僵尸进程的有效方法。</p><p><strong>生成僵尸进程</strong>：进程exit退出时，进程状态被标记为dead，退出返回值保存在PCB中，物理内存资源被释放，但是PCB本身并未被释放，需要等待父进程回收。</p><ol><li><strong>进程退出时</strong>变成僵尸进程，保留PCB和退出状态</li><li><strong>父进程通过wait()系统调用</strong>主动回收僵尸子进程</li><li><strong>循环等待机制</strong>确保所有子进程都被回收</li><li><strong>资源管理策略</strong>分两阶段：先释放内存，后释放PCB</li></ol><p>wait系统调用主动回收僵尸子进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ProgramManager::wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *retval)</span><br>&#123;<br>    PCB *child;<br>    ListItem *item;<br>    <span class="hljs-type">bool</span> interrupt, flag;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        interrupt = interruptManager.getInterruptStatus();<br>        interruptManager.disableInterrupt();<br><br>        item = this-&gt;allPrograms.head.next;<br><br>        <span class="hljs-comment">// 查找子进程</span><br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (item)<br>        &#123;<br>            child = ListItem2PCB(item, tagInAllList);<br>            <span class="hljs-keyword">if</span> (child-&gt;parentPid == this-&gt;running-&gt;pid)  <span class="hljs-comment">// 找到子进程</span><br>            &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (child-&gt;status == ProgramStatus::DEAD)  <span class="hljs-comment">// 子进程已死亡</span><br>                &#123;<br>                    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 找到僵尸子进程</span><br>                &#125;<br>            &#125;<br>            item = item-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (item) <span class="hljs-comment">// 找到一个可回收的僵尸子进程</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (retval)<br>            &#123;<br>                *retval = child-&gt;retValue;  <span class="hljs-comment">// 获取子进程退出值</span><br>            &#125;<br><br>            <span class="hljs-type">int</span> pid = child-&gt;pid;<br>            releasePCB(child);  <span class="hljs-comment">// 释放子进程PCB，完成回收</span><br>            interruptManager.setInterruptStatus(interrupt);<br>            <span class="hljs-keyword">return</span> pid;  <span class="hljs-comment">// 返回被回收子进程的PID</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">if</span> (flag) <span class="hljs-comment">// 没有子进程了</span><br>            &#123;<br>                interruptManager.setInterruptStatus(interrupt);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 存在子进程，但子进程还没死亡</span><br>            &#123;<br>                interruptManager.setInterruptStatus(interrupt);<br>                schedule();  <span class="hljs-comment">// 让出CPU，等待子进程结束</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验知识"><a href="#实验知识" class="headerlink" title="实验知识"></a>实验知识</h2><h3 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h3><p>CPU的特权级分4个：0,1,2,3。（特权级依次降低）</p><ul><li>本次实验中使用0和3；</li><li>把CPU处在特权级0的状态称为内核态，把CPU处在特权级3的称为用户态</li></ul><p>内核态和用户态的划分是对程序访问资源的限制</p><p>一些概念：</p><ul><li><strong>RPL</strong>，Request Privilege Level，段选择子的低2位所表示的值。</li><li><strong>CPL</strong>，Current Privilege Level，在CS寄存器中的段选择子的RPL，CPL标识了CPU当前的特权级。</li><li><strong>DPL</strong>，Descriptor Privilege Level，位于每一个段描述符中。</li><li><strong>一致性代码段</strong>，简单理解，就是操作系统拿出来被共享的代码段，是<u>可以被低特权级的用户直接调用访问的代码</u>。在访问前后，特权级不会改变，用户态还是用户态，内核态还是内核态。具有这样的特点的代码段被称为一致性代码段。</li><li><strong>非一致代码段</strong>，为了避免低特权级的访问而被操作系统保护起来的系统代码，<u>只允许同级间访问</u>，<u>绝对禁止不同级访问</u>，核心态不用用户态的资源，用户态也不使用核心态的资源。具有这样特点的代码段被称为非一致代码段。</li></ul><p>在访问资源前，CPU会做特权级检查：</p><ul><li>对于数据段和栈段，进行特权级检查，要求 $DPL \geq max{CPL,RPL}$ </li><li>对于代码段：如果是一致性代码段，要求 $CPL \geq DPL$;对于非一致性代码段，要求$CPL \geq RPL$和$CPL &#x3D; DPL$</li></ul><p>从内核态进入用户态或者从用户态进入内核态，就要进行特权级转移：</p><ul><li>从低特权到高特权转移：通过<strong>中断、调用</strong>等方式实现。<ul><li>中断：程序通过使用 <code>int</code> 指令来调用特定中断，然后中断描述符中的代码段选择子被加载到CS寄存器，从而改变CPL</li></ul></li><li>从高特权到低特权转移：通过<strong>中断返回</strong>和<strong>调用返回</strong></li></ul><p>CPU在不同特权级下会使用不同的栈。</p><ul><li>当CPU使用中断从低特权级向高特权级转移的时候，CPU首先会从<strong>TSS</strong>（Task State Segment）中<strong>取出高特权级的段选择子和栈指针</strong>（即下图的esp0），然后将高特权级栈的段选择子和栈指针送入<strong>SS，ESP</strong>，最后将<strong>中断发生前</strong>的SS，ESP，EFLAGS、CS、EIP依次<strong>压入</strong>高特权级栈。</li></ul><p><img src="/img/file-20250521163432894.png"></p><ul><li>TSS只会保存特权级0,1,2的段选择子和栈指针（3是最低的）</li><li>多任务切换机制下，TSS可以用于暂存任务的状态（但是目前不使用这个机制）</li><li>目前TSS的作用仅限于为CPU提供0特权级栈所在的地址和段选择子（只用到esp0和ss0）</li></ul><p>CPU进制高特权级向低特权级转移，除了中断返回或调用返回。<code>iret</code>和<code>retf</code>。</p><p>低特权级栈的信息在进入中断前被保存在高特权级栈中，因此执行<code>iret</code>后，低特权级栈的SS和ESP变可以被恢复。</p><h3 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h3><p>用户态有时候需要使用到I&#x2F;O指令等，所以这个时候我们需要跳转到内核态去。</p><p>通过中断实现系统调用：</p><ul><li>系统调用时，系统调用的参数通过5个寄存器来传递。（因此参数不能超过5个）<br>asm_system_call通过汇编实现：</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_system_call:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><span class="hljs-comment">;保护现场</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">fs</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">gs</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">2</span> * <span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">6</span> * <span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">7</span> * <span class="hljs-number">4</span>]<br><span class="hljs-comment">;调用0x80中断，会根据保存在eax的系统调用号来调用不同的函数</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">0x80</span><br><span class="hljs-comment">;恢复现场</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">gs</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">fs</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>创建一个管理系统调用的类 <code>SystemService</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SYSCALL_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYSCALL_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;os_constant.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemService</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    SystemService();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 设置系统调用，index=系统调用号，function=处理第index个系统调用函数的地址</span><br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">setSystemCall</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> function)</span>;<br>&#125;;<br><br><span class="hljs-comment">// 第0个系统调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">syscall_0</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second, <span class="hljs-type">int</span> third, <span class="hljs-type">int</span> forth, <span class="hljs-type">int</span> fifth)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>第0个系统调用：打印输入的五个参数，最后返回这五个参数的和。</p><p>中断处理函数：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_system_call_handler:</span><br><span class="hljs-comment">;保护现场</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">fs</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">gs</span><br>    <span class="hljs-keyword">pushad</span><br><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br><br>    <span class="hljs-comment">; 栈段会从tss中自动加载</span><br><span class="hljs-comment">;手动修改ds，ed，fs，gs寄存器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, DATA_SELECTOR<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">eax</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, VIDEO_SELECTOR<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">eax</span><br><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br><br>    <span class="hljs-comment">; 参数压栈</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-comment">;开中断。调用系统处理的函数</span><br>    <span class="hljs-keyword">sti</span>    <br>    <span class="hljs-keyword">call</span> <span class="hljs-built_in">dword</span>[system_call_table + <span class="hljs-built_in">eax</span> * <span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">cli</span><br><span class="hljs-comment">;将压入栈的五个参数弹出栈</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">5</span> * <span class="hljs-number">4</span><br>    <span class="hljs-comment">;将eax保存在变量ASM_TEMP中</span><br>    <span class="hljs-keyword">mov</span> [ASM_TEMP], <span class="hljs-built_in">eax</span><br>    <span class="hljs-comment">;恢复现场</span><br>    <span class="hljs-keyword">popad</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">gs</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">fs</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [ASM_TEMP]<br>    <br>    <span class="hljs-keyword">iret</span><br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="/img/file-20250521171218899.png"></p><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>用户进程和内核线程最大的区别在于用户进程有自己的虚拟地址空间，而内核线程使用的是内核虚拟地址空间</p><p>用户进程虚拟地址不会和内核冲突是由于映射保存在了每个进程自己的页目录&#x2F;页表中，是独立的。</p><p>用户进程如果要访问内核资源，可以通过<strong>高地址映射</strong>的方法实现：</p><ul><li>现有问题：<ul><li>某些情况下，用户需要进入内核中执行，如系统调用等。</li><li>但是进程自己的虚拟地址并不包含内核内容</li><li>内核地址和数据存在物理地址的0-1MB处，进程看不到</li></ul></li><li>解决办法：高地址映射<ul><li>在每个页表高端3-4GB地方，保留一段虚拟地址，映射到内核实际的物理地址处（0-1MB）</li><li>这样子在用户空间的高端和内核空间的地址映射到的是同一块物理内存</li><li>这样，进程在进入内核态时（比如系统调用），可以<u>直接用高地址访问到内核的数据结构</u>（如 <code>programManager</code>），<strong>不会和进程自己的0~1MB冲突</strong>。</li><li>实际上就将第0项和第768项指向同一个页表，就实现了。<br>  同步地，需要修改makefile，保证我们的偏移不会出错</li></ul></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">kernel<span class="hljs-selector-class">.bin</span> : kernel<span class="hljs-selector-class">.o</span><br>objcopy -O binary kernel<span class="hljs-selector-class">.o</span> kernel<span class="hljs-selector-class">.bin</span><br><br>kernel<span class="hljs-selector-class">.o</span> : entry<span class="hljs-selector-class">.obj</span> $(OBJ)<br>$(LINKER) -o kernel<span class="hljs-selector-class">.o</span> -melf_i386 -N entry<span class="hljs-selector-class">.obj</span> $(OBJ) -Ttext <span class="hljs-number">0</span>xc0020000 -e enter_<br></code></pre></td></tr></table></figure><p>相对 <code>0xc0000000</code> 进行寻址，而不是从0开始</p><p>其中，<code>-Ttext</code>参数本来是<code>0x20000</code>，现在我们将其提升到3GB的空间。<br>虽然内核的变量被提升到了<strong>3GB</strong>以上的空间，但我们实际上<strong>加载内核</strong>还是加载到<code>0x20000</code>处，只不过我们通过了<strong>分页机制</strong>将3GB以上的<strong>虚拟地址空间</strong>映射到0~1MB的空间。</p><p>同时，在跳转到内核之前，要保证正确开启了分页机制，也就是把这部分开启放置在bootloader中</p><p><img src="/img/file-20250526172538639.png"></p><h4 id="初始化TSS和用户段描述符"><a href="#初始化TSS和用户段描述符" class="headerlink" title="初始化TSS和用户段描述符"></a>初始化TSS和用户段描述符</h4><p>在ProgramManager中加入存储3个代码段、数据段和栈段描述符的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> USER_CODE_SELECTOR;  <span class="hljs-comment">// 用户代码段选择子</span><br><span class="hljs-type">int</span> USER_DATA_SELECTOR;  <span class="hljs-comment">// 用户数据段选择子</span><br><span class="hljs-type">int</span> USER_STACK_SELECTOR; <span class="hljs-comment">// 用户栈段选择子</span><br></code></pre></td></tr></table></figure><p>进程的<strong>运行环境</strong>需要用到<u>TSS、特权级3下的平坦模式代码段和数据段描述符</u><br><img src="/img/file-20250526173209395.png"><br>这三个描述符的DPL为3</p><p><img src="/img/file-20250527142346877.png"></p><p>低特权级-&gt;高特权级：</p><ul><li>CPU会先在<strong>TSS</strong>中找到高特权级栈的<strong>段选择子和栈指针</strong>，送入SS、ESP</li><li>栈变成TSS保存的高特权级的栈，同时把低特权级的SS、ESP、EFLAGS、CS、EIP压入高特权级栈保存</li></ul><p>TSS结构体：内容不可变更，是CPU规定的<br><img src="/img/file-20250527141632953.png"></p><ul><li>TSS也是存储数据的内存区域<ul><li>段基址的意思是TSS的起始地址&amp;tss</li><li>段界限是TSS的<strong>实际长度-1</strong></li><li>B为表示任务是否忙，0-不忙，1-忙<br>  <img src="/img/file-20250527141711207.png"><br>  TR寄存器：保存TSS描述符的选择子，以便于CPU在发生特权级切换时能自动加载TSS中的内容</li></ul></li></ul><p>TSS的初始化<br><img src="/img/file-20250527142704640.png"><br>我们只需要得到高特权级（也就是0特权级）下的栈指针和栈段选择子：ss0和esp0</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>三步：</p><ul><li>创建进程的PCB</li><li>初始化进程的页目录表</li><li>初始化进程的虚拟地址池<br><img src="/img/file-20250527143217290.png"></li></ul><p>首先是中断保护机制：保存当前中断状态–关中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> status = interruptManager.getInterruptStatus();<br>interruptManager.disableInterrupt();<br></code></pre></td></tr></table></figure><p>基于线程机制创建进程PCB：创建线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = executeThread((ThreadFunction)load_process,<br>                        (<span class="hljs-type">void</span> *)filename, filename, priority);<br><span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>&#123;<br>    interruptManager.setInterruptStatus(status);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取新建的PCB：<br>新建的PCB会放在 <code>allPrograms</code> 链表的末尾</p><ul><li><code>tagInAllList</code> 指定了PCB在全局程序列表中的链表节点字段</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">PCB *process = ListItem2PCB(allPrograms.back(), tagInAllList);<br></code></pre></td></tr></table></figure><p>进程页目录表：调用函数创建，如果创建失败就将进程标记为dead</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">process-&gt;pageDirectoryAddress = createProcessPageDirectory();<br><span class="hljs-keyword">if</span> (!process-&gt;pageDirectoryAddress)<br>&#123;<br>    process-&gt;status = ThreadStatus::DEAD;<br>    interruptManager.setInterruptStatus(status);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建虚拟地址池：也是调用函数来创建，如果创建失败也将进程标记为dead</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> res = createUserVirtualPool(process);<br><span class="hljs-keyword">if</span> (!res)<br>&#123;<br>    process-&gt;status = ThreadStatus::DEAD;<br>    interruptManager.setInterruptStatus(status);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，恢复中断状态并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">interruptManager.setInterruptStatus(status);<br><span class="hljs-keyword">return</span> pid;<br></code></pre></td></tr></table></figure><p>详细查看创建页目录表：</p><ul><li>从内核地址池中分配一页存储页目录表</li><li>复制内核目录项到虚拟地址的高1GB</li><li>用户进程页目录表的<strong>最后一项</strong>指向用户进程页目录表本身<br><img src="/img/file-20250527145126571.png"></li></ul><p><code>ProgramStartStack</code> 来表示启动进程之前栈放入的内容<br><img src="/img/file-20250527145256478.png"></p><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><ul><li>src&#x2F;3<br>进程的调度只需要在原先的进程的线程调度的基础上加入：</li><li>切换页目录表</li><li>更新TSS中特权级0的栈<br><img src="/img/file-20250527145927760.png"></li></ul><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>用于创建一个新进程，两个进程从fork的返回点开始执行。</p><ul><li>只调用一次fork，但能够<strong>返回两次</strong><ul><li>父进程中，fork返回子进程的pid</li><li>子进程中，fork返回0</li><li>如果创建失败，fork返回一个负值<br>  父子进程共享代码段，但不共享数据段、栈段等资源。<br>  数据段和栈段等资源会被<strong>复制</strong>到子进程中。<br>  <img src="/img/file-20250528142526437.png"><br>  运行：<br>  <img src="/img/file-20250528143152035.png"><br>  得到结果：<br>  <img src="/img/file-20250528143141941.png"><br>  可以看到父进程返回了子进程的pid&#x3D;1343，子进程返回了0</li></ul></li></ul><h4 id="实现fork"><a href="#实现fork" class="headerlink" title="实现fork()"></a>实现fork()</h4><p>需要解决4个问题：</p><ul><li>父子进程代码段的共享</li><li>父子进程从相同的返回点开始执行</li><li>除代码段外，进程包含的资源有哪些？</li><li>如何实现进程资源在进程间的复制</li></ul><p>PCB中需要添加父进程pid<br><img src="/img/file-20250528143828794.png"></p><p>fork()作为一个系统调用，需要在syscall.h中加入fork()<u>系统调用</u>和<u>系统调用处理函数</u>的定义<br><img src="/img/file-20250528144000064.png"><br>同时设置好系统调用<br><img src="/img/file-20250528144058832.png"></p><p>实现基本的函数：<br><img src="/img/file-20250528144128110.png"><br>fork这里就相当于调用2号系统调用，然后会进入到内核态，进入内核态之后，需要调用<code>programManager.fork()</code>来完成后续工作</p><ul><li>首先保留中断状态，然后关中断</li><li>禁止内核线程调用，设置父进程状态为运行之后，判断是否存在页目录地址（内核线程没有独立的页目录），通过这个来禁止。</li><li>创建子进程</li><li>初始化子进程（涉及到复制进程资源）<code>bool flag = copyProcess(parent, child);</code><ul><li>复制进程启动栈</li><li>设置子进程栈指针</li><li>拷贝<strong>PCB</strong>属性</li><li>复制虚拟地址池</li><li>准备内存拷贝</li><li>页目录表复制</li><li>页表和物理页复制</li><li>清理和返回</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ProgramManager::fork</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">bool</span> status = interruptManager.getInterruptStatus();<br>    interruptManager.disableInterrupt();<br><br>    <span class="hljs-comment">// 禁止内核线程调用</span><br>    PCB *parent = this-&gt;running;<br>    <span class="hljs-keyword">if</span> (!parent-&gt;pageDirectoryAddress)<br>    &#123;<br>        interruptManager.setInterruptStatus(status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">int</span> pid = executeProcess(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        interruptManager.setInterruptStatus(status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化子进程</span><br>    PCB *child = ListItem2PCB(this-&gt;allPrograms.back(), tagInAllList);<br>    <span class="hljs-type">bool</span> flag = copyProcess(parent, child);<br><br>    <span class="hljs-keyword">if</span> (!flag)<br>    &#123;<br>        child-&gt;status = ProgramStatus::DEAD;<br>        interruptManager.setInterruptStatus(status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    interruptManager.setInterruptStatus(status);<br>    <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>进程包含的资源：<br>0特权级栈、PCB、虚拟地址池、页目录表、页表极其指向的物理页</p><p><img src="/img/file-20250528151907932.png"></p><h3 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h3><p>用于进程和线程的主动结束运行<br>在进程或线程调用exit后，我们会释放其占用的所有资源，只保留PCB。<br>进程或线程状态标记为DEAD，PCB会由专门的进程or线程来回收</p><p>exit的实现实际上是通过<code>ProgramManager::exit</code>来完成的，总的来看，exit的实现主要分为三步。</p><ol><li>标记PCB状态为<code>DEAD</code>并放入返回值。</li><li>如果PCB标识的是进程，则释放进程所占用的物理页、页表、页目录表和虚拟地址池bitmap的空间。否则不做处理。</li><li>立即执行线程&#x2F;进程调度。</li></ol><p><img src="/img/file-20250528151956291.png"></p><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p>wait的参数<code>retval</code>用来存放子进程的返回值，如果<code>retval==nullptr</code>，则说明父进程不关心子进程的返回值。wait的返回值是被回收的子进程的pid。如果没有子进程，则wait返回<code>-1</code>。在父进程调用了wait后，如果存在子进程但子进程的状态不是<code>DEAD</code>，则父进程会被阻塞，即wait不会返回直到子进程结束。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI_lab6（未整理，乱七八糟）</title>
    <link href="/2025/05/12/AI-lab6/"/>
    <url>/2025/05/12/AI-lab6/</url>
    
    <content type="html"><![CDATA[<h1 id="深度强化学习"><a href="#深度强化学习" class="headerlink" title="深度强化学习"></a>深度强化学习</h1><p>传统的RL算法有个很大的问题在于它是一种表格方法，就是根据过去出现过的状态，统计和迭代Q值。</p><ul><li>基于表格的方法局限性很大：（对未知的泛化能力弱）<ul><li>一方面适用的状态和动作空间非常小，对于图像和高维度离散状态、连续域状态无法直接适用；</li><li>另一方面对于一个状态从未出现过，这些算法是无法处理的</li></ul></li></ul><h2 id="DQN算法："><a href="#DQN算法：" class="headerlink" title="DQN算法："></a>DQN算法：</h2><p>将Q-learning和深度神经网络结合（直接结合是naive DQN），并引入两个机制经验回放和目标网络。</p><p>经验回放（replay buffer）：将智能体探索环境得到的数据储存起来，然后<strong>随机采样小批次样本</strong>更新深度神经网络的参数</p><ul><li>可以消除数据之间的时间相关性&#x3D;&gt;数据接近于独立同分布</li><li>数据利用率高</li></ul><p>目标网络：额外引入一个目标网络，此目标网络不更新梯度，每隔一段时间将Q网络的参数赋值给此目标网络。</p><p>引入原因：</p><ul><li>深度神经网络作为有监督学习模型，要求监督数据标签是<strong>稳定的</strong></li><li>Q-Learning算法使用下一时刻的Q值和奖励值作为监督信号，由于每次神经网络更新后，Q值会变化，导致Q-Learning算法的<strong>监督信号不稳定</strong>。</li></ul><p>优点：</p><ul><li>一定程度降低了当前Q值和目标Q值的相关性。</li><li>在<strong>一段时间里</strong>目标网络的Q值是保持不变的，提高了算法稳定性。（过一段时间后才会更新）<br><img src="/img/file-20250519164144791.png"></li></ul><p><img src="/img/file-20250519175958513.png"></p><ul><li>第1行：算法名称—-带有经验回放的DQN算法。</li><li>第2行：初始化经验池以及容量N。</li><li>第3行：以一个随机权重，初始化动作-价值函数 Q。</li><li>第4行：开始一个一级循环（就是一个大循环），循环的条件是回合数，满足回合方可跳出。</li><li>第5行：初始化回合的第一个状态s1 ,预处理得到状态对应的特征输入。</li><li>第6行：从该回合的第一步出发，进行循环T步才结束。</li><li>第7行：用随机概率epsilon选择一个动作at（在代码中这里是比较变量和epsilon大小）。</li><li>第8行：否则，选择上一次的最大Q值对应的at作为本次动作。（注意，这里选最大动作时用到的值函数网络与逼近值函数所用的网络是一个网络，在代码中就是用的同一个类来实例化两个网络）上边的这两行，其实就是执行贪婪策略。</li><li>第9行：在仿真环境中执行动作at，并获取奖励rt和下一个状态xt+1（下一帧图像信息xt+1）。</li><li>第10行：更新环境状态，和权重参数等。</li><li>第11行：在经验池中存储刚才的一组数据。</li><li>第12行：从经验池中取样一个batch（这个批量的大小是可以自己设置的）</li><li>第13行：进行判断，如果还没到达最终条件，根据迭代公式计算Q值；如果到达，以最后一次奖励作为本次的Q-T网络目标值。</li><li>第14行：针对Q-Target（目标函数）和Q值函数之差的Loss，运用梯度下降策略去求解最优。一般是每隔C步更新一次TD目标网络权值。</li><li>第15行：完成一个回合之后跳出循环。</li><li>第16行：完成所有回合之后跳出循环。<br><a href="https://blog.csdn.net/qq_41821562/article/details/132090104">强化学习分享（一） DQN算法原理及实现_dqn代码-CSDN博客</a></li></ul><p><strong>Q-Learning</strong><br>Q学习算法是强化学习中的一种，更准确的说，是一种关于策略的选择方式。<br>实际上，我们可以发现，强化学习的核心和训练目标就是选择一个合适的策略<code>Policy</code>，使得在每个<code>epoch</code>结束时得到的<code>reward</code>之和最大。</p><p>Q学习的思想是：<code>Q(S, A)</code> &#x3D; 在状态<code>S</code>下，采取动作<code>A</code>后，<strong>未来</strong>将得到的奖励<code>Reward</code>值之和。</p><p>Q值更新的方法：</p><ul><li>状态和行为的组合是有限的，采用S-A<strong>表格</strong>记录<br>$Q^{new}(s_t,a_t)\gets(1-\alpha)·Q(s_t,a_t)+\alpha·(r+\gamma)·max_aQ(s_{t+1},a))$</li><li>无限的，就将深度学习与Q-learning结合。用神经网络来代替这张Q表格。</li></ul><p>DQN：<br><img src="/img/file-20250519165837412.png"></p><p><a href="https://pytorch.ac.cn/tutorials/intermediate/reinforcement_q_learning.html">强化学习 (DQN) 教程 — PyTorch 教程 2.7.0+cu126 文档 - PyTorch 深度学习库</a></p><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><p>CartPole任务</p><ul><li>在CartPole环境中实现DQN算法。<br>要求：</li><li>在给定的代码框架下补充代码。</li><li>最终的reward至少收敛至180.0（注意：这里的reward指一局游戏的奖励值之和）。</li><li>评分标准：以算法收敛的reward大小、收敛所需的样本数量给分。 reward越高（最大是200）、收敛所需样本数量越少，分数越高。</li></ul><p>相关介绍：<br><a href="https://www.gymlibrary.dev/environments/classic_control/cart_pole/">Cart Pole - Gym Documentation</a></p><table><thead><tr><th>Num</th><th>Shape</th></tr></thead><tbody><tr><td>Action Space</td><td>Discrete(2)</td></tr><tr><td>Observation Shape</td><td>(4,)</td></tr><tr><td>Observation High</td><td>[4.8 inf 0.42 inf]</td></tr><tr><td>Observation Low</td><td>[-4.8 -inf -0.42 -inf]</td></tr><tr><td>Import</td><td><code>gym.make(&quot;CartPole-v1&quot;)</code></td></tr></tbody></table><p>action space：<br>The action is a <code>ndarray</code> with shape <code>(1,)</code> which can take values <code>&#123;0, 1&#125;</code> indicating the direction of the fixed force the cart is pushed with.<br>只有两个方向可以移动，左和右</p><table><thead><tr><th>Num</th><th>Action</th></tr></thead><tbody><tr><td>0</td><td>Push cart to the left</td></tr><tr><td>1</td><td>Push cart to the right</td></tr><tr><td><strong>注</strong>： 由施加的力减少或增加的速度不是固定的，它取决于角度 杆子指向。杆子的重心会改变将推车移动到其下方所需的能量</td><td></td></tr></tbody></table><p>observation space：<br>The observation is a <code>ndarray</code> with shape <code>(4,)</code> with the values corresponding to the following positions and velocities:</p><table><thead><tr><th>Num</th><th>Observation</th><th>Min</th><th>Max</th></tr></thead><tbody><tr><td>0</td><td>Cart Position</td><td>-4.8</td><td>4.8</td></tr><tr><td>1</td><td>Cart Velocity</td><td>-Inf</td><td>Inf</td></tr><tr><td>2</td><td>Pole Angle</td><td>~ -0.418 rad (-24°)</td><td>~ 0.418 rad (24°)</td></tr><tr><td>3</td><td>Pole Angular Velocity</td><td>-Inf</td><td>Inf</td></tr><tr><td>注意：虽然上面的范围表示每个元素的观测空间的可能值， 它不反映未终止剧集中状态空间的允许值。特别：</td><td></td><td></td><td></td></tr></tbody></table><ul><li><p>The cart x-position (index 0) can be take values between <code>(-4.8, 4.8)</code>, but the episode terminates if the cart leaves the <code>(-2.4, 2.4)</code> range.</p></li><li><p>The pole angle can be observed between <code>(-.418, .418)</code> radians (or ±24°), but the episode terminates if the pole angle is not in the range <code>(-.2095, .2095)</code> (or ±12°)</p></li></ul><p>奖励reward：<br>由于目标是为了尽可能长时间保持小杆垂直，所以只要没有掉落的每一步都应该累积奖励+1,</p><p>开始状态：<br>All observations are assigned a uniformly random value in <code>(-0.05, 0.05)</code></p><p>Episode End<br>The episode ends if any one of the following occurs:</p><ol><li>Termination: Pole Angle is greater than ±12°</li><li>Termination: Cart Position is greater than ±2.4 (center of the cart reaches the edge of the display)</li><li>Truncation: Episode length is greater than 500 (200 for v0)</li></ol><p><code>.load_state_dict()</code></p><ul><li>把参数字典<strong>加载</strong>到另一个（结构相同的）网络。</li><li>例子：<code>self.target_q_net.load_state_dict(...)</code> 把参数加载到目标网络。</li></ul><p><code>summarywrite</code> :它允许你在训练过程中<strong>记录各种指标</strong>（如 reward、loss、accuracy、参数分布等），然后用 TensorBoard 直观地可视化这些数据。</p><p><code>gym.Env.reset(_self_, _*_, _seed: int | None = None_, _options: dict | None = None_) → Tuple[ObsType, dict]</code><br>ddl：6.2<br>实验六</p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><p>由于之前学了如何实现CNN，我们先来实现QNet<br>对比卷积层数量和隐藏层大小带来的差异：<br>只有三层（输入+隐藏+输出）：<br><img src="/img/file-20250524213606700.png"><br>需要78轮才能收敛<br><img src="/img/file-20250524213556582.png"></p><p>增加层数，同时设计一个纺锤形的网络：<br><img src="/img/file-20250524213726898.png"><br>可以在55轮就收敛：<br><img src="/img/file-20250524213742160.png"></p><p>如果只增加了层数，但是没有设计纺锤形的网络：<br><img src="/img/file-20250524213834045.png"><br>效果反而差了很多：<br>在203轮才收敛！<br><img src="/img/file-20250524213907031.png"></p><p>然后我们实现经验回放池：<br>经验回放的目的是消除样本之间的时间相关性</p><ul><li>初始化函数用于初始化一个有限容量的缓冲区</li><li>len()用于返回经验回放池的大小</li><li>push()用于将新的样本推入池</li><li>sample()用于随机地获取一批小样本</li><li>clean()用于清理回放池</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实现经验回放</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplayBuffer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, buffer_size</span>):<br>        <span class="hljs-variable language_">self</span>.buffer = collections.deque([], maxlen=buffer_size)<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">len</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, *transition</span>):<br>        <span class="hljs-variable language_">self</span>.buffer.append(*transition)<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">len</span> += <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 随机获得大小为batch_size的样本集</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sample</span>(<span class="hljs-params">self, batch_size</span>):<br>        <span class="hljs-keyword">return</span> random.sample(<span class="hljs-variable language_">self</span>.buffer, batch_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clean</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.buffer.clear()<br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">len</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>训练过程：<br>使用的是最简单的DQN模型<br>微调了参数：hidden_size&#x3D;256<br>v1.1版本</p><p>v2版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn, optim<br><span class="hljs-keyword">from</span> tensorboardX <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">from</span> agent_dir.agent <span class="hljs-keyword">import</span> Agent<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size, output_size</span>):<br>        <span class="hljs-built_in">super</span>(QNetwork, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.layer1 = nn.Linear(input_size, hidden_size)<br>        <span class="hljs-variable language_">self</span>.layer2 = nn.Linear(hidden_size, hidden_size)<br>        <span class="hljs-variable language_">self</span>.layer3 = nn.Linear(hidden_size, output_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = torch.relu(<span class="hljs-variable language_">self</span>.layer1(x))<br>        x = torch.relu(<span class="hljs-variable language_">self</span>.layer2(x))<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.layer3(x)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplayBuffer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, buffer_size</span>):<br>        <span class="hljs-variable language_">self</span>.buffer = collections.deque(maxlen=buffer_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.buffer)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, transition</span>):<br>        <span class="hljs-variable language_">self</span>.buffer.append(transition)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sample</span>(<span class="hljs-params">self, batch_size</span>):<br>        <span class="hljs-keyword">return</span> random.sample(<span class="hljs-variable language_">self</span>.buffer, batch_size)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AgentDQN</span>(<span class="hljs-title class_ inherited__">Agent</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, env, args</span>):<br>        <span class="hljs-built_in">super</span>().__init__(env)<br>        <span class="hljs-variable language_">self</span>.env = env<br>        <span class="hljs-variable language_">self</span>.input_size = env.observation_space.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-variable language_">self</span>.output_size = env.action_space.n<br>        <span class="hljs-variable language_">self</span>.hidden_size = <span class="hljs-built_in">getattr</span>(args, <span class="hljs-string">&quot;hidden_size&quot;</span>, <span class="hljs-number">128</span>)<br>        <span class="hljs-variable language_">self</span>.lr = <span class="hljs-built_in">getattr</span>(args, <span class="hljs-string">&quot;lr&quot;</span>, <span class="hljs-number">1e-3</span>)<br>        <span class="hljs-variable language_">self</span>.gamma = <span class="hljs-built_in">getattr</span>(args, <span class="hljs-string">&quot;gamma&quot;</span>, <span class="hljs-number">0.99</span>)<br>        <span class="hljs-variable language_">self</span>.epsilon_start = <span class="hljs-number">1.0</span><br>        <span class="hljs-variable language_">self</span>.epsilon_end = <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.epsilon_decay = <span class="hljs-number">500</span><br>        <span class="hljs-variable language_">self</span>.batch_size = <span class="hljs-number">64</span><br>        <span class="hljs-variable language_">self</span>.buffer_size = <span class="hljs-number">10000</span><br>        <span class="hljs-variable language_">self</span>.target_update_freq = <span class="hljs-number">100</span><br>        <span class="hljs-variable language_">self</span>.device = torch.device(<br>            <span class="hljs-string">&quot;cuda&quot;</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getattr</span>(args, <span class="hljs-string">&quot;use_cuda&quot;</span>, <span class="hljs-literal">False</span>) <span class="hljs-keyword">and</span> torch.cuda.is_available())<br>            <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>        )<br>        <span class="hljs-variable language_">self</span>.replay_buffer = ReplayBuffer(<span class="hljs-variable language_">self</span>.buffer_size)<br>        <span class="hljs-variable language_">self</span>.qnet = QNetwork(<span class="hljs-variable language_">self</span>.input_size, <span class="hljs-variable language_">self</span>.hidden_size, <span class="hljs-variable language_">self</span>.output_size).to(<br>            <span class="hljs-variable language_">self</span>.device<br>        )<br>        <span class="hljs-variable language_">self</span>.target_qnet = QNetwork(<br>            <span class="hljs-variable language_">self</span>.input_size, <span class="hljs-variable language_">self</span>.hidden_size, <span class="hljs-variable language_">self</span>.output_size<br>        ).to(<span class="hljs-variable language_">self</span>.device)<br>        <span class="hljs-variable language_">self</span>.target_qnet.load_state_dict(<span class="hljs-variable language_">self</span>.qnet.state_dict())<br>        <span class="hljs-variable language_">self</span>.optimizer = optim.Adam(<span class="hljs-variable language_">self</span>.qnet.parameters(), lr=<span class="hljs-variable language_">self</span>.lr)<br>        <span class="hljs-variable language_">self</span>.loss_fn = nn.MSELoss()<br>        <span class="hljs-variable language_">self</span>.writer = SummaryWriter()<br>        <span class="hljs-variable language_">self</span>.steps_done = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.epsilon = <span class="hljs-variable language_">self</span>.epsilon_start<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_action</span>(<span class="hljs-params">self, observation, test=<span class="hljs-literal">True</span></span>):<br>        obs = (<br>            torch.tensor(observation, dtype=torch.float32).unsqueeze(<span class="hljs-number">0</span>).to(<span class="hljs-variable language_">self</span>.device)<br>        )<br>        <span class="hljs-keyword">if</span> test:<br>            <span class="hljs-keyword">with</span> torch.no_grad():<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.qnet(obs).argmax(<span class="hljs-number">1</span>).item()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-variable language_">self</span>.epsilon = <span class="hljs-variable language_">self</span>.epsilon_end + (<br>                <span class="hljs-variable language_">self</span>.epsilon_start - <span class="hljs-variable language_">self</span>.epsilon_end<br>            ) * np.exp(-<span class="hljs-number">1.0</span> * <span class="hljs-variable language_">self</span>.steps_done / <span class="hljs-variable language_">self</span>.epsilon_decay)<br>            <span class="hljs-variable language_">self</span>.steps_done += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> random.random() &lt; <span class="hljs-variable language_">self</span>.epsilon:<br>                <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.env.action_space.sample()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">with</span> torch.no_grad():<br>                    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.qnet(obs).argmax(<span class="hljs-number">1</span>).item()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.replay_buffer) &lt; <span class="hljs-variable language_">self</span>.batch_size:<br>            <span class="hljs-keyword">return</span><br>        transitions = <span class="hljs-variable language_">self</span>.replay_buffer.sample(<span class="hljs-variable language_">self</span>.batch_size)<br>        batch = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*transitions))<br>        state_batch = torch.tensor(np.array(batch[<span class="hljs-number">0</span>]), dtype=torch.float32).to(<br>            <span class="hljs-variable language_">self</span>.device<br>        )<br>        action_batch = (<br>            torch.tensor(batch[<span class="hljs-number">1</span>], dtype=torch.int64).unsqueeze(<span class="hljs-number">1</span>).to(<span class="hljs-variable language_">self</span>.device)<br>        )<br>        reward_batch = (<br>            torch.tensor(batch[<span class="hljs-number">2</span>], dtype=torch.float32).unsqueeze(<span class="hljs-number">1</span>).to(<span class="hljs-variable language_">self</span>.device)<br>        )<br>        next_state_batch = torch.tensor(np.array(batch[<span class="hljs-number">3</span>]), dtype=torch.float32).to(<br>            <span class="hljs-variable language_">self</span>.device<br>        )<br>        done_batch = (<br>            torch.tensor(batch[<span class="hljs-number">4</span>], dtype=torch.float32).unsqueeze(<span class="hljs-number">1</span>).to(<span class="hljs-variable language_">self</span>.device)<br>        )<br>        q_values = <span class="hljs-variable language_">self</span>.qnet(state_batch).gather(<span class="hljs-number">1</span>, action_batch)<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            next_q_values = <span class="hljs-variable language_">self</span>.target_qnet(next_state_batch).<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].unsqueeze(<span class="hljs-number">1</span>)<br>            target_q = reward_batch + <span class="hljs-variable language_">self</span>.gamma * next_q_values * (<span class="hljs-number">1</span> - done_batch)<br>        loss = <span class="hljs-variable language_">self</span>.loss_fn(q_values, target_q)<br>        <span class="hljs-variable language_">self</span>.optimizer.zero_grad()<br>        loss.backward()<br>        <span class="hljs-variable language_">self</span>.optimizer.step()<br>        <span class="hljs-keyword">return</span> loss.item()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        best_avg_reward = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>)<br>        reward_history = []<br>        all_steps = <span class="hljs-number">0</span><br>        max_episodes = <span class="hljs-number">500</span><br>        <span class="hljs-keyword">for</span> episode <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_episodes):<br>            state = <span class="hljs-variable language_">self</span>.env.reset()<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(state, <span class="hljs-built_in">tuple</span>):  <span class="hljs-comment"># 兼容新gym</span><br>                state = state[<span class="hljs-number">0</span>]<br>            episode_reward = <span class="hljs-number">0</span><br>            done = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> done:<br>                action = <span class="hljs-variable language_">self</span>.make_action(state, test=<span class="hljs-literal">False</span>)<br>                result = <span class="hljs-variable language_">self</span>.env.step(action)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) == <span class="hljs-number">5</span>:<br>                    next_state, reward, terminated, truncated, _ = result<br>                    done = terminated <span class="hljs-keyword">or</span> truncated<br>                <span class="hljs-keyword">else</span>:<br>                    next_state, reward, done, _ = result<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(next_state, <span class="hljs-built_in">tuple</span>):<br>                    next_state = next_state[<span class="hljs-number">0</span>]<br>                <span class="hljs-variable language_">self</span>.replay_buffer.push(<br>                    (state, action, reward, next_state, <span class="hljs-built_in">float</span>(done))<br>                )<br>                state = next_state<br>                episode_reward += reward<br>                all_steps += <span class="hljs-number">1</span><br>                <span class="hljs-variable language_">self</span>.train()<br>                <span class="hljs-keyword">if</span> all_steps % <span class="hljs-variable language_">self</span>.target_update_freq == <span class="hljs-number">0</span>:<br>                    <span class="hljs-variable language_">self</span>.target_qnet.load_state_dict(<span class="hljs-variable language_">self</span>.qnet.state_dict())<br>            reward_history.append(episode_reward)<br>            avg_reward = np.mean(reward_history[-<span class="hljs-number">20</span>:])<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&quot;Episode <span class="hljs-subst">&#123;episode&#125;</span>, Reward: <span class="hljs-subst">&#123;episode_reward&#125;</span>, Avg_Reward: <span class="hljs-subst">&#123;avg_reward:<span class="hljs-number">.2</span>f&#125;</span>, Epsilon: <span class="hljs-subst">&#123;self.epsilon:<span class="hljs-number">.3</span>f&#125;</span>&quot;</span><br>            )<br>            <span class="hljs-variable language_">self</span>.writer.add_scalar(<span class="hljs-string">&quot;Reward&quot;</span>, episode_reward, episode)<br>            <span class="hljs-variable language_">self</span>.writer.add_scalar(<span class="hljs-string">&quot;AvgReward&quot;</span>, avg_reward, episode)<br>            <span class="hljs-comment"># Early stop if solved</span><br>            <span class="hljs-keyword">if</span> avg_reward &gt;= <span class="hljs-number">195</span>:  <span class="hljs-comment"># CartPole-v0 评测标准</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Solved at episode <span class="hljs-subst">&#123;episode&#125;</span>!&quot;</span>)<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> avg_reward &gt; best_avg_reward:<br>                best_avg_reward = avg_reward<br>                torch.save(<span class="hljs-variable language_">self</span>.qnet.state_dict(), <span class="hljs-string">f&quot;models\best_dqn.pth&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.writer.close()<br><br></code></pre></td></tr></table></figure><p><img src="/img/file-20250521195044516.png"></p><p><img src="/img/file-20250521211351384.png"><br><img src="/img/file-20250521211501544.png"><br><img src="/img/file-20250521211651783.png"><br><img src="/img/file-20250521211741716.png"><br><img src="/img/file-20250521211925027.png"></p><p>还是会出现过估计的问题。</p><p>v3：尝试引入Double DQN<br>效果好很多<br><img src="/img/file-20250523114845536.png"></p><p><img src="/img/file-20250523114941783.png"><br>我参考教学讲义里的QNetwork类定义，写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QNetwork</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size, output_size</span>):<br>        <span class="hljs-built_in">super</span>(QNetwork, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.net = nn.Sequential(<br>            nn.Linear(input_size, hidden_size),<br>            nn.ReLU(),<br>            nn.Linear(hidden_size, <span class="hljs-number">2</span> * hidden_size),<br>            nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">2</span> * hidden_size, hidden_size),<br>            nn.ReLU(),<br>            nn.Linear(hidden_size, output_size),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.net(x)<br></code></pre></td></tr></table></figure><p>同时我在之前实验过程中学习到纺锤体的网络格式会有比较好的效果，所以我做出了一些改变：在中间使用 <code>2*hidden_size</code> 作为隐藏层的大小</p><p>v3版本未进行调参的运行情况：</p><ul><li>效果很差，一点也不稳定，也不收敛（怀疑是因为每次采样的效果差劲）<br><img src="/img/file-20250524161530039.png"><br>进行调参：</li><li>仅仅调节了隐藏层大小（改为hidden_size&#x3D;64，效果也很一般)几百代都不收敛，直接中断了。</li><li>在修改了learning rate&#x3D;1e-3和hidden_size&#x3D;64之后，效果出奇的好<br><img src="/img/file-20250524161824967.png"></li><li>单独修改lr&#x3D;1e-3效果也是一般，在三百多代才能收敛。<br><img src="/img/file-20250524161957599.png"><br><img src="/img/file-20250524162037231.png"><br>曲线也是比较波折的，但是最后能够多代稳定在200</li><li>调整lr&#x3D;1e-4，hidden_size&#x3D;64效果也是一般，需要270代左右才能收敛<br><img src="/img/file-20250524162227538.png"><br><img src="/img/file-20250524162254809.png"></li><li>同时我还加载了batch_size&#x3D;32，但是好像没什么区别</li></ul><p>我修改了一下main.py，使得能正确使用dqn策略：</p><ul><li>即进行判断我们选择的算法是DQN算法还是PG算法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>():<br>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;SYSU_RL_HW2&quot;</span>)<br>    parser.add_argument(<br>        <span class="hljs-string">&quot;--train_pg&quot;</span>, default=<span class="hljs-literal">False</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;whether train policy gradient&quot;</span><br>    )<br>    parser.add_argument(<br>        <span class="hljs-string">&quot;--train_dqn&quot;</span>, default=<span class="hljs-literal">False</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;whether train DQN&quot;</span><br>    )<br><br>    Policy, _ = parser.parse_known_args()<br><br>    <span class="hljs-keyword">if</span> Policy.train_dqn:<br>        parser = dqn_arguments(parser)<br>    <span class="hljs-keyword">else</span>:<br>        parser = pg_arguments(parser)<br><br>    args = parser.parse_args()<br>    <span class="hljs-keyword">return</span> args<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250524163451402.png"><br><img src="/img/file-20250524164350452.png"></p><p>同时由于我们没有用到seed，可能效果并不稳定，所以我们在运行前还有run函数之前加上seed设置，这样子就能保证结果可以复现了。<br>还发现需要在gym环境设置的地方添加seed设置。<br><img src="/img/file-20250524180306030.png"><br><img src="/img/file-20250524165657586.png"></p><p><a href="https://yinyoupoet.github.io/2020/02/18/%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%BA%A6Q%E7%BD%91%E7%BB%9CDQN%E8%AF%A6%E8%A7%A3/#q-learning">深度强化学习之深度Q网络DQN详解 | yinyoupoet的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab7</title>
    <link href="/2025/05/11/OS-lab7/"/>
    <url>/2025/05/11/OS-lab7/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><ul><li>学习如何使用<strong>位图</strong>和<strong>地址池</strong>来管理资源</li><li>实现在物理地址空间下的内存管理</li><li>学习并开启二级分页机制&#x3D;&gt;实现在虚拟地址空间下的内存管理</li></ul><p>基于分页机制，我们可以将连续的虚拟地址空间映射到不连续的物理地址空间。<br>对于同一个虚拟地址，在不同的页目录表和页表下，我们会得到不同的物理地址。<br>开启了分页机制后，程序中使用的地址是虚拟地址。我们需要结合页目录表和页表才能确定虚拟地址对应的物理地址。</p><p>实验要求：</p><ul><li>ddl：6月1日</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment 1"></a>Assignment 1</h3><p><strong>复现</strong>参考代码，实现<u>二级分页机制</u>，并能够在虚拟机地址空间中进行内存管理，包括内存的申请和释放等，截图并给出过程解释。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>参考example一步步照着写。</p><h3 id="Assignment-2"><a href="#Assignment-2" class="headerlink" title="Assignment 2"></a>Assignment 2</h3><p>参照理论课上的学习的<strong>物理内存分配算法</strong>如first-fit, best-fit等实现<strong>动态分区算法</strong>等，或者自行提出自己的算法。</p><p>提示：基于scr&#x2F;3下的代码进行修改，你需要改动的文件：<br>src&#x2F;kernel&#x2F;setup.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">first_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-comment">// 第1个线程不可以返回</span><br>    <span class="hljs-comment">// stdio.moveCursor(0);</span><br>    <br>    <span class="hljs-comment">// 定义你自己分配想要分配的页数来模拟你实现的算法正确与否，这里我们提供了一个样例，你也可以自行修改：</span><br>    <span class="hljs-type">char</span> *pages_0 = (<span class="hljs-type">char</span> *)memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-number">128</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocated 128 pages for pages_0, starting at %d.\n&quot;</span>, pages_0);<br><br>    <span class="hljs-type">char</span> *pages_1 = (<span class="hljs-type">char</span> *)memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-number">64</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocated 64 pages for pages_1, starting at %d.\n&quot;</span>, pages_1);<br><br>    <span class="hljs-type">char</span> *pages_2 = (<span class="hljs-type">char</span> *)memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocated 16 pages for pages_2, starting at %d.\n&quot;</span>, pages_2);<br><br>    <span class="hljs-type">char</span> *pages_3 = (<span class="hljs-type">char</span> *)memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocated 8 pages for pages_3, starting at %d.\n&quot;</span>, pages_3);<br><br>    memoryManager.releasePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-type">int</span>(pages_0), <span class="hljs-number">128</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Released 128 pages for pages_0.\n&quot;</span>);<br><br>    memoryManager.releasePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-type">int</span>(pages_2), <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Released 16 pages for pages_2.\n&quot;</span>);<br><br>    <span class="hljs-type">char</span> *pages_4 = (<span class="hljs-type">char</span> *)memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocated 16 pages for pages_4, starting at %d.\n&quot;</span>, pages_4);<br><br>    <span class="hljs-type">char</span> *pages_5 = (<span class="hljs-type">char</span> *)memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-number">129</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocated 129 pages for pages_5, starting at %d.\n&quot;</span>, pages_5);<br><br>    asm_halt();<br>&#125;<br></code></pre></td></tr></table></figure><p>src&#x2F;utils&#x2F;bitmap.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BitMap::allocate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span>&#123;<br><span class="hljs-comment">// 你实现的算法</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>我选择实现best-fit（因为原本例子已经实现了first-fit了）<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//best fit</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">BitMap::allocate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>, empty = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> best = length + <span class="hljs-number">1</span>, best_idx = <span class="hljs-number">-1</span>; <br><br>    <span class="hljs-keyword">while</span> (index &lt; length)<br>    &#123;<br>        <span class="hljs-comment">// 跳过已分配的资源</span><br>        <span class="hljs-keyword">while</span> (index &lt; length &amp;&amp; get(index))<br>            ++index;<br><br>        <span class="hljs-keyword">if</span> (index == length)<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 记录空闲块的起始地址</span><br>        start = index;<br>        empty = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 计算当前空闲块的大小</span><br>        <span class="hljs-keyword">while</span> (index &lt; length &amp;&amp; !get(index))<br>        &#123;<br>            ++empty;<br>            ++index;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果当前空闲块满足需求且更优，更新 best 和 best_idx</span><br>        <span class="hljs-keyword">if</span> (empty &gt;= count &amp;&amp; empty &lt; best)<br>        &#123;<br>            best = empty;<br>            best_idx = start;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 分配资源</span><br>    <span class="hljs-keyword">if</span> (best_idx != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>        &#123;<br>            <span class="hljs-built_in">set</span>(best_idx + i, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> best_idx;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 无法分配</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现结果：<br><img src="/img/file-20250515222934277.png"><br>分析一下：<br>我们可以看到，我先为pages0到pages3分配了对应的页大小，然后释放了pages0以及pages2,再次分配16页的空间给pages4，可以看到分配的空间的首地址在2883584，说明分配到了pages2原本的位置，这个位置是最佳的位置。然后再看我们为pages5分配129页的空间，发现前面无法满足，就再往后开辟了。</p><h3 id="Assignment-3"><a href="#Assignment-3" class="headerlink" title="Assignment 3"></a>Assignment 3</h3><p><strong>复现</strong>“虚拟页内存管理”一节的代码，完成如下要求。</p><ul><li>结合代码分析虚拟页内存分配的三步过程和虚拟页内存释放。</li><li>构造测试例子来分析虚拟页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测试。否则，结合测例简要分析虚拟页内存管理的实现的正确性。</li><li>（<strong>不做要求，对评分没有影响</strong>）如果你有想法，可以在自己的理解的基础上，参考ucore，《操作系统真象还原》，《一个操作系统的实现》等资料来实现自己的虚拟页内存管理。在完成之后，你需要指明相比较于本教程，你的实现的虚拟页内存管理的特点所在。</li></ul><h4 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h4><h5 id="补充初始化："><a href="#补充初始化：" class="headerlink" title="补充初始化："></a>补充初始化：</h5><p>地址空间包括用户虚拟地址空间、用户物理地址空间、内核虚拟地址空间、内核物理地址空间。其中用户虚拟地址池是局部的，放在PCB中。我们的MemoryManager只需要管理剩下的三个地址池。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 内核物理地址池</span><br>AddressPool kernelPhysical;<br><span class="hljs-comment">// 用户物理地址池</span><br>AddressPool userPhysical;<br><span class="hljs-comment">// 内核虚拟地址池</span><br>AddressPool kernelVirtual;<br></code></pre></td></tr></table></figure><p>在初始化函数中，我们需要对这三个地址池进行初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">kernelPhysical.initialize(<br>    (<span class="hljs-type">char</span> *)kernelPhysicalBitMapStart,<br>    kernelPages,<br>    kernelPhysicalStartAddress);<br><br>userPhysical.initialize(<br>    (<span class="hljs-type">char</span> *)userPhysicalBitMapStart,<br>    userPages,<br>    userPhysicalStartAddress);<br><br>kernelVirtual.initialize(<br>    (<span class="hljs-type">char</span> *)kernelVirtualBitMapStart,<br>    kernelPages,<br>    KERNEL_VIRTUAL_START);<br></code></pre></td></tr></table></figure><h5 id="页内存分配："><a href="#页内存分配：" class="headerlink" title="页内存分配："></a>页内存分配：</h5><p>虚拟页内存分配的三步过程：</p><ul><li>从虚拟地址池中<strong>分配连续的多个虚拟页</strong></li><li>从物理地址池中为每一个虚拟页<strong>分配相应大小的物理页</strong></li><li>在页目录表和页表中<strong>建立</strong>虚拟页和物理页之间的<strong>对应关系</strong></li></ul><p>页内存分配函数：<code>allocatePages(enum AddressPoolType type, const int count)</code></p><p>分配连续的多个虚拟页：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 第一步：从虚拟地址池中分配若干虚拟页</span><br>    <span class="hljs-type">int</span> virtualAddress = allocateVirtualPages(type, count);<br>    <span class="hljs-keyword">if</span> (!virtualAddress)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>分配虚拟页的函数：只分配内核虚拟页。这里的allocate是first-fit</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">allocateVirtualPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (type == AddressPoolType::KERNEL)<br>    &#123;<br>        start = kernelVrirtual.allocate(count);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (start == <span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : start;<br>&#125;<br></code></pre></td></tr></table></figure><p>为每个虚拟页指定对应的物理页：<code>physicalPageAddress = allocatePhysicalPages(type, 1);</code>每次为一个虚拟页分配一个物理页，同时会对内核物理页和用户物理页做不同的区分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MemoryManager::allocatePhysicalPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (type == AddressPoolType::KERNEL)<br>    &#123;<br>        start = kernelPhysical.allocate(count);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == AddressPoolType::USER)<br>    &#123;<br>        start = userPhysical.allocate(count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (start == <span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : start;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>建立虚拟页和物理页之间的对应关系：<br><code>flag=connectPhysicalVirtualPage(vaddress, physicalPageAddress);</code><br>建立对应的函数：<br>通过计算对应的地址，如果页目录项中没有对应的页表就会进行分配，如果有就直接将页表项指向物理页。</p><ul><li>这里计算对应的地址要记得二级分页机制下的虚拟地址可以分为三部分，页目录项+页表项+页内偏移。需要分别拆解，然后进行转换提取，最后得到物理地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">toPDE</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> virtualAddress)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0xfffff000</span> + (((virtualAddress &amp; <span class="hljs-number">0xffc00000</span>) &gt;&gt; <span class="hljs-number">22</span>) * <span class="hljs-number">4</span>));<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">toPTE</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> virtualAddress)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0xffc00000</span> + ((virtualAddress &amp; <span class="hljs-number">0xffc00000</span>) &gt;&gt; <span class="hljs-number">10</span>) + (((virtualAddress &amp; <span class="hljs-number">0x003ff000</span>) &gt;&gt; <span class="hljs-number">12</span>) * <span class="hljs-number">4</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">MemoryManager::connectPhysicalVirtualPage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> virtualAddress, <span class="hljs-type">const</span> <span class="hljs-type">int</span> physicalPageAddress)</span><br>&#123;<br>    <span class="hljs-comment">// 计算虚拟地址对应的页目录项和页表项</span><br>    <span class="hljs-type">int</span> *pde = (<span class="hljs-type">int</span> *)toPDE(virtualAddress);<br>    <span class="hljs-type">int</span> *pte = (<span class="hljs-type">int</span> *)toPTE(virtualAddress);<br><br>    <span class="hljs-comment">// 页目录项无对应的页表，先分配一个页表</span><br>    <span class="hljs-keyword">if</span>(!(*pde &amp; <span class="hljs-number">0x00000001</span>)) <br>    &#123;<br>        <span class="hljs-comment">// 从内核物理地址空间中分配一个页表</span><br>        <span class="hljs-type">int</span> page = allocatePhysicalPages(AddressPoolType::KERNEL, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (!page)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 使页目录项指向页表</span><br>        *pde = page | <span class="hljs-number">0x7</span>;<br>        <span class="hljs-comment">// 初始化页表</span><br>        <span class="hljs-type">char</span> *pagePtr = (<span class="hljs-type">char</span> *)(((<span class="hljs-type">int</span>)pte) &amp; <span class="hljs-number">0xfffff000</span>);<br>        <span class="hljs-built_in">memset</span>(pagePtr, <span class="hljs-number">0</span>, PAGE_SIZE);<br>    &#125;<br><br>    <span class="hljs-comment">// 使页表项指向物理页</span><br>    *pte = physicalPageAddress | <span class="hljs-number">0x7</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="页内存释放："><a href="#页内存释放：" class="headerlink" title="页内存释放："></a>页内存释放：</h4><p>在分配页内存时，如果遇到物理页无法分配的情况，之前成功分配的虚拟页和物理页需要释放掉（打回原形），否则会导致内存泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MemoryManager::releasePages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> virtualAddress, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-type">int</span> vaddr = virtualAddress;<br>    <span class="hljs-type">int</span> *pte, *pde;<br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ENTRY_NUM = PAGE_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++i, vaddr += PAGE_SIZE)<br>    &#123;<br>        releasePhysicalPages(type, vaddr2paddr(vaddr), <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 设置页表项为不存在，防止释放后被再次使用</span><br>        pte = (<span class="hljs-type">int</span> *)toPTE(vaddr);<br>        *pte = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    releaseVirtualPages(type, virtualAddress, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每一个虚拟页，释放为其分配的物理页：vaddr2paddr()函数实现了地址的转换。<br>然后将页表项设置为不存在，防止释放后被再次使用。<br>最后再释放虚拟页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MemoryManager::releaseVirtualPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> vaddr, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (type == AddressPoolType::KERNEL)<br>    &#123;<br>        kernelVirtual.release(vaddr, count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试例子：<br><img src="/img/file-20250516212322734.png"><br>所做的测试内容是：<br>先为三个线程分配100，10，100页大小的空间，然后再释放线程2，再为线程2分配100页大小的空间，再分配10页的空间。<br>可以看到输出结果，由于虚拟页的分配是连续的：<br>(1)第一次分配：<br><code>p1 = allocatePages(KERNEL, 100)</code></p><ul><li>分配 100 页，地址跨度为：</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">100 </span>× <span class="hljs-number">4</span>KB = <span class="hljs-number">409600</span> 字节（<span class="hljs-number">0</span>x64000）<br></code></pre></td></tr></table></figure><ul><li>如果分配起始地址为 <code>0xC0100000</code>，则分配结束地址为：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0</span>xC<span class="hljs-number">0100000</span> + <span class="hljs-number">0x64000</span> = <span class="hljs-number">0</span>xC<span class="hljs-number">0164000</span><br></code></pre></td></tr></table></figure><ul><li><strong>结果</strong>：<code>p1 = 0xC0100000</code></li></ul><p>(2)第二次分配：<code> </code>p2 &#x3D; allocatePages(KERNEL, 10)&#96;</p><ul><li>分配 10 页，地址跨度为：<br>10 × 4KB &#x3D; 40960 字节（0xA000）</li><li>计算出地址：0xC0164000 + 0xA000 &#x3D; 0xC016E000</li></ul><p>(3)第三次分配：<br><code>p3 = allocatePages(KERNEL, 100)</code></p><ul><li>分配 100 页，地址跨度为：100 × 4KB &#x3D; 409600 字节（0x64000）</li><li>计算出地址：0xC016E000 + 0x64000 &#x3D; 0xC01D2000</li></ul><p>（4）释放 10 页：<code> </code>releasePages(KERNEL, (int)p2, 10)&#96;</p><ul><li>释放 <code>p2</code> 指向的 10 页（<code>0xC0164000</code> 到 <code>0xC016E000</code>）。</li><li>内存管理器将这段地址标记为可用。</li></ul><p>(5) 重新分配：<br><code>p2 = allocatePages(KERNEL, 100)</code></p><ul><li>内存管理器重新分配 100 页。</li><li>根据分配策略（假设优先复用刚释放的地址），从 <code>0xC0164000</code> 开始分配：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0xC0164000</span> + <span class="hljs-number">0</span>x64000 = <span class="hljs-number">0</span>xC01D2000<br></code></pre></td></tr></table></figure><ul><li><strong>结果</strong>：<code>p2 = 0xC0164000</code><br>(6) 再次分配：<br><code>p2 = allocatePages(KERNEL, 10)</code></li><li>分配 10 页，地址跨度为：</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span>× <span class="hljs-number">4</span>KB = <span class="hljs-number">40960</span> 字节（<span class="hljs-number">0</span>xA000）<br></code></pre></td></tr></table></figure><ul><li>从上一次分配结束地址 <code>0xC01D2000</code> 开始分配：</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0xC01D2000</span> + <span class="hljs-number">0xA000</span> = <span class="hljs-number">0xC01DC000</span><br></code></pre></td></tr></table></figure><ul><li><strong>结果</strong>：<code>p2 = 0xC01D2000</code></li></ul><p>可以看出是很符合的。<br><img src="/img/file-20250516212146391.png"></p><h3 id="（选做）Assignment-4"><a href="#（选做）Assignment-4" class="headerlink" title="（选做）Assignment 4"></a>（选做）Assignment 4</h3><p>参照理论课上虚拟内存管理的<strong>页面置换算法</strong>如FIFO、LRU等，实现页面置换，也可以提出自己的算法。可以在ubuntu实验环境中实现，也可以在win环境使用cpp模拟。</p><p>页面置换算法–进程运行时，若其<strong>访问的页面不在内存而需将其调入</strong>，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，<strong>送入磁盘的对换区</strong>，其中选择调出页面的算法就称为页面置换算法。</p><p>缺页（所需要的页面不在内存中）：</p><ul><li>先看TLB里是否有目标页面（但是我们这里没有实现TLB–skip）</li><li>再看页表中是否有目标页面（如果有就不会缺页）</li><li>页表中也没有就发生了缺页（需要去磁盘中调取）</li></ul><p>所以如果发现虚拟页没有成功分配物理页，就说明缺页了，需要进行页面置换。</p><p>FIFO算法：</p><ul><li>需要一个变量来记录找到最先进来的虚拟页 <code>firstPage</code>，当虚拟页不够时，顺着这个list释放内存。</li></ul><h2 id="实验知识学习"><a href="#实验知识学习" class="headerlink" title="实验知识学习"></a>实验知识学习</h2><h3 id="Example1：内存的探查"><a href="#Example1：内存的探查" class="headerlink" title="Example1：内存的探查"></a>Example1：内存的探查</h3><p>获取操作系统重可管理的内存的容量：</p><ul><li>实模式下，可以通过int 15h中断来获取机器的内存大小。<br><img src="/img/file-20250511171720018.png"><br><img src="/img/file-20250511171921574.png"></li><li>功能号为 <code>0xe801</code> 的 <code>15h</code> 中断获取内存较为简单：<ul><li>在<code>ax</code>寄存器中存入功能号<code>0xe801</code>即可，无需其他的输入数据</li><li>中断返回的结果是内存的大小，结果保存在寄存器中。返回结果分两部分存储，ax寄存器中存放0-15MB的内存大小（单位1KB），bx寄存器中存放的是16MB-4GB的内存大小（单位是64KB）</li><li>内存总容量为$内存总容量&#x3D;(ax⋅1024+bx⋅64⋅1024) bytes$</li></ul></li><li>由于15h只能在实模式下使用，所以我们在保护模式下如果要获取内存大小，则需要先在实模式下获取之后，保存在一个固定位置，最后在保护模式下建立内存管理时，从固定地址读取。</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">...<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">load_bootloader:</span> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">call</span> asm_read_hard_disk  <span class="hljs-comment">; 读取硬盘</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">4</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">512</span><br>    <span class="hljs-keyword">loop</span> load_bootloader<br><br>    <span class="hljs-comment">; 获取内存大小</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xe801</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">15h</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-number">0x7c00</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-number">0x7c00</span>+<span class="hljs-number">2</span>], <span class="hljs-built_in">bx</span><br>//在跳转之前就获取了内存大小<br>    <span class="hljs-keyword">jmp</span> <span class="hljs-number">0x0000</span>:<span class="hljs-number">0x7e00</span>        <span class="hljs-comment">; 跳转到bootloader</span><br>    <br>...<br></code></pre></td></tr></table></figure><ul><li>在first_thread中读取内存大小</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mel">...<br><br>void first_thread(void *arg)<br>&#123;<br>...<br><br>    <span class="hljs-keyword">int</span> <span class="hljs-keyword">memory</span> = *((uint32 *)MEMORY_SIZE_ADDRESS);<br>    <span class="hljs-comment">// ax寄存器保存的内容</span><br>    <span class="hljs-keyword">int</span> low = <span class="hljs-keyword">memory</span> &amp; <span class="hljs-number">0xffff</span>;<br>    <span class="hljs-comment">// bx寄存器保存的内容</span><br>    <span class="hljs-keyword">int</span> high = (<span class="hljs-keyword">memory</span> &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>;<br>    <span class="hljs-keyword">memory</span> = low * <span class="hljs-number">1024</span> + high * <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>;<br>    printf(<span class="hljs-string">&quot;total memory: %d bytes (%d MB)\n&quot;</span>, <span class="hljs-keyword">memory</span>, <span class="hljs-keyword">memory</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>);<br><br>    asm_halt();<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure><p>ps：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMORY_SIZE_ADDRESS 0x7c00</span><br></code></pre></td></tr></table></figure><p>运行得到：<br><img src="/img/file-20250511204118813.png"></p><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><ul><li>用来<u>标识资源状态的位的集合</u>称为位图。</li><li>BitMap使用<strong>一位</strong>来和<strong>一个资源单元</strong>建立映射关系<br><img src="/img/file-20250511204233581.png"><br>对于4GB的内存，在分页机制下，设置一个物理页大小为4KB。那么BitMap的大小为$\frac{4GB}{8*4KB}&#x3D;128KB$</li></ul><h4 id="BitMap的实现"><a href="#BitMap的实现" class="headerlink" title="BitMap的实现"></a>BitMap的实现</h4><p>BitMap的成员包括</p><ul><li>一块<u>存放BitMap</u>的内存区域。</li><li>BitMap<u>管理的资源单元数量</u>。</li><li><u>单独</u>存取位和<u>批处理</u>存取位的方法。<br>定义：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitMap</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    <span class="hljs-comment">// 被管理的资源个数，bitmap的总位数</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-comment">// bitmap的起始地址</span><br>    <span class="hljs-type">char</span> *bitmap;<br>public:<br>    <span class="hljs-comment">// 初始化</span><br>    BitMap();<br>    <span class="hljs-comment">// 设置BitMap，bitmap=起始地址，length=总位数(被管理的资源个数)</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *bitmap, <span class="hljs-type">const</span> <span class="hljs-type">int</span> length)</span>;<br>    <span class="hljs-comment">// 获取第index个资源的状态，true=allocated，false=free</span><br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> index)</span> <span class="hljs-type">const</span>;<br>    <span class="hljs-comment">// 设置第index个资源的状态，true=allocated，false=free</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> status)</span>;<br>    <span class="hljs-comment">// 分配count个连续的资源，若没有则返回-1，否则返回分配的第1个资源单元序号</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span>;<br>    <span class="hljs-comment">// 释放第index个资源开始的count个资源</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> index, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span>;<br>    <span class="hljs-comment">// 返回Bitmap存储区域</span><br>    <span class="hljs-type">char</span> *<span class="hljs-title function_">getBitmap</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 返回Bitmap的大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>;<br>private:<br>    <span class="hljs-comment">// 禁止Bitmap之间的赋值</span><br>    BitMap(<span class="hljs-type">const</span> BitMap &amp;) &#123;&#125;<br>    <span class="hljs-type">void</span> operator=(<span class="hljs-type">const</span> BitMap&amp;) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们是从外界向BitMap提供存储空间的，因为无法自己管理自己。所以我们会在内存中手动划分出一块区域来存储BitMap用来标识资源分配情况的位。</p><blockquote><p>[!NOTE]<br>注意，BitMap的成员是有<strong>指针</strong>的。一般情况下，成员涉及指针的对象的赋值都需要使用<strong>动态内存分配</strong>获得一个新的指针，但我们还没有实现动态内存分配。所以，我们将<code>copy constructor</code>和<code>operator=</code>定义为<strong>private</strong>，以<strong>禁止BitMap之间的直接赋值</strong>。这也是为什么我们在BitMap的初始化函数<code>initialize</code>中需要提供BitMap的存储区域。</p></blockquote><p>当我们使用指针来访问BitMap的存储区域时，<strong>最小的访问单位是字节</strong>，而资源单元的状态是使用一个位来表示的。<br>故给定一个资源单元的序号i，无法通过bitmap[i] 的方式来直接修改资源单元的状态，而是定位到这个位的字节序号pos，再确定这个位在字节中的偏移量，使用<strong>位运算</strong>来修改。<br>$i&#x3D;8·pos+offset,0\leq{offset}&lt;8$</p><h3 id="地址池"><a href="#地址池" class="headerlink" title="地址池"></a>地址池</h3><p>目前只需要实现<strong>页内存管理</strong>（每次分配的内存大小是一个页，每次释放的内存大小也是一个页）</p><p>也就是只需要使用一种结构（即<strong>地址池</strong>）来标识地址空间中的哪些页是已经被分配的，哪些是未被分配的。</p><ul><li>当需要页内存分配时，我们可以从地址池中取出一个空闲页。然后地址池便会<strong>标识</strong>（可以用BitMap）该空闲页已被分配，最后计算并返回该空闲页对应的地址。空闲页只要没有被释放，就不会被再次分配。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddressPool</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    BitMap resources;<br>    <span class="hljs-type">int</span> startAddress;<br>public:<br>    AddressPool();<br>    <span class="hljs-comment">// 初始化地址池</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *bitmap, <span class="hljs-type">const</span> <span class="hljs-type">int</span> length,<span class="hljs-type">const</span> <span class="hljs-type">int</span> startAddress)</span>;<br>    <span class="hljs-comment">// 从地址池中分配count个连续页，成功则返回第一个页的地址，失败则返回-1</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span>;<br>    <span class="hljs-comment">// 释放若干页的空间</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> address, <span class="hljs-type">const</span> <span class="hljs-type">int</span> amount)</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>$address&#x3D;startAddress+i×PAGE_SIZE$</p><h3 id="物理页内存管理"><a href="#物理页内存管理" class="headerlink" title="物理页内存管理"></a>物理页内存管理</h3><p>物理内存划分为两部分：内核空间和用户空间</p><ul><li>内核需要的物理页只会从内核空间中分配，用户程序需要的物理页也只会从用户空间中分配。</li><li>因此我们会使用<strong>两个地址池</strong>来对这两部分物理地址进行管理</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AddressPoolType</span></span><br><span class="hljs-class">&#123;</span><br>    USER,<br>    KERNEL<br>&#125;;<br></code></pre></td></tr></table></figure><p>内存管理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MemoryManager</span></span><br><span class="hljs-class">&#123;</span><br>public:<br>    <span class="hljs-comment">// 可管理的内存容量</span><br>    <span class="hljs-type">int</span> totalMemory;<br>    <span class="hljs-comment">// 内核物理地址池</span><br>    AddressPool kernelPhysical;<br>    <span class="hljs-comment">// 用户物理地址池</span><br>    AddressPool userPhysical;<br><br>public:<br>    MemoryManager();<br><br>    <span class="hljs-comment">// 初始化地址池</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 从type类型的物理地址池中分配count个连续的页</span><br>    <span class="hljs-comment">// 成功，返回起始地址；失败，返回0</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">allocatePhysicalPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span>;<br><br>    <span class="hljs-comment">// 释放从paddr开始的count个物理页</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">releasePhysicalPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> paddr, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span>;<br><br>    <span class="hljs-comment">// 获取内存总容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getTotalMemory</span><span class="hljs-params">()</span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>初始化地址池：<br>获取全部内存大小；预留部分内存用于存放内核；计算剩余空间内存&#x3D;&gt;同时算出空闲页等。<br><img src="/img/file-20250514144239027.png"></p><p>实现物理内存管理：<br>分配物理页和释放物理页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MemoryManager::allocatePhysicalPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (type == AddressPoolType::KERNEL)<br>    &#123;<br>        start = kernelPhysical.allocate(count);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == AddressPoolType::USER)<br>    &#123;<br>        start = userPhysical.allocate(count);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (start == <span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : start;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MemoryManager::releasePhysicalPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> paddr, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (type == AddressPoolType::KERNEL)<br>    &#123;<br>        kernelPhysical.release(paddr, count);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == AddressPoolType::USER)<br>    &#123;<br><br>        userPhysical.release(paddr, count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二级分页机制"><a href="#二级分页机制" class="headerlink" title="二级分页机制"></a>二级分页机制</h3><ul><li>程序如何装入内存</li><li>内存的保护是如何实现的</li></ul><h4 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h4><ul><li>绝对装入：<strong>在链接时</strong>，知道程序将存放在内存的具体位置，则连接程序根据实际运行的地址来修改程序的标号的地址。<ul><li>例如<code>ld</code>中的<code>-Ttext 0x00020000</code>，此时直接将程序加载到预先确定的位置便可运行。但是，当加载位置变化后，链接时的地址也要发生变化，否则必定发生错误。</li></ul></li><li>静态重定位：<strong>在装入时</strong>，我们根据程序被加载的位置来修改程序的指令和数据地址。区别在于<strong>修改地址的时间</strong>。</li><li>动态重定位：被装入内存后的程序起始地址依旧是从0开始。地址的转换被推迟到<strong>寻址</strong>的时候。使用MMU来进行变换（可以改变MMU的内容来实现不同的变换方式）。<ul><li>即使对于相同的线性地址，在不同的变换方式下，得到的物理地址就会不同</li></ul></li></ul><blockquote><p>[!NOTE]<br>对于绝对装入，程序的地址就是实际的使用的地址，而对于静态重定位，程序的地址依旧是从0开始，只有在被加载到内存时才会被修改。</p></blockquote><h5 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h5><p>一级页表：在分页机制下，内存被划分为大小相等的内存块，称为页（Page）</p><ul><li>未开启分页机制：$物理地址&#x3D;段地址+偏移地址$</li><li>开启分页机制后：$虚拟地址&#x3D;段地址+偏移地址$ ，虚拟地址再经过MMU转换才能变成物理地址。</li></ul><p>一级页表的虚拟地址到物理地址的转换关系如下。</p><ul><li>先取虚拟地址的高20位，高20位的数值表示的是页号。而每一个页表项占4字节，所以高20位的数值乘4后才是对应的页表项的地址。</li><li>从页表项中读出页地址后，由于低12位是<strong>页内偏移</strong>，使用物理页地址+低12位即可得出需要访问的物理地址。<br><img src="/img/file-20250514150128997.png"></li></ul><h5 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h5><p>通过<strong>页目录表</strong>来访问页表，然后通过<strong>页表</strong>访问物理页的方式被称为<u>二级分页机制</u>。</p><p>一个32位的虚拟地址被划分为3部分。</p><ul><li>31-22，共10位，是页目录项的序号，可以表示$2^{10}&#x3D;1024$个页目录项。</li><li>21-12，共10位，是页表项的序号，可以表示$2^{10}&#x3D;1024$个页表项。</li><li>11-0，共12位，是页内偏移，可以表示$2^{12}&#x3D;4KB$的物理页内的偏移地址。</li></ul><p>二级页表的虚拟地址到物理地址的转换关系：</p><ul><li>给定一个虚拟地址，先看页目录表项，其数值<u>乘4</u>之后得到页目录表现在页目录表的偏移地址。这个偏移地址加上<strong>页目录表的物理地址</strong>后得到<strong>页目录项的物理地址</strong>。</li><li>取页目录项中的内容，得到页表的物理地址。页表的物理地址加上21-12位<u>乘4</u>的结果后，得到页表项的物理地址。</li><li>取页表项的内容，即物理页的物理地址，加上11-0位的内容后便得到实际的物理地址。<br><img src="/img/file-20250514151918804.png"></li></ul><h4 id="开启二级页表分页机制"><a href="#开启二级页表分页机制" class="headerlink" title="开启二级页表分页机制"></a>开启二级页表分页机制</h4><p>具体请看：<br><a href="https://gitee.com/kpyang5/sysu-2025-spring-operating-system/blob/main/lab7/README.md#%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6">https://gitee.com/kpyang5/sysu-2025-spring-operating-system/blob/main/lab7/README.md#%E5%BC%80%E5%90%AF%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6</a></p><p>启动分页机制的流程：</p><ul><li>规划好页目录表和页表在内存中的位置（在内存中特意划分出位置），然后初始化。</li><li>将页目录表的地址写入cr3。</li><li>将cr0的PG位置1。</li></ul><p><strong>第一步，规划好页目录表和页表在内存中的位置并写入内容</strong>。</p><ul><li>页目录表和页表的物理地址必须是4KB的整数倍，也就是低12位为0。</li><li>根据线性地址空间的大小来确定需要分配的页表的数量和位置。</li><li>页目录项：<br><img src="/img/file-20250514152921204.png"></li><li><strong>31-12位</strong>是页表的物理地址位的<strong>高20位</strong>，这也是为什么规定了页目录表的地址必须是<strong>4KB的整数倍</strong>。页目录表和页表实际上也是内存中的一个页，而内存被划分成了大小为4KB的页。自然地，这些物理页的起始就是4KB的整数倍。</li><li><strong>P位</strong>是存在位，1表示存在，0表示不存在。</li><li><strong>RW位</strong>，read&#x2F;write。1表示可读写，0表示可读不可写。</li><li><strong>US位</strong>，user&#x2F;supervisor。若为1时，表示处于User级，任意级别（ 0、 1、 2、3）特权的程序都可以访问该页。若为0，表示处于 Supervisor 级，特权级别为3的程序不允许访问该页，该页只允许特权级别为0、1、2的程序可以访问。  </li><li><strong>PWT位</strong>，这里置0。PWT， Page-level Write-Through，意为页级通写位，也称页级写透位。若为 1 表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。</li><li><strong>PCD位</strong>，这里置0。PCD， Page-level Cache Disable，意为页级高速缓存禁止位。若为 1 表示该页启用高速缓存，为 0 表示禁止将该页缓存。</li><li><strong>A位</strong>，访问位。1表示被访问过，0表示未被访问，由CPU自动置位。</li><li><strong>D位</strong>，Dirty，意为脏页位。当CPU对一个页面执行写操作时，就会设置对应页表项的D位为1。此项 仅针对页表项有效，并不会修改页目录项中的D位。</li><li><strong>G位</strong>，这里置0，和TLB相关。</li><li><strong>PAT</strong>， 这里置0。Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。</li></ul><p>页表项：（结构和页表项完全类似）<br><img src="/img/file-20250514153122496.png"></p><p><strong>第二步，将页目录表的地址写入cr3</strong><br>cr3寄存器保存的是<strong>页目录表的地址</strong>。使得CPU的MMU能够找到页目录表的地址，然后自动地将线性地址转换成物理地址。<br>建立好页目录表和页表之后，要把页目录表地址放到CR3寄存器（页目录基址寄存器PDBR）–可以使用mov赋值<br><img src="/img/file-20250514153403449.png"></p><p><strong>第三步，将cr0的PG位置1</strong><br>启动分页机制的开关是将控制寄存器 cr0 的 PG 位置 1，PG 位是cr0寄存器的第31位，PG位为1后便进入了内存分页运行机制。</p><p>运行结果：<br><img src="/img/file-20250514154039367.png"></p><h3 id="虚拟页内存管理"><a href="#虚拟页内存管理" class="headerlink" title="虚拟页内存管理"></a>虚拟页内存管理</h3><ul><li><strong>从虚拟地址池中分配连续的多个虚拟页</strong>。注意，虚拟页之间的虚拟地址是连续的。</li><li><strong>从物理地址池中为每一个虚拟页分配相应大小的物理页</strong>。</li><li><strong>在页目录表和页表中建立虚拟页和物理页之间的对应关系</strong>。此时，由于分页机制的存在，物理页的地址可以不连续。CPU的MMU会在程序执行过程中将虚拟地址翻译成物理地址。<br><img src="/img/file-20250514154558623.png"></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>对于虚拟地址空间中的地址，要建立一个虚拟地址池来管理（虚拟地址池可以有多个）</p><ul><li>每个进程有自己的用户虚拟地址池，放在PCB中，并不是全局。</li><li>全局的：用户物理地址池，内核物理地址池和内核虚拟地址池</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MemoryManager::initialize</span><span class="hljs-params">()</span><br>&#123;<br>    this-&gt;totalMemory = <span class="hljs-number">0</span>;<br>    this-&gt;totalMemory = getTotalMemory();<br><br>    <span class="hljs-comment">// 预留的内存</span><br>    <span class="hljs-type">int</span> usedMemory = <span class="hljs-number">256</span> * PAGE_SIZE + <span class="hljs-number">0x100000</span>;<br>    <span class="hljs-keyword">if</span> (this-&gt;totalMemory &lt; usedMemory)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;memory is too small, halt.\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br>    <span class="hljs-comment">// 剩余的空闲的内存</span><br>    <span class="hljs-type">int</span> freeMemory = this-&gt;totalMemory - usedMemory;<br><br>    <span class="hljs-type">int</span> freePages = freeMemory / PAGE_SIZE;<br>    <span class="hljs-type">int</span> kernelPages = freePages / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> userPages = freePages - kernelPages;<br><br>    <span class="hljs-type">int</span> kernelPhysicalStartAddress = usedMemory;<br>    <span class="hljs-type">int</span> userPhysicalStartAddress = usedMemory + kernelPages * PAGE_SIZE;<br><br>    <span class="hljs-type">int</span> kernelPhysicalBitMapStart = BITMAP_START_ADDRESS;<br>    <span class="hljs-type">int</span> userPhysicalBitMapStart = kernelPhysicalBitMapStart + <span class="hljs-built_in">ceil</span>(kernelPages, <span class="hljs-number">8</span>);<br>    <span class="hljs-type">int</span> kernelVirtualBitMapStart = userPhysicalBitMapStart + <span class="hljs-built_in">ceil</span>(userPages, <span class="hljs-number">8</span>);<br><br>    kernelPhysical.initialize(<br>        (<span class="hljs-type">char</span> *)kernelPhysicalBitMapStart,<br>        kernelPages,<br>        kernelPhysicalStartAddress);<br><br>    userPhysical.initialize(<br>        (<span class="hljs-type">char</span> *)userPhysicalBitMapStart,<br>        userPages,<br>        userPhysicalStartAddress);<br><br>    kernelVirtual.initialize(<br>        (<span class="hljs-type">char</span> *)kernelVirtualBitMapStart,<br>        kernelPages,<br>        KERNEL_VIRTUAL_START);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;total memory: %d bytes ( %d MB )\n&quot;</span>,<br>           this-&gt;totalMemory,<br>           this-&gt;totalMemory / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kernel pool\n&quot;</span><br>           <span class="hljs-string">&quot;    start address: 0x%x\n&quot;</span><br>           <span class="hljs-string">&quot;    total pages: %d ( %d MB )\n&quot;</span><br>           <span class="hljs-string">&quot;    bitmap start address: 0x%x\n&quot;</span>,<br>           kernelPhysicalStartAddress,<br>           kernelPages, kernelPages * PAGE_SIZE / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>,<br>           kernelPhysicalBitMapStart);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;user pool\n&quot;</span><br>           <span class="hljs-string">&quot;    start address: 0x%x\n&quot;</span><br>           <span class="hljs-string">&quot;    total pages: %d ( %d MB )\n&quot;</span><br>           <span class="hljs-string">&quot;    bit map start address: 0x%x\n&quot;</span>,<br>           userPhysicalStartAddress,<br>           userPages, userPages * PAGE_SIZE / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>,<br>           userPhysicalBitMapStart);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kernel virtual pool\n&quot;</span><br>           <span class="hljs-string">&quot;    start address: 0x%x\n&quot;</span><br>           <span class="hljs-string">&quot;    total pages: %d  ( %d MB ) \n&quot;</span><br>           <span class="hljs-string">&quot;    bit map start address: 0x%x\n&quot;</span>,<br>           KERNEL_VIRTUAL_START,<br>           userPages, kernelPages * PAGE_SIZE / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>,<br>           kernelVirtualBitMapStart);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="页内存分配"><a href="#页内存分配" class="headerlink" title="页内存分配"></a>页内存分配</h4><p>页内存分配步骤：</p><ul><li>从虚拟地址池中分配若干连续的虚拟页。</li><li>对每一个虚拟页，从物理地址池中分配1页。</li><li>为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。</li></ul><p>分配虚拟页：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">allocateVirtualPages</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> AddressPoolType type, <span class="hljs-type">const</span> <span class="hljs-type">int</span> count)</span><br>&#123;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (type == AddressPoolType::KERNEL)<br>    &#123;<br>        start = kernelVrirtual.allocate(count);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (start == <span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : start;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>由于没有实现用户进程，此时能够分配页内存的地址池只有内核虚拟地址池，</li></ul><p>为每个虚拟页分配一个物理页：使用 <code>allocatePhysicalPages()</code>来实现</p><p>为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制能变换到物理页内：</p><ul><li>建立虚拟页到物理页的映射关系通过函数<code>connectPhysicalVirtualPage</code>来实现</li></ul><blockquote><p>[!NOTE]<br>只有程序才会使用虚拟地址，cr3寄存器，页目录项，页表项和CPU寻址中的地址都是物理地址。</p></blockquote><p>…</p><h4 id="页内存释放"><a href="#页内存释放" class="headerlink" title="页内存释放"></a>页内存释放</h4><p>如果遇到物理页无法分配的情况，之前成功分配的虚拟页和物理页都要释放。否则就会造成内存泄漏，这部分内存无法再被分配</p><p>页内存的释放是页内存分配的过程，分两个步骤完成。</p><ul><li>对每一个虚拟页，释放为其分配的物理页。</li><li>释放虚拟页。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab6</title>
    <link href="/2025/05/07/OS-Lab6/"/>
    <url>/2025/05/07/OS-Lab6/</url>
    
    <content type="html"><![CDATA[<h1 id="并发与锁机制"><a href="#并发与锁机制" class="headerlink" title="并发与锁机制"></a>并发与锁机制</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>使用硬件支持的原子指令来实现自旋锁SpinLock &#x3D;&gt; 可以用来实现线程互斥<br>然后使用SpinLock来实现信号量，最后使用SpinLock和信号量来给出两个实现线程互斥的解决方案。</p><p>ddl：5.18</p><h2 id="实验任务："><a href="#实验任务：" class="headerlink" title="实验任务："></a>实验任务：</h2><h3 id="Assignment-1-代码复现题"><a href="#Assignment-1-代码复现题" class="headerlink" title="Assignment 1 代码复现题"></a>Assignment 1 代码复现题</h3><h4 id="1-1-代码复现"><a href="#1-1-代码复现" class="headerlink" title="1.1 代码复现"></a>1.1 代码复现</h4><p>在本章中，我们已经实现了自旋锁和信号量机制。现在，同学们需要<strong>复现教程中的自旋锁和信号量的实现方法</strong>，<strong>分别</strong>使用二者解决一个同步互斥问题，如消失的芝士汉堡问题。最后，将结果截图并说说你是怎么做的。</p><h5 id="SpinLock复现"><a href="#SpinLock复现" class="headerlink" title="SpinLock复现"></a>SpinLock复现</h5><p>复现过程：<br>首先实现了SpinLock：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    uint32 bolt;<br>public:<br>    SpinLock();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>具体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>SpinLock::SpinLock()<br>&#123;<br>    initialize();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SpinLock::initialize</span><span class="hljs-params">()</span><br>&#123;<br>    bolt = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SpinLock::lock</span><span class="hljs-params">()</span><br>&#123;<br>    uint32 key = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        asm_atomic_exchange(&amp;key, &amp;bolt);<br>        <span class="hljs-comment">//printf(&quot;pid: %d\n&quot;, programManager.running-&gt;pid);</span><br>    &#125; <span class="hljs-keyword">while</span> (key);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SpinLock::unlock</span><span class="hljs-params">()</span><br>&#123;<br>    bolt = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程安排：可以看到在进入a_mother线程时上锁，保证 a_naughty_boy 线程无法同时访问临界区。然后在结束时再释放锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">a_mother</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    aLock.lock();<br>    <span class="hljs-type">int</span> delay = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: start to make cheese burger, there are %d cheese burger now\n&quot;</span>, cheese_burger);<br>    <span class="hljs-comment">// make 10 cheese_burger</span><br>    cheese_burger += <span class="hljs-number">10</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: oh, I have to hang clothes out.\n&quot;</span>);<br>    <span class="hljs-comment">// hanging clothes out</span><br>    delay = <span class="hljs-number">0xfffffff</span>;<br>    <span class="hljs-keyword">while</span> (delay)<br>        --delay;<br>    <span class="hljs-comment">// done</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: Oh, Jesus! There are %d cheese burgers\n&quot;</span>, cheese_burger);<br>    aLock.unlock();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">a_naughty_boy</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    aLock.lock();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;boy   : Look what I found!\n&quot;</span>);<br>    <span class="hljs-comment">// eat all cheese_burgers out secretly</span><br>    cheese_burger -= <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// run away as fast as possible</span><br>    aLock.unlock();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用SpinLock复现结果:<br><img src="/img/file-20250507155001149.png"></p><h5 id="信号量复现"><a href="#信号量复现" class="headerlink" title="信号量复现"></a>信号量复现</h5><p>首先声明信号量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    uint32 counter;<br>    List waiting;<br>    SpinLock semLock;<br><br>public:<br>    Semaphore();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(uint32 counter)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">V</span><span class="hljs-params">()</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用counter来表示芝士汉堡的数量。调用P操作时会检查芝士汉堡数量是否足够，如果足够就会分配给请求的单元，如果不够就将请求这个资源的线程挂载到芝士汉堡信号量的阻塞队列中，直到有资源被释放，线程被唤醒。</p><p>调用V操作时会释放芝士汉堡资源，同时检查阻塞队列中是否有线程存在，如果有就去唤醒。</p><p>具体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">Semaphore::Semaphore()<br>&#123;<br>    initialize(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Semaphore::initialize</span><span class="hljs-params">(uint32 counter)</span><br>&#123;<br>    this-&gt;counter = counter;<br>    semLock.initialize();<br>    waiting.initialize();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Semaphore::P</span><span class="hljs-params">()</span><br>&#123;<br>    PCB *cur = nullptr;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        semLock.lock();<br>        <span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            --counter;<br>            semLock.unlock();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        cur = programManager.running;<br>        waiting.push_back(&amp;(cur-&gt;tagInGeneralList));<br>        cur-&gt;status = ProgramStatus::BLOCKED;<br><br>        semLock.unlock();<br>        programManager.schedule();<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Semaphore::V</span><span class="hljs-params">()</span><br>&#123;<br>    semLock.lock();<br>    ++counter;<br>    <span class="hljs-keyword">if</span> (waiting.size())<br>    &#123;<br>        PCB *program = ListItem2PCB(waiting.front(), tagInGeneralList);<br>        waiting.pop_front();<br>        semLock.unlock();<br>        programManager.MESA_WakeUp(program);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        semLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>线程设置：可以看到mother线程在最开始的时候请求访问临界区，然后在执行完之后再释放资源，这样子调皮小孩就没办法同时访问临界资源了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">a_mother</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    semaphore.P();<br>    <span class="hljs-type">int</span> delay = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: start to make cheese burger, there are %d cheese burger now\n&quot;</span>, cheese_burger);<br>    <span class="hljs-comment">// make 10 cheese_burger</span><br>    cheese_burger += <span class="hljs-number">10</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: oh, I have to hang clothes out.\n&quot;</span>);<br>    <span class="hljs-comment">// hanging clothes out</span><br>    delay = <span class="hljs-number">0xfffffff</span>;<br>    <span class="hljs-keyword">while</span> (delay)<br>        --delay;<br>    <span class="hljs-comment">// done</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: Oh, Jesus! There are %d cheese burgers\n&quot;</span>, cheese_burger);<br>    semaphore.V();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">a_naughty_boy</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    semaphore.P();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;boy   : Look what I found!\n&quot;</span>);<br>    <span class="hljs-comment">// eat all cheese_burgers out secretly</span><br>    cheese_burger -= <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// run away as fast as possible</span><br>    semaphore.V();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用信号量复现运行结果：<br><img src="/img/file-20250507153855621.png"></p><h4 id="1-2-锁机制的实现"><a href="#1-2-锁机制的实现" class="headerlink" title="1.2 锁机制的实现"></a>1.2 锁机制的实现</h4><p>我们使用了原子指令<code>xchg</code>来实现自旋锁。但是，这种方法并不是唯一的。例如，x86指令中提供了另外一个原子指令<code>bts</code>和<code>lock</code>前缀等，这些指令也可以用来实现锁机制。现在，同学们需要结合自己所学的知识，实现一个与本教程的实现方式不完全相同的锁机制。最后，测试你实现的锁机制，将结果截图并说说你是怎么做的。</p><p>提示：在<code>asm_utils.asm</code>中实现你自己的原子操作<code>your_asm_atomic_exchange</code>，并在<code>sync.cpp</code>中做相应修改。</p><p><strong>BTS指令</strong>：用于<strong>测试</strong>并<strong>设置</strong>指定位置的位值为1<br>指令：<code>BTS dest,src</code></p><p><strong>LOCK前缀</strong>：指令前缀，用于在多处理器环境中以原子方式执行<br>语法：<code>LOCK instruction</code></p><ul><li><strong>工作原理</strong>：<ol><li>当指令执行时，处理器会锁定系统总线或使用缓存一致性机制</li><li>防止其他处理器在当前指令完成前访问同一内存位置</li><li>确保指令的操作是原子的，不会被其他处理器的操作中断</li></ol></li><li><strong>适用指令</strong>：只能用于某些特定指令，如ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs asm">; void my_asm_atomic_exchange(uint32 *register, uint32 *memeory);<br>my_asm_atomic_exchange:<br>    push ebp<br>    mov ebp, esp<br>    pushad  ; 保存所有寄存器状态<br><br>    mov ebx, [ebp + 4 * 2] ; register<br>    mov ebx, [ebp + 4 * 3] ; memory<br>    <br>    mov ebx, [esi]         ; 获取register指向的值到ebx<br>    <br>exchange_loop:<br>    mov eax, [edi]         ; 获取当前内存值到eax<br>    <br>    ; 使用lock cmpxchg原子地比较并交换<br>    lock cmpxchg [edi], ebx  ; 如果[edi]==eax，则[edi]=ebx，否则eax=[edi]<br>    <br>    ; 如果交换失败(ZF=0)，eax已经包含了最新的内存值<br>    jnz exchange_loop      ; 如果交换失败，则重试<br>    <br>    ; 此时eax包含原始内存值，将其存回register指针<br>    mov [esi], eax<br>    <br>    popad<br>    pop ebp<br>    ret<br></code></pre></td></tr></table></figure><p>执行结果：<br><img src="/img/file-20250507170037315.png"></p><h3 id="Assignment-2-生产者-消费者问题"><a href="#Assignment-2-生产者-消费者问题" class="headerlink" title="Assignment 2 生产者-消费者问题"></a>Assignment 2 生产者-消费者问题</h3><h4 id="2-1-Race-Condition"><a href="#2-1-Race-Condition" class="headerlink" title="2.1 Race Condition"></a>2.1 Race Condition</h4><p>同学们可以任取一个<strong>生产者-消费者问题</strong>，然后在lab6的代码环境下<strong>创建多个线程</strong>来模拟这个问题。在2.1中，我们不使用任何同步互斥的工具。因此，这些线程可能会产生冲突，进而无法产生我们预期的结果。同学们<u>需要将这个产生错误的场景呈现出来</u>，将结果截图并说说你是怎么做的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs 伪代码">var items = 0, space = 10, mutex = 1;<br>var in = 0, out = 0;<br>item buf[10] = &#123; NULL &#125;;<br><br>producer &#123;<br>    while( true ) &#123;<br>        wait( space );  // 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前<br>        wait( mutex );  // 保证在product时不会有其他线程访问缓冲区<br><br>        // product<br>        buf.push( item, in );  // 将新资源放到buf[in]位置 <br>        in = ( in + 1 ) % 10;<br>        <br>        signal( mutex );  // 唤醒的顺序可以不同<br>        signal( items );  // 通知consumer缓冲区有资源可以取走<br>    &#125;<br>&#125;<br><br>consumer &#123;<br>    while( true ) &#123;<br>        wait( items );  // 等待缓冲区有资源可以使用<br>        wait( mutex );  // 保证在consume时不会有其他线程访问缓冲区<br><br>        // consume<br>        buf.pop( out );  // 将buf[out]位置的的资源取走<br>        out = ( out + 1 ) % 10;<br><br>        signal( mutex );  // 唤醒的顺序可以不同<br>        signal( space );  // 通知缓冲区有空闲位置<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>设计一个生产者消费者问题，假设有一个生产者和一个消费者，我们让生产者先生产一个资源，然后再消费者去获取资源。我发现在生产者把资源生产出来之前，消费者就去取了，还对外声称拿到了资源！<br><img src="/img/file-20250507184526174.png"></p><p>修改了一下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> delay = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> before = resources;<br>    delay = <span class="hljs-number">0xfffffff</span>; <span class="hljs-comment">// 模拟耗时操作</span><br>    <span class="hljs-keyword">while</span> (delay--)<br>        ;<br><br>    resources = before + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[Producer] Produced 1, resources = %d\n&quot;</span>, resources);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> delay = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (resources &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[Consumer] No resources to consume! resources = %d\n&quot;</span>, resources);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> before = resources;<br>    delay = <span class="hljs-number">0xfffffff</span>; <span class="hljs-comment">// 模拟耗时操作</span><br>    <span class="hljs-keyword">while</span> (delay--)<br>        ;<br><br>    resources = before - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[Consumer] Consumed 1, resources = %d\n&quot;</span>, resources);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">first_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-comment">// 清屏</span><br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span> * <span class="hljs-number">80</span>; ++i)<br>        stdio.print(<span class="hljs-string">&#x27; &#x27;</span>);<br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br><br>    resources = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建多个生产者和消费者线程</span><br>    programManager.executeThread(producer, nullptr, <span class="hljs-string">&quot;producer1&quot;</span>, <span class="hljs-number">1</span>);<br>    programManager.executeThread(consumer, nullptr, <span class="hljs-string">&quot;consumer1&quot;</span>, <span class="hljs-number">1</span>);<br>    programManager.executeThread(consumer, nullptr, <span class="hljs-string">&quot;consumer2&quot;</span>, <span class="hljs-number">1</span>);<br>    programManager.executeThread(producer, nullptr, <span class="hljs-string">&quot;producer2&quot;</span>, <span class="hljs-number">1</span>);<br>    programManager.executeThread(consumer, nullptr, <span class="hljs-string">&quot;consumer3&quot;</span>, <span class="hljs-number">1</span>);<br><br>    asm_halt();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/file-20250510181456865.png"></p><h4 id="2-2-信号量解决方法"><a href="#2-2-信号量解决方法" class="headerlink" title="2.2 信号量解决方法"></a>2.2 信号量解决方法</h4><p>使用信号量解决上述你模拟的生产者-消费者问题。将结果截图并说说你是怎么做的。</p><p>提示：</p><p>①经典的生产者-消费者问题有读者-写者问题、有界缓冲区问题等，可任取一个来模拟。</p><p>②模拟生产者-消费者问题的步骤：1、在代码中创建多个线程，分别代表生产者和消费者。2、编写生产者和消费者的线程函数。在这些函数中，根据问题的具体场景实现生产数据和消费数据的逻辑。3、创建并启动生产者和消费者线程。观察线程之间的交互并记录结果。4、展示没有使用同步互斥工具（如信号量）时，线程之间可能产生的冲突。5、使用信号量解决同步问题，并展示解决后的结果。</p><p>③样例视频模拟了读者-写者问题的场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//模拟读错误</span><br><span class="hljs-comment">//创建线程读第1-4条记录</span><br>programManager.<span class="hljs-built_in">executeThread</span>(readFirstQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;second thread&quot;</span>, <span class="hljs-number">1</span>);<br>programManager.<span class="hljs-built_in">executeThread</span>(readSecondQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;third thread&quot;</span>, <span class="hljs-number">1</span>);<br>programManager.<span class="hljs-built_in">executeThread</span>(readThirdQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;fourth thread&quot;</span>, <span class="hljs-number">1</span>);<br>programManager.<span class="hljs-built_in">executeThread</span>(readFourthQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;fifth thread&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//创建线程，修改第2条和第4条记录为较长内容</span><br><span class="hljs-comment">//由于写时间较长，写线程运行时间大于RRschedule的time quantum</span><br>programManager.<span class="hljs-built_in">executeThread</span>(writeSecondQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;sixth thread&quot;</span>, <span class="hljs-number">1</span>);<br>programManager.<span class="hljs-built_in">executeThread</span>(writeFourthQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;seventh thread&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//创建线程读第2条和第4条记录</span><br><span class="hljs-comment">//发现没有读到修改后的项，而是输出了初始项</span><br>programManager.<span class="hljs-built_in">executeThread</span>(readSecondQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;eighth thread&quot;</span>, <span class="hljs-number">1</span>);<br>programManager.<span class="hljs-built_in">executeThread</span>(readFourthQuote, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot;ninth thread&quot;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>而使用信号量后，可以读到修改后的项。</p><p>使用信号量之后，生产者消费者问题得到了很好的解决<br><img src="/img/file-20250507185504196.png"></p><h3 id="Assignment-3-哲学家就餐问题"><a href="#Assignment-3-哲学家就餐问题" class="headerlink" title="Assignment 3 哲学家就餐问题"></a>Assignment 3 哲学家就餐问题</h3><p>假设有 5 个哲学家，他们的生活只是思考和吃饭。这些哲学家共用一个圆桌，每位都有一把椅子。在桌子中央有一碗米饭，在桌子上放着 5 根筷子。</p><p><img src="https://gitee.com/kpyang5/sysu-2025-spring-operating-system/raw/main/lab6/gallery/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98.jpeg" alt="哲学家就餐问题"></p><p>当一位哲学家思考时，他与其他同事不交流。时而，他会感到饥饿，并试图拿起与他相近的两根筷子（筷子在他和他的左或右邻居之间）。一个哲学家一次只能拿起一根筷子。显然，他不能从其他哲学家手里拿走筷子。当一个饥饿的哲学家同时拥有两根筷子时，他就能吃。在吃完后，他会放下两根筷子，并开始思考。</p><h4 id="3-1-初步解决方法"><a href="#3-1-初步解决方法" class="headerlink" title="3.1 初步解决方法"></a>3.1 初步解决方法</h4><p>同学们需要在本教程的代码环境下，创建多个线程来模拟哲学家就餐的场景。然后，同学们需要结合信号量来实现理论课教材中给出的关于哲学家就餐问题的方法。最后，将结果截图并说说你是怎么做的。</p><p>该方案可能导致死锁，请举例出现死锁的场景和原因，并提出一种解决死锁的方案。</p><p>让我们来看一下运行情况：<br>启动：<br><img src="/img/file-20250507195411767.png"><br><img src="/img/file-20250507195511916.png"><br>过了一段时间后，发现谁也拿不起来了，出现了<strong>死锁</strong>！<br><img src="/img/file-20250507195535572.png"></p><p>不出现死锁：<br><img src="/img/77c4cb7b443f7e05b99484e4b0e2b52.png"></p><h4 id="3-2-死锁解决方法（选做）"><a href="#3-2-死锁解决方法（选做）" class="headerlink" title="3.2 死锁解决方法（选做）"></a>3.2 死锁解决方法（选做）</h4><p>虽然3.1的解决方案保证两个邻居不能同时进食，但是它可能导致死锁。现在，同学们需要想办法将死锁的场景演示出来。提出一种解决死锁的方法并实现。最后，将结果截图并说说你是怎么做的。</p><p>说明：</p><p>①为演示死锁场景，可以在哲学家进食的线程中添加等待时间，使哲学家们的操作更接近于同时进行。</p><p>②样例视频演示了等待时间较少——正常、等待时间较长——出现死锁。<br>通过设置同一时间只允许4个人就餐来避免死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">Semaphore semaphore[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 限制同时就餐人数的信号量</span><br>Semaphore table;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">philosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>    <span class="hljs-type">int</span> meals = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于计数和限制用餐次数，避免无限循环</span><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d is thinking\n&quot;</span>, i);<br>        <br>       <span class="hljs-comment">//同时只能有4人上桌</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d tries to sit at the table\n&quot;</span>, i);<br>        table.P();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d sits at the table\n&quot;</span>, i);<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d tries to pick up left chopstick\n&quot;</span>, i);<br>        semaphore[i].P();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d picks up left chopstick\n&quot;</span>, i);<br>        <br>        <span class="hljs-comment">// thinking</span><br>        <span class="hljs-type">int</span> delay = <span class="hljs-number">0x1FFFFFF</span>;<br>        <span class="hljs-keyword">while</span> (delay) --delay;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d tries to pick up right chopstick\n&quot;</span>, i);<br>        semaphore[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>].P();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d picks up right chopstick\n&quot;</span>, i);<br>        <br>        <span class="hljs-comment">// 进餐</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d is eating...\n&quot;</span>, i);<br>        delay = <span class="hljs-number">0x3FFFFFF</span>;<br>        <span class="hljs-keyword">while</span> (delay) --delay;<br>        <br>        <span class="hljs-comment">// 放下筷子</span><br>        semaphore[i].V();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d puts down left chopstick\n&quot;</span>, i);<br>        <br>        semaphore[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">5</span>].V();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d puts down right chopstick\n&quot;</span>, i);<br>        <br>        <span class="hljs-comment">// 离开餐桌，让其他哲学家有机会</span><br>        table.V();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d leaves the table\n&quot;</span>, i);<br>        <br>        meals++; <span class="hljs-comment">// 增加用餐计数</span><br>    &#125; <span class="hljs-keyword">while</span> (meals &lt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 限制每个哲学家用餐3次</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;philosopher %d finish eating\n&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250507203711903.png"></p><h2 id="知识学习"><a href="#知识学习" class="headerlink" title="知识学习"></a>知识学习</h2><h3 id="消失的芝士汉堡"><a href="#消失的芝士汉堡" class="headerlink" title="消失的芝士汉堡"></a>消失的芝士汉堡</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">a_mother</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> delay = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: start to make cheese burger, there are %d cheese burger now\n&quot;</span>, cheese_burger);<br>    <span class="hljs-comment">// make 10 cheese_burger</span><br>    cheese_burger += <span class="hljs-number">10</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: oh, I have to hang clothes out.\n&quot;</span>);<br>    <span class="hljs-comment">// hanging clothes out</span><br>    delay = <span class="hljs-number">0xfffffff</span>;<br>    <span class="hljs-keyword">while</span> (delay)<br>        --delay;<br>    <span class="hljs-comment">// done</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mother: Oh, Jesus! There are %d cheese burgers\n&quot;</span>, cheese_burger);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">a_naughty_boy</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;boy   : Look what I found!\n&quot;</span>);<br>    <span class="hljs-comment">// eat all cheese_burgers out secretly</span><br>    cheese_burger -= <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// run away as fast as possible</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">first_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-comment">// 第1个线程不可以返回</span><br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span> * <span class="hljs-number">80</span>; ++i)<br>    &#123;<br>        stdio.print(<span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br><br>    cheese_burger = <span class="hljs-number">0</span>;<br>    <br>    programManager.executeThread(a_mother, nullptr, <span class="hljs-string">&quot;second thread&quot;</span>, <span class="hljs-number">1</span>);<br>    programManager.executeThread(a_naughty_boy, nullptr, <span class="hljs-string">&quot;third thread&quot;</span>, <span class="hljs-number">1</span>);<br><br>    asm_halt();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：<br><img src="/img/file-20250507143934453.png"></p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁的<strong>基本思想</strong>是定义一个<strong>共享变量</strong><code>bolt</code>，<code>bolt</code>会被初始化为0。在线程进入临界区之前，即访问共享变量之前，都需要去检查<code>bolt</code>是否为0。</p><ul><li>如果<code>bolt</code>为0，那么这个线程就会将<code>bolt</code>设置为1，然后进入临界区。待线程离开临界区后，线程会将<code>bolt</code>设置为0。</li><li>如果线程在检查<code>bolt</code>时，发现<code>bolt</code>为1，说明有其他线程在临界区中。此时这个线程就会一直在<strong>循环检查</strong><code>bolt</code>的值（<u>类似陀螺在原地旋转，所以被称为自旋</u>），直到<code>bolt</code>为0，然后进入临界区。（不过会导致忙等待）<br>不能保证有限等待的原则</li></ul><h4 id="实现自旋锁"><a href="#实现自旋锁" class="headerlink" title="实现自旋锁"></a>实现自旋锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpinLock</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    uint32 bolt; <br>public:<br>    SpinLock();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>常常将<code>SpinLock</code>定义为一个<strong>全局变量</strong>，而全局变量的构造函数在我们的操作系统实验中不会被自动调用，所以在使用 <code>SpinLock</code> 时需要手动调用 <code>SpinLock::initialize</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">SpinLock::SpinLock()<br>&#123;<br>    initialize();<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SpinLock::initialize</span><span class="hljs-params">()</span><br>&#123;<br>    bolt = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SpinLock::lock</span><span class="hljs-params">()</span><br>&#123;<br>    uint32 key = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        asm_atomic_exchange(&amp;key, &amp;bolt); <br>        <span class="hljs-comment">//printf(&quot;pid: %d\n&quot;, programManager.running-&gt;pid);</span><br>    &#125; <span class="hljs-keyword">while</span> (key);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">SpinLock::unlock</span><span class="hljs-params">()</span><br>&#123;<br>    bolt = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>lock()：会不断检查是否能进入临界区，这里需要使用“原子”操作<code>asm_atomic_exchange(&amp;key, &amp;bolt)</code> 。但是实际上不是一个真正的原子指令，需要在某些条件下才是一个原子指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asm">; void asm_atomic_exchange(uint32 *register, uint32 *memeory);<br>asm_atomic_exchange:<br>    push ebp<br>    mov ebp, esp<br>    pushad<br><br>    mov ebx, [ebp + 4 * 2] ; register<br>    mov eax, [ebx]      ; 取出register指向的变量的值<br>    mov ebx, [ebp + 4 * 3] ; memory<br>    xchg [ebx], eax      ; 原子交换指令<br>    mov ebx, [ebp + 4 * 2] ; memory<br>    mov [ebx], eax      ; 将memory指向的值赋值给register指向的变量<br><br>    popad<br>    pop ebp<br>    ret<br></code></pre></td></tr></table></figure><ul><li>矛盾的根源就在于CPU提供的原子指令<code>xchg</code>的操作数要么是<strong>内存地址和寄存器</strong>，要么<strong>都是寄存器</strong>，而不存在两个操作数都是内存地址的情况</li><li>因此，我们在实现 <code>asm_atomic_exchange</code> 的时候作了一个重要的假设——形式参数register指向的变量不是一个共享变量</li></ul><p>我们为芝士汉堡成功的上了锁，保证在执行完 <code>a_mother</code> 线程之后才会执行 <code>a_naughty_boy</code> 线程。</p><p>执行结果：<br><img src="/img/file-20250507145633494.png"></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>由于SpinLock存在如下的缺点：</p><ul><li>忙等待</li><li>可能导致饥饿</li><li>可能死锁</li></ul><p>定义一个非负整数counter表示邻接资源个数</p><ul><li>请求资源，执行P操作：检查counter数量，如果有可用资源，则分配；如果没有则挂载到信号量的阻塞队列当中</li><li>释放资源，执行V操作：释放资源，同时检查挂载的阻塞队列中有没有线程，有则唤醒</li></ul><p>counter和阻塞队列是共享变量，需要实现互斥访问&#x3D;&gt;使用SpinLock</p><p>信号量的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    uint32 counter;<br>    List waiting;<br>    SpinLock semLock;<br><br>public:<br>    Semaphore();<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(uint32 counter)</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">V</span><span class="hljs-params">()</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>P操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Semaphore::P</span><span class="hljs-params">()</span><br>&#123;<br>    PCB *cur = nullptr;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <span class="hljs-comment">//</span><br>    &#123;<br>        semLock.lock(); <span class="hljs-comment">//共享资源，需要互斥访问</span><br>        <span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//存在可用资源</span><br>        &#123;<br>            --counter;<br>            semLock.unlock(); <br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//不存在可用资源，挂载</span><br>        cur = programManager.running;<br>        waiting.push_back(&amp;(cur-&gt;tagInGeneralList));<br>        cur-&gt;status = ProgramStatus::BLOCKED;<br><br>        semLock.unlock();<br>        programManager.schedule();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>V操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Semaphore::V</span><span class="hljs-params">()</span><br>&#123;<br>    semLock.lock();<br>    ++counter; <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-keyword">if</span> (waiting.size()) <span class="hljs-comment">//查看是否需要唤醒线程</span><br>    &#123;<br>        PCB *program = ListItem2PCB(waiting.front(), tagInGeneralList);<br>        waiting.pop_front();<br>        semLock.unlock();<br>        programManager.MESA_WakeUp(program);<span class="hljs-comment">//唤醒</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        semLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上线程的唤醒有三种方式。</p><ul><li><strong>MESA模型</strong>：阻塞队列中的阻塞线程被唤醒后，<strong>不会立即执行</strong>而是<strong>放入到就绪队列</strong>，等待下一次的调度运行。而正在运行的线程会继续执行，直到程序执行完毕。</li><li><strong>Hasen 模型</strong>：阻塞队列中的阻塞线程被唤醒后，会在当前线程执行完成后<strong>立即运行刚被唤醒的阻塞线程</strong>。</li><li><strong>Hoare 模型</strong>：阻塞队列中的阻塞线程被唤醒后，<strong>当前线程会立即中断</strong>，并<strong>运行刚刚被唤醒的阻塞线程</strong>，等阻塞线程完成再回来运行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab5</title>
    <link href="/2025/04/29/AI-lab5/"/>
    <url>/2025/04/29/AI-lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="理论内容回顾"><a href="#理论内容回顾" class="headerlink" title="理论内容回顾"></a>理论内容回顾</h1><h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><h3 id="重安装conda（虽然与pytorch没什么大关系）"><a href="#重安装conda（虽然与pytorch没什么大关系）" class="headerlink" title="重安装conda（虽然与pytorch没什么大关系）"></a>重安装conda（虽然与pytorch没什么大关系）</h3><p>由于我将ai实验移动到ubuntu里来做，所以我重新在这里安装一下conda。（先使用miniconda了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>安装完如果发现重启了终端也无法查找到 <code>conda --version</code> ，那么就输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 运行安装脚本（注意用 root 权限）</span><br>bash Miniconda3-latest-Linux-x86_64.sh<br><br><span class="hljs-comment"># 2. 安装过程中注意以下选项：</span><br><span class="hljs-comment">#    - 按回车阅读协议，输入 `yes` 同意。</span><br><span class="hljs-comment">#    - 安装路径默认是 `/root/miniconda3`（root 用户）或 `~/miniconda3`（普通用户），直接回车即可。</span><br><span class="hljs-comment">#    - 提示 `Do you wish the installer to initialize Miniconda3?` 时，必须输入 `yes`（否则需手动配置 PATH）。</span><br></code></pre></td></tr></table></figure><p>然后再重启终端，发现可以查看到版本号了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(base) root@PQCU:~/2025AI# conda --version<br>conda 25.1.1<br></code></pre></td></tr></table></figure><p>配置一下清华镜像源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<br>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/<br>conda config --<span class="hljs-built_in">set</span> show_channel_urls <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h4 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h4><p><strong>1. 环境管理</strong></p><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda create --name myenv python=3.9</code></td><td>创建名为 <code>myenv</code> 的 Python 3.9 环境</td></tr><tr><td><code>conda activate myenv</code></td><td>激活 <code>myenv</code> 环境</td></tr><tr><td><code>conda deactivate</code></td><td>退出当前环境</td></tr><tr><td><code>conda env list</code></td><td>列出所有环境</td></tr><tr><td><code>conda remove --name myenv --all</code></td><td>删除 <code>myenv</code> 环境</td></tr><tr><td><code>conda env export &gt; environment.yml</code></td><td>导出当前环境配置到 YAML 文件</td></tr><tr><td><code>conda env create -f environment.yml</code></td><td>从 YAML 文件创建环境</td></tr></tbody></table><p><strong>2. 包管理</strong></p><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda install numpy</code></td><td>安装包（如 <code>numpy</code>）</td></tr><tr><td><code>conda install -c conda-forge package_name</code></td><td>从 <code>conda-forge</code> 渠道安装包</td></tr><tr><td><code>conda list</code></td><td>列出当前环境所有已安装包</td></tr><tr><td><code>conda search numpy</code></td><td>搜索包（查看可用版本）</td></tr><tr><td><code>conda update numpy</code></td><td>更新指定包</td></tr><tr><td><code>conda remove numpy</code></td><td>卸载包</td></tr><tr><td><code>conda update --all</code></td><td>更新所有包</td></tr></tbody></table><p><strong>3. Conda 自身管理</strong></p><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda --version</code></td><td>查看 Conda 版本</td></tr><tr><td><code>conda update conda</code></td><td>更新 Conda 到最新版本</td></tr><tr><td><code>conda clean --all</code></td><td>清理缓存（减少占用空间）</td></tr></tbody></table><ol start="4"><li><strong>查看&#x2F;修改配置</strong></li></ol><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>conda config --show</code></td><td>查看当前配置</td></tr><tr><td><code>conda config --remove-key channels</code></td><td>恢复默认镜像源</td></tr><tr><td><code>conda config --set auto_activate_base false</code></td><td>禁止自动激活 <code>base</code> 环境</td></tr></tbody></table><h3 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a>pytorch安装</h3><p>直接去官网<a href="https://pytorch.org/get-started/locally/">Start Locally | PyTorch官网</a>找到对应的版本号，然后复制命令安装即可。由于本人的电脑没有GPU，所有下载CPU版本。</p><p>linux+CPU：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu<br></code></pre></td></tr></table></figure><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>英文版：<br><a href="https://pytorch.org/docs/stable/index.html">PyTorch documentation — PyTorch 2.7 documentation</a><br>中文版：<br><a href="https://pytorch.ac.cn/docs/stable/index.html">PyTorch 文档 — PyTorch 2.7 文档 - PyTorch 深度学习库</a><br><a href="https://pytorch-cn.readthedocs.io/zh/latest/">主页 - PyTorch中文文档</a></p><h3 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a>tensor</h3><ul><li>pytorch的基本数据类型，在使用torch框架进行操作时，对象一般都是要求是tensor类型</li></ul><p>初始化tensor</p><ul><li><p>直接初始化<br><img src="/img/file-20250429151116933.png"><br><img src="/img/file-20250429151131189.png"></p></li><li><p>通过原始数据转化<br><img src="/img/file-20250429151256138.png"><br><img src="/img/file-20250429151235438.png"></p></li><li><p>通过numpy数据转化<br><img src="/img/file-20250429151441026.png"><br><img src="/img/file-20250429151456910.png"></p></li><li><p>也可以通过<code>torch.zeros()</code>，<code>torch.ones()</code>等创建指定大小的全0或全1张量<br><img src="/img/file-20250429152224887.png"><br><img src="/img/file-20250429152233048.png"></p></li><li><p>初始化未指定数据类型时，tensor会根据数据本身的类型自行判断</p></li></ul><p>梯度计算：</p><ul><li><code>requires_grad=True</code> –pytorch会追踪该张量的所有计算（自动微分），以便后续进行反向传播计算梯度</li></ul><p>维度变换：</p><ul><li><code>torch.view()</code>或者<code>torch.reshape()</code> 维度重置（但总数要一致），若根据已有维度可推算出剩下的维度，可使用 -1 替代<ul><li>用于<strong>改变张量的形状</strong>，但是总元素的数量必须保持不变。</li><li>可以使用 <code>-1</code> 自动计算某一维度的大小</li></ul></li></ul><table><thead><tr><th>方法</th><th>是否共享内存</th><th>是否适用于非连续内存</th><th>适用场景</th></tr></thead><tbody><tr><td><code>view()</code></td><td>✅ 是</td><td>❌ 只能在连续内存上使用</td><td>高效调整形状（不复制数据）</td></tr><tr><td><code>reshape()</code></td><td>✅ 是（如果可能）</td><td>✅ 可以处理非连续内存</td><td>更通用，但可能触发数据复制</td></tr></tbody></table><ul><li><code>torch.reshape()</code>也可以重置维度<ul><li><strong>压缩（删除）大小为 1 的维度</strong>。</li><li>如果不指定 <code>dim</code>，则<strong>删除所有大小为 1 的维度</strong>。</li><li>如果指定 <code>dim</code>，则<strong>只压缩该维度</strong>（<strong>该维度必须为 1</strong>，否则报错）。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># shape: [1, 3, 1, 2]</span><br><br><span class="hljs-comment"># 不指定 dim，删除所有大小为 1 的维度</span><br>x_squeeze = x.squeeze()  <span class="hljs-comment"># shape: [3, 2]</span><br><span class="hljs-built_in">print</span>(x_squeeze.shape)  <span class="hljs-comment"># torch.Size([3, 2])</span><br><br><span class="hljs-comment"># 指定 dim=2（第3个维度，从0开始计数）</span><br>x_squeeze_dim = x.squeeze(dim=<span class="hljs-number">2</span>)  <span class="hljs-comment"># shape: [1, 3, 2]</span><br><span class="hljs-built_in">print</span>(x_squeeze_dim.shape)  <span class="hljs-comment"># torch.Size([1, 3, 2])</span><br><br><span class="hljs-comment"># 如果 dim 不是 1，会报错</span><br>x.squeeze(dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 报错，因为 dim=1 的大小是 3，不是 1</span><br></code></pre></td></tr></table></figure><ul><li>torch.squeeze(dim) 若不指定维度，则会将tensor中为1的dim压缩，若指定只会压缩对应的维度</li><li>torch.unsqueeze(dim) 维度扩展<ul><li><strong>在指定位置插入一个大小为 1 的维度</strong>（与 <code>squeeze</code> 相反）。</li><li>常用于<strong>扩展维度</strong>，以适应某些操作（如矩阵乘法、卷积等）。</li></ul></li><li><code>torch.cat(List[tensor,tensor],dim)</code> 向量拼接，需要指定维度<ul><li>输入一个张量列表</li><li>dim指定沿哪个维度拼接</li><li>非拼接维度的形状必须相同，否则会报错</li><li>如果 <code>dim=0</code>（行拼接），则<strong>其他维度（如列数）必须相同</strong>。</li><li>如果 <code>dim=1</code>（列拼接），则<strong>行数必须相同</strong>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 创建两个张量</span><br>x = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])  <span class="hljs-comment"># shape: [2, 2]</span><br>y = torch.tensor([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])  <span class="hljs-comment"># shape: [2, 2]</span><br><br><span class="hljs-comment"># 沿第0维（行方向）拼接</span><br>z0 = torch.cat([x, y], dim=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(z0)<br><span class="hljs-comment"># tensor([[1, 2],</span><br><span class="hljs-comment">#         [3, 4],</span><br><span class="hljs-comment">#         [5, 6],</span><br><span class="hljs-comment">#         [7, 8]])  # shape: [4, 2]</span><br><br><span class="hljs-comment"># 沿第1维（列方向）拼接</span><br>z1 = torch.cat([x, y], dim=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(z1)<br><span class="hljs-comment"># tensor([[1, 2, 5, 6],</span><br><span class="hljs-comment">#         [3, 4, 7, 8]])  # shape: [2, 4]</span><br></code></pre></td></tr></table></figure><h3 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h3><p>自定义神经网络类的基本框架：继承 nn.Module 神经网络基本类，该类实例化后输入数据将<strong>自动调用 forward 前向计算</strong></p><p>。有点没看懂。<br><img src="/img/file-20250429161016822.png"></p><p><img src="/img/file-20250429161107780.png"></p><h3 id="网络训练一般步骤"><a href="#网络训练一般步骤" class="headerlink" title="网络训练一般步骤"></a>网络训练一般步骤</h3><p>实例化网络 net &#x3D; Net() 后，<strong>定义网络优化器</strong></p><ul><li>optim &#x3D; nn.optim.Adam(net.parameters(), lr&#x3D;lr)<br>计算得到 Loss，</li><li>loss&#x3D;MSE(a,b)<br>在更新前，需清除上一步的梯度，即</li><li>optim.zero_grad()<br>然后 Loss 反向传播：</li><li>loss.backward()<br>最后优化器更新：</li><li>optim.step()</li></ul><h2 id="CNN网络训练实例"><a href="#CNN网络训练实例" class="headerlink" title="CNN网络训练实例"></a>CNN网络训练实例</h2><p>手写数字识别作为样例<br>1.读入训练集和测试集中的数字图片信息以及对图片预处理<br>2.用pytorch搭建神经网络（包括卷积和全连接神经网络）<br>3.将一个batch的训练集中的图片输入至神经网络，得到所有数字的预测分类概率（总共10个数字,0123456789）</p><p>4.根据真实标签和预测标签，利用交叉熵损失函数计算loss值，并进行梯度下降<br>5.根据测试集计算准确率，如果准确率没收敛，跳转回步骤3<br>6.画出loss、测试集准确率的曲线图<br>参考视频：<a href="https://www.bilibili.com/video/BV1Vx411j7kT?p=19">https://www.bilibili.com/video/BV1Vx411j7kT?p=19</a><br>参考代码：<a href="https://github.com/MorvanZhou/PyTorchTutorial/blob/master/tutorial%02contents/401_CNN.py">https://github.com/MorvanZhou/PyTorchTutorial/blob/master/tutorialcontents/401_CNN.py</a></p><h2 id="CNN卷积网络卷了什么？"><a href="#CNN卷积网络卷了什么？" class="headerlink" title="CNN卷积网络卷了什么？"></a>CNN卷积网络卷了什么？</h2><p>我们之前就知道图片的表示形式是一大堆数字（0-255），如果是灰色图数值代表的是灰度，而如果是彩色图记录的就是RGB颜色，使用三维张量或者三个矩阵来记录。</p><ul><li>每一个矩阵可以称为图片的一个channel，用宽高深来描述。</li></ul><p>传统的神经网络会导致物体如果处在同一个图片的不同位置，就可能会识别为不同物体，但是卷积神经网络可以捕捉图像中的局部特征而不受位置的影响。（不变性）</p><h3 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h3><p>在信号与系统课程中我们与卷积打了不少交道<br>连续：$F(x) &#x3D; \int_{-\infty}^{\infty} f(\tau) g(x - \tau) d\tau$</p><p>在卷积神经网络中，卷积操作是将一个<strong>可移动的小窗口</strong>（<strong>滤波器&#x2F;卷积核</strong>）与图像进行逐元素相乘然后相加的操作。滤波器相当于一组固定的权重。</p><p>例如：将一个 <code>6*6</code> 的网格滤波成 <code>4*4</code> 的网格，保留下来的是特征<br>这里的卷积核是一个 <code>3*3</code> 的矩阵，通过将黄色部分和卷积核进行卷积得到一个值填入到特征矩阵中，进行特征提取。<br><img src="/img/file-20250502112212143.png"></p><p><img src="/img/file-20250502112326957.png"><br>这个时候发现了边缘的特征丢失了<br>使用 <code>padding</code> 扩充方式，将 <code>6*6</code>的像素图扩充成 <code>8*8</code> 的像素图（用0填充）<br><img src="/img/file-20250502112502760.png"></p><p>因此在设置卷积神经网络时，我们需要关注这些参数</p><ul><li>步长stride：每次滑动的位置步长（也就是小窗口移动的距离）</li><li>卷积核的个数：决定输出的depth厚度</li><li>填充值zero-padding：在外围边缘用0填充（要使得总长能被步长整除）</li></ul><p>动图：<br><a href="https://i-blog.csdnimg.cn/blog_migrate/d0172774f7e42ae2f6310b63e59b4906.gif">https://i-blog.csdnimg.cn/blog_migrate/d0172774f7e42ae2f6310b63e59b4906.gif</a></p><p>卷积神经网络模型：<br><img src="/img/file-20250503095146360.png"><br>红色部分可以看做一个滤波器，多个滤波器叠加就成了卷积层</p><p>最大池化：（max pooling）<br>将图片特征进一步压缩，仅反映最突出的特点，也就是将图像切割成如图多个 <code>2*2</code> 的网格，取出每个小矩阵中最大的值。<br>池化后的数据保留了原始图片中最精华的特征<br><img src="/img/file-20250503095522607.png"></p><p>扁平化处理：<br><img src="/img/file-20250503095700734.png"><br>把池化后的数据进行扁平化处理：将两个 <code>3*3</code> 的像素图叠加转换为1维的数据条。<br>数据条作为输入，连接到全连接隐藏层，最终产生输出结果。（感觉做完转换后，得到的扁平化信息到最终输出结果就和MLP很类似了）</p><p><img src="/img/file-20250503095800527.png"></p><p>如果想进一步理解复杂的cnn模型：<a href="https://plantdraw2.samlab.cn/">CNN Explainer</a></p><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><h3 id="中药图片分类任务"><a href="#中药图片分类任务" class="headerlink" title="中药图片分类任务"></a>中药图片分类任务</h3><p>利用pytorch框架搭建神经网络实现中药图片分类，其中中药图片数据分为训练集 <code>train</code>和测试集 <code>test</code>，训练集仅用于网络训练阶段，测试集仅用于模型的性能测试阶段。训练集和测试集均包含五种不同类型的中药图片：<code>baihe</code>、<code>dangshen</code>、<code>gouqi</code>、<code>huaihua</code>、<code>jinyinhua</code>。请合理设计神经网络架构，利用训练集完成网络训练，统计网络模型的训练准确率和测试准确率，画出模型的训练过程的loss曲线、准确率曲线。</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ol><li>最后提交的代码只需包含性能最好的实现方法和参数设置. 只需提交一个代码文件, 请不要提交其他文件.</li><li>本次作业可以使用 <code>pytorch</code>库、 <code>numpy</code>库、<code>matplotlib</code>库以及python标准库.</li><li>数据集可以在Github上下载。</li><li>模型的训练性能以及测试性能均作为本次作业的评分标准。</li><li>测试集不可用于模型训练。</li><li>不能使用开源的预训练模型进行训练。</li></ol><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>我们看到训练集和测试集都是彩色图，所以我们要采用三通道卷积的方式来表示。<br><img src="/img/file-20250503101420291.png"><br>也就是分别卷积后再相加得到结果。</p><p>n通道的卷积过程：<br><img src="/img/file-20250503101455202.png"><br>或<br><img src="/img/file-20250503101534982.png"><br>卷积层：</p><ul><li><p><strong><code>nn.Conv1d</code></strong></p><ul><li>输入：<code>(batch_size, channels, length)</code></li><li>处理<strong>一维序列数据</strong>（如时间序列、文本词向量）       </li><li>例：音频波形、传感器数据、自然语言处理中的词嵌入序列。</li></ul></li><li><p><strong><code>nn.Conv2d</code></strong>    </p><ul><li>输入：<code>(batch_size, channels, height, width)</code></li><li>处理<strong>二维网格数据</strong>（如图像）。        </li><li>例：RGB图像、二维频谱图。</li></ul></li><li><p><strong><code>nn.Conv3d</code></strong></p><ul><li>输入：<code>(batch_size, channels, depth, height, width)</code>     </li><li>处理<strong>三维体数据</strong>（如视频或医学扫描图像）。      </li><li>例：视频帧（时间+空间）、CT&#x2F;MRI扫描的3D体素数据。</li></ul></li><li><p><strong><code>Conv2d</code></strong>：</p><ul><li>卷积核沿<strong>2个方向（高度和宽度）滑动</strong>，输出二维特征图。    </li><li>卷积核尺寸：<code>(kernel_size, kernel_size)</code>（如<code>3x3</code>）。</li></ul></li></ul><table><thead><tr><th>卷积类型</th><th>适用场景示例</th></tr></thead><tbody><tr><td><code>Conv1d</code></td><td>文本分类（词序列）、语音识别（音频帧）、股票预测（时间序列）</td></tr><tr><td><code>Conv2d</code></td><td>图像分类、目标检测、风格迁移（2D图像处理）</td></tr><tr><td><code>Conv3d</code></td><td>视频动作识别、医学影像分析（3D体数据）</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>, dilation=<span class="hljs-number">1</span>, groups=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><ul><li><strong>in_channels</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a>) – 输入图像中的通道数</li><li><strong>out_channels</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a>) – 卷积产生的通道数</li><li><strong>kernel_size</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a>) – 卷积核的大小</li><li><strong>stride</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>可选的</em>) – 卷积的步长。默认值：1</li><li><strong>padding</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a><em>,</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>可选的</em>) – 输入四边添加的填充。默认值：0</li><li><strong>dilation</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a> <em>或</em> <a href="https://docs.pythonlang.cn/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>可选的</em>) – 内核元素之间的间距。默认值：1</li><li><strong>groups</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#int"><em>int</em></a><em>,</em> <em>可选的</em>) – 从输入通道到输出通道的组连接数。默认值：1</li><li><strong>bias</strong> (<a href="https://docs.pythonlang.cn/3/library/functions.html#bool"><em>bool</em></a><em>,</em> <em>可选的</em>) – 如果为 <code>True</code>，则向输出添加一个可学习的偏置项。默认值：<code>True</code></li><li><strong>padding_mode</strong> (<a href="https://docs.pythonlang.cn/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>可选的</em>) – <code>&#39;zeros&#39;</code>, <code>&#39;reflect&#39;</code>, <code>&#39;replicate&#39;</code> 或 <code>&#39;circular&#39;</code>。默认值：<code>&#39;zeros&#39;</code></li></ul><p>池化层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.nn.MaxPool2d(*kernel_size*, *stride=<span class="hljs-literal">None</span>*, *padding=<span class="hljs-number">0</span>*, *dilation=<span class="hljs-number">1</span>*, *return_indices=<span class="hljs-literal">False</span>*, *ceil_mode=<span class="hljs-literal">False</span>*)<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250503102731587.png"></p><p><img src="/img/file-20250503102916495.png"></p><p>进行测试后发现，不够稳定：<br><img src="/img/file-20250504112430590.png" alt="epoches&#x3D;15"></p><p><img src="/img/file-20250504112445890.png" alt="epoches&#x3D;30"></p><p><img src="/img/file-20250504112508914.png" alt="epoches&#x3D;100"></p><p><img src="/img/file-20250504112521791.png" alt="epoches&#x3D;500"><br><img src="/img/file-20250504112538716.png" alt="epoches&#x3D;1000"><br><img src="/img/file-20250504112551762.png" alt="epoches&#x3D;2000"><br>尝试添加归一化函数<code>nn.BatchNorm2d()</code>，并去掉了随机旋转和水平翻转（因为我观察到小规模测试集里的图片还是比较正的（））</p><ul><li>测试了一下50代，感觉效果一般<br><img src="/img/file-20250504113529656.png"></li></ul><p>又尝试在预处理数据部分添加了归一化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">transforms.Normalize(<br>            mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>]<br>        ),  <span class="hljs-comment"># 常用的参数</span><br></code></pre></td></tr></table></figure><p>发现在epoches&#x3D;50的情况下效果也好了很多，将进一步尝试更多代，寻找更加稳定的代数<br><img src="/img/file-20250504113749402.png" alt="epoches&#x3D;50"></p><p>资料：<br><a href="https://blog.csdn.net/AI_dataloads/article/details/133250229">【深度学习】一文搞懂卷积神经网络（CNN）的原理（超详细）_卷积神经网络原理-CSDN博客</a><br><a href="https://blog.csdn.net/m0_55697123/article/details/119464001">python标准库 —— os模块_python中os库的作用-CSDN博客</a><a href="https://pytorch.ac.cn/docs/stable/nn.html#convolution-layers">torch.nn — PyTorch 2.7 文档 - PyTorch 深度学习库</a></p><p><a href="https://zhuanlan.zhihu.com/p/163613814">python进度条库tqdm详解 - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ai新手赛部分题解</title>
    <link href="/2025/04/29/ai%E6%96%B0%E6%89%8B%E8%B5%9B%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/29/ai%E6%96%B0%E6%89%8B%E8%B5%9B%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>比赛结果：<br><img src="/img/file-20250429113148114.png"></p><p><img src="/img/d7c6ae3d320a570860ea2a249e091e3.jpg" alt="排行榜"></p><p><img src="/img/f5c32e6412ef17296b10162cf510e4d.jpg" alt="最后得分"></p><p><img src="/img/af1752655222fcb5c747d3799a11201.jpg" alt="奖品+奖状"></p><h1 id="NS-2025-00-须弥识花大赛-解题报告（Writeup）"><a href="#NS-2025-00-须弥识花大赛-解题报告（Writeup）" class="headerlink" title="NS-2025-00 须弥识花大赛 解题报告（Writeup）"></a>NS-2025-00 须弥识花大赛 解题报告（Writeup）</h1><h2 id="一、赛题理解与任务目标"><a href="#一、赛题理解与任务目标" class="headerlink" title="一、赛题理解与任务目标"></a>一、赛题理解与任务目标</h2><p>本次比赛模拟须弥地区的生态危机，任务目标是构建一个具备泛化能力的花卉识别 AI，能够在复杂环境下准确分类多种花卉种类。</p><p>从技术角度看，本题实质为一个 <strong>多类图像分类任务</strong>，即输入为一张图像，输出为其对应的花卉类别标签。该任务可归结为监督学习问题，挑战点在于：</p><ul><li>样本环境多变（雨天、晴天、被踩踏等）</li><li>类别较多且视觉相似度高</li><li>泛化能力要求高，需适应未知测试集</li></ul><h2 id="二、解题思路概述"><a href="#二、解题思路概述" class="headerlink" title="二、解题思路概述"></a>二、解题思路概述</h2><p>为应对复杂多变的测试图像环境，我们采用了如下整体策略：</p><ol><li><strong>数据增强 + 多模型集成</strong> 提升泛化能力；</li><li><strong>MixUp &#x2F; CutMix</strong> 等标签混合增强强化训练；</li><li><strong>使用预训练模型迁移学习</strong>，充分利用 ImageNet 语义特征；</li><li><strong>引入 Label Smoothing</strong> 缓解过拟合；</li><li><strong>测试时增强（TTA）</strong> 提高鲁棒性；</li><li><strong>早停机制</strong> 控制训练轮次防止过拟合。</li></ol><h2 id="三、模型设计与训练策略"><a href="#三、模型设计与训练策略" class="headerlink" title="三、模型设计与训练策略"></a>三、模型设计与训练策略</h2><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>我们构建了一个自定义的 <strong>多模型集成系统</strong>，结构如下：</p><table><thead><tr><th>序号</th><th>模型名称</th><th>预训练</th><th>修改输出层</th><th>Dropout</th></tr></thead><tbody><tr><td>1</td><td>ResNet50</td><td>✔️</td><td>Linear</td><td>0.5</td></tr><tr><td>2</td><td>EfficientNet-B0</td><td>✔️</td><td>Linear</td><td>0.3</td></tr><tr><td>3</td><td>MobileNetV3-Large</td><td>✔️</td><td>Linear</td><td>0.3</td></tr></tbody></table><blockquote><p>所有模型的输出通过“软投票”方式（概率平均）融合，提高整体鲁棒性。</p></blockquote><h3 id="数据增强策略"><a href="#数据增强策略" class="headerlink" title="数据增强策略"></a>数据增强策略</h3><ul><li><strong>训练集</strong>：使用多种图像变换组合（旋转、裁剪、亮度扰动、自动对比、灰度化、随机擦除）；</li><li><strong>标签增强</strong>：随机应用 MixUp（β&#x3D;0.2）或 CutMix（β&#x3D;1.0）进行样本合成；</li><li><strong>验证集&#x2F;测试集</strong>：保持中心裁剪 + 标准归一化，确保一致性。</li></ul><h3 id="损失函数与优化器"><a href="#损失函数与优化器" class="headerlink" title="损失函数与优化器"></a>损失函数与优化器</h3><ul><li>损失函数：使用 <strong>LabelSmoothingLoss</strong>（smoothing&#x3D;0.1）防止模型过拟合；</li><li>优化器：<strong>AdamW</strong> + <strong>OneCycleLR</strong> 学习率调度；</li><li>混合精度训练 + 梯度裁剪，提升效率并稳定训练过程。</li></ul><h3 id="训练控制机制"><a href="#训练控制机制" class="headerlink" title="训练控制机制"></a>训练控制机制</h3><ul><li>使用 <strong>早停机制</strong>（patience&#x3D;10）防止过拟合；</li><li>训练轮数：最多 30 epoch；</li><li>模型存储：保存最佳与最终模型权重，方便后续推理与对比。</li></ul><h2 id="四、模型预测与推理流程"><a href="#四、模型预测与推理流程" class="headerlink" title="四、模型预测与推理流程"></a>四、模型预测与推理流程</h2><h3 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h3><p>我们定义了自动化加载 <code>model_info.json</code> + <code>*.pth</code> 权重的流程，自动判断使用集成 or 单模型结构。</p><h3 id="测试时增强（TTA）"><a href="#测试时增强（TTA）" class="headerlink" title="测试时增强（TTA）"></a>测试时增强（TTA）</h3><p>为了提高推理阶段的鲁棒性，对每张测试图像进行多种视图增强，具体包括：</p><ol><li>原始图像；</li><li>水平翻转；</li><li>垂直翻转；</li><li>尺寸裁剪；</li><li>亮度扰动。</li></ol><p>对上述增强图像进行推理后平均预测结果，提高模型的鲁棒性和准确性。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>最终输出为 <code>results.csv</code>，包含：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csv">file_name,label<br>123.jpg,7<br>...<br></code></pre></td></tr></table></figure><p>确保与比赛提交格式一致。</p><h2 id="五、性能评估与可视化"><a href="#五、性能评估与可视化" class="headerlink" title="五、性能评估与可视化"></a>五、性能评估与可视化</h2><p>训练阶段使用验证集进行模型性能评估，并生成：</p><ul><li>分类报告（classification_report.txt）；</li><li>混淆矩阵（confusion_matrix.png）；</li><li>训练曲线（training_history.png）；</li><li>预测可视化（model_predictions.png）。</li></ul><p>这些可视化图像有效支持模型诊断和调优。</p><h2 id="六、使用的工具与框架"><a href="#六、使用的工具与框架" class="headerlink" title="六、使用的工具与框架"></a>六、使用的工具与框架</h2><ul><li><strong>语言</strong>：Python 3.8+</li><li><strong>深度学习框架</strong>：PyTorch 1.13</li><li><strong>计算资源</strong>：NVIDIA GPU (CUDA 加速)</li><li><strong>辅助库</strong>：NumPy、Pandas、sklearn、Pillow、tqdm、seaborn、matplotlib、torchvision</li><li><strong>ai工具</strong>：copilot–claude3.7sonnet</li></ul><h2 id="七、总结与经验教训"><a href="#七、总结与经验教训" class="headerlink" title="七、总结与经验教训"></a>七、总结与经验教训</h2><ul><li>多模型融合是提升分类精度的重要手段；</li><li>数据增强和标签平滑有效提高泛化能力；</li><li>测试时增强进一步改善预测稳定性；</li><li>合理的训练控制策略（如早停和混合精度）提升了训练效率和最终性能。</li></ul><p>最终模型在验证集上表现稳定，预测准确率高，泛化能力强，能够较好适应测试集中复杂多变的花卉图像。效果良好，但达不到优秀，得分360。</p><h2 id="附录一：关键代码模块"><a href="#附录一：关键代码模块" class="headerlink" title="附录一：关键代码模块"></a>附录一：关键代码模块</h2><h3 id="模型构建（多模型集成）"><a href="#模型构建（多模型集成）" class="headerlink" title="模型构建（多模型集成）"></a>模型构建（多模型集成）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelEnsemble</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_classes, device, num_models=<span class="hljs-number">3</span>, model_types=<span class="hljs-literal">None</span>, use_pretrained=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-built_in">super</span>(ModelEnsemble, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.models = []<br>        <span class="hljs-variable language_">self</span>.device = device<br>        <span class="hljs-variable language_">self</span>.num_models = num_models<br>        ...<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_models):<br>            model_type = model_types[i % <span class="hljs-built_in">len</span>(model_types)]<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;resnet&#x27;</span> <span class="hljs-keyword">in</span> model_type:<br>                model = torchvision.models.resnet50(weights=pretrained_weights)<br>                num_ftrs = model.fc.in_features<br>                model.fc = nn.Sequential(nn.Dropout(<span class="hljs-number">0.5</span>), nn.Linear(num_ftrs, num_classes))<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;efficientnet&#x27;</span> <span class="hljs-keyword">in</span> model_type:<br>                model = torchvision.models.efficientnet_b0(weights=pretrained_weights)<br>                num_ftrs = model.classifier[<span class="hljs-number">1</span>].in_features<br>                model.classifier[<span class="hljs-number">1</span>] = nn.Sequential(nn.Dropout(<span class="hljs-number">0.3</span>), nn.Linear(num_ftrs, num_classes))<br>            <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;mobilenet&#x27;</span> <span class="hljs-keyword">in</span> model_type:<br>                model = torchvision.models.mobilenet_v3_large(weights=pretrained_weights)<br>                num_ftrs = model.classifier[<span class="hljs-number">3</span>].in_features<br>                model.classifier[<span class="hljs-number">3</span>] = nn.Sequential(nn.Dropout(<span class="hljs-number">0.3</span>), nn.Linear(num_ftrs, num_classes))<br>            <span class="hljs-variable language_">self</span>.models.append(model.to(device))<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        outputs = [model(x) <span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.models]<br>        <span class="hljs-keyword">return</span> torch.mean(torch.stack(outputs), dim=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="标签混合增强（MixUp-CutMix）"><a href="#标签混合增强（MixUp-CutMix）" class="headerlink" title="标签混合增强（MixUp &amp; CutMix）"></a>标签混合增强（MixUp &amp; CutMix）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MixUp</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, alpha=<span class="hljs-number">0.2</span></span>): <span class="hljs-variable language_">self</span>.alpha = alpha<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, batch, targets</span>):<br>        lam = np.random.beta(<span class="hljs-variable language_">self</span>.alpha, <span class="hljs-variable language_">self</span>.alpha)<br>        index = torch.randperm(batch.size(<span class="hljs-number">0</span>)).to(batch.device)<br>        mixed_batch = lam * batch + (<span class="hljs-number">1</span> - lam) * batch[index]<br>        <span class="hljs-keyword">return</span> mixed_batch, targets, targets[index], lam<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CutMix</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, alpha=<span class="hljs-number">1.0</span></span>): <span class="hljs-variable language_">self</span>.alpha = alpha<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, batch, targets</span>):<br>        lam = np.random.beta(<span class="hljs-variable language_">self</span>.alpha, <span class="hljs-variable language_">self</span>.alpha)<br>        index = torch.randperm(batch.size(<span class="hljs-number">0</span>)).to(batch.device)<br>        bbx1, bby1, bbx2, bby2 = <span class="hljs-variable language_">self</span>._rand_bbox(batch.size(), lam)<br>        batch[:, :, bbx1:bbx2, bby1:bby2] = batch[index, :, bbx1:bbx2, bby1:bby2]<br>        lam = <span class="hljs-number">1</span> - ((bbx2 - bbx1) * (bby2 - bby1)) / (batch.size(-<span class="hljs-number">1</span>) * batch.size(-<span class="hljs-number">2</span>))<br>        <span class="hljs-keyword">return</span> batch, targets, targets[index], lam<br></code></pre></td></tr></table></figure><hr><h3 id="标签平滑损失函数"><a href="#标签平滑损失函数" class="headerlink" title="标签平滑损失函数"></a>标签平滑损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LabelSmoothingLoss</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, classes, smoothing=<span class="hljs-number">0.1</span></span>):<br>        <span class="hljs-built_in">super</span>(LabelSmoothingLoss, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>.confidence = <span class="hljs-number">1.0</span> - smoothing<br>        <span class="hljs-variable language_">self</span>.smoothing = smoothing<br>        <span class="hljs-variable language_">self</span>.cls = classes<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, pred, target</span>):<br>        pred = pred.log_softmax(dim=-<span class="hljs-number">1</span>)<br>        true_dist = torch.zeros_like(pred)<br>        true_dist.fill_(<span class="hljs-variable language_">self</span>.smoothing / (<span class="hljs-variable language_">self</span>.cls - <span class="hljs-number">1</span>))<br>        true_dist.scatter_(<span class="hljs-number">1</span>, target.unsqueeze(<span class="hljs-number">1</span>), <span class="hljs-variable language_">self</span>.confidence)<br>        <span class="hljs-keyword">return</span> torch.mean(torch.<span class="hljs-built_in">sum</span>(-true_dist * pred, dim=-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><hr><h3 id="测试时增强（TTA）-1"><a href="#测试时增强（TTA）-1" class="headerlink" title="测试时增强（TTA）"></a>测试时增强（TTA）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_time_augmentation</span>(<span class="hljs-params">model, image, transform, device, num_augmentations=<span class="hljs-number">5</span></span>):<br>    model.<span class="hljs-built_in">eval</span>()<br>    predictions = []<br><br>    <span class="hljs-comment"># 原图预测</span><br>    image_tensor = transform(image).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(image_tensor))<br><br>    <span class="hljs-comment"># 水平翻转</span><br>    h_tensor = transform(transforms.functional.hflip(image)).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(h_tensor))<br><br>    <span class="hljs-comment"># 垂直翻转</span><br>    v_tensor = transform(transforms.functional.vflip(image)).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(v_tensor))<br><br>    <span class="hljs-comment"># 中心裁剪+亮度扰动</span><br>    jitter_transform = transforms.Compose([<br>        transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>),<br>        transform<br>    ])<br>    jitter_tensor = jitter_transform(image).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>    predictions.append(model(jitter_tensor))<br><br>    <span class="hljs-comment"># 综合平均</span><br>    <span class="hljs-keyword">return</span> torch.mean(torch.stack(predictions), dim=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h1 id="NS-2025-07-LLM-to-BTs–Writeup"><a href="#NS-2025-07-LLM-to-BTs–Writeup" class="headerlink" title="NS-2025-07 LLM to BTs–Writeup"></a>NS-2025-07 LLM to BTs–Writeup</h1><h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>本题要求实现一个将英文自然语言指令自动转换为行为树(Behavior Tree)结构化XML的系统。系统需要将用户文本指令转换为符合BehaviorTree.CPP库和Groot可视化工具要求的XML，并且以规定格式输出，包含119个使用CDATA包装的item元素。系统需要正确理解指令中的执行逻辑，并构建相应的行为树结构。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>针对不使用大语言模型的环境限制，我实现了一个基于规则和模式匹配的SimpleBehaviorTreeGenerator类。主要解题思路包括：</p><h3 id="1-数据分析与样例学习"><a href="#1-数据分析与样例学习" class="headerlink" title="1. 数据分析与样例学习"></a>1. 数据分析与样例学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_training_examples</span>(<span class="hljs-params">self, input_file, output_file, max_examples=<span class="hljs-number">20</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;加载训练示例用于参考&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        inputs = json.load(f)<br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        outputs = json.load(f)<br>        <br>    <span class="hljs-comment"># 选择示例（简单起见，取前N个）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(inputs[:max_examples], outputs[:max_examples]))<br></code></pre></td></tr></table></figure><p>通过载入训练样例，系统可以参考已有的指令-行为树对应关系，提高生成质量。为了节省内存，我只载入了前20个样例作为参考。</p><h3 id="2-基于相似度的模式匹配"><a href="#2-基于相似度的模式匹配" class="headerlink" title="2. 基于相似度的模式匹配"></a>2. 基于相似度的模式匹配</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_similar_example</span>(<span class="hljs-params">self, instruction</span>):<br>    <span class="hljs-comment"># 提取指令中的关键词</span><br>    keywords = <span class="hljs-variable language_">self</span>.extract_keywords(instruction)<br>    <br>    best_match = <span class="hljs-literal">None</span><br>    best_score = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> ex_input, ex_output <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.train_examples:<br>        <span class="hljs-comment"># 计算关键词匹配度</span><br>        ex_keywords = <span class="hljs-variable language_">self</span>.extract_keywords(ex_input)<br>        common_keywords = <span class="hljs-built_in">set</span>(keywords) &amp; <span class="hljs-built_in">set</span>(ex_keywords)<br>        score = <span class="hljs-built_in">len</span>(common_keywords) / <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(keywords), <span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-keyword">if</span> score &gt; best_score <span class="hljs-keyword">and</span> score &gt; <span class="hljs-number">0.2</span>:  <span class="hljs-comment"># 至少20%的关键词匹配</span><br>            best_score = score<br>            best_match = (ex_input, ex_output)<br>    <br>    <span class="hljs-keyword">return</span> best_match<br></code></pre></td></tr></table></figure><p>系统会尝试在训练样例中找到与输入指令相似的例子，通过关键词匹配计算相似度，当相似度超过20%时，可以借鉴其行为树结构。</p><h3 id="3-规则化语义解析"><a href="#3-规则化语义解析" class="headerlink" title="3. 规则化语义解析"></a>3. 规则化语义解析</h3><p>为了从文本中提取动作和条件，我实现了多个关键函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_actions</span>(<span class="hljs-params">self, text</span>):<br>    <span class="hljs-comment"># 基于常见动词的简单提取</span><br>    action_list = []<br>    <br>    <span class="hljs-comment"># 常见动作动词</span><br>    action_verbs = [<span class="hljs-string">&quot;打开&quot;</span>, <span class="hljs-string">&quot;关闭&quot;</span>, <span class="hljs-string">&quot;移动&quot;</span>, <span class="hljs-string">&quot;走向&quot;</span>, <span class="hljs-string">&quot;前进&quot;</span>, <span class="hljs-string">&quot;后退&quot;</span>, <span class="hljs-string">&quot;转向&quot;</span>, <span class="hljs-string">&quot;拿起&quot;</span>, <span class="hljs-string">&quot;放下&quot;</span>,<br>                    <span class="hljs-string">&quot;检查&quot;</span>, <span class="hljs-string">&quot;观察&quot;</span>, <span class="hljs-string">&quot;寻找&quot;</span>, <span class="hljs-string">&quot;等待&quot;</span>, <span class="hljs-string">&quot;计算&quot;</span>, <span class="hljs-string">&quot;进入&quot;</span>, <span class="hljs-string">&quot;离开&quot;</span>, <span class="hljs-string">&quot;拿&quot;</span>, <span class="hljs-string">&quot;取&quot;</span>, <br>                    <span class="hljs-string">&quot;放置&quot;</span>, <span class="hljs-string">&quot;推&quot;</span>, <span class="hljs-string">&quot;拉&quot;</span>, <span class="hljs-string">&quot;跳&quot;</span>, <span class="hljs-string">&quot;握住&quot;</span>, <span class="hljs-string">&quot;松开&quot;</span>, <span class="hljs-string">&quot;启动&quot;</span>, <span class="hljs-string">&quot;停止&quot;</span>, <span class="hljs-string">&quot;跟随&quot;</span>,<br>                    <span class="hljs-string">&quot;测量&quot;</span>, <span class="hljs-string">&quot;抓取&quot;</span>, <span class="hljs-string">&quot;识别&quot;</span>, <span class="hljs-string">&quot;使用&quot;</span>, <span class="hljs-string">&quot;保存&quot;</span>, <span class="hljs-string">&quot;下载&quot;</span>, <span class="hljs-string">&quot;上传&quot;</span>, <span class="hljs-string">&quot;执行&quot;</span>, <span class="hljs-string">&quot;完成&quot;</span>]<br>    <br>    <span class="hljs-comment"># 分割文本</span><br>    parts = re.split(<span class="hljs-string">r&#x27;[,，。、；;]&#x27;</span>, text)<br>    <br>    <span class="hljs-comment"># 检查每个部分是否包含动作</span><br>    <span class="hljs-keyword">for</span> part <span class="hljs-keyword">in</span> parts:<br>        <span class="hljs-comment"># 省略实现细节...</span><br>        <br>    <span class="hljs-keyword">return</span> action_list<br></code></pre></td></tr></table></figure><p>虽然代码中包含了中文动词列表，但考虑到实际测试集全是英文，我在实际部署前对代码做了修改，补充了英文动词列表，如”move”、”go”、”turn”、”pick”等。</p><h3 id="4-控制结构判断"><a href="#4-控制结构判断" class="headerlink" title="4. 控制结构判断"></a>4. 控制结构判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">determine_control_structure</span>(<span class="hljs-params">self, text</span>):<br>    <span class="hljs-comment"># 默认使用顺序执行</span><br>    structure = <span class="hljs-string">&quot;Sequence&quot;</span><br>    <br>    <span class="hljs-comment"># 检查是否存在选择逻辑</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(keyword <span class="hljs-keyword">in</span> text <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;或者&quot;</span>, <span class="hljs-string">&quot;否则&quot;</span>, <span class="hljs-string">&quot;要么&quot;</span>, <span class="hljs-string">&quot;如果不&quot;</span>, <span class="hljs-string">&quot;失败后&quot;</span>, <span class="hljs-string">&quot;选择&quot;</span>]):<br>        structure = <span class="hljs-string">&quot;Fallback&quot;</span><br>    <br>    <span class="hljs-comment"># 检查是否存在并行逻辑</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(keyword <span class="hljs-keyword">in</span> text <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;同时&quot;</span>, <span class="hljs-string">&quot;并行&quot;</span>, <span class="hljs-string">&quot;一起&quot;</span>, <span class="hljs-string">&quot;并且&quot;</span>, <span class="hljs-string">&quot;一边&quot;</span>, <span class="hljs-string">&quot;同步&quot;</span>]):<br>        structure = <span class="hljs-string">&quot;Parallel&quot;</span><br>    <br>    <span class="hljs-comment"># 检查是否需要反应式</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(keyword <span class="hljs-keyword">in</span> text <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;持续检查&quot;</span>, <span class="hljs-string">&quot;保持&quot;</span>, <span class="hljs-string">&quot;反复&quot;</span>, <span class="hljs-string">&quot;一直&quot;</span>, <span class="hljs-string">&quot;直到&quot;</span>, <span class="hljs-string">&quot;监控&quot;</span>]):<br>        <span class="hljs-keyword">if</span> structure == <span class="hljs-string">&quot;Sequence&quot;</span>:<br>            structure = <span class="hljs-string">&quot;ReactiveSequence&quot;</span><br>        <span class="hljs-keyword">elif</span> structure == <span class="hljs-string">&quot;Fallback&quot;</span>:<br>            structure = <span class="hljs-string">&quot;ReactiveFallback&quot;</span><br>    <br>    <span class="hljs-keyword">return</span> structure<br></code></pre></td></tr></table></figure><p>同样，在实际部署前，我将关键词判断逻辑修改为英文版本，增加了”or”、”else”、”parallel”、”simultaneously”、”continuous”等关键词。</p><h3 id="5-XML树构建与验证"><a href="#5-XML树构建与验证" class="headerlink" title="5. XML树构建与验证"></a>5. XML树构建与验证</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_xml_tree</span>(<span class="hljs-params">self, actions, conditions, control_structure</span>):<br>    xml = <span class="hljs-string">f&#x27;&lt;root BTCPP_format=&quot;4&quot;&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">f&#x27;  &lt;BehaviorTree ID=&quot;MainTree&quot;&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">f&#x27;    &lt;<span class="hljs-subst">&#123;control_structure&#125;</span> name=&quot;Root<span class="hljs-subst">&#123;control_structure&#125;</span>&quot;&gt;\n&#x27;</span><br>    <br>    <span class="hljs-comment"># 添加条件节点</span><br>    <span class="hljs-keyword">for</span> condition <span class="hljs-keyword">in</span> conditions:<br>        xml += <span class="hljs-string">f&#x27;      &lt;Condition ID=&quot;<span class="hljs-subst">&#123;condition[<span class="hljs-string">&quot;ID&quot;</span>]&#125;</span>&quot; /&gt;\n&#x27;</span><br>    <br>    <span class="hljs-comment"># 添加动作节点</span><br>    <span class="hljs-keyword">for</span> action <span class="hljs-keyword">in</span> actions:<br>        xml += <span class="hljs-string">f&#x27;      &lt;Action ID=&quot;<span class="hljs-subst">&#123;action[<span class="hljs-string">&quot;ID&quot;</span>]&#125;</span>&quot; /&gt;\n&#x27;</span><br>    <br>    xml += <span class="hljs-string">f&#x27;    &lt;/<span class="hljs-subst">&#123;control_structure&#125;</span>&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">f&#x27;  &lt;/BehaviorTree&gt;\n&#x27;</span><br>    xml += <span class="hljs-string">&#x27;&lt;/root&gt;&#x27;</span><br>    <br>    <span class="hljs-keyword">return</span> xml<br></code></pre></td></tr></table></figure><p>这个函数构建了符合BehaviorTree.CPP格式的XML结构，通过validate_xml函数进行检查确保结构合法。</p><h3 id="6-CDATA标签处理"><a href="#6-CDATA标签处理" class="headerlink" title="6. CDATA标签处理"></a>6. CDATA标签处理</h3><p>最初遇到的主要技术困难是ElementTree库不直接支持CDATA标签。解决方案是使用minidom库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提取所有item节点并手动添加CDATA</span><br>item_nodes = items_node.getElementsByTagName(<span class="hljs-string">&quot;item&quot;</span>)<br><br><span class="hljs-keyword">for</span> item_node <span class="hljs-keyword">in</span> item_nodes:<br>    <span class="hljs-comment"># 获取文本内容</span><br>    text_content = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> item_node.childNodes:<br>        <span class="hljs-keyword">if</span> child.nodeType == minidom.Node.TEXT_NODE:<br>            text_content += child.data<br>    <br>    <span class="hljs-comment"># 清除所有子节点</span><br>    <span class="hljs-keyword">while</span> item_node.hasChildNodes():<br>        item_node.removeChild(item_node.firstChild)<br>    <br>    <span class="hljs-comment"># 创建新的CDATA节点</span><br>    cdata = reparsed.createCDATASection(text_content)<br>    item_node.appendChild(cdata)<br></code></pre></td></tr></table></figure><p>这段代码解决了将XML内容正确包装在CDATA标签中的问题，确保输出符合要求格式。</p><h2 id="实现中的关键技术难点与解决方案"><a href="#实现中的关键技术难点与解决方案" class="headerlink" title="实现中的关键技术难点与解决方案"></a>实现中的关键技术难点与解决方案</h2><h3 id="1-CDATA节点处理"><a href="#1-CDATA节点处理" class="headerlink" title="1. CDATA节点处理"></a>1. CDATA节点处理</h3><p><strong>问题</strong>: ElementTree库不直接支持创建CDATA节点，导致初始实现时出错。</p><p><strong>解决方案</strong>: 使用minidom库替代处理CDATA部分，通过createCDATASection方法创建CDATA节点，并手动替换原有文本节点。</p><h3 id="2-英文自然语言理解"><a href="#2-英文自然语言理解" class="headerlink" title="2. 英文自然语言理解"></a>2. 英文自然语言理解</h3><p><strong>问题</strong>: 代码初始设计时主要考虑了中文关键词，不适合全英文测试集。</p><p><strong>解决方案</strong>: 在实际部署前，修改了关键词列表，添加了英文动作动词和条件关键词，并调整了相关的正则表达式和文本处理逻辑。</p><h3 id="3-输出格式标准化"><a href="#3-输出格式标准化" class="headerlink" title="3. 输出格式标准化"></a>3. 输出格式标准化</h3><p><strong>问题</strong>: 需要确保生成119个item元素，即使测试输入可能少于这个数量。</p><p><strong>解决方案</strong>: 在process_test_set方法中强制处理119个项目，对于超出测试集范围的项目使用空字符串作为内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 确保处理119个项目</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">120</span>):<br>    <span class="hljs-comment"># 如果索引超出测试输入范围，使用空XML</span><br>    <span class="hljs-keyword">if</span> i-<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(test_inputs):<br>        instruction = test_inputs[i-<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 生成行为树</span><br>        xml_output = <span class="hljs-variable language_">self</span>.generate_behavior_tree(instruction)<br>    <span class="hljs-keyword">else</span>:<br>        logger.info(<span class="hljs-string">f&quot;No instruction for item <span class="hljs-subst">&#123;i&#125;</span>, using empty XML&quot;</span>)<br>        xml_output = <span class="hljs-string">&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># 创建item元素...</span><br></code></pre></td></tr></table></figure><h2 id="使用的工具与依赖"><a href="#使用的工具与依赖" class="headerlink" title="使用的工具与依赖"></a>使用的工具与依赖</h2><ol><li><p><strong>Python 3.8+</strong>: 主要开发语言</p></li><li><p><strong>Standard Library</strong>:</p><ul><li>xml.etree.ElementTree: XML树操作</li><li>xml.dom.minidom: CDATA处理与XML格式化</li><li>re: 正则表达式用于文本分析</li><li>json: 读取训练和测试数据</li><li>logging: 日志记录和调试</li><li>argparse: 命令行参数解析</li><li>datetime: 性能监测</li></ul></li><li><p>ai工具：claude 3.7sonnet</p></li></ol><h2 id="关键算法分析"><a href="#关键算法分析" class="headerlink" title="关键算法分析"></a>关键算法分析</h2><h3 id="1-相似度计算算法"><a href="#1-相似度计算算法" class="headerlink" title="1. 相似度计算算法"></a>1. 相似度计算算法</h3><p>使用集合交集计算关键词匹配度，算法复杂度为O(len(keywords))，通过设置阈值0.2确保只使用足够相似的样例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">common_keywords = <span class="hljs-built_in">set</span>(keywords) &amp; <span class="hljs-built_in">set</span>(ex_keywords)<br>score = <span class="hljs-built_in">len</span>(common_keywords) / <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(keywords), <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="2-动作提取算法"><a href="#2-动作提取算法" class="headerlink" title="2. 动作提取算法"></a>2. 动作提取算法</h3><p>通过文本分割和动词匹配，识别可能的动作，复杂度为O(n*m)，其中n是文本片段数，m是动词列表长度。</p><h3 id="3-控制结构判断算法"><a href="#3-控制结构判断算法" class="headerlink" title="3. 控制结构判断算法"></a>3. 控制结构判断算法</h3><p>通过关键词匹配确定最合适的控制结构，采用优先级判断的方式处理多种可能性。</p><h2 id="实验结果与性能"><a href="#实验结果与性能" class="headerlink" title="实验结果与性能"></a>实验结果与性能</h2><p>在我的测试环境中，系统能够在几秒内处理完119个指令，转换效率较高。通过日志记录，分析了成功率和常见失败模式，不断调整关键词列表和规则逻辑，提高了整体处理质量。</p><p>由于没有使用大语言模型，系统在处理复杂语义和隐含逻辑时存在局限性，但对于结构化明确的指令有良好表现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我实现的SimpleBehaviorTreeGenerator系统通过<strong>规则匹配和模式识别</strong>，成功实现了英文自然语言指令到行为树XML的自动转换。系统不依赖大型语言模型，通过简单有效的文本处理技术和结构生成规则，提供了合理的转换质量。特别是通过样例学习和相似度匹配，结合精心设计的规则库，系统能够处理多种常见指令模式，生成符合BehaviorTree.CPP标准的行为树结构。</p><p>虽然相比大型语言模型，规则化方法在语义理解的深度上存在局限，但在计算资源受限的环境中，这种方法提供了一个高效且实用的解决方案。通过将CDATA处理、XML验证等关键技术融入系统，确保了输出格式的规范性和有效性。</p><h1 id="NS-2025-08-我搭的靶场-题解"><a href="#NS-2025-08-我搭的靶场-题解" class="headerlink" title="NS-2025-08 我搭的靶场 题解"></a>NS-2025-08 我搭的靶场 题解</h1><h2 id="题目理解"><a href="#题目理解" class="headerlink" title="题目理解"></a>题目理解</h2><p>本题要求我们设计一个二维障碍场景，用于测试强化学习无人机智能体 Alpha Pilot 的路径规划能力。我们需要布置起点、终点和最多30个圆形障碍物，目标是让智能体尽可能失败（高失败率、长路径），同时保证场景理论上可解。</p><p>关键约束条件：</p><ul><li>场地大小：50m × 50m</li><li>起点和终点距离至少20m</li><li>障碍物半径1m，障碍物间距≥3m</li><li>起点&#x2F;终点与障碍物距离≥2.5m</li><li>无人机半径0.5m，最大速度2m&#x2F;s</li></ul><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-分析智能体弱点"><a href="#1-分析智能体弱点" class="headerlink" title="1. 分析智能体弱点"></a>1. 分析智能体弱点</h3><p>通过研究<code>agent.py</code>代码，可以发现Alpha Pilot智能体有以下潜在弱点：</p><ul><li>使用Q-learning算法，可能对复杂环境泛化能力有限</li><li>感知范围有限（约15m）</li><li>在障碍物附近有<strong>负奖励</strong>，可能导致”<strong>畏惧</strong>“靠近障碍物</li><li>可能有<strong>方向偏好</strong>（如倾向于向右或向上移动）</li></ul><h3 id="2-设计策略性障碍布局"><a href="#2-设计策略性障碍布局" class="headerlink" title="2. 设计策略性障碍布局"></a>2. 设计策略性障碍布局</h3><p>基于上述分析，我们设计了几种针对性的障碍布局策略：</p><h4 id="a-误导性路径"><a href="#a-误导性路径" class="headerlink" title="a) 误导性路径"></a>a) 误导性路径</h4><ul><li>在起点和终点之间创建看似合理但实际是死胡同的路径</li><li>利用无人机对特定方向的偏好设置陷阱</li></ul><h4 id="b-感知边界障碍"><a href="#b-感知边界障碍" class="headerlink" title="b) 感知边界障碍"></a>b) 感知边界障碍</h4><ul><li>在无人机感知范围边界（约15m）布置障碍物</li><li>使无人机难以提前规划路径，容易陷入局部最优</li></ul><h4 id="c-狭窄通道"><a href="#c-狭窄通道" class="headerlink" title="c) 狭窄通道"></a>c) 狭窄通道</h4><ul><li>设计宽度刚好略大于无人机通过能力的通道（约3.5m）</li><li>利用无人机对靠近障碍物的负奖励，使其犹豫不决</li></ul><h4 id="d-迷宫结构"><a href="#d-迷宫结构" class="headerlink" title="d) 迷宫结构"></a>d) 迷宫结构</h4><ul><li>创建复杂的迷宫式布局</li><li>增加路径规划的复杂度，容易使智能体迷失方向</li></ul><h3 id="3-遗传算法优化"><a href="#3-遗传算法优化" class="headerlink" title="3. 遗传算法优化"></a>3. 遗传算法优化</h3><p>使用遗传算法自动优化环境设计：</p><ol><li><strong>初始化种群</strong>：随机生成多个满足约束的环境</li><li><strong>评估适应度</strong>：通过test_scoring.py评估每个环境的失败率和平均步数</li><li><strong>选择精英</strong>：保留表现最好的环境</li><li><strong>交叉变异</strong>：组合优秀环境的特征并引入随机变化</li><li><strong>迭代优化</strong>：重复上述过程直到收敛</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>我们通过编写一个随机生成合理有效路障地图并测试失败率的程序来自我迭代搜索出最佳路障地图，主要类<code>EnvironmentOptimizer</code>实现了上述思路：</p><ol><li><p><strong>环境生成</strong>：</p><ul><li><code>generate_random_environment</code>：创建随机但有效的基础环境</li><li>四种策略方法创建针对性障碍物</li></ul></li><li><p><strong>评估函数</strong>：</p><ul><li>调用<code>test_scoring.py</code>获取失败率和平均步数</li><li>计算综合得分（失败率×300 + min(平均步数&#x2F;50000, 0.9)×100）</li></ul></li><li><p><strong>遗传算法</strong>：</p><ul><li>种群初始化、选择、交叉、变异</li><li>保留精英个体确保不退化</li></ul></li><li><p><strong>约束检查</strong>：</p><ul><li>确保所有几何约束得到满足</li><li>验证环境可解性</li></ul></li></ol><h2 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h2><p>经过多代进化，算法能够找到使智能体高失败率的环境特征：</p><ul><li>在关键路径点设置”陷阱”区域</li><li>利用狭窄通道增加决策难度</li><li>在感知边界布置障碍物限制信息获取</li><li>保持理论可解性但实际很难通过</li></ul><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol><li><p>运行<code>python solution.py</code>开始优化过程</p></li><li><p>程序会自动保存最佳环境到<code>results.json</code></p></li><li><p>可使用<code>test_env.py</code>可视化结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python test_env.py results.json --test-agent<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>test_scoring.py</code>来进行评分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python test_scoring.py results.json <br></code></pre></td></tr></table></figure><ul><li>我们本地测试是可以实现让agent十次都失败，但是最终提交结果没有拿到400分满分，可能还是稍微有些许漏洞或者应该多提交几次（hh。（最终得分是：399.95）</li></ul></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过分析智能体弱点并针对性设计障碍布局，结合遗传算法自动优化，我们能够创建出理论上可解但实际上极具挑战性的测试环境。这种方法不仅适用于本题，也可推广到其他智能体测试场景的设计中。</p><p>最佳环境通常具有以下特征：</p><ul><li>起点和终点位于对角线位置（最大化距离）</li><li>25-30个精心布置的障碍物</li><li>结合多种策略的复合障碍布局</li><li>在关键路径点设置决策难点</li></ul><h2 id="使用工具与环境"><a href="#使用工具与环境" class="headerlink" title="使用工具与环境"></a>使用工具与环境</h2><ul><li>开发语言：Python 3.8</li><li>框架库：numpy，matplotlib（可视化）</li><li>环境配置：CUDA 12.1，Ubuntu 22.04</li><li>ai工具：ChatGPT-4o</li></ul><h2 id="关键代码展示"><a href="#关键代码展示" class="headerlink" title="关键代码展示"></a>关键代码展示</h2><ul><li><p>展示4个策略：</p><h4 id="误导性路径"><a href="#误导性路径" class="headerlink" title="误导性路径"></a>误导性路径</h4><ul><li>在起点和终点之间创建看似合理但实际是死胡同的路径</li><li>利用无人机对特定方向的偏好设置陷阱</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_misleading_path</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;创建一个误导性的路径，利用无人机向右和向上的偏好&quot;&quot;&quot;</span><br>        obstacles = []<br>        <br>        <span class="hljs-comment"># 计算从起点到终点的直线方向</span><br>        dx = end[<span class="hljs-number">0</span>] - start[<span class="hljs-number">0</span>]<br>        dy = end[<span class="hljs-number">1</span>] - start[<span class="hljs-number">1</span>]<br>        <br>        <span class="hljs-comment"># 创建一个看似通向目标但实际是误导的路径</span><br>        mislead_x = start[<span class="hljs-number">0</span>] + dx * <span class="hljs-number">0.6</span><br>        mislead_y = start[<span class="hljs-number">1</span>] + dy * <span class="hljs-number">0.6</span><br>        <br>        <span class="hljs-comment"># 在误导点周围创建障碍物包围圈</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            angle = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * math.pi)<br>            radius = random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br>            x = mislead_x + radius * math.cos(angle)<br>            y = mislead_y + radius * math.sin(angle)<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>        <br>        <span class="hljs-comment"># 创建一个向右上方的诱饵路径（利用代理对向右和向上的偏好）</span><br>        bait_points = []<br>        bait_length = <span class="hljs-built_in">min</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">int</span>(<span class="hljs-variable language_">self</span>.point_distance(start, end) / <span class="hljs-number">3</span>))<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, bait_length + <span class="hljs-number">1</span>):<br>            bait_x = start[<span class="hljs-number">0</span>] + i * <span class="hljs-number">1.5</span><br>            bait_y = start[<span class="hljs-number">1</span>] + i * <span class="hljs-number">1.5</span><br>            bait_points.append([bait_x, bait_y])<br>        <br>        <span class="hljs-comment"># 在诱饵路径末端设置障碍物陷阱</span><br>        <span class="hljs-keyword">if</span> bait_points:<br>            end_point = bait_points[-<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>                angle = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * math.pi)<br>                radius = random.uniform(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)<br>                x = end_point[<span class="hljs-number">0</span>] + radius * math.cos(angle)<br>                y = end_point[<span class="hljs-number">1</span>] + radius * math.sin(angle)<br>                <br>                <span class="hljs-comment"># 确保在场地范围内</span><br>                x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>                y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>                <br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles):<br>                    obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>        <br>        <span class="hljs-keyword">return</span> obstacles<br>        <br></code></pre></td></tr></table></figure><h4 id="感知边界障碍"><a href="#感知边界障碍" class="headerlink" title="感知边界障碍"></a>感知边界障碍</h4><ul><li>在无人机感知范围边界（约15m）布置障碍物</li><li>使无人机难以提前规划路径，容易陷入局部最优</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_narrow_passages</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建狭窄通道，利用无人机在障碍物3米范围内的负奖励&quot;&quot;&quot;</span><br>    obstacles = []<br>    <br>    <span class="hljs-comment"># 计算从起点到终点的方向</span><br>    dx = end[<span class="hljs-number">0</span>] - start[<span class="hljs-number">0</span>]<br>    dy = end[<span class="hljs-number">1</span>] - start[<span class="hljs-number">1</span>]<br>    distance = math.sqrt(dx**<span class="hljs-number">2</span> + dy**<span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-comment"># 将方向单位化</span><br>    <span class="hljs-keyword">if</span> distance &gt; <span class="hljs-number">0</span>:<br>        dx /= distance<br>        dy /= distance<br>    <br>    <span class="hljs-comment"># 计算垂直于路径方向的向量</span><br>    perp_dx = -dy<br>    perp_dy = dx<br>    <br>    <span class="hljs-comment"># 在路径上创建多个狭窄通道</span><br>    num_passages = <span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">int</span>(distance / <span class="hljs-number">10</span>))<br>    passage_width = <span class="hljs-number">3.5</span>  <span class="hljs-comment"># 略大于障碍物直径+无人机直径</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_passages):<br>        <span class="hljs-comment"># 计算通道中心点</span><br>        t = (i + <span class="hljs-number">1</span>) / (num_passages + <span class="hljs-number">1</span>)<br>        center_x = start[<span class="hljs-number">0</span>] + t * dx * distance<br>        center_y = start[<span class="hljs-number">1</span>] + t * dy * distance<br>        <br>        <span class="hljs-comment"># 在通道两侧创建障碍物</span><br>        <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> [-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]:<br>            offset = passage_width / <span class="hljs-number">2</span> + <span class="hljs-variable language_">self</span>.obstacle_radius<br>            x = center_x + side * perp_dx * offset<br>            y = center_y + side * perp_dy * offset<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>                <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>                <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-keyword">return</span> obstacles<br></code></pre></td></tr></table></figure><h4 id="狭窄通道"><a href="#狭窄通道" class="headerlink" title="狭窄通道"></a>狭窄通道</h4><ul><li>设计宽度刚好略大于无人机通过能力的通道（约3.5m）</li><li>利用无人机对靠近障碍物的负奖励，使其犹豫不决</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_narrow_passages</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建狭窄通道，利用无人机在障碍物3米范围内的负奖励&quot;&quot;&quot;</span><br>    obstacles = []<br>    <br>    <span class="hljs-comment"># 计算从起点到终点的方向</span><br>    dx = end[<span class="hljs-number">0</span>] - start[<span class="hljs-number">0</span>]<br>    dy = end[<span class="hljs-number">1</span>] - start[<span class="hljs-number">1</span>]<br>    distance = math.sqrt(dx**<span class="hljs-number">2</span> + dy**<span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-comment"># 将方向单位化</span><br>    <span class="hljs-keyword">if</span> distance &gt; <span class="hljs-number">0</span>:<br>        dx /= distance<br>        dy /= distance<br>    <br>    <span class="hljs-comment"># 计算垂直于路径方向的向量</span><br>    perp_dx = -dy<br>    perp_dy = dx<br>    <br>    <span class="hljs-comment"># 在路径上创建多个狭窄通道</span><br>    num_passages = <span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, <span class="hljs-built_in">int</span>(distance / <span class="hljs-number">10</span>))<br>    passage_width = <span class="hljs-number">3.5</span>  <span class="hljs-comment"># 略大于障碍物直径+无人机直径</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_passages):<br>        <span class="hljs-comment"># 计算通道中心点</span><br>        t = (i + <span class="hljs-number">1</span>) / (num_passages + <span class="hljs-number">1</span>)<br>        center_x = start[<span class="hljs-number">0</span>] + t * dx * distance<br>        center_y = start[<span class="hljs-number">1</span>] + t * dy * distance<br>        <br>        <span class="hljs-comment"># 在通道两侧创建障碍物</span><br>        <span class="hljs-keyword">for</span> side <span class="hljs-keyword">in</span> [-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]:<br>            offset = passage_width / <span class="hljs-number">2</span> + <span class="hljs-variable language_">self</span>.obstacle_radius<br>            x = center_x + side * perp_dx * offset<br>            y = center_y + side * perp_dy * offset<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>                <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>                <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-keyword">return</span> obstacles<br></code></pre></td></tr></table></figure><h4 id="迷宫结构"><a href="#迷宫结构" class="headerlink" title="迷宫结构"></a>迷宫结构</h4><ul><li>创建复杂的迷宫式布局</li><li>增加路径规划的复杂度，容易使智能体迷失方向</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_maze_structure</span>(<span class="hljs-params">self, start, end, existing_obstacles=[]</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建迷宫结构，让无人机容易迷失方向&quot;&quot;&quot;</span><br>    obstacles = []<br>    <br>    <span class="hljs-comment"># 在起点和终点之间创建迷宫结构</span><br>    mid_x = (start[<span class="hljs-number">0</span>] + end[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span><br>    mid_y = (start[<span class="hljs-number">1</span>] + end[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span><br>    <br>    <span class="hljs-comment"># 创建迷宫的中心区域</span><br>    maze_radius = <span class="hljs-built_in">min</span>(<span class="hljs-number">15</span>, <span class="hljs-variable language_">self</span>.point_distance(start, end) / <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-comment"># 创建迷宫的几条&quot;墙&quot;</span><br>    <span class="hljs-keyword">for</span> wall_idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        wall_angle = wall_idx * <span class="hljs-number">2</span> * math.pi / <span class="hljs-number">3</span><br>        wall_length = maze_radius * <span class="hljs-number">0.8</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            t = (i + <span class="hljs-number">1</span>) / <span class="hljs-number">4</span><br>            x = mid_x + t * wall_length * math.cos(wall_angle)<br>            y = mid_y + t * wall_length * math.sin(wall_angle)<br>            <br>            <span class="hljs-comment"># 确保在场地范围内</span><br>            x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>            y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>                <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>                <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>                obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-comment"># 创建一些随机的迷宫元素</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        angle = random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * math.pi)<br>        radius = random.uniform(maze_radius * <span class="hljs-number">0.3</span>, maze_radius)<br>        x = mid_x + radius * math.cos(angle)<br>        y = mid_y + radius * math.sin(angle)<br>        <br>        <span class="hljs-comment"># 确保在场地范围内</span><br>        x = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, x))<br>        y = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-variable language_">self</span>.field_size - <span class="hljs-number">1</span>, y))<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">self</span>.point_distance([x, y], start) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span> <br>            <span class="hljs-variable language_">self</span>.point_distance([x, y], end) &gt;= <span class="hljs-variable language_">self</span>.min_obstacle_to_start_end <span class="hljs-keyword">and</span><br>            <span class="hljs-variable language_">self</span>.is_valid_position([x, y], existing_obstacles + obstacles)):<br>            obstacles.append(&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y&#125;)<br>    <br>    <span class="hljs-keyword">return</span> obstacles<br></code></pre></td></tr></table></figure><h1 id="NS-2025-11-接管厨房客厅的那一天-Writeup"><a href="#NS-2025-11-接管厨房客厅的那一天-Writeup" class="headerlink" title="NS-2025-11 接管厨房客厅的那一天 Writeup"></a>NS-2025-11 接管厨房客厅的那一天 Writeup</h1><h2 id="一、任务背景与目标"><a href="#一、任务背景与目标" class="headerlink" title="一、任务背景与目标"></a>一、任务背景与目标</h2><p>本次“NS-2025-11 家庭智能协作挑战”要求参赛者基于多模态输入（图像 + 自然语言）构建智能体，使其控制机械臂完成一系列具有挑战性的家庭任务。这些任务具有不同的动态特征与动作要求，包括：</p><ul><li>堆叠积木（stack_blocks）</li><li>放置杯子（place_cups）</li><li>把钱放入保险箱（put_money_in_safe）</li><li>拧入灯泡（light_bulb_in）</li><li>将物品放入抽屉（put_item_in_drawer）</li></ul><p>智能体需对序列输入做出连续动作预测：三维位置（XYZ）、旋转（四元数）、抓取信号（是否夹取）。挑战评估模型对任务目标完成度、轨迹质量与精度的适应能力。</p><hr><h2 id="二、系统架构与模型设计"><a href="#二、系统架构与模型设计" class="headerlink" title="二、系统架构与模型设计"></a>二、系统架构与模型设计</h2><p>为统一处理所有任务，我们设计了统一结构的策略网络 <code>TaskModel</code>，其整体结构分为以下三个部分：</p><h3 id="2-1-编码器：ActionDecoder-encoder"><a href="#2-1-编码器：ActionDecoder-encoder" class="headerlink" title="2.1 编码器：ActionDecoder.encoder"></a>2.1 编码器：<code>ActionDecoder.encoder</code></h3><p>输入为 <code>[B, T, D]</code> 的观测向量序列（图像 + 语言的融合特征），经过两层全连接网络映射到维度为 <code>embed_dim=128</code> 的特征表示，并通过 <code>ReLU</code> 激活增强非线性表达能力。</p><h3 id="2-2-时序建模模块：TemporalBlock"><a href="#2-2-时序建模模块：TemporalBlock" class="headerlink" title="2.2 时序建模模块：TemporalBlock"></a>2.2 时序建模模块：<code>TemporalBlock</code></h3><p>采用标准的 Transformer 子结构（多头注意力 + 残差 LayerNorm + 前馈网络），能够建模动作序列中时间步间的依赖关系与长期轨迹规律：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MultiheadAttention -&gt; LayerNorm -&gt; MLP -&gt; LayerNorm<br></code></pre></td></tr></table></figure><p>该模块允许模型识别出不同时间步之间的操作规律，如“插入-旋转-释放”等时序动作序列。</p><h3 id="2-3-动作解码头"><a href="#2-3-动作解码头" class="headerlink" title="2.3 动作解码头"></a>2.3 动作解码头</h3><ul><li><code>head_pos</code>: 输出每一步的三维位置（XYZ）</li><li><code>head_rot</code>: 输出归一化四元数，表示旋转角度</li><li><code>head_grip</code>: 输出抓取信号，通过 <code>sigmoid</code> 激活</li></ul><p>最终模型输出维度为 <code>action_dim = 3 + 4 + 1 = 8</code>。</p><hr><h2 id="三、任务感知的损失函数设计"><a href="#三、任务感知的损失函数设计" class="headerlink" title="三、任务感知的损失函数设计"></a>三、任务感知的损失函数设计</h2><p>我们在 <code>TaskModel.compute_loss()</code> 中为不同任务设计了特定的损失加权策略，从而提高模型在各类任务中的表现力与泛化性。</p><h3 id="通用损失构成："><a href="#通用损失构成：" class="headerlink" title="通用损失构成："></a>通用损失构成：</h3><ul><li><code>loss_pos</code>: 所有时间步的 MSE（位置）</li><li><code>loss_rot</code>: 所有时间步的 Cosine 相似度损失（四元数）</li><li><code>loss_grip</code>: 所有时间步的 BCE（抓取信号）</li></ul><h3 id="任务特化策略如下："><a href="#任务特化策略如下：" class="headerlink" title="任务特化策略如下："></a>任务特化策略如下：</h3><table><thead><tr><th>任务名称</th><th>调整策略</th></tr></thead><tbody><tr><td>stack_blocks</td><td>强调<strong>最后一步的位置稳定性</strong>与<strong>旋转精度</strong>，将最后一帧位置误差加入损失，并将旋转损失权重翻倍。</td></tr><tr><td>place_cups</td><td>增加轨迹差值损失项，鼓励轨迹对齐；同时强调<strong>最后时刻的旋转一致性</strong>，增强杯口方向控制。</td></tr><tr><td>put_money_in_safe</td><td>加强末帧抓取状态与位置精度的监督，确保插入时精度与夹持控制。</td></tr><tr><td>light_bulb_in</td><td>提高位置与旋转损失权重，适配对姿态和插入精度的高要求；抓取控制也更为关键。</td></tr><tr><td>put_item_in_drawer</td><td>默认使用 <code>put_money_in_safe</code> 相似策略，注重轨迹尾部插入点与释放状态的联合优化。</td></tr></tbody></table><hr><h2 id="四、训练与实现细节"><a href="#四、训练与实现细节" class="headerlink" title="四、训练与实现细节"></a>四、训练与实现细节</h2><table><thead><tr><th>参数</th><th>配置</th></tr></thead><tbody><tr><td>Batch Size</td><td>32</td></tr><tr><td>Epochs</td><td>30</td></tr><tr><td>Optimizer</td><td>Adam</td></tr><tr><td>Learning Rate</td><td>1e-4</td></tr><tr><td>Scheduler</td><td>Cosine Annealing</td></tr><tr><td>Sequence Length</td><td>10</td></tr><tr><td>Input Dim</td><td>64（图像+语言特征）</td></tr><tr><td>Embed Dim</td><td>128</td></tr></tbody></table><p>代码实现基于 PyTorch 框架，支持多任务训练与微调。每个任务模型独立训练并评估。</p><hr><h2 id="五、实验结果与分析"><a href="#五、实验结果与分析" class="headerlink" title="五、实验结果与分析"></a>五、实验结果与分析</h2><p>在官方验证平台上的评测结果如下（分数越高表示性能越优）：</p><table><thead><tr><th>任务名称</th><th>得分</th></tr></thead><tbody><tr><td>put_money_in_safe</td><td>292.48</td></tr><tr><td>stack_blocks</td><td>219.12</td></tr><tr><td>light_bulb_in</td><td>284.34</td></tr><tr><td>put_item_in_drawer</td><td>320.00</td></tr><tr><td>place_cups</td><td>260.35</td></tr></tbody></table><p>该结果表明我们的方法在多任务适配性与精度控制方面具有良好的表现，尤其是在插入与抓取精度要求高的任务中（如 drawer, light bulb）。</p><hr><h2 id="六、使用工具与环境"><a href="#六、使用工具与环境" class="headerlink" title="六、使用工具与环境"></a>六、使用工具与环境</h2><ul><li>开发语言：Python 3.10</li><li>框架库：PyTorch 2.1.0、NumPy、WandB（日志）、Matplotlib（可视化）</li><li>环境配置：CUDA 12.1，Ubuntu 22.04</li><li>ai工具：ChatGPT-4o</li></ul><hr><h2 id="七、挑战与展望"><a href="#七、挑战与展望" class="headerlink" title="七、挑战与展望"></a>七、挑战与展望</h2><p>我们观察到如下挑战与优化方向：</p><ul><li><strong>多任务共享结构</strong>：虽然当前模型能适应多任务，但可能存在参数干扰问题。未来考虑引入任务提示向量（Task Prompt）进行条件控制。</li><li><strong>语言与图像融合方式</strong>：当前仅使用预融合输入，未来可尝试引入 Cross-Attention 机制实现更强的模态融合。</li><li><strong>动作输出结构优化</strong>：不同任务在输出精度要求差异大，可设计更细粒度的输出头或使用分层结构优化不同粒度的预测项。针对不同任务的特性进一步优化。</li></ul><hr><h2 id="八、-部分代码展示"><a href="#八、-部分代码展示" class="headerlink" title="八、 部分代码展示"></a>八、 部分代码展示</h2><p>关键代码：</p><h3 id="1-模型主干设计（BasePolicy）"><a href="#1-模型主干设计（BasePolicy）" class="headerlink" title="1. 模型主干设计（BasePolicy）"></a>1. 模型主干设计（BasePolicy）</h3><p>这是所有任务共享的基本网络结构，使用了 <code>ResNet18</code> 提取视觉特征，并用 <code>TransformerEncoder</code> 编码语言。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePolicy</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        resnet = resnet18(pretrained=<span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.vision_encoder = nn.Sequential(*<span class="hljs-built_in">list</span>(resnet.children())[:-<span class="hljs-number">1</span>])<br>        encoder_layer = nn.TransformerEncoderLayer(d_model=<span class="hljs-number">512</span>, nhead=<span class="hljs-number">8</span>)<br>        <span class="hljs-variable language_">self</span>.lang_encoder = nn.TransformerEncoder(encoder_layer, num_layers=<span class="hljs-number">2</span>)<br>        <span class="hljs-variable language_">self</span>.cross_modal = nn.MultiheadAttention(embed_dim=<span class="hljs-number">512</span>, num_heads=<span class="hljs-number">8</span>, batch_first=<span class="hljs-literal">True</span>)<br>        <span class="hljs-variable language_">self</span>.fc_out = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">256</span>), nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">128</span>), nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">7</span>)<br>        )<br>        <span class="hljs-variable language_">self</span>.grip_cls = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">64</span>), nn.ReLU(),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">2</span>)<br>        )<br><br></code></pre></td></tr></table></figure><h3 id="2-跨模态编码（视觉-语言）"><a href="#2-跨模态编码（视觉-语言）" class="headerlink" title="2. 跨模态编码（视觉 + 语言）"></a>2. <strong>跨模态编码（视觉 + 语言）</strong></h3><p>视觉特征和语言特征交叉融合，通过 Multi-Head Attention 得到联合特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode_inputs</span>(<span class="hljs-params">self, obs, instr</span>):<br>    B, C_view, Two, C, H, W = obs.shape<br>    obs = obs.view(B * C_view * Two, C, H, W)<br>    vision_feat = <span class="hljs-variable language_">self</span>.vision_encoder(obs).view(B, C_view * Two, -<span class="hljs-number">1</span>).mean(dim=<span class="hljs-number">1</span>)<br>    instr = instr.permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    lang_feat_seq = <span class="hljs-variable language_">self</span>.lang_encoder(instr).permute(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    lang_feat_att, _ = <span class="hljs-variable language_">self</span>.cross_modal(vision_feat.unsqueeze(<span class="hljs-number">1</span>), lang_feat_seq, lang_feat_seq)<br>    <span class="hljs-keyword">return</span> vision_feat, lang_feat_att.squeeze(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="3-loss函数"><a href="#3-loss函数" class="headerlink" title="3. loss函数"></a>3. loss函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_loss</span>(<span class="hljs-params">pred, target, task=<span class="hljs-literal">None</span>, epoch=<span class="hljs-number">0</span></span>):<br>    pos_loss = F.mse_loss(pred[:, :<span class="hljs-number">3</span>], target[:, :<span class="hljs-number">3</span>])<br>    rot_weight = <span class="hljs-built_in">min</span>(<span class="hljs-number">1.0</span>, epoch / <span class="hljs-number">20.0</span>)<br>    rot_loss = F.smooth_l1_loss(pred[:, <span class="hljs-number">3</span>:<span class="hljs-number">7</span>], target[:, <span class="hljs-number">3</span>:<span class="hljs-number">7</span>]) * rot_weight<br>    grip_target = target[:, <span class="hljs-number">7</span>:].long().squeeze(<span class="hljs-number">1</span>)<br>    grip_loss = F.cross_entropy(torch.cat([<span class="hljs-number">1</span> - pred[:, <span class="hljs-number">7</span>:], pred[:, <span class="hljs-number">7</span>:]], dim=<span class="hljs-number">1</span>), grip_target)<br><br>    <span class="hljs-keyword">if</span> task == <span class="hljs-string">&#x27;stack_blocks&#x27;</span>:<br>        rot_loss *= <span class="hljs-number">2.0</span><br>    <span class="hljs-keyword">elif</span> task == <span class="hljs-string">&#x27;put_money_in_safe&#x27;</span>:<br>        pos_loss *= <span class="hljs-number">1.5</span><br>    <span class="hljs-keyword">elif</span> task == <span class="hljs-string">&#x27;light_bulb_in&#x27;</span>:<br>        pos_loss *= <span class="hljs-number">1.3</span><br>        grip_loss *= <span class="hljs-number">1.2</span><br><br>    <span class="hljs-keyword">return</span> pos_loss + rot_loss + <span class="hljs-number">0.1</span> * grip_loss<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab4.2</title>
    <link href="/2025/04/21/AI-Lab4-2/"/>
    <url>/2025/04/21/AI-Lab4-2/</url>
    
    <content type="html"><![CDATA[<h1 id="人工神经网络介绍"><a href="#人工神经网络介绍" class="headerlink" title="人工神经网络介绍"></a>人工神经网络介绍</h1><h2 id="单层感知机"><a href="#单层感知机" class="headerlink" title="单层感知机"></a>单层感知机</h2><ul><li>由于M-P神经元模型参数需要事先设定好，为了能够自适应学习出所需要的参数，研究人员就提出了<strong>单层感知机(Perceptron)</strong></li><li>感知机的基本公式为：<strong>y(𝑥)&#x3D;𝑠𝑖𝑔𝑛(𝑤𝑥+𝑏)</strong></li><li>sign为符号函数，当自变量为<strong>正数</strong>时取值为1，否则取值为0</li></ul><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><ul><li>包含三个层次：一个<strong>输入层</strong>，一个或多个中间层(也叫<strong>隐藏层</strong>，hidden layer) 和一个<strong>输出层</strong></li><li>输入层与输出层的节点数是固定的，中间层则可以自由指定</li><li>MLP通常还会引入<strong>偏置单元b</strong></li></ul><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><ul><li>常见：sigmoid、Relu、tanh<br><img src="/img/file-20250421163950262.png"></li><li>sigmoid可以用于<strong>计算概率</strong></li><li>ReLU函数的拟合效果可能更好一点</li><li>tanh函数</li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><ul><li>作用：衡量网络表现是否良好，并为之后的网络参数优化提供指导<br><img src="/img/file-20250421164225769.png"></li></ul><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><ul><li>梯度定义：梯度是一个向量，表示某一函数在该点出的方向导数沿着该方向取得最大值。</li><li>梯度下降的一般公式为：<code>𝜃=𝜃−𝜂∇𝜃𝐿(𝜃)</code>，其中，𝜂是<strong>学习率</strong>，∇𝜃是对𝜃的梯度，𝜃是参数<ul><li>学习率太小学习地很慢</li><li>学习率太大效果不太好，可能错过最小值，无法收敛</li></ul></li></ul><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="2-1：购房预测分类任务"><a href="#2-1：购房预测分类任务" class="headerlink" title="2.1：购房预测分类任务"></a>2.1：购房预测分类任务</h2><ul><li>利用感知机算法在给定数据集完成购房预测训练</li><li>要求：<ul><li>选择<strong>合适的损失函数</strong>，利用<strong>训练集</strong>完成网络训练，<strong>画出数据可视化图、loss曲线图</strong>。（可以任意拿两个特征、三个出来画，全部都要画出来）</li><li>单层感知机示例：<br>  <img src="/img/file-20250421164713292.png"></li></ul></li></ul><p>&#x3D;&gt;感知机算法</p><h4 id="房价预测任务"><a href="#房价预测任务" class="headerlink" title="房价预测任务"></a>房价预测任务</h4><p><code>data.csv</code>数据集包含五个属性，共10000条数据，其中 <code>longitude</code>和 <code>latitude</code>表示房子经纬度，<code>housing_age</code>表示<strong>房子年龄</strong>，<code>homeowner_income</code>表示<strong>房主的收入</strong>（单位：十万元）， <code>house_price</code>表示<strong>房子的价格</strong>。请根据数据集 <code>data.csv</code>中四个属性 <code>longitude</code>、<code>latitude</code>、<code>housing_age</code>、<code>homeowner_income</code>，利用<strong>感知机算法</strong>预测房价 <code>house_price</code>，并画出<strong>数据可视化图、loss曲线图</strong>。</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol><li>最后提交的代码只需包含性能最好的实现方法和参数设置. 只需提交一个代码文件, 请不要提交其他文件.</li><li>本次作业可以使用 <code>numpy</code>库、<code>matplotlib</code>库以及python标准库.</li><li>数据集可以在Github上下载。</li></ol><h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h3><h4 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h4><h5 id="1-1-数据处理"><a href="#1-1-数据处理" class="headerlink" title="1.1 数据处理"></a>1.1 数据处理</h5><ul><li>加载数据集、数据预处理（标准化&#x2F;归一化）</li><li>划分训练集和测试集（8:2）</li></ul><p>&#x3D;&gt;利用 loadtxt函数读取csv文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">np.loadtxt(filepath,delimiter,usecols,unpack)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">参数：</span><br><span class="hljs-string">filepath:加载文件路径  </span><br><span class="hljs-string">delimiter:加载文件分隔符  (csv一般以&#x27;,&#x27;进行分隔)</span><br><span class="hljs-string">usecols:加载数据文件中列索引（标签）</span><br><span class="hljs-string">unpack:当加载多列数据时是否需要将数据列进行解耦赋值给不同的变量 </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="1-2-感知机模型构建"><a href="#1-2-感知机模型构建" class="headerlink" title="1.2 感知机模型构建"></a>1.2 感知机模型构建</h5><ul><li>定义感知机模型结构（<code>__init__</code>，参数包括：学习率，迭代次数，loss数组)</li><li>实现前向传播算法</li><li>实现反向传播与权重更新</li></ul><h5 id="1-3-模型训练与评估"><a href="#1-3-模型训练与评估" class="headerlink" title="1.3 模型训练与评估"></a>1.3 模型训练与评估</h5><ul><li>设定超参数（学习率、迭代次数等）</li><li>训练模型并记录loss</li><li>在测试集上评估模型性能</li></ul><h5 id="1-4-可视化结果"><a href="#1-4-可视化结果" class="headerlink" title="1.4 可视化结果"></a>1.4 可视化结果</h5><ul><li>数据分布可视化</li><li>loss曲线绘制</li></ul><h2 id="知识补给："><a href="#知识补给：" class="headerlink" title="知识补给："></a>知识补给：</h2><h3 id="感知机概述："><a href="#感知机概述：" class="headerlink" title="感知机概述："></a>感知机概述：</h3><ul><li>感知机是二分类的线性分类模型，属于监督学习算法（提供label进行训练）</li><li>为求得超平面，感知机导入了基于误分类的损失函数，利用<strong>梯度下降法</strong>对损失函数进行最优化求解。</li><li>如果训练数据集是线性可分的，则感知机一定能求得分离超平面。如果是非线性可分的数据，则无法获得超平面。</li></ul><h3 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h3><p>感知机模型：$f(x)&#x3D;sign(w⋅x+b)$</p><ul><li>sign()是符号函数</li><li>其中的一个超平面是$wx+b&#x3D;0$</li></ul><h3 id="感知机损失函数（loss）"><a href="#感知机损失函数（loss）" class="headerlink" title="感知机损失函数（loss）"></a>感知机损失函数（loss）</h3><p>损失函数的一个自然选择是<strong>误分类点的总数</strong>，但是这样的函数不是连续可导函数，不易优化。因此感知机采用的损失函数是<strong>误分类点到超平面的总距离</strong>。</p><p>对于误分类样本 $(x_i, y_i)$（满足 $y_i(w \cdot x_i + b) \leq 0$），损失函数为<strong>误分类点到超平面的距离的相反数</strong>：</p><p>$$<br>L(w,b) &#x3D; -\sum_{x_i \in M} y_i(w \cdot x_i + b)<br>$$</p><p>其中 $M$ 是误分类样本集合。</p><h4 id="距离公式推导"><a href="#距离公式推导" class="headerlink" title="距离公式推导"></a>距离公式推导</h4><p>误分类点到超平面的几何距离：$||w||$是w的$L_2$范数</p><p>$$<br>\text{Distance} &#x3D; \frac{|w \cdot x_i + b|}{|w|_2}<br>$$</p><p>因误分类时 $y_i(w \cdot x_i + b) &lt; 0$，可简化为：</p><p>$$<br>\text{Distance} &#x3D; -\frac{y_i(w \cdot x_i + b)}{|w|_2}<br>$$</p><h4 id="梯度下降更新规则"><a href="#梯度下降更新规则" class="headerlink" title="梯度下降更新规则"></a>梯度下降更新规则</h4><p>参数更新公式（$\eta$ 为学习率）：</p><p>$$<br>\begin{aligned}<br>w &amp;\leftarrow w + \eta y_i x_i \<br>b &amp;\leftarrow b + \eta y_i<br>\end{aligned}<br>$$</p><p>梯度计算：</p><p>$$<br>\begin{aligned}<br>\nabla_w L &amp;&#x3D; -y_i x_i \<br>\nabla_b L &amp;&#x3D; -y_i<br>\end{aligned}<br>$$</p><h4 id="收敛性定理（Novikoff）"><a href="#收敛性定理（Novikoff）" class="headerlink" title="收敛性定理（Novikoff）"></a>收敛性定理（Novikoff）</h4><p>对于线性可分数据集，感知机保证在有限步 $k$ 内收敛：</p><p>$$<br>k \leq \left( \frac{R}{\gamma} \right)^2<br>$$</p><p>其中：</p><ul><li>$R &#x3D; \max |x_i|$ 是输入特征的最大模长</li><li>$\gamma$ 是分离超平面的间隔（margin）</li></ul><h4 id="多层感知机："><a href="#多层感知机：" class="headerlink" title="多层感知机："></a>多层感知机：</h4><p><img src="/img/file-20250421164856817.png"></p><ul><li>要手写权重、偏置、梯度下降率</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex_learning</title>
    <link href="/2025/04/17/LaTex-learning/"/>
    <url>/2025/04/17/LaTex-learning/</url>
    
    <content type="html"><![CDATA[<p>参考资料链接：<br><a href="https://texdoc.org/serve/texlive-zh-cn.pdf/0">TEX Live指南2025</a><br><a href="https://oi-wiki.org/tools/latex/">LaTeX 入门 - OI Wiki</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>[!NOTE]<br>本文是在windows下的安装记录+vscode配置使用</p></blockquote><p>通过官网进行安装，下载 <code>install-tl-windows.exe</code> ，跟着指令继续做即可</p><p>安装好后，需要将bin加入环境变量，此处我是加入 <code>E:\software\texLive2\texlive\2025\bin\windows</code> 到环境变量</p><p>查看版本看是否安装好了：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">tex <span class="hljs-comment">--version</span><br>latex <span class="hljs-comment">--version</span><br>xelatex <span class="hljs-comment">--version</span><br>pdflatex <span class="hljs-comment">--version</span><br><span class="hljs-keyword">context</span> <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><p>输出版本号则成功</p><h1 id="与vscode打通"><a href="#与vscode打通" class="headerlink" title="与vscode打通"></a>与vscode打通</h1><ul><li>安装Latex Workshop</li><li>配置setting.json</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs prolog"> <span class="hljs-string">&quot;latex-workshop.latex.tools&quot;</span>: [<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;args&quot;</span>: [<br><br>            <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br><br>            <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br><br>            <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;args&quot;</span>: [<br><br>            <span class="hljs-string">&quot;-synctex=1&quot;</span>,<br><br>            <span class="hljs-string">&quot;-interaction=nonstopmode&quot;</span>,<br><br>            <span class="hljs-string">&quot;-file-line-error&quot;</span>,<br><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>        <span class="hljs-string">&quot;command&quot;</span>: <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>        <span class="hljs-string">&quot;args&quot;</span>: [<br><br>            <span class="hljs-string">&quot;%DOCFILE%&quot;</span><br><br>        ]<br><br>    &#125;<br><br>],<br><br>  <br><br><span class="hljs-string">&quot;latex-workshop.latex.recipes&quot;</span>: [<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span><br><br>        ],<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xe-&gt;bib-&gt;xe-&gt;xe&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;xelatex&quot;</span><br><br>        ]<br><br>    &#125;,<br><br>    &#123;<br><br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pdf-&gt;bib-&gt;pdf-&gt;pdf&quot;</span>,<br><br>        <span class="hljs-string">&quot;tools&quot;</span>: [<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;bibtex&quot;</span>,<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span>,<br><br>            <span class="hljs-string">&quot;pdflatex&quot;</span><br><br>        ]<br><br>    &#125;<br><br>],<br></code></pre></td></tr></table></figure><p>测试：</p><ul><li>新建一个 <code>.tex</code> 文件</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-meta">% !TEX program = xelatex  % 强制使用 XeLaTeX 编译（部分编辑器需要）</span><br><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125; <span class="hljs-comment">% 自动处理中文（推荐）</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>你好，LaTeX！<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>构建项目即可查看预览：<br><img src="/img/file-20250417172301672.png"></p><h1 id="使用笔记"><a href="#使用笔记" class="headerlink" title="使用笔记"></a>使用笔记</h1><h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[a4paper, 12pt]&#123;article&#125; <span class="hljs-keyword">\begin</span>&#123;document&#125; A sentence of text. <span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><ul><li><code>\documentclass</code> 命令必须出现在每个LaTeX文档开头。花括号内的文本指定了文档的类型。<ul><li><strong>article</strong> 文档类型适合<strong>较短的文章</strong>，比如期刊文章和短篇报告。其他文档类型包括 <strong>report</strong>（适用于更长的多章节的文档，比如博士生论文），<strong>proc</strong>（会议论文集），<strong>book</strong> 和 <strong>beamer</strong>。</li><li>方括号内的文本指定了一些<strong>选项</strong>——示例中它设置纸张大小为 A4，主要文字大小为 12pt。</li></ul></li><li><code>\begin&#123;document&#125;</code> 和 <code>\end&#123;document&#125;</code> 命令将你的文本内容包裹起来。<ul><li><code>\begin&#123;document&#125;</code> 之前的视为前导命令</li></ul></li></ul><h3 id="文档标题"><a href="#文档标题" class="headerlink" title="文档标题"></a>文档标题</h3><p><code>\maketitle</code> 命令可以给文档<strong>创建标题</strong>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\title&#123;My</span> First Document&#125; <br><span class="hljs-string">\author&#123;My</span> Name&#125; <br><span class="hljs-string">\date&#123;\today&#125;</span> <br><span class="hljs-string">\maketitle</span><br></code></pre></td></tr></table></figure><ul><li>放置在<code>\begin&#123;document&#125;</code>之后</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-meta">% !TEX program = xelatex  % 强制使用 XeLaTeX 编译（部分编辑器需要）</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125; <span class="hljs-comment">% 自动处理中文（推荐）</span><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\title</span>&#123;My First Document&#125;<br><span class="hljs-keyword">\author</span>&#123;PQCU&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><span class="hljs-keyword">\maketitle</span><br>你好，LaTeX！<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250417174047528.png"></p><blockquote><p>[!NOTE]</p><ul><li><strong>article</strong> 文档的正文会紧跟着标题之后在同一页上排版。<strong>report</strong> 会将标题置为单独的一页。</li></ul></blockquote><h3 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h3><ul><li><code>\section&#123;...&#125;</code></li><li><code>\subsection&#123;...&#125;</code></li><li><code>\subsubsection&#123;...&#125;</code></li><li><code>\paragraph&#123;...&#125;</code></li><li><code>\subparagraph&#123;...&#125; 花括号内的文本表示**章节的标题** 对于 **report** 和 **book** 类型的文档还支持 </code>\chapter{…}&#96; 的命令。</li></ul><p>使用展示：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-meta">% !TEX program = xelatex  % 强制使用 XeLaTeX 编译（部分编辑器需要）</span><br><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;ctex&#125; <span class="hljs-comment">% 自动处理中文（推荐）</span><br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\title</span>&#123;My First Document&#125; <br><span class="hljs-keyword">\author</span>&#123;PQCU&#125; <br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125; <br><span class="hljs-keyword">\maketitle</span><br><span class="hljs-keyword">\section</span>&#123;Introduction&#125;<br>  This is the introduction.<br><br>  <span class="hljs-keyword">\section</span>&#123;Methods&#125;<br><br>  <span class="hljs-keyword">\subsection</span>&#123;Stage 1&#125;<br>  The first part of the methods.<br>  <span class="hljs-keyword">\subsubsection</span>&#123;wow&#125;<br><br>  <span class="hljs-keyword">\subsection</span>&#123;Stage 2&#125;<br>  The second part of the methods.<br><br>  <span class="hljs-keyword">\section</span>&#123;Results&#125;<br>  Here are my results.<br>  <span class="hljs-keyword">\paragraph</span>&#123;hhh1&#125;<br>  <span class="hljs-keyword">\subparagraph</span>&#123;hhh&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure><p>渲染结果：<br><img src="/img/file-20250417174832497.png"></p><h3 id="learn-when-use"><a href="#learn-when-use" class="headerlink" title="learn when use"></a>learn when use</h3><ol><li>插入代码块<ul><li>加入listings包 <code>\usepackage&#123;listings&#125;</code> </li><li>在代码段中添加代码：</li></ul> <figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Latex"><span class="hljs-keyword">\begin</span>&#123;lstlisting&#125; <br><span class="hljs-comment">% 代码段 </span><br><span class="hljs-keyword">\end</span>&#123;lstlisting&#125;<br></code></pre></td></tr></table></figure></li><li>行内代码<ul><li><code>\texttt&#123;code&#125;</code> 或者 <code>\verb|code|</code><br><a href="https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted">Code Highlighting with minted - Overleaf, Online LaTeX Editor</a></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Latex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab3</title>
    <link href="/2025/04/14/AI-lab4/"/>
    <url>/2025/04/14/AI-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><ul><li>训练集有标签y</li><li>目标是找到能区分正负样本的决策边界，据此拟合一个假设函数</li><li>分类问题</li></ul><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><ul><li>训练集的数据不带有标签y</li><li>需要根据样本间的相似性对样本集进行聚类，试图使类内差距最小化，类间差距最大化</li><li>聚类问题<ul><li>k-means，密度聚类，层次聚类等</li></ul></li></ul><h2 id="K聚类"><a href="#K聚类" class="headerlink" title="K聚类"></a>K聚类</h2><p>算法概述：</p><ul><li>K-means算法是一种无监督学习方法。</li><li>使用一个没有标签的数据集，然后将数据聚类成不同的组。</li><li>通过迭代将数据点分配到K个簇中，使得每个数据点与其所属簇的中心(质心)之间的<strong>距离平方和最小化</strong>。</li></ul><p>距离度量：</p><ul><li>闵可夫斯基距离（Minkowski distance）<ul><li>p&#x3D;2–欧式距离</li><li>p&#x3D;1–曼哈顿距离</li><li>切比雪夫距离<img src="/img/file-20250414171426341.png"></li></ul></li></ul><p>算法流程：</p><ol><li>选择K个点作为初始质心。（初始化簇质心为任意点）</li><li>将每个点指派到最近的质心， 形成K个簇。（遍历所有数据点，计算所有质心与数据点的距离，根据距离选择簇）</li><li>对于上一步聚类的结果， 对所有簇计算平均距离， 得出该簇的新的聚类中心（新的质心）。</li><li>重复上述两步&#x2F;直到迭代结束：质心不发生变化。<br><img src="/img/file-20250414171640499.png"></li></ol><p>优点</p><ul><li>原理简单，实现容易，收敛速度快</li><li>聚类效果较优</li><li>算法的可解释度比较强</li><li>主要需要调参的参数仅仅时簇数K</li></ul><p>缺点<br>◼ 需要预先指定簇的数量<br>◼ 无法区分高度重叠的数据<br>◼ 欧几里得距离限制了能处理的数据变量类型<br>◼ 随机选择质心并不能带来理想的结果<br>◼ 无法处理异常值和噪声数据<br>◼ 不适用于非线性数据<br>◼ 对特征尺度敏感<br>◼ 如果遇到非常大的数据集，计算机可能会崩溃</p><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><p>聚类任务</p><ul><li>在给定数据集上，设计合适的k以及距离度量函数，利用k-means算法完成数据的聚类</li><li>要求：<ul><li>尝试分别在前200条、前1000条、前10000条数据完成聚类。</li><li>画出聚类后的数据可视化图。</li></ul></li></ul><h2 id="聚类个数K和初始聚类中心的选取"><a href="#聚类个数K和初始聚类中心的选取" class="headerlink" title="聚类个数K和初始聚类中心的选取"></a>聚类个数K和初始聚类中心的选取</h2><ul><li>合适的k值怎么选取？&#x3D;&gt;手肘法</li><li>聚类的目标是使得<strong>每个样本点到距离其最近的聚类中心的总误差平方和（也即聚类的代价函数–SSE）尽可能小</strong><br>$$<br>SSE&#x3D;\sum\limits_{i&#x3D;1}\limits^k\sum\limits_{x\in{C_i}}|d(x,C_i)|^2</li></ul><p>$$<br>SSE的大小表示聚类结果的好坏，k为簇的个数<br>$d(x,C_i)$表示的是欧拉距离公式</p><p><img src="/img/file-20250414185257096.png"></p><p>方法二：Gap Statistics方法（自动）<br>$Gap(K)&#x3D;E(logD_k)-logD_k$<br>$D_k$为损失函数，$E(logD_k)$是期望。<br>这个数值通常通过蒙特卡洛模拟产生，我们在样本里所在的区域中按照均匀分布随机产生和原始样本数一样多的随机样本，并对这个随机样本做 K-Means，从而得到一个$D_k$ 。如此往复多次，通常 20 次，我们可以得到 20 个$logD_k$  。对这 20 个数值求平均值，就得到了$E(logD_k)$ ​ 的近似值。最终可以计算 Gap Statisitc。而 Gap statistic 取得最大值所对应的 K 就是最佳的 K。</p><p>初始聚类中心：</p><ul><li>对初始聚类中心的位置敏感</li><li>优化方式：<ul><li>最大距离法（课上学过）<ul><li>先选取数据集中距离最大的两个点作为初始聚类中心</li><li>将剩余数据对象进行分配，更新聚类中心</li><li>继续寻找与聚类中心距离最远的点作为下一个中心点</li></ul></li></ul></li></ul><h1 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h1><p><a href="https://zhuanlan.zhihu.com/p/619739126">最常用的聚类算法——K-Means原理详解和实操应用(R&amp;Python) - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Some Resources</title>
    <link href="/2025/04/14/Some%20Resources/"/>
    <url>/2025/04/14/Some%20Resources/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.latexlive.com/help#d12">在线LaTeX公式编辑器-帮助文档</a></p>]]></content>
    
    
    <categories>
      
      <category>资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eBPF-Chap3</title>
    <link href="/2025/04/10/eBPF-chap3/"/>
    <url>/2025/04/10/eBPF-chap3/</url>
    
    <content type="html"><![CDATA[<h1 id="eBPF程序结构"><a href="#eBPF程序结构" class="headerlink" title="eBPF程序结构"></a>eBPF程序结构</h1><p>本章展示了eBPF程序从源代码到执行的整个过程中经历的各个阶段<br><img src="/img/file-20250410211708647.png"></p><ul><li>eBPF程序是一组eBPF字节码指令，可以直接使用eBPF字节码编写，但是一般来说使用高级语言编写会更轻松</li></ul><h2 id="eBPF-虚拟机"><a href="#eBPF-虚拟机" class="headerlink" title="eBPF 虚拟机"></a>eBPF 虚拟机</h2><ul><li>计算机软件实现</li><li>以eBPF字节码（由一组指令组成）指令的形式接受程序，这些指令必须转换为在CPU上运行的本地机器指令。</li></ul><h3 id="eBPF寄存器"><a href="#eBPF寄存器" class="headerlink" title="eBPF寄存器"></a>eBPF寄存器</h3><ul><li>使用10个通用寄存器（0-9）</li><li>寄存器10用作栈指针</li><li>eBPF程序的<strong>上下文参数</strong>在开始执行之前加载到<strong>寄存器1</strong>中，<strong>函数的返回值</strong>存储在<strong>寄存器0</strong>中</li><li>eBPF调用函数之前，参数放到<strong>寄存器1-5</strong>中（传递参数）</li></ul><h3 id="eBPF指令"><a href="#eBPF指令" class="headerlink" title="eBPF指令"></a>eBPF指令</h3><p>eBPF指令的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_insn</span> &#123;</span><br>__u8 code; <span class="hljs-comment">/* opcode */</span><br>__u8 dst_reg:<span class="hljs-number">4</span>; <span class="hljs-comment">/* dest register */</span><br>__u8 src_reg:<span class="hljs-number">4</span>; <span class="hljs-comment">/* source register */</span><br>__s16 off; <span class="hljs-comment">/* signed offset */</span><br>__s32 imm; <span class="hljs-comment">/* signed immediate constant */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>如果一条指令长度超过了8byte，则可以使用宽指令编码（wide instruction encoding）</li><li>操作码类别：<ul><li>将值写入寄存器（立即数或从内存中读取的值或从其他寄存器中读取的值）</li><li>存储寄存器中的值到内存中</li><li>进行数值计算</li><li>跳转到其他指令（满足一定条件时）</li></ul></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="example1："><a href="#example1：" class="headerlink" title="example1："></a>example1：</h3><p>当网络数据包到达时触发它并写入一行跟踪</p><p><strong>XDP 的返回值</strong><br>在 XDP 程序中，返回值决定了数据包的处理方式，常用的返回值包括：</p><ul><li><strong><code>XDP_DROP</code></strong>: 丢弃数据包。</li><li><strong><code>XDP_PASS</code></strong>: 将数据包传递给内核网络栈进行正常处理。</li><li><strong><code>XDP_TX</code></strong>: 数据包直接回送到接收的网卡（即本地发送）。</li><li><strong><code>XDP_REDIRECT</code></strong>: 将数据包重定向到另一个网络接口或用户空间。</li></ul><p>程序解释：<br><code>SEC(&quot;edp&quot;)</code> 声明这是一个XDP程序，运行在网络驱动处理的阶段<br><code>bpf_printk()</code> 用于向内核日志打印调试信息</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>可以使用clang来编译<br>makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs makefile">TARGETS = hello hello-func<br><br><span class="hljs-section">all: <span class="hljs-variable">$(TARGETS)</span></span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br><br><span class="hljs-variable">$(TARGETS)</span>: %: %.bpf.o<br><br><span class="hljs-section">%.bpf.o: %.bpf.c</span><br><br>    clang \<br>        -target bpf \<br>        -I/usr/<span class="hljs-keyword">include</span>/<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -m)</span>-linux-gnu \<br>        -g \<br>        -O2 -o <span class="hljs-variable">$@</span> -c <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">clean:</span><br>    - rm *.bpf.o<br>    - rm -f /sys/fs/bpf/hello<br>    - rm -f /sys/fs/bpf/hello-func<br></code></pre></td></tr></table></figure><h4 id="检查eBPF对象文件"><a href="#检查eBPF对象文件" class="headerlink" title="检查eBPF对象文件"></a>检查eBPF对象文件</h4><p><code>file hello.bpf.o</code> 命令可以用于查看文件的内容</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">root<span class="hljs-variable">@PQCU</span><span class="hljs-symbol">:~/eBPF/learning-ebpf/chapter3</span><span class="hljs-comment"># file hello.bpf.o</span><br><span class="hljs-symbol">hello.bpf.o:</span> <span class="hljs-title class_">ELF</span> <span class="hljs-number">64</span>-bit <span class="hljs-title class_">LSB</span> relocatable, eBPF, version <span class="hljs-number">1</span> (<span class="hljs-title class_">SYSV</span>), <span class="hljs-keyword">with</span> debug_info, <span class="hljs-keyword">not</span> stripped<br></code></pre></td></tr></table></figure><p>表明它是一个ELF文件，包含eBPF代码，适用于64bit架构</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs tap">root@PQCU:~/eBPF/learning-ebpf/chapter3<span class="hljs-comment"># llvm-objdump -S hello.bpf.o</span><br><br>hello.bpf.o:    file format elf64-bpf<br><br>Disassembly of section xdp:<br><br>0000000000000000 &lt;hello&gt;:<br>; int hello(struct xdp_md *ctx) &#123;<br>       0:       b7<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>r1 = 0<br>;     bpf_printk(&quot;Hello World %d&quot;, counter);<br>       1:      <span class="hljs-number"> 73 </span>1a fe ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u8 *)(r10 - 2) = r1<br>       2:       b7<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>25<span class="hljs-number"> 64 </span>00<span class="hljs-number"> 00 </span>r1 = 25637<br>       3:       6b 1a fc ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u16 *)(r10 - 4) = r1<br>       4:       b7<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>72 6c<span class="hljs-number"> 64 </span>20 r1 = 543452274<br>       5:      <span class="hljs-number"> 63 </span>1a f8 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u32 *)(r10 - 8) = r1<br>       6:      <span class="hljs-number"> 18 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 48 </span>65 6c 6c<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 6f<span class="hljs-number"> 20 </span>57 6f r1 =<span class="hljs-number"> 8022916924116329800 </span>ll<br>       8:       7b 1a f0 ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u64 *)(r10 - 16) = r1<br>       9:      <span class="hljs-number"> 18 </span>06<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r6 =<span class="hljs-number"> 0 </span>ll<br>      11:      <span class="hljs-number"> 61 </span>63<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r3 = *(u32 *)(r6 + 0)<br>      12:       bf a1<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r1 = r10<br>      13:      <span class="hljs-number"> 07 </span>01<span class="hljs-number"> 00 </span>00 f0 ff ff ff r1 += -16<br>;     bpf_printk(&quot;Hello World %d&quot;, counter);<br>      14:       b7<span class="hljs-number"> 02 </span>00<span class="hljs-number"> 00 </span>0f<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>r2 = 15<br>      15:      <span class="hljs-number"> 85 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 06 </span>00<span class="hljs-number"> 00 </span>00 call 6<br>;     counter++;<br>      16:      <span class="hljs-number"> 61 </span>61<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 r1 = *(u32 *)(r6 + 0)<br>      17:      <span class="hljs-number"> 07 </span>01<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00 r1 += 1<br>      18:      <span class="hljs-number"> 63 </span>16<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 *(u32 *)(r6 + 0) = r1<br>;     return XDP_PASS;<br>      19:       b7<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>02<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>r0 = 2<br>      20:      <span class="hljs-number"> 95 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00 exit<br></code></pre></td></tr></table></figure><ul><li>llvm-objdump用于显示目标文件或可执行文件信息；可以显示文件头信息、符号表、反汇编代码等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS</category>
      
      <category>eBPF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS</tag>
      
      <tag>eBPF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab5_updated</title>
    <link href="/2025/04/02/OS-Lab5-updated/"/>
    <url>/2025/04/02/OS-Lab5-updated/</url>
    
    <content type="html"><![CDATA[<h1 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本次实验会学习C语言的可变参数机制的实现方法，然后实现一个简单的printf函数，通过printf()和gdb来帮助debug；同时会实现内核线程（定义PCB；实现基于时钟中断的RR算法）。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul><li>DDL：2024.5.4 24:00</li><li>提交的内容：将<strong>3+1（选做）个assignment的代码</strong>和<strong>实验报告</strong>放到<strong>压缩包</strong>中，命名为“<strong>lab5-学号-姓名</strong>”，并交到课程邮箱 <a href="https://gitee.com/link?target=mailto:os_sysu_lab@163.com">os_sysu_lab@163.com</a></li><li>将实验报告的pdf提交至 <a href="https://gitee.com/link?target=http://inbox.weiyun.com/3CiJFwEn">http://inbox.weiyun.com/3CiJFwEn</a></li><li><strong>材料的Example的代码放置在 <code>src</code>目录下</strong>。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/clover-toeic/p/3736748.html">可变参数函数详解 - clover_toeic - 博客园</a></p><h2 id="printf的实现"><a href="#printf的实现" class="headerlink" title="printf的实现"></a>printf的实现</h2><p>printf()可以使用任意数量的参数来调用，这类函数称为<strong>可变参数函数</strong></p><h3 id="C语言的可变参数机制"><a href="#C语言的可变参数机制" class="headerlink" title="C语言的可变参数机制"></a>C语言的可变参数机制</h3><p>C语言允许我们使用定义可变参数函数，此时函数参数列表分为两部分：固定参数（如int，char* )+可变参数(用 <code>...</code>来表示)<br>例如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> _Format, ...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>可变参数函数，参数列表中至少要有一个固定参数</li><li>可变参数列表必须放在形参列表最后</li></ul><p>为了<strong>引用可变参数列表中的参数</strong>，我们需要用到 <code>&lt;stdarg.h&gt;</code>头文件定义的一个变量类型 <code>va_list</code>和三个宏 <code>va_start</code>，<code>va_arg</code>，<code>va_end</code>，这三个宏用于获取可变参数列表中的参数，用法如下。</p><table><thead><tr><th>宏</th><th>用法说明</th></tr></thead><tbody><tr><td><code>va_list</code></td><td>定义一个<strong>指向可变参数列表的指针</strong>。</td></tr><tr><td><code>void va_start(va_list ap, last_arg)</code></td><td><strong>初始化可变参数列表指针</strong> <code>ap</code>，使其指向可变参数列表的<strong>起始位置</strong>，即函数的固定参数列表的最后一个参数 <code>last_arg</code>的后面第一个参数。<strong>（使用固定参数的最后一个参数来初始化可变参数指针）</strong></td></tr><tr><td><code>type va_arg(va_list ap, type)</code></td><td>以类型 <code>type</code>返回可变参数，并使 <code>ap</code>指向<strong>下一个参数</strong>。</td></tr><tr><td><code>void va_end(va_list ap)</code></td><td>清零 <code>ap</code>。</td></tr></tbody></table><ul><li>可变参数必须<strong>从头到尾</strong>逐个访问。如果你在访问了几个可变参数之后想半途中止，这是可以的，但是，如果你想一开始就访问参数列表中间的参数，那是不行的(可以把想访问的中间参数之前的参数读取但是不使用，曲线救国)。</li><li>这些宏是无法直接判断实际实际存在参数的数量。</li><li>这些宏无法判断每个参数的类型，所以在使用 <code>va_arg</code>的时候一定要指定正确的类型。</li><li>如果在 <code>va_arg</code>中指定了错误的类型，那么将会影响到后面的参数的读取。</li><li>第一个参数也未必要是可变参数个数，例如 <code>printf</code>的第一个参数就是字符串指针。</li></ul><p>无论参数数量有多少，这些参数都被统一地按函数调用给出的顺序放到了栈上，只不过使用可变参数的函数并不知道这些栈上的参数具体含义&#x3D;&gt;才需要使用 <code>va_arg</code>来指定参数的类型<br>$可变参数列表的起始地址&#x3D;固定参数列表的最后一个参数的地址+这个参数的大小$<br>初始化了 <code>parameter</code>后，我们就使用 <code>parameter</code>和 <code>va_arg</code>来引用可变参数。<br>从本质上来说，<code>parameter</code>就是指向函数调用栈的一个指针，类似 <code>esp</code>、<code>ebp</code>，<code>va_arg</code>按照指定的类型来返回 <code>parameter</code>指向的内容。注意，在 <code>va_arg</code>返回后，<code>parameter</code>会指向下一个参数，无需我们手动调整。</p><h3 id="src：2"><a href="#src：2" class="headerlink" title="src：2"></a>src：2</h3><p>定义的几个宏</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">_INTSIZEOF</span>(n) ((sizeof(n) + <span class="hljs-built_in">sizeof</span>(int) - <span class="hljs-number">1</span>) &amp; ~(sizeof(int) - <span class="hljs-number">1</span>))<br><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">va_start</span>(ap, v) (ap = (va_list)&amp;v + <span class="hljs-built_in">_INTSIZEOF</span>(v))<br><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">va_arg</span>(ap, type) (*(type *)((ap += _INTSIZEOF(type)) - <span class="hljs-built_in">_INTSIZEOF</span>(type)))<br><br><span class="hljs-selector-id">#define</span> <span class="hljs-built_in">va_end</span>(ap) (ap = (va_list)<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>作用：<br><code>_INTSIZEOF</code> 宏：对齐宏，将给定类型的大小向上舍入为sizeof(int)的倍数。（push和pop是32位的，所以都像4字节对齐）</p><ul><li><code>sizeof(n) + sizeof(int) - 1</code> 确保我们有足够的字节</li><li><code>&amp; ~(sizeof(int) - 1)</code> 通过屏蔽掉低位来确保适当的对齐</li></ul><p><code>va_start</code> 宏：初始化va_list使其指向第一个可变参数</p><ul><li><code>&amp;v</code> 是最后一个命名参数的地址</li><li><code>_INTSIZEOF(v)</code> 计算需要跳过多少字节才能到达第一个可变参数</li><li>结果指针指向可变参数列表的开头</li></ul><p><code>va_arg</code> 宏：获取下一个参数</p><ul><li>它将指针前进适当对齐的请求类型大小：<code>ap += _INTSIZEOF(type)</code></li><li>然后再回调相同的大小：<code>- _INTSIZEOF(type)</code></li><li>将结果地址转换为请求类型的指针：<code>(type *)</code></li><li>解引用该指针以获取值：<code>*(type *)</code></li></ul><p><code>va_end</code>宏：将va_list指针设置为NULL来清理，标记可变参数的结束</p><h3 id="Example1-实现printf"><a href="#Example1-实现printf" class="headerlink" title="Example1  实现printf"></a>Example1  实现printf</h3><ul><li>定义：<code>int printf(const char *const fmt,...);</code><ul><li>首先找到fmt中形如 <code>%c,%d,%x,%s</code>对应的参数，然后用这些参数具体的值来替换，得到新的格式化输出字符串（fmt的解析）</li><li>最后printf将这个新的格式化输出字符即可。</li></ul></li></ul><blockquote><p>[!NOTE]<br>实际上，我们会定义一个缓冲区，然后对fmt进行逐字符地解析，将结果逐字符的放到缓冲区中。放入一个字符后，我们会检查缓冲区，如果缓冲区已满，则将其输出，然后清空缓冲区，否则不做处理。</p></blockquote><ul><li>我们还需要实现：<ul><li>一个能输出字符串的函数</li><li>这个函数要能正确处理换行（光标移动到下一行开始）</li><li>光标超过了屏幕表示范围需要滚屏</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">STDIO::print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> str)</span><br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; str[i]; ++i)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (str[i])<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<br>            uint row;<br>            row = getCursor() / <span class="hljs-number">80</span>;<br>            <span class="hljs-keyword">if</span> (row == <span class="hljs-number">24</span>)<br>            &#123;<br>                rollUp();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ++row;<br>            &#125;<br>            moveCursor(row * <span class="hljs-number">80</span>);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            print(str[i]);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>%d</td><td>按十进制整数输出</td></tr><tr><td>%c</td><td>输出一个字符</td></tr><tr><td>%s</td><td>输出一个字符串</td></tr><tr><td>%x</td><td>按16进制输出</td></tr><tr><td>printf()</td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> fmt, ...)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_LEN = <span class="hljs-number">32</span>;<br><br>    <span class="hljs-type">char</span> buffer[BUF_LEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span> number[<span class="hljs-number">33</span>];<br><br>    <span class="hljs-type">int</span> idx, counter;<br>    va_list ap;<br><br>    va_start(ap, fmt);<br>    idx = <span class="hljs-number">0</span>;<br>    counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; fmt[i]; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (fmt[i] != <span class="hljs-string">&#x27;%&#x27;</span>)<br>        &#123;<br>            counter += printf_add_to_buffer(buffer, fmt[i], idx, BUF_LEN);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            i++;<br>            <span class="hljs-keyword">if</span> (fmt[i] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">switch</span> (fmt[i])<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>                counter += printf_add_to_buffer(buffer, fmt[i], idx, BUF_LEN);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>                counter += printf_add_to_buffer(buffer, va_arg(ap, <span class="hljs-type">int</span>), idx, BUF_LEN);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>                buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                idx = <span class="hljs-number">0</span>;<br>                counter += stdio.print(buffer);<br>                counter += stdio.print(va_arg(ap, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *));<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br>                <span class="hljs-type">int</span> temp = va_arg(ap, <span class="hljs-type">int</span>);<br><br>                <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> &amp;&amp; fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span>)<br>                &#123;<br>                    counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;-&#x27;</span>, idx, BUF_LEN);<br>                    temp = -temp;<br>                &#125;<br><br>                temp = itos(number, temp, (fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span> ? <span class="hljs-number">10</span> : <span class="hljs-number">16</span>));<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = temp - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)<br>                &#123;<br>                    counter += printf_add_to_buffer(buffer, number[j], idx, BUF_LEN);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    counter += stdio.print(buffer);<br><br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加到缓冲区函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf_add_to_buffer</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">char</span> c, <span class="hljs-type">int</span> &amp;idx, <span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_LEN)</span><br>&#123;<br>    <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br>    buffer[idx] = c;<br>    ++idx;<br><br>    <span class="hljs-keyword">if</span> (idx == BUF_LEN)<br>    &#123;<br>        buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        counter = stdio.print(buffer);<br>        idx = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250417193048263.png"></p><h2 id="内核线程-1"><a href="#内核线程-1" class="headerlink" title="内核线程"></a>内核线程</h2><ul><li>程序、进程、线程</li></ul><h3 id="用户线程和内核线程"><a href="#用户线程和内核线程" class="headerlink" title="用户线程和内核线程"></a>用户线程和内核线程</h3><ul><li>用户线程：线程只由用户进程实现，os察觉不到（无线程机制）&#x3D;&gt;一旦挂起，整个进程挂起</li><li>内核线程：让进程更多地占用CPU资源，某一线程阻塞了也只会阻塞这个线程，不会影响其他线程</li></ul><h3 id="线程的描述"><a href="#线程的描述" class="headerlink" title="线程的描述"></a>线程的描述</h3><ul><li>五个状态（创建态、运行态、就绪态、阻塞态、终止态）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ProgramStatus</span></span><br><span class="hljs-class">&#123;</span><br>    CREATED,<br>    RUNNING,<br>    READY,<br>    BLOCKED,<br>    DEAD<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>PCB数据结构</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> *<span class="hljs-built_in">stack</span>;                      <span class="hljs-comment">// 栈指针，用于调度时保存esp</span><br>    <span class="hljs-type">char</span> name[MAX_PROGRAM_NAME + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 线程名</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ProgramStatus</span> <span class="hljs-title">status</span>;</span>       <span class="hljs-comment">// 线程的状态</span><br>    <span class="hljs-type">int</span> priority;                    <span class="hljs-comment">// 线程优先级</span><br>    <span class="hljs-type">int</span> pid;                         <span class="hljs-comment">// 线程pid</span><br>    <span class="hljs-type">int</span> ticks;                       <span class="hljs-comment">// 线程时间片总时间</span><br>    <span class="hljs-type">int</span> ticksPassedBy;               <span class="hljs-comment">// 线程已执行时间</span><br>    ListItem tagInGeneralList;       <span class="hljs-comment">// 线程队列标识</span><br>    ListItem tagInAllList;           <span class="hljs-comment">// 线程队列标识</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>stack：各个线程虽然共享内核空间，但是又有自己的栈，这个栈保存在PCB中；<ul><li>每个PCB会被分配一个页，上面的数据结构PCB只是这个页的低地址部分，栈指针从这个页的结束为止向下递减。（所以栈的空间是有限的，过多会覆盖PCB的信息）<br>  <img src="/img/file-20250428190629787.png"></li></ul></li><li><code>ticks</code>是线程剩余的执行次数。在时间片调度算法中，每发生中断一次记为一个<code>tick</code>，当<code>ticks=0</code>时，线程会被换下处理器，然后将其他线程换上处理器执行。</li><li><code>ticksPassedBy</code>是线程总共执行的<code>tick</code>的次数。</li><li><code>tagInGeneralList</code>和<code>tagInAllList</code>是线程在线程队列中的标识，用于在线程队列中找到线程的PCB。</li></ul><h3 id="PCB的分配"><a href="#PCB的分配" class="headerlink" title="PCB的分配"></a>PCB的分配</h3><ul><li>大小4096个字节（一个页）–目前手动预留–后面实现了内存分页、页内存管理，就是由页内存管理来实现）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// PCB的大小，4KB。</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PCB_SIZE = <span class="hljs-number">4096</span>;         <br><span class="hljs-comment">// 存放PCB的数组，预留了MAX_PROGRAM_AMOUNT个PCB的大小空间。</span><br><span class="hljs-type">char</span> PCB_SET[PCB_SIZE * MAX_PROGRAM_AMOUNT]; <br><span class="hljs-comment">// PCB的分配状态，true表示已经分配，false表示未分配。</span><br><span class="hljs-type">bool</span> PCB_SET_STATUS[MAX_PROGRAM_AMOUNT];     <br></code></pre></td></tr></table></figure><ul><li>在<code>ProgramManager</code>中声明两个管理PCB所在的内存空间函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 分配一个PCB</span><br>PCB *<span class="hljs-title function_">allocatePCB</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 归还一个PCB</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">releasePCB</span><span class="hljs-params">(PCB *program)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>allocatePCB</code>会去检查<code>PCB_SET</code>中每一个PCB的状态，如果找到一个<strong>未被分配的PCB</strong>，则返回这个PCB的起始地址。若未找到，则返回nullptr。</li><li>PCB_SET中的PCB是连续存放的，对于第i个PCB，起始地址即为<code>i*PCB_SIZE</code></li><li><code>releasePCB</code>接受一个PCB指针<code>program</code>，然后计算出<code>program</code>指向的PCB在<code>PCB_SET</code>中的位置，然后将<code>PCB_SET_STATUS</code>中的对应位置设置<code>false</code>即可。</li></ul><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><ul><li>加入两个List成员，<code>allPrograms</code> （所有状态的线程、进程的队列）和<code>readyProframs</code>（处于就绪态的线程、进程的队列）</li><li>创建线程<ul><li>线程实际上执行的是<strong>某个函数的代码</strong>。（规定线程只能执行返回值为void，参数为 <code>void*</code> 的函数<br>  用于创建线程的函数：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个线程并放入就绪队列</span><br><span class="hljs-comment">// function：线程执行的函数</span><br><span class="hljs-comment">// parameter：指向函数的参数的指针</span><br><span class="hljs-comment">// name：线程的名称</span><br><span class="hljs-comment">// priority：线程的优先级</span><br><span class="hljs-comment">// 成功，返回pid；失败，返回-1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">executeThread</span><span class="hljs-params">(ThreadFunction function, <span class="hljs-type">void</span> *parameter, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> priority)</span>;<br></code></pre></td></tr></table></figure><p>具体实现的注解：<br><img src="/img/file-20250429104258940.png"></p><ul><li>4个为0的值是要放到ebp，ebx，edi，esi中的。</li><li><code>thread-&gt;stack[4]</code>是线程执行的函数的起始地址。</li><li><code>thread-&gt;stack[5]</code>是线程的返回地址，所有的线程执行完毕后都会返回到这个地址。</li><li><code>thread-&gt;stack[6]</code>是线程的参数的地址。</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>在ProgramManager中加入成员running，用来<u>记录当前处理机上执行的线程的PCB</u></p><ul><li>本次实验用的方法是RR（时间片轮转算法）</li><li>线程切换：<ul><li>由于线程的所有信息都在线程栈中，只要我们切换线程栈就能实现线程的切换，<strong>线程栈的切换就是将线程的栈指针放到esp中</strong></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">asm_switch_thread:<br>    push ebp<br>    push ebx<br>    push edi<br>    push esi<br><br>    mov eax, [esp + 5 * 4]<br>    mov [eax], esp ; 保存当前栈指针到PCB中，以便日后恢复<br><br>    mov eax, [esp + 6 * 4]<br>    mov esp, [eax] ; 此时栈已经从cur栈切换到next栈<br><br>    pop esi<br>    pop edi<br>    pop ebx<br>    pop ebp<br><br>    sti<br>    ret<br></code></pre></td></tr></table></figure><p>第2-5行，我们保存寄存器<code>ebp</code>，<code>ebx</code>，<code>edi</code>，<code>esi</code>。（C语言规则决定的，要求被调函数主动为主调函数保存这四个寄存器的值）<br>第7-8行，我们保存esp的值到线程的<code>PCB::statck</code>中，用做下次恢复。注意到<code>PCB::stack</code>在<code>PCB</code>的偏移地址是0。第7行代码是首先将<code>cur-&gt;stack</code>的地址放到<code>eax</code>中，第8行向<code>[eax]</code>中写入<code>esp</code>的值，也就是向<code>cur-&gt;stack</code>中写入esp。<br><img src="/img/file-20250429111214591.png"><br>第10-11行，我们将<code>next-&gt;stack</code>的值写入到esp中，从而完成线程栈的切换。<br><img src="/img/file-20250429111249331.png"><br>最后使用pop语句将四个0放入寄存器中。</p><h2 id="Example2-第一个线程"><a href="#Example2-第一个线程" class="headerlink" title="Example2 第一个线程"></a>Example2 第一个线程</h2><p>例子内容：创建第一个线程，并输出”hello world”，pid和线程的名字。</p><ul><li>第一个线程不可以返回</li><li>创建第一个线程：由于当前系统中没有线程，因此无法通过在时钟中断调度的方式将第一个线程换上处理器执行。而是要<strong>找出第一个线程的PCB</strong>，然后手动执行类似 <code>schedule</code> 的过程，最后执行 <code>asm_switch_thread</code> 会强制将第一个线程换上处理器执行。<br>这一部分是找到第一个线程的PCB，手动设置第一个线程为运行状态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">ListItem *item = programManager.readyPrograms.front();  <span class="hljs-comment">// 获取就绪队列的第一个线程</span><br>PCB *firstThread = ListItem2PCB(item, tagInGeneralList); <span class="hljs-comment">// 转换为 PCB 结构</span><br>firstThread-&gt;status = RUNNING;  <span class="hljs-comment">// 标记为运行状态</span><br>programManager.readyPrograms.pop_front();  <span class="hljs-comment">// 从就绪队列移除</span><br>programManager.running = firstThread;      <span class="hljs-comment">// 设为当前运行线程</span><br></code></pre></td></tr></table></figure><p>然后再使用线程切换程序，切换到第一个线程。作用是：</p><ul><li>保存当前的上下文</li><li>加载第一个线程的上下文</li><li>跳转到 <code>first_thread</code> 执行<br>运行结果：<br><img src="/img/file-20250430144301726.png"></li></ul><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><h2 id="Assignment1-printf的实现"><a href="#Assignment1-printf的实现" class="headerlink" title="Assignment1 printf的实现"></a>Assignment1 printf的实现</h2><p>学习可变参数机制，然后实现printf，你可以在材料中的printf上进行改进，或者从头开始实现自己的printf函数。结果截图并说说你是怎么做的。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul><li>我决定对材料中的printf进行改进，即添加一些新的格式化输出方式。</li><li>修改fmt解析过程，添加进新的格式化输出方式</li><li>得到新的格式化输出字符串之后，将这个字符串打印<br>PS:</li><li>实际上，我们会定义一个缓冲区，然后对fmt进行逐字符地解析，将结果逐字符的放到缓冲区中。放入一个字符后，我们会检查缓冲区，如果缓冲区已满，则将其输出，然后清空缓冲区，否则不做处理。</li></ul><p>材料中定义了一个print函数，作用是正确处理字符串中的换行符，暂时无需修改。</p><p>我要做的是修改printf函数实现，加入新的</p><ul><li>原本有的：<code>%d</code>，<code>%c</code>，<code>%s</code>，<code>%x</code>，<code>%%</code></li><li>加入：<code>%f</code>，<code>%o</code>，（还可能加入左右对齐）</li></ul><p>再次观察一下原本的printf函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF_LEN = <span class="hljs-number">32</span>;       <span class="hljs-comment">// 缓冲区大小（32字节）</span><br><span class="hljs-type">char</span> buffer[BUF_LEN + <span class="hljs-number">1</span>];      <span class="hljs-comment">// 临时缓冲区（存放待输出的字符）</span><br><span class="hljs-type">char</span> number[<span class="hljs-number">33</span>];               <span class="hljs-comment">// 数字转换缓冲区（存放整数转字符串的结果）</span><br><span class="hljs-type">int</span> idx, counter;              <span class="hljs-comment">// idx: buffer 的当前写入位置，counter: 已输出的字符总数</span><br>va_list ap;                    <span class="hljs-comment">// 可变参数列表</span><br></code></pre></td></tr></table></figure><p>初始化可变参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">va_start(ap, fmt);  <span class="hljs-comment">// 初始化 ap，使其指向第一个可变参数</span><br>idx = <span class="hljs-number">0</span>;            <span class="hljs-comment">// buffer 初始为空</span><br>counter = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 输出字符数初始为 0</span><br></code></pre></td></tr></table></figure><p>遍历格式化字符串 <code>fmt</code> 直至遇到 <code>\0</code></p><ul><li>一些判断<br>普通字符：存入 <code>buffer</code><br>这里的 <code>printf_add_to_buffer</code> 函数用于：</li></ul><ol><li>将字符 <code>fmt[i]</code> 写入 <code>buffer[idx]</code></li><li>如果 <code>buffer</code> 满了，先调用 <code>stdio.print(buffer)</code> 刷新缓冲区</li><li>返回 <code>1</code> （表示成功写入一个字符）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fmt[i] != <span class="hljs-string">&#x27;%&#x27;</span>)<br>&#123;<br>    counter += printf_add_to_buffer(buffer, fmt[i], idx, BUF_LEN);<br>&#125;<br></code></pre></td></tr></table></figure><p>格式化占位符：检查下一个字符，决定如何处理</p><ol><li>如果%是最后一个字符，直接结束</li><li>根据几种不同情况来进行处理</li></ol><p>输出%的情况：</p><ul><li><code>%%</code>的情况：将%加入到buffer中</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>    counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;%&#x27;</span>, idx, BUF_LEN);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><blockquote><p>[!NOTE]<br>C语言中当函数使用可变参数时，某些类型的参数会自动提升为更大的类型，以确保参数的传递一致性</p></blockquote><table><thead><tr><th>原始类型</th><th>提升后的类型</th></tr></thead><tbody><tr><td><code>char</code></td><td><code>int</code></td></tr><tr><td><code>short</code></td><td><code>int</code></td></tr><tr><td><code>float</code></td><td><code>double</code></td></tr></tbody></table><ul><li>%c的情况：从可变参数列表取出一个字符<br>所以这里从可变参数列表中提取的是一个 <code>int</code> （即使我们传入的是char）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>    counter += printf_add_to_buffer(buffer, va_arg(ap, <span class="hljs-type">int</span>), idx, BUF_LEN);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><ul><li>%s的情况：先刷新buffer，然后直接用stdio.print输出参数字符串，避免拷贝到buffer</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>    buffer[idx] = <span class="hljs-string">&#x27;\0&#x27;</span>;          <span class="hljs-comment">// 先终止当前 buffer</span><br>    idx = <span class="hljs-number">0</span>;                     <span class="hljs-comment">// 重置 buffer 指针</span><br>    counter += stdio.print(buffer);  <span class="hljs-comment">// 输出 buffer 中的内容</span><br>    counter += stdio.print(va_arg(ap, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *));  <span class="hljs-comment">// 直接输出参数字符串</span><br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><ul><li>%d和%x的情况：<br>先从参数列表中取出一个整数，然后进行处理<br>如果是一个负数，需要手动处理（%d）<br>然后将整数转换为字符串，逆序写入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br>    <span class="hljs-type">int</span> temp = va_arg(ap, <span class="hljs-type">int</span>);  <span class="hljs-comment">// 取出一个整数</span><br>    <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> &amp;&amp; fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span>)  <span class="hljs-comment">// 处理负数（仅十进制）</span><br>    &#123;<br>        counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;-&#x27;</span>, idx, BUF_LEN);<br>        temp = -temp;  <span class="hljs-comment">// 转为正数</span><br>    &#125;<br>    temp = itos(number, temp, (fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span> ? <span class="hljs-number">10</span> : <span class="hljs-number">16</span>));  <span class="hljs-comment">// 整数转字符串</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = temp - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j)  <span class="hljs-comment">// 逆序写入 buffer（因为 itos 返回的是反向字符串）</span><br>    &#123;<br>        counter += printf_add_to_buffer(buffer, number[j], idx, BUF_LEN);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>加入%f和%o：<br>实现方法：<br>八进制添加方法比较简单，直接参照十进制和十六进制即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<span class="hljs-comment">//八进制</span><br>    temp = va_arg(ap, <span class="hljs-type">int</span>); <span class="hljs-comment">// Declare temp here</span><br>    <span class="hljs-keyword">if</span> (temp &lt; <span class="hljs-number">0</span> &amp;&amp; fmt[i] == <span class="hljs-string">&#x27;d&#x27;</span>)<br>    &#123;<br>        counter += printf_add_to_buffer(buffer, <span class="hljs-string">&#x27;-&#x27;</span>, idx, BUF_LEN);<br>        temp = -temp;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fmt[i]==<span class="hljs-string">&#x27;d&#x27;</span>)&#123;<br>        itos(number, temp,<span class="hljs-number">10</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(fmt[i]==<span class="hljs-string">&#x27;x&#x27;</span>)&#123;<br>        itos(number, temp, <span class="hljs-number">16</span> );<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        itos(number, temp, <span class="hljs-number">8</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; number[j]; ++j)<br>    &#123;<br>        counter += printf_add_to_buffer(buffer, number[j], idx, BUF_LEN);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>浮点数输出稍微麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-comment">//浮点数</span><br>   tmp = va_arg(ap, <span class="hljs-type">double</span>); <span class="hljs-comment">//进制扩展</span><br>   <span class="hljs-type">char</span> float_str[<span class="hljs-number">64</span>];<br>   ftos(float_str, tmp, <span class="hljs-number">4</span>); <br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; float_str[j]; ++j)<br>   &#123;<br>       counter += printf_add_to_buffer(buffer, float_str[j], idx, BUF_LEN);<br>   &#125;<br>   <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>其他的部分和输出整数类似，但是需要重新写ftos函数，用于将浮点数转换为字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ftos</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">double</span> value, <span class="hljs-type">int</span> precision = <span class="hljs-number">6</span>)</span> &#123;<br>    <span class="hljs-type">char</span> *ptr = buf;<br><br>    <span class="hljs-comment">// 处理负数</span><br>    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>        *ptr++ = <span class="hljs-string">&#x27;-&#x27;</span>;<br>        value = -value;<br>    &#125;<br><br>    <span class="hljs-comment">// 提取整数部分</span><br>    <span class="hljs-type">int</span> integer = (<span class="hljs-type">int</span>)value;<br>    value -= integer;  <span class="hljs-comment">// 剩余小数部分</span><br><br>    <span class="hljs-comment">// 整数部分转字符串（逆序）</span><br>    <span class="hljs-type">char</span> int_str[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        int_str[i++] = <span class="hljs-string">&#x27;0&#x27;</span> + (integer % <span class="hljs-number">10</span>);<br>        integer /= <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">while</span> (integer &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 逆序写入整数部分</span><br>    <span class="hljs-keyword">while</span> (--i &gt;= <span class="hljs-number">0</span>) &#123;<br>        *ptr++ = int_str[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 添加小数点</span><br>    *ptr++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br><br>    <span class="hljs-comment">// 处理小数部分</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; precision; ++j) &#123;<br>        value *= <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> digit = (<span class="hljs-type">int</span>)value;<br>        *ptr++ = <span class="hljs-string">&#x27;0&#x27;</span> + digit;<br>        value -= digit;<br>    &#125;<br><br>    *ptr = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 终止字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：<br><img src="/img/file-20250430160236085.png"></p><h2 id="Assignment-2-线程的实现"><a href="#Assignment-2-线程的实现" class="headerlink" title="Assignment 2 线程的实现"></a>Assignment 2 线程的实现</h2><p>自行设计PCB，可以添加更多的属性，如优先级等，然后根据你的PCB来实现线程，演示执行结果。</p><p>实现过程：<br>我为PCB添加了<strong>优先级</strong>属性，修改了代码中的线程程序，打印出了优先级。但是由于我们还没有实现按照优先级进行抢占等调度方式，只实现了RR，所以并不会发生优先级抢占。<br><img src="/img/file-20250501194749870.png"><br><img src="/img/file-20250505223636947.png"></p><h2 id="Assignment-3-线程调度切换的秘密"><a href="#Assignment-3-线程调度切换的秘密" class="headerlink" title="Assignment 3 线程调度切换的秘密"></a>Assignment 3 线程调度切换的秘密</h2><p>操作系统的线程能够<strong>并发执行</strong>的秘密在于我们<u>需要中断线程的执行，保存当前线程的状态，然后调度下一个线程上处理机，最后使被调度上处理机的线程从之前被中断点处恢复执行</u>。现在，同学们可以亲手揭开这个秘密。</p><p>编写若干个线程函数，使用gdb跟踪<code>c_time_interrupt_handler</code>、<code>asm_switch_thread</code>等函数，观察线程切换前后栈、寄存器、PC等变化，结合gdb、材料中“线程的调度”的内容来跟踪并说明下面两个过程。</p><ul><li>一个新创建的线程是<strong>如何被调度</strong>然后<strong>开始执行</strong>的。</li><li>一个正在执行的线程是<strong>如何被中断然后被换下</strong>处理器的，以及<strong>换上处理机后又是如何从被中断点开始执行的</strong>。</li></ul><p>通过上面这个练习，同学们应该能够进一步理解操作系统是如何实现线程的并发执行的。</p><p>实现方法：<br>首先我在调度函数（ <code>schedule()</code>）中加入了打印信息：</p><p><img src="/img/file-20250501201034941.png"></p><p>开启gdb模式：<br>先追踪setup_kernel()函数</p><ul><li>先修改一下gdbinit添加断点</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">target remote:<span class="hljs-number">1234</span><br><span class="hljs-function"><span class="hljs-title">file</span></span> ../build/kernel.o<br><span class="hljs-keyword">set</span> disassembly-flavor <span class="hljs-comment">intel</span><br>b <span class="hljs-comment">setup_kernel</span><br>c<br></code></pre></td></tr></table></figure><p>再打开gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make debug<br></code></pre></td></tr></table></figure><p>启动界面如图所示：<br><img src="/img/file-20250501201808114.png"><br>已经加载好符号表，并跳转到即将进入setup_kernel()</p><p>一直到切换线程之前都没有输出，因为并没有调用调度函数。<br><img src="/img/file-20250501202011141.png"><br>但再向前一步就有输出了<br><img src="/img/file-20250501202044113.png"><br>现在发现pid&#x3D;0的进程无法退出（根），而third_thread程序中是死循环，所以会一直在pid&#x3D;0和pid&#x3D;2之间一直切换</p><p>再跟踪c_time_interrupt_handler()<br><img src="/img/file-20250501203827173.png"><br>可以看到启动后屏幕上打印了线程1的执行情况，说明现在进入了中断</p><p>在schedule()函数中我们设置了时间片为<code>优先级*10</code>，在创建线程时我们设置优先级均为1，所以时间片就为10了。所以要十次才会轮换<br><img src="/img/file-20250501210736317.png"><br>又过10次：<br><img src="/img/file-20250501210801326.png"><br>又过10次：<br><img src="/img/file-20250501210820361.png"></p><p>ps：<br><img src="/img/file-20250501205216649.png"></p><p>总的来说：</p><ul><li>线程并发执行的核心原理是通过快速、时分复用地切换CPU的使用权，给用户造成一种“所有线程同时运行的错觉”</li><li>新线程被选中是因为next指针指向了新创建线程的PCB</li><li>进入 asm_switch_thread 时，cur指向当前运行的线程，next指向新创建的线程，同时保存了cur线程的上下文。单步执行或者continue之后，PC会跳转到新线程的入口函数的第一条指令，然后开始执行。</li><li>中断的发生、切换与恢复<ul><li>触发中断后会进入到 <code>c_time_interrupt_handler</code>中</li><li>其中会处理tick计数、判断时间片是否用完等</li></ul></li><li>线程切换会使用到asm_switch_thread函数，最后ret恢复执行，再次调度回去。</li></ul><h2 id="（必做与选做）Assignment-4-调度算法的实现"><a href="#（必做与选做）Assignment-4-调度算法的实现" class="headerlink" title="（必做与选做）Assignment 4 调度算法的实现"></a>（必做与选做）Assignment 4 调度算法的实现</h2><p>在材料中，我们已经学习了如何使用时间片轮转算法来实现线程调度。但线程调度算法不止一种，例如</p><ul><li>先来先服务。</li><li>最短作业（进程）优先。</li><li>响应比最高者优先算法。</li><li>优先级调度算法。</li><li>多级反馈队列调度算法。</li></ul><p>此外，我们的调度算法还可以是抢占式的。</p><p>现在，同学们需要将线程调度算法修改为上面提到的算法或者是同学们自己设计的算法。然后，同学们需要自行编写测试样例来呈现你的算法实现的正确性和基本逻辑。最后，将结果截图并说说你是怎么做的。<strong>（先来先服务为必做，其他为选做）</strong></p><p>参考资料：<a href="https://gitee.com/link?target=https://zhuanlan.zhihu.com/p/97071815">https://zhuanlan.zhihu.com/p/97071815</a></p><p>Tips：</p><ul><li>先来先服务最简单。</li><li>有些调度算法的实现<strong>可能需要</strong>用到中断。</li></ul><p>提示：你可能需要改动的地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">lab5/src/<span class="hljs-number">4</span>/include/program.h<br><br><span class="hljs-comment">// 执行线程调度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 你自己的线程调度算法的声明</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">your_schedule</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">lab5/src/<span class="hljs-number">4</span>/src/kernel/program.cpp<br><br><span class="hljs-comment">// 你自己的线程调度算法的具体实现</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ProgramManager::your_schedule</span><span class="hljs-params">()</span>&#123;<br>...<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">program_exit</span><span class="hljs-params">()</span><br>&#123;<br>    PCB *thread = programManager.running;<br>    thread-&gt;status = ProgramStatus::DEAD;<br><br>    <span class="hljs-keyword">if</span> (thread-&gt;pid)<br>    &#123;<br>        <span class="hljs-comment">// 修改你想要调用的线程调度算法</span><br>        programManager.your_schedule();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        interruptManager.disableInterrupt();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;halt\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">lab5/src/<span class="hljs-number">4</span>/src/kernel/setup.cpp<br><br><span class="hljs-comment">// 你可以自由添加线程与修改打印信息</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">third_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 你可以添加多个线程</span><br><span class="hljs-comment">// 创建第一个线程</span><br><span class="hljs-type">int</span> pid = programManager.executeThread(first_thread, nullptr, <span class="hljs-string">&quot;first thread&quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can not execute thread\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br><span class="hljs-comment">// 再加入一个线程</span><br><span class="hljs-type">int</span> pid2 = programManager.executeThread(second_thread, nullptr, <span class="hljs-string">&quot;second_thread&quot;</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (pid2 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can not execute thread\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br></code></pre></td></tr></table></figure><p>FIFO算法：<br>按照任务进入队列的顺序，依次调用，执行完一个任务再执行下一个任务，只有当任务结束后才会发生切换。</p><p>SJF算法：<br>按照任务的耗时长短进行调度，优先调度耗时短的任务，这个算法有个前提，需要预先知道每个任务的耗时情况，这在实际情况中是不大现实的。另外，这个时间是指任务剩余还需要的执行时间，举例，一个耗时1小时的任务还剩10秒执行完成，这个时候若再来一个耗时1分钟的任务，调度仍然还是继续执行完那个耗时1小时的任务，因为他剩余的时间是10秒，比1分钟短，所以此算法又叫最短剩余时间任务有限算法（SRTJ），能够解决FIFO算法中短耗时任务等待前面耗时长任务的窘境。</p><p>先实现先进先出算法：<br>由于是执行完一个任务就执行下一个任务，即在任务结束才发生切换，不需要使用中断函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ProgramManager::FIFO_schedule</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">bool</span> status = interruptManager.getInterruptStatus();<br>    interruptManager.disableInterrupt();<br>    <br>    <span class="hljs-keyword">if</span>(readyPrograms.size() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;All thread has been finished.\n&quot;</span>);<br>        asm_halt();<br>    &#125;<br><br>    <span class="hljs-comment">//只需要判断进程是否结束，结束就释放掉</span><br>    <span class="hljs-keyword">if</span> (running-&gt;status == ProgramStatus::DEAD)<br>    &#123;<br>        releasePCB(running);<br>    &#125;<br><br>    ListItem *item = readyPrograms.front();<br>    PCB *next = ListItem2PCB(item, tagInGeneralList);<br>    PCB *cur = running;<br>    next-&gt;status = ProgramStatus::RUNNING;<br>    running = next;<br>    readyPrograms.pop_front();<br><br>    asm_switch_thread(cur, next);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d is finished, and pid %d is loaded and start to run.\n&quot;</span>, cur-&gt;pid, next-&gt;pid);<br><br>    <br>    interruptManager.setInterruptStatus(status);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">third_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    programManager.FIFO_schedule();<br>    <span class="hljs-comment">// while (1)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">second_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    programManager.FIFO_schedule();<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">first_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-comment">// 第1个线程不可以返回</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;pid, programManager.running-&gt;name);<br>    <span class="hljs-keyword">if</span> (!programManager.running-&gt;pid)<br>    &#123;<br>        programManager.executeThread(second_thread, nullptr, <span class="hljs-string">&quot;second thread&quot;</span>, <span class="hljs-number">2</span>);<br>        programManager.executeThread(third_thread, nullptr, <span class="hljs-string">&quot;third thread&quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>    programManager.FIFO_schedule();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250501214258828.png"></p><p>（非抢占）优先级调度算法：<br>主要就是每次执行完一个线程之后，运行下一个线程是从队列中取出优先级最高的线程来执行。<br>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ProgramManager::priority_schedule</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">bool</span> status = interruptManager.getInterruptStatus();<br>    interruptManager.disableInterrupt();<br><br>    <span class="hljs-keyword">if</span> (readyPrograms.size() == <span class="hljs-number">0</span>)<br>    &#123;<br>        interruptManager.setInterruptStatus(status);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前运行的进程仍然是运行状态，将其放回就绪队列</span><br>    <span class="hljs-keyword">if</span> (running-&gt;status == ProgramStatus::RUNNING)<br>    &#123;<br>        running-&gt;status = ProgramStatus::READY;<br>        <span class="hljs-comment">// running-&gt;ticks = running-&gt;priority * 10;</span><br>        readyPrograms.push_back(&amp;(running-&gt;tagInGeneralList));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (running-&gt;status == ProgramStatus::DEAD)<br>    &#123;<br>        releasePCB(running);<br>    &#125;<br><br><br>    <span class="hljs-comment">// 找到优先级最高的进程</span><br>    ListItem *highestPriorityItem = readyPrograms.front();<br>    PCB *highestPriorityPCB = ListItem2PCB(highestPriorityItem, tagInGeneralList);<br>    <br>    <span class="hljs-comment">// 遍历就绪队列找到优先级最高的进程</span><br>    ListItem *item = readyPrograms.front();<br>    <span class="hljs-keyword">while</span> (item != nullptr)<br>    &#123;<br>        PCB *pcb = ListItem2PCB(item, tagInGeneralList);<br>        <span class="hljs-keyword">if</span> (pcb-&gt;priority &gt; highestPriorityPCB-&gt;priority)<br>        &#123;<br>            highestPriorityPCB = pcb;<br>            highestPriorityItem = item;<br>        &#125;<br>        item = item-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 从就绪队列中移除将要运行的进程</span><br>    readyPrograms.erase(highestPriorityItem);<br><br>    PCB *cur = running;<br>    running = highestPriorityPCB;<br>    running-&gt;status = ProgramStatus::RUNNING;<br><br>    asm_switch_thread(cur, running);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pid %d is switched out, and pid %d with priority %d is loaded and start to run.\n&quot;</span>, <br>           cur-&gt;pid, running-&gt;pid, running-&gt;priority);<br><br>    interruptManager.setInterruptStatus(status);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修改一下线程，让输出可以显示出优先级的作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">third_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;priority: %d--pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;priority, programManager.running-&gt;pid, programManager.running-&gt;name);<br><br>    programManager.priority_schedule();<br><br>    <span class="hljs-comment">// while (1)</span><br><br>    <span class="hljs-comment">// &#123;</span><br><br>    <span class="hljs-comment">// &#125;</span><br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">second_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;priority: %d--pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;priority, programManager.running-&gt;pid, programManager.running-&gt;name);<br><br>    programManager.priority_schedule();<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">first_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br><br>&#123;<br><br>    <span class="hljs-comment">// 第1个线程不可以返回</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;priority: %d--pid %d name \&quot;%s\&quot;: Hello World!\n&quot;</span>, programManager.running-&gt;priority, programManager.running-&gt;pid, programManager.running-&gt;name);<br><br>    <span class="hljs-keyword">if</span> (!programManager.running-&gt;pid)<br><br>    &#123;<br><br>        programManager.executeThread(second_thread, nullptr, <span class="hljs-string">&quot;second thread&quot;</span>, <span class="hljs-number">2</span>);<br><br>        programManager.executeThread(third_thread, nullptr, <span class="hljs-string">&quot;third thread&quot;</span>, <span class="hljs-number">3</span>);<br><br>    &#125;<br><br>    programManager.priority_schedule();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现结果：<br><img src="/img/file-20250505222954149.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab4</title>
    <link href="/2025/04/02/OS-Lab4/"/>
    <url>/2025/04/02/OS-Lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lab4：中断"><a href="#OS-Lab4：中断" class="headerlink" title="OS_Lab4：中断"></a>OS_Lab4：中断</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul><li>DDL：<strong>2024年4月20号 24:00</strong></li><li>提交的内容：将<strong>4个assignment的代码</strong>和<strong>实验报告</strong>放到<strong>压缩包</strong>中，命名为“<strong>lab4-学号-姓名</strong>”，并交到课程并交到课程邮箱 <a href="https://gitee.com/link?target=mailto:os_sysu_lab@163.com">os_sysu_lab@163.com</a><br>  将实验报告的pdf提交至 <a href="https://gitee.com/link?target=http://inbox.weiyun.com/NOKI03hf">http://inbox.weiyun.com/NOKI03hf</a></li><li><strong>Example材料的代码放置在<code>src</code>目录下</strong>。</li></ul><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>本章会学习：</p><ul><li>C代码变成C程序的过程。</li><li>C&#x2F;C++项目的组织方法。</li><li>makefile的使用。</li><li>C和汇编混合编程。</li><li>保护模式中断处理机制。</li><li>8259A可编程中断处理部件。</li><li>时钟中断的处理。</li></ul><p>通过本章的学习，同学们将掌握<strong>使用C语言来编写内核</strong>的方法，<strong>理解保护模式的中断处理机制和处理时钟中断</strong>，为后面的二级分页机制和多线程&#x2F;进程打下基础。</p><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p><a href="https://www.cnblogs.com/linzworld/p/13690620.html">C语言-从代码到程序的过程理解 - 亥码 - 博客园</a></p><h2 id="C代码变成C程序的过程"><a href="#C代码变成C程序的过程" class="headerlink" title="C代码变成C程序的过程"></a>C代码变成C程序的过程</h2><p><img src="/img/file-20250402143442814.png"></p><ol><li>预处理：输入源程序并保存(.C文件)。<ul><li>处理源代码中以“#”开头的预编译指令</li><li>删掉注释行</li><li>.i文件中不包含任何宏定义和注释行</li></ul></li><li>将源文件转换成汇编代码（.s文件）的过程<ul><li>词法分析 -&gt; 语法分析 -&gt; 语义分析及相关的优化-&gt; 中间代码生成 -&gt; 目标代码生成（汇编文件.s）</li></ul></li><li>汇编阶段是把编译阶段生成的”.s”文件转成二进制目标代码（.o文件）。</li><li>将多个目标文件链接生成可执行文件( .EXE文件（windows）,.out文件（Linux）)。</li></ol><p>gcc指令生成中间过程文件：<br><code>gcc [选项] 要编译的文件 [选项] [目标文件]</code><br>or<br><code>gcc [option] filename [option] [objectfile]</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <span class="hljs-comment">//直接生成可执行文件main.out</span><br>gcc hello<span class="hljs-selector-class">.c</span> -o hello <br>gcc -E <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.i</span> <span class="hljs-comment">//生成预处理后的代码（还是文本文件）</span><br>gcc -S <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.s</span> <span class="hljs-comment">//汇编代码</span><br>gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o hello<span class="hljs-selector-class">.o</span> <span class="hljs-comment">//目标代码</span><br></code></pre></td></tr></table></figure><h3 id="example0"><a href="#example0" class="headerlink" title="example0"></a>example0</h3><p><strong>使用gcc跑一下程序</strong><br><img src="/img/file-20250402144450731.png"><br>or（可以不列举.h，因为.c文件中已经#include了，在.c&#x3D;&gt;.i阶段会将.h文件内容展开插入到）<br><img src="/img/file-20250402144559227.png"></p><ul><li>在.h中编写函数声明，不要在.h中实现函数，如果.h被多次引用可能会导致出现<strong>函数重定义</strong>问题</li><li>编译时要把所有.c和.cpp文件都加上去编译</li></ul><p><strong>查看各个步骤</strong></p><ul><li>预处理生成.i文件：<br>  <code>gcc -E main.c -o main</code></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 0 <span class="hljs-string">&quot;main.c&quot;</span></span><br><span class="hljs-meta"># 0 <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="hljs-meta"># 0 <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="hljs-meta"># 1 <span class="hljs-string">&quot;/usr/include/stdc-predef.h&quot;</span> 1 3 4</span><br><span class="hljs-meta"># 0 <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span> 2</span><br><span class="hljs-meta"># 1 <span class="hljs-string">&quot;main.c&quot;</span></span><br><span class="hljs-meta"># 1 <span class="hljs-string">&quot;print.h&quot;</span> 1  </span><br>  <br><br>void print_something()<span class="hljs-comment">;</span><br><span class="hljs-meta"># 2 <span class="hljs-string">&quot;main.c&quot;</span> 2</span><br><br><span class="hljs-built_in">int</span> main() &#123;<br><br>    print_something()<span class="hljs-comment">;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译生成汇编文件<br>  <code>gcc -S main.c -o main.s -masm=intel</code><br>  这里 <code>-masm=intel</code> 指示生成intel风格的汇编代码，否则默认AT&amp;T风格代码</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.file</span><span class="hljs-string">&quot;main.c&quot;</span><br><span class="hljs-meta">.intel_syntax</span> noprefix<br><span class="hljs-meta">.text</span><br><span class="hljs-meta">.globl</span>main<br><span class="hljs-meta">.type</span>main, @function<br><span class="hljs-symbol">main:</span><br><span class="hljs-symbol">.LFB0:</span><br><span class="hljs-meta">.cfi_startproc</span><br>endbr64<br><span class="hljs-keyword">push</span><span class="hljs-built_in">rbp</span><br><span class="hljs-meta">.cfi_def_cfa_offset</span> <span class="hljs-number">16</span><br><span class="hljs-meta">.cfi_offset</span> <span class="hljs-number">6</span>, -<span class="hljs-number">16</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-meta">.cfi_def_cfa_register</span> <span class="hljs-number">6</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">call</span>print_something@PLT<br><span class="hljs-keyword">mov</span><span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">pop</span><span class="hljs-built_in">rbp</span><br><span class="hljs-meta">.cfi_def_cfa</span> <span class="hljs-number">7</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">ret</span><br><span class="hljs-meta">.cfi_endproc</span><br><span class="hljs-symbol">.LFE0:</span><br><span class="hljs-meta">.size</span>main, .-main<br><span class="hljs-meta">.ident</span><span class="hljs-string">&quot;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&quot;</span><br><span class="hljs-meta">.section</span>.note<span class="hljs-number">.</span>GNU-stack,<span class="hljs-string">&quot;&quot;</span>,@progbits<br><span class="hljs-meta">.section</span>.note<span class="hljs-number">.</span>gnu<span class="hljs-number">.</span>property,<span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-meta">.long</span>1f - 0f<br><span class="hljs-meta">.long</span>4f - 1f<br><span class="hljs-meta">.long</span><span class="hljs-number">5</span><br><span class="hljs-number">0</span>:<br><span class="hljs-meta">.string</span><span class="hljs-string">&quot;GNU&quot;</span><br><span class="hljs-number">1</span>:<br><span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-meta">.long</span><span class="hljs-number">0xc0000002</span><br><span class="hljs-meta">.long</span>3f - 2f<br><span class="hljs-number">2</span>:<br><span class="hljs-meta">.long</span><span class="hljs-number">0x3</span><br><span class="hljs-number">3</span>:<br><span class="hljs-meta">.align</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span>:<br></code></pre></td></tr></table></figure><ul><li>重定位<br>  <code>gcc main.c print.c -o main.o</code><ul><li>在linux下，可重定位文件的格式是<strong>ELF</strong>文件格式，其包含了ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）等信息。</li></ul></li><li><strong>gcc是编译工具集合，在进行这些操作时会自动调用as、ld等</strong></li></ul><h2 id="Makefile（OS-Lab3中也有相关内容）"><a href="#Makefile（OS-Lab3中也有相关内容）" class="headerlink" title="Makefile（OS_Lab3中也有相关内容）"></a>Makefile（OS_Lab3中也有相关内容）</h2><p><img src="/img/file-20250402151015905.png"><br><img src="/img/file-20250402151025502.png"></p><h2 id="C-C-和汇编混合编程"><a href="#C-C-和汇编混合编程" class="headerlink" title="C&#x2F;C++和汇编混合编程"></a>C&#x2F;C++和汇编混合编程</h2><ul><li>在C&#x2F;C++代码中使用汇编代码实现的函数。</li><li>在汇编代码中使用C&#x2F;C++中的函数。</li></ul><p>混合编程是必要的，例如在bootloader初始化后，<strong>我们需要跳转到C&#x2F;C++编写的函数中执行</strong>；又如我们需要在C&#x2F;C++中调用使用汇编代码读取硬盘的函数。</p><ul><li>使用汇编函数（使用汇编函数实现的函数）来代替内联汇编</li></ul><p>&#x3D;&gt;汇编代码和C代码最终都会转换成可执行代码</p><ul><li>如果要在汇编代码中使用c函数，只需要在汇编代码中<strong>声明这个函数来自外部</strong>（在链接阶段才会使用到函数实现）</li><li>同理，要在c中使用汇编函数也只需要声明用到的函数来自外部即可<br>&#x3D;&gt;how？</li><li><strong>汇编代码</strong>：<br>使用来自C的函数：<br>声明：</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">extern</span> function_from_C<br></code></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">call</span> function_from_C<br></code></pre></td></tr></table></figure><p>使用来自CPP的函数：</p><ul><li>需要在C++代码的函数定义前加上<code>extern &quot;C&quot;</code></li><li>因为C++支持函数重载，为了区别同名的重载函数，C++在编译时会进行名字修饰。也就是说，<code>function_from_CPP</code>编译后的标号不再是<code>function_from_CPP</code>，而是要<strong>带上额外的信息</strong>。而&#x3D;&#x3D;C代码编译后的标号还是原来的函数名&#x3D;&#x3D;。</li><li>extern “C” 目的是告诉编译器按C代码规则编译，不加名字修饰。<br>在C++代码中声明：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">functionFromCpp</span>()</span>;<br></code></pre></td></tr></table></figure><p>在汇编代码中声明：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">extern</span> function_from_CPP<br></code></pre></td></tr></table></figure><ul><li>C&#x2F;CPP：<br>要先在汇编代码中奖函数声明为 <code>global</code>。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">global</span> function_from_asm<br></code></pre></td></tr></table></figure><p>C&#x2F;C++中声明其来自外部：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function_from_asm</span>()</span>;<br></code></pre></td></tr></table></figure><p>在C++中需要声明为 <code>extern &quot;C&quot;</code> </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function_from_asm</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="如果函数带返回值和参数"><a href="#如果函数带返回值和参数" class="headerlink" title="如果函数带返回值和参数"></a>如果函数带返回值和参数</h3><ul><li>如果函数有<strong>参数</strong>，那么参数&#x3D;&#x3D;<strong>从右向左&#x3D;&#x3D;依次入栈</strong>。</li><li>如果函数<strong>有返回值</strong>，返回值放在<strong>eax</strong>中。</li><li>放置于栈的参数一般使用<strong>ebp</strong>来获取。<br><strong>特别注意，汇编函数并没有函数参数和返回值的概念，因此汇编函数也被称为过程，不过是一段指令序列而已。</strong></li></ul><h3 id="Example1-混合编程"><a href="#Example1-混合编程" class="headerlink" title="Example1 混合编程"></a>Example1 混合编程</h3><ul><li>在文件<code>c_func.c</code>中定义C函数<code>function_from_C</code>。</li><li>在文件<code>cpp_func.cpp</code>中定义C++函数<code>function_from_CPP</code>。</li><li>在文件<code>asm_func.asm</code>中定义汇编函数<code>function_from_asm</code>，在<code>function_from_asm</code>中调用<code>function_from_C</code>和<code>function_from_CPP</code>。</li><li>在文件<code>main.cpp</code>中调用汇编函数<code>function_from_asm</code>。</li></ul><p>指令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o c_func<span class="hljs-selector-class">.o</span> -m32 -c c_func<span class="hljs-selector-class">.c</span><br>g++ -o cpp_func<span class="hljs-selector-class">.o</span> -m32 -c cpp_func<span class="hljs-selector-class">.cpp</span> <br>g++ -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -m32 -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>nasm -o asm_utils<span class="hljs-selector-class">.o</span> -f elf32 asm_utils<span class="hljs-selector-class">.asm</span><br>g++ -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.out</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> c_func<span class="hljs-selector-class">.o</span> cpp_func<span class="hljs-selector-class">.o</span> asm_utils<span class="hljs-selector-class">.o</span> -m32<br></code></pre></td></tr></table></figure><p><code>-f elf32</code>指定了nasm编译生成的文件格式是<code>ELF32</code>文件格式<br><img src="/img/file-20250402154026967.png"></p><h3 id="Example2：内核加载"><a href="#Example2：内核加载" class="headerlink" title="Example2：内核加载"></a>Example2：内核加载</h3><p>项目结构：</p><ul><li><code>project/build</code>。存放Makefile，make之后生成的中间文件如<code>.o</code>，<code>.bin</code>等会放置在这里，目的是防止这些文件混在代码文件中。</li><li><code>project/include</code>。存放<code>.h</code>等函数定义和常量定义的头文件等。</li><li><code>project/run</code>。存放gdb配置文件，硬盘映像<code>.img</code>文件等。</li><li><code>project/src</code>。存放<code>.c</code>，<code>.cpp</code>等函数实现的文件。</li></ul><p>不需要在.cpp文件中写出.h的具体地址，只需要在编译时指出include和.cpp文件的地址就行了。<br>编译指令中使用<code>-I</code>参数指明<strong>头文件的位置</strong>即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ -o hello -<span class="hljs-selector-tag">I</span>../include ../<span class="hljs-attribute">src</span>/hello<span class="hljs-selector-class">.cpp</span><br></code></pre></td></tr></table></figure><p>mbr &#x3D;&gt; bootloader &#x3D;&gt; kernel<br>进入内核后，定义内核起始点<br>src&#x2F;boot&#x2F;entry.asm：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">extern setup_kernel<br><span class="hljs-symbol">enter_kernel:</span><br>    <span class="hljs-keyword">jmp</span> setup_kernel<br></code></pre></td></tr></table></figure><p>在链接阶段巧妙地将<code>entry.asm</code>的代码放在内核代码的最开始部分，使得bootloader在执行跳转之后，转到的就是内核代码的起始指令，执行 <code>jmp setup_kernel</code> 。然后就跳转到了C++编写的函数<code>setup_kernel</code>，即可以使用c++来写内核了。</p><p>运行代码：<br>way1：不使用makefile</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cd build<br><span class="hljs-comment"># 编译mbr和bootloader</span><br>nasm -o mbr.bin -f bin -I<span class="hljs-built_in">..</span>/include/ <span class="hljs-built_in">..</span>/src/boot/mbr.asm<br>nasm -o bootloader.bin -f bin -I<span class="hljs-built_in">..</span>/include/ <span class="hljs-built_in">..</span>/src/boot/bootloader.asm<br><span class="hljs-comment"># `-I`参数指定了头文件路径，`-f`指定了生成的文件格式是二进制的文件。</span><br><br><span class="hljs-comment"># 编译内核的代码，将所有的代码都统一编译成可重定位文件，然后再链接成一个可执行文件</span><br><span class="hljs-comment"># 编译 entry.asm和asm_utils.asm</span><br>nasm -o entry.obj -f elf32 <span class="hljs-built_in">..</span>/src/boot/entry.asm<br>nasm -o asm_utils.o -f elf32 <span class="hljs-built_in">..</span>/src/utils/asm_utils.asm<br><br><span class="hljs-comment"># 编译setup.cpp</span><br>g++ -g -Wall <span class="hljs-attribute">-march</span>=i386 -m32 -nostdlib -fno-builtin -ffreestanding -fno-pic -I<span class="hljs-built_in">..</span>/include -c <span class="hljs-built_in">..</span>/src/kernel/setup.cpp<br><br><span class="hljs-comment"># 链接生成可重定位文件：kernel.bin和kernel.o（只包含代码的文件和可执行文件）</span><br><br>ld -o kernel.o -melf_i386 -N entry.obj setup.o asm_utils.o -e enter_kernel -Ttext 0x00020000<br>ld -o kernel.bin -melf_i386 -N entry.obj setup.o asm_utils.o -e enter_kernel -Ttext 0x00020000 --oformat binary<br><br><span class="hljs-comment"># 最后将mbr.bin bootloader.bin kernel.bin写入硬盘</span><br><br>dd <span class="hljs-attribute">if</span>=mbr.bin <span class="hljs-attribute">of</span>=../run/hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1 <span class="hljs-attribute">seek</span>=0 <span class="hljs-attribute">conv</span>=notrunc<br>dd <span class="hljs-attribute">if</span>=bootloader.bin <span class="hljs-attribute">of</span>=../run/hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=5 <span class="hljs-attribute">seek</span>=1 <span class="hljs-attribute">conv</span>=notrunc<br>dd <span class="hljs-attribute">if</span>=kernel.bin <span class="hljs-attribute">of</span>=../run/hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=200 <span class="hljs-attribute">seek</span>=6 <span class="hljs-attribute">conv</span>=notrunc<br><br><span class="hljs-comment"># 在run目录下启动</span><br><br>qemu-system-i386 -hda <span class="hljs-built_in">..</span>/run/hd.img -serial <span class="hljs-literal">null</span> -parallel stdio -no-reboot<br><br></code></pre></td></tr></table></figure><p>way2：使用makefile</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">cd build<br><span class="hljs-built_in">make</span><br><span class="hljs-built_in">make</span> <span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><p><img src="/img/file-20250402165250552.png"></p><p><strong>一些解释：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">g++ -g -Wall -march<span class="hljs-operator">=</span><span class="hljs-type">i386</span> -m<span class="hljs-number">32</span> -nostdlib -fno-<span class="hljs-keyword">builtin</span> -ffreestanding -fno-pic -I../include -<span class="hljs-keyword">c</span> ../src/kernel/setup.cpp<br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li><code>-O0</code>告诉编译器<strong>不开启编译优化</strong>。（如果要开启有几种可以选择，O1,O2,O3…</li><li><code>-Wall</code>告诉编译器<strong>显示所有编译器警告信息</strong></li><li><code>-march=i386</code>告诉编译器生成i386处理器下的<code>.o</code>文件格式。</li><li><code>-m32</code>告诉编译器生成<strong>32位</strong>的二进制文件。</li><li><code>-nostdlib -fno-builtin -ffreestanding -fno-pic</code>是告诉编译器不要包含C的任何标准库。</li><li><code>-g</code>表示向生成的文件中加入debug信息供gdb使用。</li><li><code>-I</code>指定了代码需要的头文件的目录。</li><li><code>-c</code>表示生成可重定位文件。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld -o kernel<span class="hljs-selector-class">.o</span> -melf_i386 -N entry<span class="hljs-selector-class">.obj</span> setup<span class="hljs-selector-class">.o</span> asm_utils<span class="hljs-selector-class">.o</span> -e enter_kernel -Ttext <span class="hljs-number">0</span>x00020000<br><br>ld -o kernel<span class="hljs-selector-class">.bin</span> -melf_i386 -N entry<span class="hljs-selector-class">.obj</span> setup<span class="hljs-selector-class">.o</span> asm_utils<span class="hljs-selector-class">.o</span> -e enter_kernel -Ttext <span class="hljs-number">0</span>x00020000 <span class="hljs-attr">--oformat</span> binary<br></code></pre></td></tr></table></figure><ul><li><code>-m</code>参数指定<strong>模拟器为i386</strong>。</li><li><code>-N</code>参数告诉链接器<strong>不要进行页对齐</strong>。</li><li><code>-Ttext</code>指定标号的起始地址。</li><li><code>-e</code>参数<strong>指定程序进入点</strong>。</li><li><code>--oformat</code>指定<strong>输出文件格式</strong>。<blockquote><p>[!NOTE]<br>为什么要生成两个文件呢？注意到上面两条指令差别仅在于是否有<code>-oformat binary</code>。实际上，<code>kernel.o</code>也是<code>ELF32</code>格式的，其不仅包含代码和数据，还包含<code>debug</code>信息和<code>elf</code>文件信息等。特别地，<code>kernel.o</code>开头并不是内核进入点，而是<code>ELF</code>的文件头，因此我们需要解析ELF文件才能找到真正的内核进入点。</p></blockquote></li></ul><p>&#x3D;&gt;为了简便，我们只希望链接生成的文件只有内核的代码，不包含其他信息。</p><blockquote><p>[!NOTE]<br>输出的二进制文件的机器指令顺序和<strong>链接时给出的文件顺序</strong>相同<br>所以要注意把entry.o放到最前面</p></blockquote><h2 id="保护模式下的中断"><a href="#保护模式下的中断" class="headerlink" title="保护模式下的中断"></a>保护模式下的中断</h2><p>中断：在外设产生请求时，通过一种信号告诉CPU应该暂停当前状态，转向处理外设请求，处理完之后再恢复到原先暂停的状态继续运行。<br>中断：</p><ul><li>外部中断（硬件产生，硬中断）<ul><li>屏蔽中断–INTR引脚产生</li><li>不可屏蔽中断–NMI引脚产生</li></ul></li><li>内部中断（软件产生，在程序中使用int指令调用，软中断）</li></ul><p>保护模式下的中断向量号：</p><table><thead><tr><th>向量号</th><th>助记符</th><th>说明</th><th>类型</th><th>错误号</th><th>产生源</th></tr></thead><tbody><tr><td>0</td><td>#DE</td><td>除出错</td><td>故障</td><td>无</td><td>DIV或IDIV指令</td></tr><tr><td>1</td><td>#DB</td><td>调试</td><td>故障&#x2F;陷阱</td><td>无</td><td>任何代码或数据引用，或是INT 1指令</td></tr><tr><td>2</td><td>–</td><td>NMI中断</td><td>中断</td><td>无</td><td>非屏蔽外部中断</td></tr><tr><td>3</td><td>#BP</td><td>断点</td><td>陷阱</td><td>无</td><td>INT 3指令</td></tr><tr><td>4</td><td>#OF</td><td>溢出</td><td>陷阱</td><td>无</td><td>INTO指令</td></tr><tr><td>5</td><td>#BR</td><td>边界范围超出</td><td>故障</td><td>无</td><td>BOUND指令</td></tr><tr><td>6</td><td>#UD</td><td>无效操作码（未定义操作码）</td><td>故障</td><td>无</td><td>UD2指令或保留的操作码。（Pentium Pro中加入的新指令）</td></tr><tr><td>7</td><td>#NM</td><td>设备不存在（无数学协处理器）</td><td>故障</td><td>无</td><td>浮点或WAIT&#x2F;FWAIT指令</td></tr><tr><td>8</td><td>#DF</td><td>双重错误</td><td>异常终止</td><td>有（0）</td><td>任何可产生异常、NMI或INTR的指令</td></tr><tr><td>9</td><td>–</td><td>协处理器段超越（保留）</td><td>故障</td><td>无</td><td>浮点指令（386以后的CPU不产生该异常）</td></tr><tr><td>10</td><td>#TS</td><td>无效的任务状态段TSS</td><td>故障</td><td>有</td><td>任务交换或访问TSS</td></tr><tr><td>11</td><td>#NP</td><td>段不存在</td><td>故障</td><td>有</td><td>加载段寄存器或访问系统段</td></tr><tr><td>12</td><td>#SS</td><td>堆栈段错误</td><td>故障</td><td>有</td><td>堆栈操作和SS寄存器加载</td></tr><tr><td>13</td><td>#GP</td><td>一般保护错误</td><td>故障</td><td>有</td><td>任何内存引用和其他保护检查</td></tr><tr><td>14</td><td>#PF</td><td>页面错误</td><td>故障</td><td>有</td><td>任何内存引用</td></tr><tr><td>15</td><td>–</td><td>（Intel保留，请勿使用）</td><td></td><td>无</td><td></td></tr><tr><td>16</td><td>#MF</td><td>x87 FPU浮点错误（数学错误）</td><td>故障</td><td>无</td><td>x87 FPU浮点或WAIT&#x2F;FWAIT指令</td></tr><tr><td>17</td><td>#AC</td><td>对起检查</td><td>故障</td><td>有（0）</td><td>对内存中任何数据的引用</td></tr><tr><td>18</td><td>#MC</td><td>机器检查</td><td>异常终止</td><td>无</td><td>错误码（若有）和产生源与CPU类型有关（奔腾处理器引进）</td></tr><tr><td>19</td><td>#XF</td><td>SIMD浮点异常</td><td>故障</td><td>无</td><td>SSE和SSE2浮点指令（PIII处理器引进）</td></tr><tr><td>20-31</td><td>–</td><td>（Intel保留，请勿使用）</td><td></td><td></td><td></td></tr><tr><td>32-255</td><td>–</td><td>用户定义（非保留）中断</td><td>中断</td><td></td><td>外部中断或者INT n指令</td></tr></tbody></table><h3 id="中断处理机制"><a href="#中断处理机制" class="headerlink" title="中断处理机制"></a>中断处理机制</h3><p>保护模式下中断处理程序处理过程：</p><ul><li>中断前的准备。</li><li>CPU 检查是否有<strong>中断信号</strong>。</li><li>CPU根据<strong>中断向量号</strong>到IDT中取得处理这个向量的<strong>中断描述符</strong>。</li><li>CPU根据中断描述符中的段选择符到 GDT 中找到相应的段描述符。</li><li>CPU 根据特权级的判断设定即将运行程序的栈地址。</li><li>CPU保护现场。</li><li>CPU跳转到中断服务程序的第一条指令开始处执行。</li><li>中断服务程序运行。</li><li>中断服务程序处理完成，使用iret返回。</li></ul><h4 id="中断前的准备"><a href="#中断前的准备" class="headerlink" title="中断前的准备"></a>中断前的准备</h4><ul><li><p>为了标识中断处理程序的位置，保护模式使用了中断描述符（64位）。<br><img src="/img/file-20250402171903443.png"></p></li><li><p>段选择子：中断程序所在段的选择子。</p></li><li><p>偏移量：中断程序的代码在中断程序所在段的偏移位置。</p></li><li><p>P位：段存在位。 0表示不存在，1表示存在。</p></li><li><p>DPL：特权级描述。 0-3 共4级特权，特权级从0到3依次降低。</p></li><li><p>D位： D&#x3D;1表示32位代码，D&#x3D;0表示16位代码。</p></li><li><p>保留位：保留不使用。</p></li></ul><p>中断描述符的结合被称为中断描述符表IDT，并存放在IDTR中。<br><img src="/img/file-20250402172029124.png"><br>中断描述符最多有2^16&#x2F;2^3&#x3D;2^13<br>但CPU只能处理前256个中断，所以我们只会往IDT中放入256个中断描述符。<br>类似地，我们使用<strong>lidt指令</strong>对IDTR赋值<br><img src="/img/file-20250402172325228.png" alt="使用lgdt为GDTR赋值"></p><h4 id="CPU检查是否有中断信号"><a href="#CPU检查是否有中断信号" class="headerlink" title="CPU检查是否有中断信号"></a>CPU检查是否有中断信号</h4><ul><li>除了主动调用中断之外，CPU<strong>每执行完一条指令</strong>之后，就回去中断控制器8259A中检查是否有中断请求。</li><li>若有中断请求，在相应的时钟脉冲到来时，CPU就会<strong>从总线上读取中断向量号</strong>。</li><li>根据中断向量号到IDT中取得对应的<strong>中断描述符</strong>（中断的向量号就是中断描述符在IDT的序号）</li><li>CPU根据中断描述符中的<strong>段选择符</strong>到<strong>GDT</strong>中找到相应的段描述符</li><li>CPU 根据特权级的判断设定即将运行程序的栈地址</li><li>CPU保护现场<ul><li>依次将EFLAGS，CS，EIP中的内容压栈（特权级不变时）</li><li>从用户态切换到内核态后，CPU会依次将SS，ESP，EFLAGS、CS、EIP压栈（特权级改变时）</li></ul></li><li>CPU跳转到中断服务程序的第一条指令开始处执行</li><li>中断服务程序运行</li><li><strong>中断服务程序处理完成，使用iret返回。</strong> <ul><li>在特权级不发生变化的情况下，iret会将之前压入栈的EFLAGS，CS，EIP的值送入对应的寄存器，然后便实现了中断返回。若特权级发生变化，CPU还会更新SS和ESP。</li></ul></li></ul><h3 id="Example3"><a href="#Example3" class="headerlink" title="Example3"></a>Example3</h3><p>&#x3D;&gt;what to do：初始化IDT的256个中断</p><ul><li>这256个中断的中断处理程序均是向栈中压入<code>0xdeadbeef</code>后做死循环。<br>我们要做的事情只有三件。</li><li>确定IDT的地址。</li><li>定义中断默认处理函数。</li><li>初始化256个中断描述符。</li></ul><h4 id="中断管理器"><a href="#中断管理器" class="headerlink" title="中断管理器"></a>中断管理器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> INTERRUPT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERRUPT_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;os_type.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterruptManager</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    <span class="hljs-comment">// IDT起始地址</span><br>    uint32 *IDT;<br>    <br>public:<br>    InterruptManager();<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 设置中断描述符</span><br>    <span class="hljs-comment">// index   第index个描述符，index=0, 1, ..., 255</span><br>    <span class="hljs-comment">// address 中断处理程序的起始地址</span><br>    <span class="hljs-comment">// DPL     中断描述符的特权级</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">setInterruptDescriptor</span><span class="hljs-params">(uint32 index, uint32 address, byte DPL)</span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h5 id="初始化IDT-initialize"><a href="#初始化IDT-initialize" class="headerlink" title="初始化IDT: initialize()"></a>初始化IDT: <code>initialize()</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::initialize</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 初始化IDT</span><br>    IDT = (uint32 *)IDT_START_ADDRESS;<br>    asm_lidt(IDT_START_ADDRESS, <span class="hljs-number">256</span> * <span class="hljs-number">8</span> - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i)<br>    &#123;<br>        setInterruptDescriptor(i, (uint32)asm_interrupt_empty_handler, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>设置IDT地址，然后初始化256个中断描述符（每个8字节）</p><ul><li>IDT_START_ADDRESS&#x3D;…</li><li>CPU&#x3D;&gt;IDTR&#x3D;&gt;IDT<ul><li>CPU先到IDTR寻找IDT的地址</li><li>根据中断向量号在IDT找到对应的中断描述符</li><li>跳转到对应的函数</li></ul></li><li>此处确定IDTR的32位基地址为0x8880，表界限为2047（8 * 256 - 1）</li><li><code>lidt [tag]</code><ul><li>将以tag为起始地址的48字节放入到寄存器IDTR中</li><li>C语言中初始化IDT的方法：在汇编代码中实现函数 <code>asm_lidt</code> 用于将IDT信息放入到IDTR中</li></ul></li></ul><h5 id="定义中断描述符"><a href="#定义中断描述符" class="headerlink" title="定义中断描述符"></a>定义中断描述符</h5><p>中断描述符中有几个值是定值：</p><ul><li>P&#x3D;1表示存在。</li><li>D&#x3D;1表示32位代码。</li><li>DPL&#x3D;0表示特权级0.</li><li>代码段选择子等于bootloader中的代码段选择子，也就是寻址4GB空间的代码段选择子。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置中断描述符</span><br><span class="hljs-comment">// index   第index个描述符，index=0, 1, ..., 255</span><br><span class="hljs-comment">// address 中断处理程序的起始地址</span><br><span class="hljs-comment">// DPL     中断描述符的特权级</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::setInterruptDescriptor</span><span class="hljs-params">(uint32 index, uint32 address, byte DPL)</span><br>&#123;<br>    IDT[index * <span class="hljs-number">2</span>] = (CODE_SELECTOR &lt;&lt; <span class="hljs-number">16</span>) | (address &amp; <span class="hljs-number">0xffff</span>);<br>    IDT[index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = (address &amp; <span class="hljs-number">0xffff0000</span>) | (<span class="hljs-number">0x1</span> &lt;&lt; <span class="hljs-number">15</span>) | (DPL &lt;&lt; <span class="hljs-number">13</span>) | (<span class="hljs-number">0xe</span> &lt;&lt; <span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>IDT是起始地址指针</li></ul><h5 id="中断默认处理函数"><a href="#中断默认处理函数" class="headerlink" title="中断默认处理函数"></a>中断默认处理函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">ASM_UNHANDLED_INTERRUPT_INFO db &#x27;Unhandled interrupt happened, halt...&#x27;<br>                             db 0<br><br>; void asm_unhandled_interrupt()<br>asm_unhandled_interrupt:<br>    cli ;关中断<br>    mov esi, ASM_UNHANDLED_INTERRUPT_INFO ;提示字符串<br>    xor ebx, ebx<br>    mov ah, 0x03<br>.output_information:<br>    cmp byte[esi], 0<br>    je .end<br>    mov al, byte[esi]<br>    mov word[gs:bx], ax<br>    inc esi<br>    add ebx, 2<br>    jmp .output_information<br>.end:<br>    jmp $<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250405172317304.png"></p><p><img src="/img/file-20250405172728632.png"></p><h2 id="8259A-芯片（可编程中断控制器）"><a href="#8259A-芯片（可编程中断控制器）" class="headerlink" title="8259A 芯片（可编程中断控制器）"></a>8259A 芯片（可编程中断控制器）</h2><blockquote><p>[!NOTE]<br>硬中断和软中断指示调用方式不同，而中断的初始化和中断描述符的设置方式是完全相同的</p></blockquote><p>计算机需要知道这些中断请求的中断向量号和优先级，可以通过8259A芯片解决（用代码来修改其处理优先级、屏蔽某个中断等）</p><h3 id="8259A的初始化"><a href="#8259A的初始化" class="headerlink" title="8259A的初始化"></a>8259A的初始化</h3><p>初始化过程是<strong>依次通过向8259A的特定端口发送4个ICW</strong>，ICW1~ICW4（初始化命令字，Initialization Command Words）来完成的。</p><blockquote><p>[!NOTE]<br>四个ICW必须严格按照顺序依次发送</p></blockquote><h4 id="ICW结构"><a href="#ICW结构" class="headerlink" title="ICW结构"></a>ICW结构</h4><h5 id="ICW1：发送到0x20端口（主片）和0xA0端口（从片）"><a href="#ICW1：发送到0x20端口（主片）和0xA0端口（从片）" class="headerlink" title="ICW1：发送到0x20端口（主片）和0xA0端口（从片）"></a>ICW1：发送到0x20端口（主片）和0xA0端口（从片）</h5><p><img src="/img/file-20250405173725507.png"></p><ul><li><p>I位：若<strong>置1</strong>，表示<strong>ICW4会被发送</strong>。置0表示ICW4不会被发送。我们会发送ICW4，所以I位置1。</p></li><li><p>C位：若<strong>置0</strong>，表示8259A工作在&#x3D;&#x3D;级联&#x3D;&#x3D;环境下。8259A的主片和从片我们都会使用到，所以C位置0。</p></li><li><p>M位：指出中断请求的<strong>电平触发模式</strong>，在PC机中，M位应当被置0，表示采用“<strong>边沿触发模式</strong>”。</p></li></ul><h5 id="ICW2：发送到0x21（主片）和0xA1（从片）端口"><a href="#ICW2：发送到0x21（主片）和0xA1（从片）端口" class="headerlink" title="ICW2：发送到0x21（主片）和0xA1（从片）端口"></a>ICW2：发送到0x21（主片）和0xA1（从片）端口</h5><p><img src="/img/file-20250405173905771.png"></p><p>对于主片和从片，ICW2都是用来表示当&#x3D;&#x3D;IRQ0&#x3D;&#x3D;的中断发生时，8259A会向CPU提供的中断向量号。</p><p>此后，IRQ0，IRQ1，…，IRQ7的<strong>中断号</strong>为ICW2，ICW2+1，ICW2+2，…，ICW2+7。</p><p>&#x3D;&#x3D;ICW2的低3位必须是0&#x3D;&#x3D;</p><h5 id="ICW3：发送到0x21（主片）和0xA1（从片）端口"><a href="#ICW3：发送到0x21（主片）和0xA1（从片）端口" class="headerlink" title="ICW3：发送到0x21（主片）和0xA1（从片）端口"></a>ICW3：发送到0x21（主片）和0xA1（从片）端口</h5><ul><li>ICW3只有在级联工作时才会被发送，主要用来建立两处PIC之间的连接，对于主片和从片，其结构是不一样的</li><li>主片：<br><img src="/img/file-20250405174025929.png"><br>上面的相应位被置1，则相应的IRQ线就被用作于与从片相连，若置0则表示被连接到外围设备。</li></ul><p>从片被连接到主片的IRQ2位，所以主片只有第2位被置1&#x3D;&gt;主片<strong>ICW3&#x3D;0x04</strong></p><ul><li>从片：<br><img src="/img/file-20250405174118941.png"><br>IRQ指出是主片的哪一个IRQ连接到了从片，这里，从片的<strong>ICW3&#x3D;0x02</strong>，即IRQ&#x3D;0x02，其他位置均为0。</li></ul><h5 id="ICW4：发送到0x21（主片）和0xA1（从片）端口"><a href="#ICW4：发送到0x21（主片）和0xA1（从片）端口" class="headerlink" title="ICW4：发送到0x21（主片）和0xA1（从片）端口"></a>ICW4：发送到0x21（主片）和0xA1（从片）端口</h5><p><img src="/img/file-20250405174414639.png"></p><ul><li><p>EOI位：若置1表示<strong>自动结束</strong>，在PC位上这位需要被清零，详细原因在后面再提到。</p></li><li><p>80x86位：置1表示PC工作在80x86架构下，因此我们置1。</p></li></ul><blockquote><p>[!NOTE]<br>ICW1,ICW3,ICW4的值已经固定，可变的只有ICW2</p></blockquote><h3 id="8259A的工作流程"><a href="#8259A的工作流程" class="headerlink" title="8259A的工作流程"></a>8259A的工作流程</h3><p>（无需掌握）</p><blockquote><p>[!NOTE]<br><strong>对于8259A芯片产生的中断，我们需要手动在中断返回前向8259A发送EOI消息。如果没有发送EOI消息，那么此后的中断便不会被响应</strong></p></blockquote><p>发送EOI消息的示例代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;发送OCW2字</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>, <span class="hljs-built_in">al</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>, <span class="hljs-built_in">al</span><br></code></pre></td></tr></table></figure><ul><li>8259A的中断处理函数末尾必须加上这段代码，否则中断不会被响应</li></ul><h3 id="优先级、中断屏蔽字和EOI消息的动态改变"><a href="#优先级、中断屏蔽字和EOI消息的动态改变" class="headerlink" title="优先级、中断屏蔽字和EOI消息的动态改变"></a>优先级、中断屏蔽字和EOI消息的动态改变</h3><p><strong>初始化</strong>8259A后，可以在任何时优先级、中断屏蔽字和EOI消息的动态改变候<strong>发送OCW</strong>（Operation Command Words）字来实现</p><p>OCW有三个：OCW1，OCW2，OCW3</p><ul><li><p>OCW1：中断屏蔽，发送到0x21（主片）或0xA1（从片）端口<br><img src="/img/file-20250409142738523.png"><br>位置1表示<strong>屏蔽相应的IRQ请求</strong>。<br>在初始化8259A的代码末尾，将0xFF发送到0x21和0xA1端口。这是因为我们还没建立起处理8259A芯片的中断处理函数，所以暂时屏蔽主片和从片的所有中断。</p></li><li><p>OCW2：一般用于<strong>发送EOI消息</strong>，发送到0x20（主片）或0xA0（从片）端口。<br><img src="/img/file-20250409142845513.png"><br>EOI消息是发送<code>0x20</code>，即<strong>只有EOI位是1</strong>，<strong>其他位置为0</strong>。</p></li><li><p>OCW3：用于<u>设置下一个读端口动作将要读取的IRR或ISR</u>，我们不需要使用。</p></li></ul><h3 id="中断程序编写思路"><a href="#中断程序编写思路" class="headerlink" title="中断程序编写思路"></a>中断程序编写思路</h3><ul><li><strong>保护现场</strong>。保存寄存器中的内容（压栈）</li><li><strong>中断处理</strong>。执行中断处理程序</li><li><strong>恢复现场</strong>。处理完中断后恢复之前放在栈中的寄存器内容，然后执行 <code>iret</code> 返回。执行 <code>iret</code>前，如果有错误码，则需要将错误码弹出栈；如果是8259A芯片产生的中断，则需要在中断返回前发送EOI消息。<ul><li>注意，8259A芯片产生的中断不会错误码。事实上，只有中断向量号1-19的部分中断才会产生错误码。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">interrupt_handler_example:</span><br><span class="hljs-keyword">pushad</span><br>... <span class="hljs-comment">; 中断处理程序</span><br><span class="hljs-keyword">popad</span><br><br><span class="hljs-comment">; 非必须</span><br><br><span class="hljs-comment">; 1 弹出错误码，没有则不可以加入</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span><br><br><span class="hljs-comment">; 2 对于8259A芯片产生的中断，最后需要发送EOI消息，若不是则不可以加入</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>, <span class="hljs-built_in">al</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>, <span class="hljs-built_in">al</span><br><br><span class="hljs-keyword">iret</span> <span class="hljs-comment">;中断返回</span><br></code></pre></td></tr></table></figure><h3 id="Example4-8259A编程"><a href="#Example4-8259A编程" class="headerlink" title="Example4 8259A编程"></a>Example4 8259A编程</h3><p><img src="/img/file-20250409144538936.png"></p><ul><li>初始化8259A芯片：</li></ul><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">void</span> InterruptManager::initialize<span class="hljs-number">8259</span>A()<br>&#123;<br>    <span class="hljs-comment">// ICW 1</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">20</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span>);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">0</span>, <span class="hljs-number">0</span>x<span class="hljs-number">11</span>);<br>    <span class="hljs-comment">// ICW 2</span><br>    IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_M</span>ASTER = <span class="hljs-number">0</span>x<span class="hljs-number">20</span>;<br>    IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_</span>SLAVE = <span class="hljs-number">0</span>x<span class="hljs-number">28</span>;<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_M</span>ASTER);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, IRQ<span class="hljs-number">0_8259</span>A<span class="hljs-number">_</span>SLAVE);<br>    <span class="hljs-comment">// ICW 3</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, <span class="hljs-number">4</span>);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-comment">// ICW 4</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, <span class="hljs-number">1</span>);<br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// OCW 1 屏蔽主片所有中断，但主片的IRQ2需要开启</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>x<span class="hljs-number">21</span>, <span class="hljs-number">0</span>xfb);<br>    <span class="hljs-comment">// OCW 1 屏蔽从片所有中断</span><br>    asm<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_p</span>ort(<span class="hljs-number">0</span>xa<span class="hljs-number">1</span>, <span class="hljs-number">0</span>xff);<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化8259A芯片的过程是通过设置一系列的ICW字来完成的。由于我们并未建立处理8259A中断的任何函数，因此在初始化的最后，我们需要屏蔽主片和从片的所有中断。</p><ul><li><code>asm_out_port</code> 是对 <code>out</code> 指令的封装</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_out_port:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">2</span>] <span class="hljs-comment">; port</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">3</span>] <span class="hljs-comment">; value</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br>    <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><ul><li><code>asm_in_port</code> 是对 <code>in</code> 指令的封装</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; void asm_in_port(uint16 port, uint8 *value)</span><br><span class="hljs-symbol">asm_in_port:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span><br><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">2</span>] <span class="hljs-comment">; port</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">4</span> * <span class="hljs-number">3</span>] <span class="hljs-comment">; *value</span><br><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">ebx</span>], <span class="hljs-built_in">al</span><br><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><ul><li>处理时钟中断：主片的IRQ0中断<ul><li>8253芯片能以一定频率来产生时钟中断。当产生了时钟中断后，信号会被8259A截获，从而产生IRQ0中断。处理时钟中断：<ul><li>编写中断处理函数</li><li>设置主片IRQ0中断对应的中断描述符</li><li>开启时钟中断</li><li>开中断</li></ul></li></ul></li></ul><p>&#x3D;&gt;编写中断处理函数：<br>不再使用放置字符到显存地址的方式来显示字符，而是去封装一个函数来处理屏幕输出的类 <code>STDIO</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> STDIO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STDIO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;os_type.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">STDIO</span></span><br><span class="hljs-class">&#123;</span><br>private:<br>    uint8 *screen;<br><br>public:<br>    STDIO();<br>    <span class="hljs-comment">// 初始化函数</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 打印字符c，颜色color到位置(x,y)</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(uint x, uint y, uint8 c, uint8 color)</span>;<br>    <span class="hljs-comment">// 打印字符c，颜色color到光标位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(uint8 c, uint8 color)</span>;<br>    <span class="hljs-comment">// 打印字符c，颜色默认到光标位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(uint8 c)</span>;<br>    <span class="hljs-comment">// 移动光标到一维位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">moveCursor</span><span class="hljs-params">(uint position)</span>;<br>    <span class="hljs-comment">// 移动光标到二维位置</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">moveCursor</span><span class="hljs-params">(uint x, uint y)</span>;<br>    <span class="hljs-comment">// 获取光标位置</span><br>    uint <span class="hljs-title function_">getCursor</span><span class="hljs-params">()</span>;<br><br>public:<br>    <span class="hljs-comment">// 滚屏</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">rollUp</span><span class="hljs-params">()</span>;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>处理光标位置<ul><li>与光标读写相关的端口： <code>0x3d4</code> 和 <code>0x3d5</code></li><li>需要向端口<code>0x3d4</code>写入数据，表明处理的是高8位（0x0e）还是低8位(0x0f)</li><li>从<code>0x3d5</code>读取数据可以读取到光标的位置，如果要改变光标的位置，将新位置写入&#96;0x3d5<br>  移动光标：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">STDIO::moveCursor</span><span class="hljs-params">(uint position)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">80</span> * <span class="hljs-number">25</span>) <span class="hljs-comment">//判断是否溢出</span><br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    uint8 temp;<br><br>    <span class="hljs-comment">// 处理高8位</span><br>    temp = (position &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>;<br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0e</span>);<br>    asm_out_port(<span class="hljs-number">0x3d5</span>, temp);<span class="hljs-comment">//out--写入</span><br><br>    <span class="hljs-comment">// 处理低8位</span><br>    temp = position &amp; <span class="hljs-number">0xff</span>;<br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0f</span>);<br>    asm_out_port(<span class="hljs-number">0x3d5</span>, temp);<br>&#125;<br></code></pre></td></tr></table></figure><p>获取光标：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">uint <span class="hljs-title function_">STDIO::getCursor</span><span class="hljs-params">()</span><br>&#123;<br>    uint pos;<br>    uint8 temp;<br><br>    pos = <span class="hljs-number">0</span>;<br>    temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 处理高8位</span><br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0e</span>);<br>    asm_in_port(<span class="hljs-number">0x3d5</span>, &amp;temp);<span class="hljs-comment">//in--读取</span><br>    pos = ((uint)temp) &lt;&lt; <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">// 处理低8位</span><br>    asm_out_port(<span class="hljs-number">0x3d4</span>, <span class="hljs-number">0x0f</span>);<br>    asm_in_port(<span class="hljs-number">0x3d5</span>, &amp;temp);<br>    pos = pos | ((uint)temp);<br><br>    <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>中断处理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 中断处理函数</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">void</span> <span class="hljs-title function_">c_time_interrupt_handler</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 清空屏幕</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80</span>; ++i)<br>    &#123;<br>        stdio.print(<span class="hljs-number">0</span>, i, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0x07</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出中断发生的次数</span><br>    ++times;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;interrupt happend: &quot;</span>;<br>    <span class="hljs-type">char</span> number[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> temp = times;<br><br>    <span class="hljs-comment">// 将数字转换为字符串表示</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i ) &#123;<br>        <span class="hljs-keyword">if</span>(temp) &#123;<br>            number[i] = temp % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            number[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        temp /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动光标到(0,0)输出字符</span><br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; ++i ) &#123;<br>        stdio.print(str[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出中断发生的次数</span><br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">9</span>; i &gt; <span class="hljs-number">0</span>; --i ) &#123;<br>        stdio.print(number[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面这个函数还不完全是一个中断处理函数，因为我们进入中断后需要保护现场，离开中断需要恢复现场</strong>。这里，现场指的是寄存器的内容。但是，C语言并未提供相关指令。最重要的是，中断的返回需要使用<code>iret</code>指令，而C语言的任何函数编译出来的返回语句都是<code>ret</code>。因此，我们<strong>只能在汇编代码中完成保护现场、恢复现场和中断返回</strong></p><p>中断发生后 &#x3D;&gt; CPU跳转到汇编实现的代码 &#x3D;&gt; 使用汇编代码保存寄存器的内容 &#x3D;&gt; 保护现场后，调用 <code>call</code> 指令来跳转到C语言编写的中断函数主题 &#x3D;&gt; C语言函数返回后 &#x3D;&gt; 返回到 <code>call</code> 指令的下一条汇编代码 &#x3D;&gt; 汇报代码中恢复保存的寄存器内容 &#x3D;&gt; <code>iret</code>返回</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_time_interrupt_handler:</span><br>    <span class="hljs-keyword">pushad</span><br>    <br>    <span class="hljs-keyword">nop</span> <span class="hljs-comment">; 否则断点打不上去</span><br>    <span class="hljs-comment">; 发送EOI消息，否则下一次中断不发生</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-number">0x20</span>, <span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-number">0xa0</span>, <span class="hljs-built_in">al</span><br>    <br>    <span class="hljs-keyword">call</span> c_time_interrupt_handler<br><br>    <span class="hljs-keyword">popad</span><br>    <span class="hljs-keyword">iret</span><br></code></pre></td></tr></table></figure><ul><li><p><code>pushad</code>指令是将<code>EAX</code>,<code>ECX</code>,<code>EDX</code>,<code>EBX</code>,<code>ESP</code>,<code>EBP</code>,<code>ESI</code>,<code>EDI</code>依次入栈，<code>popad</code>则相反</p></li><li><p>对于8259A芯片产生的中断，我们需要在中断返回前发送EOI消息。否则，8259A不会产生下一次中断。</p></li><li><p>设置中断描述符</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::setTimeInterrupt</span><span class="hljs-params">(<span class="hljs-type">void</span> *handler)</span><br>&#123;<br>    setInterruptDescriptor(IRQ0_8259A_MASTER, (uint32)handler, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>封装开启和关闭时钟中断的函数<ul><li>读取OCW1可以得知中断开启情况</li><li>要修改中断开启情况：先读取再写入对应的OCW1</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::enableTimeInterrupt</span><span class="hljs-params">()</span><br>&#123;<br>    uint8 value;<br>    <span class="hljs-comment">// 读入主片OCW</span><br>    asm_in_port(<span class="hljs-number">0x21</span>, &amp;value);<br>    <span class="hljs-comment">// 开启主片时钟中断，置0开启</span><br>    value = value &amp; <span class="hljs-number">0xfe</span>;<br>    asm_out_port(<span class="hljs-number">0x21</span>, value);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InterruptManager::disableTimeInterrupt</span><span class="hljs-params">()</span><br>&#123;<br>    uint8 value;<br>    asm_in_port(<span class="hljs-number">0x21</span>, &amp;value);<br>    <span class="hljs-comment">// 关闭时钟中断，置1关闭</span><br>    value = value | <span class="hljs-number">0x01</span>;<br>    asm_out_port(<span class="hljs-number">0x21</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><h3 id="Assignment-1-混合编程的基本思路"><a href="#Assignment-1-混合编程的基本思路" class="headerlink" title="Assignment 1 混合编程的基本思路"></a>Assignment 1 混合编程的基本思路</h3><p>复现Example 1，结合具体的代码说明C代码调用汇编函数的语法和汇编代码调用C函数的语法。例如，结合代码说明<code>global</code>、<code>extern</code>关键字的作用，为什么C++的函数前需要加上<code>extern &quot;C&quot;</code>等， 结果截图并说说你是怎么做的。同时，学习make的使用，并用make来构建Example 1，结果截图并说说你是怎么做的。</p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><h3 id="Assignment-2-使用C-C-来编写内核"><a href="#Assignment-2-使用C-C-来编写内核" class="headerlink" title="Assignment 2 使用C&#x2F;C++来编写内核"></a>Assignment 2 使用C&#x2F;C++来编写内核</h3><p>复现Example 2，在进入<code>setup_kernel</code>函数后，将输出 Hello World 改为输出你的学号，结果截图并说说你是怎么做的。</p><h3 id="Assignment-3-中断的处理"><a href="#Assignment-3-中断的处理" class="headerlink" title="Assignment 3 中断的处理"></a>Assignment 3 中断的处理</h3><p>复现Example 3，你可以更改Example中默认的中断处理函数为你编写的函数，然后触发之，结果截图并说说你是怎么做的。</p><h3 id="Assignment-4-时钟中断"><a href="#Assignment-4-时钟中断" class="headerlink" title="Assignment 4 时钟中断"></a>Assignment 4 时钟中断</h3><p>复现Example 4，仿照Example中使用C语言来实现时钟中断的例子，利用C&#x2F;C++、 InterruptManager、STDIO和你自己封装的类来实现你的时钟中断处理过程，结果截图并说说你是怎么做的。注意，不可以使用纯汇编的方式来实现。(例如，通过时钟中断，你可以在屏幕的第一行实现一个跑马灯。跑马灯显示自己学号和英文名，即类似于LED屏幕显示的效果。)</p><ul><li>只需要修改<code>c_time_interrupt_handler()</code>这个函数</li><li>在原本的基础上简单修改就好了<ul><li>stdio中有几种不同的print函数，使用可以自定义color的那个，产生跑马灯效果</li><li>把名字、学号放在第一行（设置光标位置即可实现）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c">uint8 color = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-type">void</span> <span class="hljs-title function_">c_time_interrupt_handler</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 清空屏幕</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">80</span>; ++i) &#123;<br>        stdio.print(<span class="hljs-number">0</span>, i, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0x07</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出中断发生的次数</span><br>    ++times;<br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;LQT 23336139&quot;</span>;  <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> str_len = <span class="hljs-number">13</span>;  <span class="hljs-comment">// 实际显示长度</span><br>    <span class="hljs-type">char</span> number[<span class="hljs-number">13</span>] = &#123;<span class="hljs-number">0</span>&#125;; <br>    <br>    <span class="hljs-comment">// 正确转换数字为字符串</span><br>    <span class="hljs-type">int</span> temp = times;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        number[i++] = temp % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>        temp /= <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">while</span>(temp &amp;&amp; i &lt; <span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-comment">// 第一行输出</span><br>    stdio.moveCursor(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str_len; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= cnt &amp;&amp; i &lt; cnt + <span class="hljs-number">3</span> &amp;&amp; cnt + <span class="hljs-number">2</span> &lt; str_len) &#123;<br>            stdio.print(str[i], ++color % <span class="hljs-number">16</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stdio.print(str[i]);<br>        &#125;<br>    &#125;<br>    <br>    cnt = (cnt + <span class="hljs-number">1</span>) % (str_len - <span class="hljs-number">2</span>);  <span class="hljs-comment">// 限制cnt范围</span><br>    <br>    <span class="hljs-comment">// 第二行输出</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;interrupt happend: &quot;</span>;<br>    stdio.moveCursor(<span class="hljs-number">80</span>);  <span class="hljs-comment">// 第二行开始</span><br>    <br>    <span class="hljs-comment">// 输出前缀字符串</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str1[i]; i++) &#123;<br>        stdio.print(str1[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 逆序输出数字(从最高位开始)</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        stdio.print(number[j]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu22.04安装bcc</title>
    <link href="/2025/03/29/ubuntu22-04%E5%AE%89%E8%A3%85bcc/"/>
    <url>/2025/03/29/ubuntu22-04%E5%AE%89%E8%A3%85bcc/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_39678161/article/details/137339963">WSL2安装BCC_bcc wsl-CSDN博客</a></p><p>遇到问题：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">LD vmlinux BTFIDS vmlinux FAILED: <span class="hljs-built_in">load</span> BTF <span class="hljs-built_in">from</span> vmlinux: No such <span class="hljs-built_in">file</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">directory</span> make: *** [Makefile:<span class="hljs-number">1226</span>: vmlinux] Error <span class="hljs-number">255</span> make: *** Deleting <span class="hljs-built_in">file</span> <span class="hljs-string">&#x27;vmlinux&#x27;</span><br></code></pre></td></tr></table></figure><p>尝试方法：</p><ul><li>在”scripts\pahole-flags.sh”文件下添加</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;pahole_ver&#125;</span>&quot;</span> -ge <span class="hljs-string">&quot;124&quot;</span> ]; <span class="hljs-attribute">then</span><br>       <span class="hljs-comment"># see PAHOLE_HAS_LANG_EXCLUDE</span><br>       extra_paholeopt=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;extra_paholeopt&#125;</span> --skip_encoding_btf_enum64&quot;</span><br>fi<br></code></pre></td></tr></table></figure><p>失败</p><ul><li><p>再次开始发现是因为在设置.config的时候不知道为什么出现了问题，然后make的时候出现[n&#x2F;y&#x2F;m]的选择也选择错误。最后再来一次正确设置就没问题了。</p></li><li><p>每次重启后需要重新编译内核，但是又出现了问题<br><img src="/img/f6ad7575dc6c73ae8e91fd7dd66e66f.png"><br>查询后发现是wsl内存设置太小的问题，找到.wslconfig，修改为：</p></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[wsl2]</span><br><span class="hljs-attr">memory</span>=<span class="hljs-number">8</span>GB   <span class="hljs-comment"># 设置内存上限为8GB</span><br><span class="hljs-attr">swap</span>=<span class="hljs-number">4</span>GB     <span class="hljs-comment"># 交换空间4GB</span><br><span class="hljs-attr">kernelCommandLine</span>=sysctl.vm.overcommit_memory=<span class="hljs-number">1</span><br><span class="hljs-attr">processors</span>=<span class="hljs-number">4</span> <span class="hljs-comment"># 可选：分配4个CPU核心</span><br></code></pre></td></tr></table></figure><p>每次开始前：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">KERNELRELEASE</span>=$(uname -r)<br>make <span class="hljs-attribute">KERNELRELEASE</span>=<span class="hljs-variable">$KERNELRELEASE</span> -j 4<br>make <span class="hljs-attribute">KERNELRELEASE</span>=<span class="hljs-variable">$KERNELRELEASE</span> modules -j 4<br>sudo make <span class="hljs-attribute">KERNELRELEASE</span>=<span class="hljs-variable">$KERNELRELEASE</span> modules_install<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>eBPF_learning</title>
    <link href="/2025/03/28/eBPF-learning/"/>
    <url>/2025/03/28/eBPF-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter1-Introduction"><a href="#Chapter1-Introduction" class="headerlink" title="Chapter1 Introduction"></a>Chapter1 Introduction</h1><h2 id="什么是eBPF"><a href="#什么是eBPF" class="headerlink" title="什么是eBPF"></a>什么是eBPF</h2><ul><li><p>eBPF可以在特权上下文中（如kernel）运行&#x3D;&#x3D;沙盒&#x3D;&#x3D;程序。用于<strong>安全有效地扩展内核的功能</strong>，而无需通过更改内核源代码或加载内核模块的方式来实现。<br><img src="/img/Pasted%20image%2020250328231557.png"></p></li><li><p>eBPF从根本上改变了这个方式，通过允许<strong>在操作系统中运行沙盒程序</strong>的方式，应用程序开发人员可以<strong>运行eBPF程序</strong>，以便在运行时向操作系统<strong>添加额外的功能</strong>。然后在<strong>JIT编译器</strong>和<strong>验证引擎</strong>的帮助下，操作系统确保它像本地编译的程序一样具备安全性和执行效率</p></li><li><p>eBPF最初代表了<strong>伯克利包过滤器 (Berkeley Packet Filter)</strong>，但现在能做的更多了，缩写不再有意义。最初的eBPF有时候被称为cBPF（经典BPF）。</p></li></ul><h2 id="eBPF简介"><a href="#eBPF简介" class="headerlink" title="eBPF简介"></a>eBPF简介</h2><h2 id="resources："><a href="#resources：" class="headerlink" title="resources："></a>resources：</h2><p><a href="https://docs.cilium.io/en/stable/reference-guides/bpf/index.html">BPF 和 XDP 参考指南 — Cilium 1.17.2 文档</a><br><a href="https://ebpf.io/zh-hans/what-is-ebpf/#%E4%BB%80%E4%B9%88%E6%98%AF-ebpf-">什么是 eBPF ? An Introduction and Deep Dive into the eBPF Technology</a>（中文版）</p><h2 id="钩子概览"><a href="#钩子概览" class="headerlink" title="钩子概览"></a>钩子概览</h2><p>eBPF 程序是<strong>事件驱动</strong>的，当内核或应用程序<em>通过某个钩子点</em>时运行。<strong>预定义的钩子</strong>包括系统调用、函数入口&#x2F;退出、内核跟踪点、网络事件等。<br><img src="/img/Pasted%20image%2020250328234202.png"><br>如果预定义的钩子不能满足特定需求，则可以<strong>创建内核探针</strong>（kprobe）或<strong>用户探针</strong>（uprobe），以便在内核或用户应用程序的<strong>几乎任何位置附加 eBPF 程序</strong>。<br><img src="/img/Pasted%20image%2020250328234616.png"></p><p>eBPF的核心钩子位置：<br>eBPF程序通常通过以下的内核钩子注入并执行：</p><ul><li><strong>Kprobes&#x2F;Uprobes</strong>：动态跟踪内核或用户空间函数调用</li><li><strong>Tracepoints</strong>：静态内核事件跟踪点（如系统调用、调度事件）</li><li><strong>TC（Traffic Control）</strong>：在<strong>网络流量控制层</strong>处理数据包</li><li><strong>Socket Filters</strong>：过滤或监控套接字数据</li></ul><h2 id="如何编写eBPF程序"><a href="#如何编写eBPF程序" class="headerlink" title="如何编写eBPF程序"></a>如何编写eBPF程序</h2><p>使用<strong>cilium、bcc或bpftrace</strong>这样子的项目间接使用，这些项目提供了 eBPF 之上的抽象，不需要直接编写程序，而是提供了指定基于意图的来定义实现的能力，然后用 eBPF 实现。</p><h2 id="加载器和校验架构"><a href="#加载器和校验架构" class="headerlink" title="加载器和校验架构"></a>加载器和校验架构</h2><p>确定所需的钩子后，可以使用 <strong>bpf 系统调用</strong>将 eBPF 程序加载到 Linux 内核中。这通常是使用一个可用的 eBPF 库来完成的。<br><img src="/img/go.webp"></p><p>当层序被加载到Linux内核中时，它在被附加到所请求的钩子上之前要经过两个步骤：</p><ul><li>验证：验证步骤用来确保eBPF程序可以安全运行<ul><li>加载eBPF程序的进程&#x3D;&#x3D;必须要所需的能力（特权）&#x3D;&#x3D;，<u>除非启用非特权eBPF</u>，否则只有特权进程可以加载eBPF程序</li><li>eBPF程序不会崩溃或者对系统造成损害</li><li>eBPF程序一定会运行至结束</li></ul></li><li>JIT编译<ul><li>JIT (Just-in-Time) 编译步骤<u>将程序的通用字节码转换为机器特定的指令集</u>，用以<strong>优化程序的执行速</strong>度。这使得 eBPF 程序可以像本地编译的内核代码或作为内核模块加载的代码一样高效地运行。</li></ul></li></ul><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>eBPF 程序的其中一个重要方面是<strong>共享和存储</strong>所收集的信息和状态的能力。<br>为此，eBPF 程序可以利用 eBPF maps 的概念来存储和检索各种数据结构中的数据。eBPF maps 既可以<strong>从 eBPF 程序访问</strong>，也可以通过<strong>系统调用</strong>从<strong>用户空间中的应用程序访问</strong>。<br><img src="/img/file-20250329153804831.png"></p><h2 id="Helper调用"><a href="#Helper调用" class="headerlink" title="Helper调用"></a>Helper调用</h2><p>eBPF 程序不直接调用内核函数。这样做会将 eBPF 程序绑定到特定的内核版本，会使程序的兼容性复杂化。而对应地，eBPF 程序改为调用 helper 函数达到效果，这是内核提供的通用且稳定的 API。</p><p><a href="https://ebpf.io/static/6e18b76323d8520107fab90c033edaf4/01295/helper.png"><img src="https://ebpf.io/static/6e18b76323d8520107fab90c033edaf4/b14d5/helper.png" alt="Helper"></a></p><p>可用的 helper 调用集也在不断发展迭代中。一些 helper 调用的示例:</p><ul><li>生成随机数</li><li>获取当前时间日期</li><li>eBPF map 访问</li><li>获取进程 &#x2F; cgroup 上下文</li><li>操作网络数据包及其转发逻辑</li></ul><h2 id="尾调用和函数调用"><a href="#尾调用和函数调用" class="headerlink" title="尾调用和函数调用"></a>尾调用和函数调用</h2><p>eBPF 程序可以通过尾调用和函数调用的概念来组合。函数调用允许在 eBPF 程序内部完成定义和调用函数。尾调用可以调用和执行另一个 eBPF 程序并替换执行上下文，类似于 execve() 系统调用对常规进程的操作方式。<br><img src="/img/file-20250329153901010.png"></p><h1 id="Chapter-2：简单运行Hello-World"><a href="#Chapter-2：简单运行Hello-World" class="headerlink" title="Chapter 2：简单运行Hello World"></a>Chapter 2：简单运行Hello World</h1><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>code：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-meta">#!/usr/bin/python3</span><br>from bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;</span>Hello World!<span class="hljs-string">&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;</span><span class="hljs-string">&quot;&quot;</span><br><br>b = BPF(text=program)<br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br>b.trace_print()<br></code></pre></td></tr></table></figure><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 给予执行权限</span><br><span class="hljs-built_in">chmod</span> +x ~/ebpf-programs/hello.py<br><br><span class="hljs-comment"># 2. 使用sudo运行（eBPF需要root权限）</span><br><span class="hljs-built_in">sudo</span> ~/ebpf-programs/hello.py<br><br><span class="hljs-comment"># 或者</span><br><span class="hljs-built_in">sudo</span> python3 ~/ebpf-programs/hello.py<br></code></pre></td></tr></table></figure><h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><p>这段代码由两部分组成：运行在内核中的<strong>eBPF程序</strong>（被””” “””包住的部分)本身，以及<strong>将eBPF程序加载到内核并读取其生成的跟踪的用户空间代码</strong></p><p>hello.py是用户空间，hello()是运行在内核中的eBPF程序。<br><img src="/img/file-20250405102033975.png"></p><blockquote><p>[!NOTE]<br>整个代码是用python写的，但是eBPF程序本身是用C写的</p></blockquote><ul><li>辅助函数bpf_trace_printk()：可以用来编写消息&#x2F;打印信息；辅助函数是eBPF程序可以调用与系统交互的函数</li><li>跟踪输出：bpf_trace_printk()总是将输出发送到相同的预定义的伪文件位置：&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace_pipe。但如果有多个eBPF程序会导致混乱（都保存到同样的地方）&#x3D;&gt;引入BPF Maps</li></ul><blockquote><p>[!NOTE]<br>eBPF需要在root下运行（需要特权），如果不在root下则需要使用sudo</p></blockquote><ul><li>eBPF程序可以动态改变系统的行为，一旦负载到事件上就可以由效果-</li></ul><h2 id="BPF-Maps"><a href="#BPF-Maps" class="headerlink" title="BPF Maps"></a>BPF Maps</h2><ul><li>map是一种可以<strong>在用户空间访问</strong>的数据结构</li><li>maps可以用来在<strong>多个eBPF程序</strong>中共享数据，或者在<strong>用户空间</strong>应用程序和<strong>运行的eBPF代码</strong>之间通信<ul><li>用户空间写入配置信息到eBPF程序，以便检索</li><li>由一个eBPF程序存储状态以便后续由另一个程序检索</li><li>eBPF程序将结果或metrics写入map，以便用户空间应用呈现&#x2F;检索结果</li></ul></li></ul><h3 id="Hash-Table-Map"><a href="#Hash-Table-Map" class="headerlink" title="Hash Table Map"></a>Hash Table Map</h3><p>C程序部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">BPF_HASH(counter_table);<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctx)</span> &#123;<br>   u64 uid;<br>   u64 counter = <span class="hljs-number">0</span>;<br>   u64 *p;<br><br>   uid = bpf_get_current_uid_gid() &amp; <span class="hljs-number">0xFFFFFFFF</span>;<br>   p = counter_table.lookup(&amp;uid); <span class="hljs-comment">//查找map中是否存在对应的uid</span><br>   <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>      counter = *p;<span class="hljs-comment">//存在则取出对应的值cnt，不存在的话counter=0没有影响</span><br>   &#125;<br>   counter++;<span class="hljs-comment">//调用+1</span><br>   counter_table.update(&amp;uid, &amp;counter);<span class="hljs-comment">//更新对应的调用次数</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>BPF_HASH()</code>是bcc用于定义hash table的宏</li><li><code>bpf_get_current_uid_gid()</code>是一个辅助函数，用于获得触发k探针事件的进程ID（保存到了64位的低32位中，高32位保留给group ID（但是这部分被masked out了））</li><li><code>lookup(&amp;uid)</code> 在哈希表中查找具有与用户ID相匹配的键的条目，并返回一个指向对应值的指针</li></ul><p>bcc framework部分和前面helloworld基本相同，读取信息部分需要修改为从哈希表中读取<br>code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3  </span><br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_HASH(counter_table);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">   u64 uid;</span><br><span class="hljs-string">   u64 counter = 0;</span><br><span class="hljs-string">   u64 *p;</span><br><span class="hljs-string"></span><br><span class="hljs-string">   uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;</span><br><span class="hljs-string">   p = counter_table.lookup(&amp;uid);</span><br><span class="hljs-string">   if (p != 0) &#123;</span><br><span class="hljs-string">      counter = *p;</span><br><span class="hljs-string">   &#125;</span><br><span class="hljs-string">   counter++;</span><br><span class="hljs-string">   counter_table.update(&amp;uid, &amp;counter);</span><br><span class="hljs-string">   return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program)<br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-comment"># Attach to a tracepoint that gets hit for all syscalls </span><br><span class="hljs-comment"># b.attach_raw_tracepoint(tp=&quot;sys_enter&quot;, fn_name=&quot;hello&quot;)</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    sleep(<span class="hljs-number">2</span>)<br>    s = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> b[<span class="hljs-string">&quot;counter_table&quot;</span>].items():<br>        s += <span class="hljs-string">f&quot;ID <span class="hljs-subst">&#123;k.value&#125;</span>: <span class="hljs-subst">&#123;v.value&#125;</span>\t&quot;</span><br>    <span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>运行结果:<br><img src="/img/file-20250405121158545.png"><br>在调用ls时，只会增加一个count，而运行sudo ls时由于会执行sudo和ls，会增加两个count</p><h3 id="Perf-and-Ring-Buffer-Maps"><a href="#Perf-and-Ring-Buffer-Maps" class="headerlink" title="Perf and Ring Buffer Maps"></a>Perf and Ring Buffer Maps</h3><ul><li>允许以我们选择的结构将数据写入到perf环缓冲区映射中</li><li>环缓冲区可以看做是逻辑组织在环中的内存，由单独的写、读指针。任意长度的数据被写入指针的任何位置，<strong>长度信息包含在该数据的头</strong>中。对于读取操作，从读取指针所在的任何位置读取数据，使用头来确定要读取多少数据<br><img src="/img/file-20250405113648981.png"></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3  </span><br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_PERF_OUTPUT(output); </span><br><span class="hljs-string"> </span><br><span class="hljs-string">struct data_t &#123;     </span><br><span class="hljs-string">   int pid;</span><br><span class="hljs-string">   int uid;</span><br><span class="hljs-string">   char command[16];</span><br><span class="hljs-string">   char message[12];</span><br><span class="hljs-string">&#125;;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">int hello(void *ctx) &#123;</span><br><span class="hljs-string">   struct data_t data = &#123;&#125;; </span><br><span class="hljs-string">   char message[12] = &quot;Hello World&quot;;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">   data.pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span><br><span class="hljs-string">   data.uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;</span><br><span class="hljs-string">   </span><br><span class="hljs-string">   bpf_get_current_comm(&amp;data.command, sizeof(data.command));</span><br><span class="hljs-string">   bpf_probe_read_kernel(&amp;data.message, sizeof(data.message), message); </span><br><span class="hljs-string"> </span><br><span class="hljs-string">   output.perf_submit(ctx, &amp;data, sizeof(data)); </span><br><span class="hljs-string"> </span><br><span class="hljs-string">   return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program) <br>syscall = b.get_syscall_fnname(<span class="hljs-string">&quot;execve&quot;</span>)<br>b.attach_kprobe(event=syscall, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_event</span>(<span class="hljs-params">cpu, data, size</span>):  <br>   data = b[<span class="hljs-string">&quot;output&quot;</span>].event(data)<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;data.pid&#125;</span> <span class="hljs-subst">&#123;data.uid&#125;</span> <span class="hljs-subst">&#123;data.command.decode()&#125;</span> <span class="hljs-subst">&#123;data.message.decode()&#125;</span>&quot;</span>)<br> <br>b[<span class="hljs-string">&quot;output&quot;</span>].open_perf_buffer(print_event) <br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:   <br>   b.perf_buffer_poll()<br></code></pre></td></tr></table></figure><ul><li><code>BPF_PERF_OUTPUT</code>用于创建一个map（从内核传递消息到用户空间–map output）</li><li><code>bpf_get_current_pid_tgid()</code>：获取触发词eBPF程序的进程ID</li><li><code>bpf_get_current_comm()</code>：用于获取在创建execve系统共享的进程中运行的可执行文件；这是一个字符串，传递参数方法不太一样（要传递地址和长度）</li></ul><p><img src="/img/file-20250405123905949.png"><br><img src="/img/file-20250405123948939.png"></p><h3 id="Tail-Calls"><a href="#Tail-Calls" class="headerlink" title="Tail Calls"></a>Tail Calls</h3><ul><li>尾调用可以调用并执行另一个eBPF程序，并替换执行上下文，且不会返回原始位置</li><li><code>long bpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index)</code><ul><li>ctx允许将上下文从调用的eBPF程序传递给被调用者。</li><li>prog_array_map是一种BPF_MAP_TYPE_PROG_ARRAY类型的eBPF映射，它包含一组标识eBPF程序的文件描述符。</li><li>index指示应该调用哪一组eBPF程序<br>  BCC framework下可以这样简化使用：<code>prog_array_map.call(ctx, index)</code></li></ul></li></ul><p>code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3  </span><br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><span class="hljs-keyword">import</span> ctypes <span class="hljs-keyword">as</span> ct<br><br>program = <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">BPF_PROG_ARRAY(syscall, 500);</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello(struct bpf_raw_tracepoint_args *ctx) &#123;</span><br><span class="hljs-string">    int opcode = ctx-&gt;args[1];</span><br><span class="hljs-string">    syscall.call(ctx, opcode);</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Another syscall: %d&quot;, opcode);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_exec(void *ctx) &#123;</span><br><span class="hljs-string">    bpf_trace_printk(&quot;Executing a program&quot;);</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int hello_timer(struct bpf_raw_tracepoint_args *ctx) &#123;</span><br><span class="hljs-string">    int opcode = ctx-&gt;args[1];</span><br><span class="hljs-string">    switch (opcode) &#123;</span><br><span class="hljs-string">        case 222:</span><br><span class="hljs-string">            bpf_trace_printk(&quot;Creating a timer&quot;);</span><br><span class="hljs-string">            break;</span><br><span class="hljs-string">        case 226:</span><br><span class="hljs-string">            bpf_trace_printk(&quot;Deleting a timer&quot;);</span><br><span class="hljs-string">            break;</span><br><span class="hljs-string">        default:</span><br><span class="hljs-string">            bpf_trace_printk(&quot;Some other timer operation&quot;);</span><br><span class="hljs-string">            break;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">int ignore_opcode(void *ctx) &#123;</span><br><span class="hljs-string">    return 0;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>b = BPF(text=program)<br>b.attach_raw_tracepoint(tp=<span class="hljs-string">&quot;sys_enter&quot;</span>, fn_name=<span class="hljs-string">&quot;hello&quot;</span>)<br><br>ignore_fn = b.load_func(<span class="hljs-string">&quot;ignore_opcode&quot;</span>, BPF.RAW_TRACEPOINT)<br>exec_fn = b.load_func(<span class="hljs-string">&quot;hello_exec&quot;</span>, BPF.RAW_TRACEPOINT)<br>timer_fn = b.load_func(<span class="hljs-string">&quot;hello_timer&quot;</span>, BPF.RAW_TRACEPOINT)<br><br>prog_array = b.get_table(<span class="hljs-string">&quot;syscall&quot;</span>)<br><br><span class="hljs-comment"># Ignore all syscalls initially</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(prog_array)):<br>    prog_array[ct.c_int(i)] = ct.c_int(ignore_fn.fd)<br><br><span class="hljs-comment"># Only enable few syscalls which are of the interest</span><br>prog_array[ct.c_int(<span class="hljs-number">59</span>)] = ct.c_int(exec_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">222</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">223</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">224</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">225</span>)] = ct.c_int(timer_fn.fd)<br>prog_array[ct.c_int(<span class="hljs-number">226</span>)] = ct.c_int(timer_fn.fd)<br><br>b.trace_print()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab3</title>
    <link href="/2025/03/24/AI-lab3/"/>
    <url>/2025/03/24/AI-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="AI-Lab3–搜索算法"><a href="#AI-Lab3–搜索算法" class="headerlink" title="AI-Lab3–搜索算法"></a>AI-Lab3–搜索算法</h1><h2 id="任务List"><a href="#任务List" class="headerlink" title="任务List"></a>任务List</h2><ol><li>利用盲目搜索解决迷宫问题（无需提交）</li><li>利用启发式搜索解决15-Puzzle问题</li><li>利用博弈树搜索实现象棋AI（无需提交）</li><li>利用遗传算法求解TSP问题</li></ol><h2 id="任务1：利用盲目搜索解决迷宫问题"><a href="#任务1：利用盲目搜索解决迷宫问题" class="headerlink" title="任务1：利用盲目搜索解决迷宫问题"></a>任务1：利用盲目搜索解决迷宫问题</h2><p>尝试利用DFS、BFS、深度受限算法、迭代加深算法、双向搜索算法解决迷宫问题:</p><ul><li>S表示起点;</li><li>E表示终点;</li><li>1表示墙;</li><li>0是可通行。<br>迷宫样例图：</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">111111111111111111111111111111111111</span><br><span class="hljs-number">1000000000000000000000000000000000</span><span class="hljs-built_in">S1</span><br><span class="hljs-number">101111111111111111111111101111111101</span><br><span class="hljs-number">101100010001000000111111100011000001</span><br><span class="hljs-number">101101010101011110111111111011011111</span><br><span class="hljs-number">101101010101000000000000011011000001</span><br><span class="hljs-number">101101010101010111100111000011111101</span><br><span class="hljs-number">101001010100010000110111111110000001</span><br><span class="hljs-number">101101010111111110110000000011011111</span><br><span class="hljs-number">101101000110000000111111111011000001</span><br><span class="hljs-number">100001111110111111100000011011111101</span><br><span class="hljs-number">111111000000100000001111011010000001</span><br><span class="hljs-number">100000011111101111101000011011011111</span><br><span class="hljs-number">101111110000001000000011111011000001</span><br><span class="hljs-number">100000000111111011111111111011001101</span><br><span class="hljs-number">111111111100000000000000000011111101</span><br><span class="hljs-number">1</span>E0000000001111111111111111000000001<br><span class="hljs-number">111111111111111111111111111111111111</span><br></code></pre></td></tr></table></figure><h2 id="任务2：利用启发式搜索解决15-Puzzle问题"><a href="#任务2：利用启发式搜索解决15-Puzzle问题" class="headerlink" title="任务2：利用启发式搜索解决15-Puzzle问题"></a>任务2：利用启发式搜索解决15-Puzzle问题</h2><p>尝试使用<code>A*</code>与<code>IDA*</code>算法解决15-Puzzle问题，启发式函数可以自己选取，最好多尝试几种不同的启发式函数</p><p><img src="/img/image-20250324172954172.png" alt="样例_15puzzle"></p><p>利用A*算法和IDA*算法解决15-Puzzle问题, 可自定义启发式函数. Puzzle问题的输入数据类型为二维嵌套list, 空位置用 <code>0</code>表示. 输出的解数据类型为 <code>list</code>, 是移动数字方块的次序.</p><p>若选择A*算法, 则函数名为 <code>A_star</code>; 若选择IDA*算法, 则函数名为 <code>IDA_star</code>.</p><p>例子: 输入</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">puzzle = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3,4]</span>,<span class="hljs-comment">[5,6,7,8]</span>,<span class="hljs-comment">[9,10,11,12]</span>,<span class="hljs-comment">[0,13,14,15]</span>]</span><br></code></pre></td></tr></table></figure><p>则调用 <code>A_star(puzzle)</code>或 <code>IDA_star(puzzle)</code>后输出解</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[13,14,15]</span><br></code></pre></td></tr></table></figure><p>相关知识：<br><code>A*</code>算法的必要知识点：<br>&#x3D;&#x3D;算法描述&#x3D;&#x3D;：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">* 初始化open_set和close_set；<br>* 将起点加入open_set中，并设置优先级为0（优先级最高）；<br>* 如果open_set不为空，则从open_set中选取优先级最高的节点n：<br>    * 如果节点n为终点，则：<br>        * 从终点开始逐步追踪parent节点，一直达到起点；<br>        * 返回找到的结果路径，算法结束；<br>    * 如果节点n不是终点，则：<br>        * 将节点n从open_set中删除，并加入close_set中；<br>        * 遍历节点n所有的邻近节点：<br>            * 如果邻近节点m在close_set中，则：<br>                * 跳过，选取下一个邻近节点<br>            * 如果邻近节点m也不在open_set中，则：<br>                * 设置节点m的parent为节点n<br>                * 计算节点m的优先级<br>                * 将节点m加入open_set中<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;启发式函数：&#x3D;&#x3D; <code>f(n)=g(n)+h(n)</code></p><ul><li>f(n)是节点n的<strong>综合</strong>优先级。（每次选择会选择总和优先级最高，也就是<strong>f(n)值最小</strong>的节点&#x3D;&gt;维护一个优先队列）</li><li>g(n)是节点n距离<strong>起点</strong>的代价</li><li>h(n)是节点n距离<strong>终点</strong>的预估代价</li></ul><p>&#x3D;&gt;启发函数的选取：（网格形式的图）</p><ul><li>曼哈顿距离–适用于只允许&#x3D;&#x3D;上下左右&#x3D;&#x3D;四个方向移动  √ （同时加上线性冲突判断）</li><li>对角距离–适用于允许朝八个方向移动</li><li>欧几里得距离–适用于允许朝任何方向移动</li></ul><p>&#x3D;&gt;计算曼哈顿距离的函数：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">def heuristic(node):<br>dx=<span class="hljs-built_in">abs</span>(node.<span class="hljs-variable language_">x</span>-goal.<span class="hljs-variable language_">x</span>)<br>dy=<span class="hljs-built_in">abs</span>(node.<span class="hljs-variable language_">y</span>-goal.<span class="hljs-variable language_">y</span>)<br><span class="hljs-keyword">return</span> cost*(dx+dy)<br></code></pre></td></tr></table></figure><p><code>IDA*</code>算法：<br><code>IDA*</code>算法是在DFS的基础上，添加启发信息的启发式搜索算法。（IDA * 为采用了<strong>迭代加深算法的 A * 算法</strong>。）<br>优点：（相对于A*)</p><ul><li>不需要判重、不需要排序，利于深度剪枝</li><li><strong>空间需求减少</strong>：每个深度下实际上是一个深度优先搜索，不过有深度限制，使用DFS可以减小空间消耗<br>缺点：<br>重复搜索：当深度变大后每次都要从头搜索（不记忆-节省内存）</li></ul><p>&#x3D;&#x3D;算法描述&#x3D;&#x3D;：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1、开始时，计算起点所有邻居结点的估价函数，选取估价函数最小的结点作为下一个访问结点。(?)<br><br>2、重复步骤一，在递归过程中，若当前结点的估价函数大于阈值bound，则返回当前结点的估价得分。<br><br>3、若当前结点是目标结点，则得到最优解，返回路径。<br></code></pre></td></tr></table></figure><p><img src="/img/file-20250330115435358.png"></p><p>算法思路：</p><h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources:"></a>Resources:</h3><p><a href="https://zhuanlan.zhihu.com/p/54510444">路径规划之 A* 算法 - 知乎</a><br><a href="https://witchpuff.github.io/posts/astar/#2-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA">Solving 15-Puzzle with A* and IDA* | CyberWitch</a></p><p><img src="/img/file-20250329203607439.png" alt="1"><br><img src="/img/file-20250329203936669.png" alt="2"><br><img src="/img/file-20250331220621299.png" alt="3"></p><h2 id="任务3：利用博弈树搜索实现象棋AI"><a href="#任务3：利用博弈树搜索实现象棋AI" class="headerlink" title="任务3：利用博弈树搜索实现象棋AI"></a>任务3：利用博弈树搜索实现象棋AI</h2><p>编写一个中国象棋博弈程序，要求用alpha-beta剪枝算法，可以实现两个AI对弈。</p><ul><li>一方由人类点击或者AI算法控制。</li><li>一方由内置规则AI控制。</li><li>算法支持红黑双方互换</li></ul><h2 id="任务4：利用遗传算法求解TSP问题利用遗传算法求解-TSP-问题"><a href="#任务4：利用遗传算法求解TSP问题利用遗传算法求解-TSP-问题" class="headerlink" title="任务4：利用遗传算法求解TSP问题利用遗传算法求解 TSP 问题"></a>任务4：利用遗传算法求解TSP问题利用遗传算法求解 TSP 问题</h2><ul><li>在National Traveling Salesman Problems（uwaterloo.ca)（<a href="https://www.math.uwaterloo.ca/tsp/world/countries.html%EF%BC%89">https://www.math.uwaterloo.ca/tsp/world/countries.html）</a> 中任选两个TSP问题的数据集。</li><li>建议：<ul><li><p>对于规模较大的TSP问题, 遗传算法可能需要运行几分钟甚至几个小时的时间才能得到一个比较好的结果. 因此建议先用城市数较小的数据集测试算法正确与否, 再用城市数较大的数据集来评估算法性能。</p></li><li><p>由于遗传算法是基于随机搜索的算法, 只运行一次算法的结果并不能反映算法的性能. 为了更好地分析遗传算法的性能, 应该以不同的初始随机种子或用不同的参数(例如种群数量, 变异概率等)多次运行算法, 这些需要在实验报告中呈现.</p></li></ul></li></ul><p>resources：<br><a href="https://zhuanlan.zhihu.com/p/623494344">初识Numpy数组，看这一篇就够了！ - 知乎</a></p><h3 id="更加详细的要求："><a href="#更加详细的要求：" class="headerlink" title="更加详细的要求："></a>更加详细的要求：</h3><p>为了方便批改作业, 我们统一用类 <code>GeneticAlgTSP</code>来编写遗传算法的各个模块, 并分析算法性能. 该类需包含以下方法:</p><ul><li>构造函数 <code>__init__()</code>, 输入为TSP数据集文件名 <code>filename</code>, 数据类型 <code>str</code>. 例如 <code>&quot;dj38.tsp&quot;</code>是Djibouti的38个城市坐标数据文件; <code>&quot;ch71009.tsp&quot;</code>是China的71009个城市坐标数据文件. 我们需要在构造函数中读取该文件中的数据, 存储到类成员 <code>self.cities</code>中(数据类型自定, 建议存储为 <code>numpy</code>数组). 同时在构造函数中初始化种群, 存储到类成员 <code>self.population</code>中(数据类型自定).</li><li>求解方法 <code>iterate()</code>, 输入为算法迭代的轮数 <code>num_iterations</code>, 数据类型 <code>int</code>. 该方法是基于当前种群 <code>self.population</code>进行迭代(不是从头开始), 返回迭代后种群中的一个较优解, 数据类型 <code>list</code>, 格式为1-n个城市编号的排列. 例如, 对于n&#x3D;5的TSP问题, 迭代后返回的较优解形如 <code>[1,3,4,5,2]</code>, 表示当前较好的游览城市次序为1-3-4-5-2-1.</li></ul><p>可以在类中编写其他方法以方便编写并分析遗传算法的性能. 请在代码注释或实验报告中说明每个方法&#x2F;模块的功能.</p><h3 id="steps："><a href="#steps：" class="headerlink" title="steps："></a>steps：</h3><ul><li>读取文件，提取出城市维度和城市坐标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_tsp</span>(<span class="hljs-params">filename</span>):<br><br>    nodes=[]<br><br>    dimension=<span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file:<br><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br><br>            <span class="hljs-keyword">if</span> line.strip().startswith(<span class="hljs-string">&#x27;DIMENSION&#x27;</span>):<br><br>                <span class="hljs-comment">#获取维度信息</span><br><br>                dimension=line.split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>].strip()<br><br>            <span class="hljs-comment">#节点信息获取</span><br><br>            <span class="hljs-keyword">if</span> line.strip().startswith(<span class="hljs-string">&#x27;NODE_COORD_SECTION&#x27;</span>):<br><br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br><br>            line = line.strip()<br><br>            <span class="hljs-keyword">if</span> line==<span class="hljs-string">&#x27;EOF&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> line:<br><br>                <span class="hljs-keyword">break</span>  <span class="hljs-comment">#结束</span><br><br>            parts=line.split()<br><br>            <span class="hljs-comment">#去掉开头编号，生成元组</span><br><br>            nodes.append((<span class="hljs-built_in">float</span>(parts[<span class="hljs-number">1</span>]),<span class="hljs-built_in">float</span>(parts[<span class="hljs-number">2</span>])))<br><br>    location=np.array(nodes)<br><br>    <span class="hljs-keyword">return</span> dimension,location<br></code></pre></td></tr></table></figure><ul><li>初始化种族：在城市数较少时使用<strong>随机数</strong>生成法，中等城市数可以考虑部分贪婪（？，大体量城市再考虑其他</li></ul><h2 id="相关资料：NumPy随机排列：使用numpy-random-permutation实现数组元素的随机重排-极客教程"><a href="#相关资料：NumPy随机排列：使用numpy-random-permutation实现数组元素的随机重排-极客教程" class="headerlink" title="相关资料：NumPy随机排列：使用numpy.random.permutation实现数组元素的随机重排|极客教程"></a>相关资料：<a href="https://geek-docs.com/numpy/numpy-ask-answer/numpy-random-permutation_z1.html">NumPy随机排列：使用numpy.random.permutation实现数组元素的随机重排|极客教程</a></h2><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><ol><li>数据集来源于网站<a href="https://www.math.uwaterloo.ca/tsp/world/countries.html">National Traveling Salesman Problems (uwaterloo.ca)</a>. 可浏览该网站参考相关国家的TSP问题的解. 可以自选1-2个数据集来测试算法性能, 并在实验报告中说明.</li><li>TSP问题上遗传算法的具体实现(解的表示, 染色体交叉操作等)不一定局限于课件上的方式, 也许存在比课件效果更好的具体实现方法.</li><li>由于遗传算法是基于随机搜索的算法, 只运行一次算法的结果并不能反映算法的性能. 为了更好地分析遗传算法的性能, 应该以不同的初始随机种子或用不同的参数(例如种群数量, 变异概率等)多次运行算法, 这些需要在实验报告中呈现.</li><li>最后提交的代码只需包含性能最好的实现方法和参数设置. 只需提交一个代码文件, 请不要提交其他文件.</li><li>对于规模较大的TSP问题, 遗传算法可能需要运行几分钟甚至几个小时的时间才能得到一个比较好的结果. 因此建议先用城市数较小的数据集测试算法正确与否, 再用城市数较大的数据集来评估算法性能.</li><li>本次作业可以使用 <code>numpy</code>库以及python标准库. 有余力的同学可用 <code>matplotlib</code>库对遗传算法的结果进行可视化处理与分析, 并在实验报告中呈现.</li></ol><h2 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h2><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>模拟退火算法SA来源于固体退火原理，是一种基于<strong>概率</strong>的算法。<br>模拟退火算法从某一较高初温出发，伴随温度参数的不断下降，&#x3D;&#x3D;结合概率突跳特性在解空间中随机寻找目标函数的全局最优解&#x3D;&#x3D;，<strong>即在局部最优解能</strong>概率性地跳出<strong>并</strong>最终趋于全局最优。</p><blockquote><p>[!NOTE]<br>算法思想为：先从一个<strong>较高的初始温度</strong>出发，逐渐降低温度，直到温度降低到满足热平衡条件为止。在每个温度下，进行<strong>n轮搜索</strong>，每轮搜索时对旧解添加随机扰动生成新解，并按一定规则接受新解。</p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模拟退火算法包含两个部分即&#x3D;&#x3D;Metropolis算法&#x3D;&#x3D;和&#x3D;&#x3D;退火过程&#x3D;&#x3D;，分别对应内循环和外循环。</p><ul><li><strong>外循环就是退火过程</strong>，将固体达到较高的温度（初始温度T（0）），然后按照降温系数alpha使温度按照一定的比例下降，当达到<strong>终止温度Tf</strong>时，冷却结束，即退火过程结束。<blockquote><p>[!NOTE]</p><ul><li><p>外层循环控制温度由高向低变化</p></li><li><p>内层循环中温度固定，对旧解添加随机扰动得到新解，并按一定规则接受新解。迭代次数成为马尔可夫链长度</p></li></ul></blockquote></li><li><strong>Metropolis算法是内循环</strong>，即<u>在每次温度下，迭代L次，寻找在该温度下能量的最小值</u>（即最优解）。</li></ul><h3 id="算法优点"><a href="#算法优点" class="headerlink" title="算法优点"></a>算法优点</h3><p><strong>不管函数形式多复杂，模拟退火算法更有可能找到全局最优解。</strong></p><p>过程图：</p><p><img src="/img/file-20250331170514223.png"></p><p>伪代码：<br><img src="/img/file-20250331170528207.png"><br><img src="/img/file-20250331170610602.png"></p><p>resources：<br><a href="https://zhuanlan.zhihu.com/p/382426984">模拟退火算法超详细教程 - 知乎</a></p><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><blockquote><p>[!NOTE]<br>遗传算法是受自然进化理论启发的一系列搜索算法。</p></blockquote><p>达尔文进化论的原理概括总结如下：</p><ol><li>&#x3D;&#x3D;变异&#x3D;&#x3D;：种群中单个样本的特征(性状，属性)可能会有所不同，这导致了样本彼此之间有一定程度的差异</li><li>&#x3D;&#x3D;遗传&#x3D;&#x3D;：某些特征可以遗传给其后代。导致后代与双亲样本具有一定程度的相似性</li><li>&#x3D;&#x3D;选择&#x3D;&#x3D;：种群通常在给定的环境中争夺资源。更适应环境的个体在生存方面更具优势，因此会产生更多的后代</li></ol><p>进化算法：</p><ol><li>选择</li><li>交叉（或重组）</li><li>变异</li></ol><p><strong>达尔文进化论&lt;&#x3D;&gt;遗传算法</strong>的对应概念</p><ul><li>遗传算法试图找问题的最优解</li></ul><table><thead><tr><th>达尔文进化论</th><th>遗传算法</th></tr></thead><tbody><tr><td>保留种群的个体性状</td><td>保留了针对给定问题的<strong>候选解集合</strong></td></tr><tr><td><strong>适者生存</strong>并更有可能遗传优良特性</td><td>候选解经过<strong>迭代评估</strong>，越优的解越有可能将特征传递给下一代候选解集合</td></tr></tbody></table><p>算法的基本思想：<br>在求解问题时从多个解开始，然后通过一定的法则进行逐步迭代以产生新的解</p><p>遗传算法的过程：</p><ul><li>开始时，种群随机初始化，并计算每个个体的适应度函数，初代产生</li><li>如果不满足优化准则，开始产生新一代计算</li><li>为了产生下一代，按照适应度选择个体，父代进行基因重组而产生子代</li><li>子代有几率变异，子代的适应度被重新计算</li><li>循环直到满足优化准则</li></ul><p>伪代码：<br><img src="/img/file-20250331172623564.png"></p><p><img src="/img/9a1dfe9d663af4eb0c6989344df3c6f.jpg"></p><p>resources：<br><a href="https://zhuanlan.zhihu.com/p/436453994">遗传算法 (Genetic Algorithm, GA) 详解与实现 - 知乎</a></p><h2 id="旅行商问题–解的表示"><a href="#旅行商问题–解的表示" class="headerlink" title="旅行商问题–解的表示"></a>旅行商问题–解的表示</h2><p><img src="/img/file-20250331173623765.png"><br><img src="/img/file-20250331173701655.png"><br><img src="/img/file-20250331173729854.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML_Notes</title>
    <link href="/2025/03/16/HTML-Notes/"/>
    <url>/2025/03/16/HTML-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-入门"><a href="#HTML-入门" class="headerlink" title="HTML 入门"></a>HTML 入门</h1><p>Resources：</p><p><a href="https://wangdoc.com/html/intro">HTML 语言简介 - HTML 教程 - 网道</a></p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=tag_meta_name">W3School TIY Editor</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HTML是网页使用的语言，定义了网页的结构和内容，是一种标签语言。浏览器访问网站相当于从服务器下载HTML代码，然后渲染出网页。</p><p>浏览器的网页开发，涉及三种技术：<strong>HTML、CSS 和 JavaScript</strong>。HTML 语言定义网页的<strong>结构和内容</strong>，CSS 样式表定义<strong>网页的样式</strong>，JavaScript 语言定义网页与用户的互动行为（<strong>交互</strong>）。</p><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>打开就会看到Hello World</p><h2 id="网页的基本概念"><a href="#网页的基本概念" class="headerlink" title="网页的基本概念"></a>网页的基本概念</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><blockquote><p>作为一门标签语言，学习HTML就是学习各种标签的用法</p></blockquote><p>标签大多是<strong>成对</strong>出现的，比如<code>&lt;title&gt;</code>和<code>&lt;/title&gt;</code>，前者为开始标签，后者为结束标签；单独使用的标签：如<code>&lt;meta&gt;</code>标签，用于提示浏览器，做一些特别处理，并不需要使用到标签之间的内容。</p><p>标签用于指示浏览器如何处理这段代码，如何渲染</p><p>标签可以嵌套，但要正确嵌套，闭合顺序和括号是类似的，不能跨层嵌套</p><ul><li>正确：<code>&lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt;</code></li></ul><p>HTML标签名对<strong>大小写不敏感</strong>，习惯上使用小写，同时HTML语言<strong>忽略缩进与换行</strong>。</p><ul><li>下面三种情况都是一样的：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br>  网页标题<br><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页<br>标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>浏览器渲染网页时，会把 HTML 源码解析成一个标签树，每个标签都是树的一个节点，这种节点就称为网页元素。比如<code>&lt;p&gt;</code>标签对应网页的<code>p</code>元素</p><p>嵌套的标签构成了网页元素的层级关系。</p><h4 id="块集元素、行内元素"><a href="#块集元素、行内元素" class="headerlink" title="块集元素、行内元素"></a>块集元素、行内元素</h4><p>块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据 100% 的宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>p</code>元素是会计元素，所以浏览器会将内容分成两行显示</p><p>行内元素默认与其他元素在同一行，<strong>不产生换行</strong>。比如，<code>span</code>就是行内元素，通常用来为某些文字指定<strong>特别的样式</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>world<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>span</code>元素是行内元素，因此浏览器会<strong>将两行内容放在一行显示</strong></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是标签的额外信息，使用<strong>空格与标签名</strong>和其他属性分隔</p><p>属性可以用<code>=</code>指定属性值，比如 <code>&lt;img src=&quot;demo.jpg&quot; width=&quot;500&quot;&gt;</code>；属性值一般放在双引号里面，这不是必须的，但推荐使用</p><p>属性名对大小写不敏感</p><h2 id="网页的基本标签"><a href="#网页的基本标签" class="headerlink" title="网页的基本标签"></a>网页的基本标签</h2><p>基本结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title="&lt;!doctype&gt;"></a>&lt;!doctype&gt;</h3><p>网页的第一个标签通常是&lt;!doctype&gt;，表示<strong>文档类型</strong>，告诉浏览器如何解析网页。</p><p>一般来说，只要像下面这样，简单声明<code>doctype</code>为<code>html</code>即可。浏览器就会按照 HTML 5 的规则处理网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="&lt;html&gt;"></a><code>&lt;html&gt;</code></h3><p>这个标签是网页的<strong>顶层容器</strong>，即标签树结构的<strong>顶层节点</strong>，也称为<strong>根元素</strong>，其他元素都是它的子元素。<strong>一个网页只能有一个 <code>html</code>标签</strong></p><p>该标签的 <code>lang</code> 属性表示网页内容<strong>默认的语言</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title="&lt;head&gt;"></a><code>&lt;head&gt;</code></h3><p><code>&lt;head&gt;</code>标签是一个容器标签，用于放置网页的<strong>元信息</strong>。它的内容不会出现在网页上，而是<u>为网页渲染提供额外信息</u>。</p><ul><li>在爬虫时我们也需要使用到head，将自己伪装成真实的浏览器</li></ul><p><code>&lt;head&gt;</code>是<code>&lt;html&gt;</code>的第一个子元素。如果网页不包含<code>&lt;head&gt;</code>，浏览器会自动创建一个。</p><p><code>&lt;head&gt;</code>的<strong>子元素</strong>一般有下面七个，后文会一一介绍。</p><ul><li><code>&lt;meta&gt;</code>：设置网页的<strong>元数据</strong>。</li><li><code>&lt;link&gt;</code>：连接<strong>外部样式表</strong>。</li><li><code>&lt;title&gt;</code>：设置<strong>网页标题</strong>。</li><li><code>&lt;style&gt;</code>：放置<strong>内嵌的样式表</strong>。</li><li><code>&lt;script&gt;</code>：引入脚本。</li><li><code>&lt;noscript&gt;</code>：浏览器不支持脚本时，所要显示的内容。</li><li><code>&lt;base&gt;</code>：设置网页内部相对 URL 的计算基准。</li></ul><h3 id="-3"><a href="#-3" class="headerlink" title="&lt;meta&gt;"></a><code>&lt;meta&gt;</code></h3><p><code>&lt;meta&gt;</code>标签用于设置或说明网页的元数据，必须放在<code>&lt;head&gt;</code>里面。一个<code>&lt;meta&gt;</code>标签就是一项元数据，网页可以有多个<code>&lt;meta&gt;</code>。</p><p>不管什么样的网页，一般都可以放置下面两个 <code>&lt;meta&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Page Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>第一个<code>&lt;meta&gt;</code>标签表示网页采用 UTF-8 格式编码，第二个<code>&lt;meta&gt;</code>标签表示<strong>网页在手机端可以自动缩放</strong>。</p><h4 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h4><p><strong>（1）charset 属性</strong>：</p><ul><li>用来指定网页的编码方式，防止乱码</li></ul><p><strong>（2）name 属性，content 属性</strong>：</p><ul><li><code>name</code>属性表示元数据的名字， <code>content</code>属性表示元数据的值；合在一起使用可以为网页指定一项元数据</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML 语言入门&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML,教程&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;张三&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">application-name</td><td align="left">规定页面代表的 Web 应用程序的名称。</td></tr><tr><td align="left">author</td><td align="left">规定文档作者的姓名。例如：<meta name="author" content="YK Investment"></td></tr><tr><td align="left">description</td><td align="left">规定页面的描述。搜索引擎可以选择此描述来显示搜索结果。例如：<meta name="description" content="免费的 Web 教程"></td></tr><tr><td align="left">generator</td><td align="left">规定用于生成文档的软件包之一（不用于手写页面）。例如：<meta name="generator" content="FrontPage 4.0"></td></tr><tr><td align="left">keywords</td><td align="left">规定与页面相关的关键字列表，以逗号分隔。告知搜索引擎关于页面的内容。**提示：**请始终规定关键字（搜索引擎需要对页面进行分类）。例如：<meta name="keywords" content="HTML, meta tag, tag reference"></td></tr><tr><td align="left">viewport</td><td align="left">控制视口（网页的用户可见区域）。</td></tr></tbody></table><p><strong>（3）http-equiv 属性，content 属性</strong>：</p><p><code>&lt;meta&gt;</code>标签的http-equiv属性用来<strong>补充 HTTP 回应的头信息字段</strong>，如果服务器发回的HTTP回应缺少某个字段，就可以用它来补充。</p><h3 id="-4"><a href="#-4" class="headerlink" title="&lt;title&gt;"></a><code>&lt;title&gt;</code></h3><p><code>&lt;title&gt;</code>标签用于<strong>指定网页的标题</strong>，会<u>显示在浏览器窗口的标题栏</u>。</p><p><code>&lt;title&gt;</code>标签内部不能嵌套标签，只能放置<strong>无格式的纯文本</strong></p><h3 id="-5"><a href="#-5" class="headerlink" title="&lt;body&gt;"></a><code>&lt;body&gt;</code></h3><p><code>&lt;body&gt;</code>标签是一个容器标签，用于放置网页的<strong>主体内容</strong>；浏览器显示的页面内容，都放置在它的内部</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="空格和换行"><a href="#空格和换行" class="headerlink" title="空格和换行"></a>空格和换行</h2><p>HTML 语言有自己的空格处理规则。<strong>标签内容的头部和尾部的空格</strong>，一律忽略不计。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>  hello world   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&gt;这个只会显示成 <code>hello world</code>而非 <code>  hello world   </code></p><p>标签内容里面的<strong>多个连续空格</strong>（包含制表符<code>\t</code>），会被浏览器<strong>合并成一个</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello      world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&gt;只会显示成 <code>hello world</code>而非 <code>hello      world</code></p><p>还会将文本中的<strong>换行符 <code>\n</code>和回车符 <code>\t</code>替换成空格</strong>，如果文本之间有多个换行，会替换成空格，然后多个空格会合并为一个空格。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello<br><br><br><br>world<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&gt;只会显示成 <code>hello world</code></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释以<code>&lt;!--</code>开头，以<code>--&gt;</code>结尾，注释可以是多行的。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  &lt;p&gt;这是一个注释&lt;/p&gt;</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><h1 id="URL简介"><a href="#URL简介" class="headerlink" title="URL简介"></a>URL简介</h1><p>URL 是“统一资源定位符”（Uniform Resource Locator）的首字母缩写，中文是“网址”</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>浏览器请求服务器资源的方法，如HTTPS协议</p><p>HTTPS是HTTP的<strong>加密版本</strong>，每个协议的格式不同，https后面会加 <code>://</code>，但邮件协议<code>mailto</code>的协议后面只有一个冒号，eg：<code>mailto:foo@example.com</code></p><h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><p>主机host是<strong>资源所在的网站名或服务器的名字</strong>，又称为<strong>域名</strong>。</p><p>有些主机没有域名，只有ip地址–局域网常常出现</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>同一个域名下面可能同时包含多个网站，他们通过<strong>端口port</strong>区分</p><p>HTTP 协议的<u>默认端口是80</u>，如果省略了这个参数，服务器就会返回80端口的网站。</p><p>端口紧跟在域名后面，两者之间使用冒号分隔，比如<code>www.example.com:80</code></p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>路径（path）是资源在网站的位置。</p><p>比如<code>https://pqcu77.github.io/index.html</code>指向了博客路径下的index.html文件。现在由于服务器可能模拟这些位置，所以路径只是虚拟位置</p><p>路径可能只包含目录，不包含文件名，在不同的服务器设置下，服务器可能会默认跳转到该目录下的文件中。</p><h3 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h3><p>查询参数是提供给服务器的额外信息，参数位置是在路径后面，两者之间使用 <code>? </code>分隔，查询参数可以有一组或者多组，每组参数都是键值对的形式，键值对之间用等号<code>=</code>连接，多组参数之间使用<code>&amp;</code>连接</p><p>如：<code>?key1=value1&amp;key2=value2</code></p><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>锚点是网页内部的定位点，使用<code>#</code>加上锚点名称，放在网址的最后。例子：<code>https://pqcu77.github.io/2025/03/06/cs50-ai-Machine-Learning/#Project</code></p><p>浏览器加载页面以后，会自动滚动到锚点所在的位置，锚点名称通过网页元素<code>id</code>属性命名</p><p><img src="/img/image-20250316164425053.png" alt="image-20250316164425053"></p><p>图中你可以看到有多个id属性</p><h2 id="URL字符"><a href="#URL字符" class="headerlink" title="URL字符"></a>URL字符</h2><p>URL 的各个组成部分，只能使用以下这些字符。</p><ul><li>26个英语字母（包括大写和小写）</li><li>10个阿拉伯数字</li><li>连词号（<code>-</code>）</li><li>句点（<code>.</code>）</li><li>下划线（<code>_</code>）</li></ul><p>还有18个字符属于URL的保留字符，只能在给定的位置出现。比如查询参数的<code>?</code></p><p>如果要使用他们，需要使用转义字符，对应方式是：<u>在这些字符的十六进制ASCII码前面加上百分号%</u>。</p><ul><li><p><code>!</code>：%21</p></li><li><p><code>#</code>：%23</p></li><li><p><code>$</code>：%24</p></li><li><p><code>&amp;</code>：%26</p></li><li><p><code>&#39;</code>：%27</p></li><li><p><code>(</code>：%28</p></li><li><p><code>)</code>：%29</p></li><li><p><code>*</code>：%2A</p></li><li><p><code>+</code>：%2B</p></li><li><p><code>,</code>：%2C</p></li><li><p><code>/</code>：%2F</p></li><li><p><code>:</code>：%3A</p></li><li><p><code>;</code>：%3B</p></li><li><p><code>=</code>：%3D</p></li><li><p><code>?</code>：%3F</p></li><li><p><code>@</code>：%40</p></li><li><p><code>[</code>：%5B</p></li><li><p><code>]</code>：%5D</p></li><li><p>空格的转义形式是 <code>%20</code></p></li></ul><p>既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在 URL 里面，比如<code>www.example.com/中国.html</code>，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制 UTF-8 编码，每两位算作一组，然后每组头部添加百分号（<code>%</code>）。</p><h2 id="绝对URL和相对URL"><a href="#绝对URL和相对URL" class="headerlink" title="绝对URL和相对URL"></a>绝对URL和相对URL</h2><p>绝对URL：带有资源的完整信息，包含协议、主机、路径等部分</p><p>相对URL：不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。</p><p>URL 还可以使用两个特殊简写，表示特定位置。</p><ul><li><code>.</code>：表示当前目录，比如<code>./a.html</code>（当前目录下的<code>a.html</code>文件）</li><li><code>..</code>：表示上级目录，比如<code>../a.html</code>（上级目录下的<code>a.html</code>文件）</li></ul><h2 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;base&gt;标签"></a><code>&lt;base&gt;</code>标签</h2><p>指定网页内部的所有相对URL的计算基准，整张网页只能有一个<code>&lt;base&gt;</code>标签</p><h1 id="网页元素的属性"><a href="#网页元素的属性" class="headerlink" title="网页元素的属性"></a>网页元素的属性</h1><p>网页元素的属性（attribute）可以定制元素的行为，不同的属性会导致元素有不同的行为。</p><p>属性名也对大小写不敏感</p><h3 id="全局属性：所有元素都可以使用"><a href="#全局属性：所有元素都可以使用" class="headerlink" title="全局属性：所有元素都可以使用"></a>全局属性：所有元素都可以使用</h3><ul><li>但有些属性对某些元素可能不产生意义</li></ul><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ul><li>id属性是元素在网页内的<strong>唯一标识符</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统实验四</title>
    <link href="/2025/03/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
    <url>/2025/03/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="conda指令"><a href="#conda指令" class="headerlink" title="conda指令"></a>conda指令</h1><ul><li>创建python虚拟环境<br><code>conda create -n py36 python=3.6.5</code></li><li>进入某个python虚拟环境<br><code>conda activate xxx</code></li><li>在虚拟环境中安装<br><code>conda install numpy</code>或<code>pip install numpy</code></li></ul><p><a href="https://blog.csdn.net/menc15/article/details/71477949">Anaconda环境管理-CSDN博客</a></p><h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><ol><li><p>实验目的<br>（1）深入理解和掌握<strong>离散时间非周期信号的傅里叶变换</strong>及计算方法；<br>（2）熟悉离散时间傅里叶变换的性质；<br>（3）理解离散时间 LTI 系统的频域分析原理和方法，掌握离散时间 LTI 系统的频率响应求解方法，并能编程绘制相应的幅频、相频响应曲线。</p></li><li><p>实验原理<br><img src="/img/file-20250413093659825.png"></p></li></ol><p>python提供的 <code>scipy.signal.freqz()</code>函数可以近似求解离散时间傅里叶变换。<br>无穷级数求和：SymPy符号函数求和方法： <code>sum()</code> <code>summation()</code> <code>gosper_sum()</code>等函数都可以用于级数求和操作。<br>SymPy符号函数积分的方法：<code>integrate()</code><br>通过numpy库和scipy库可以产生<strong>基本的信号</strong>，如阶跃信号、指数信号、脉冲信号等等，其中<strong>scipy.signal可用于计算信号的卷积</strong><br><a href="https://docs.scipy.org/doc/scipy/reference/signal.html#module-scipy.signal">Signal processing (scipy.signal) — SciPy v1.15.2 Manual</a></p><ol start="3"><li><p>性质<br><img src="/img/file-20250413105048333.png"><br><img src="/img/file-20250413105117697.png"><br><img src="/img/file-20250413105354392.png"></p></li><li><p>实验任务<br>（1）编程计算双边指数衰减信号$𝑥[𝑛] &#x3D; e^{−2|𝑛|}$的离散时间傅里叶变换，并验证其时域内插，即<br>$$<br>\begin{cases}<br> \begin{split}<br> x[n&#x2F;k],n为k的整数倍\<br> 0, 其他n<br> \end{split}<br>\end{cases}<br>$$<br>的离散时间傅里叶变换，取𝑘 &#x3D; 3。请分别绘制$𝑥[𝑛]$和$𝑥_{k}[𝑛]$的幅频曲线和相频曲线。<br><img src="/img/file-20250414105151886.png"></p></li></ol><p><img src="/img/file-20250414113453654.png"><br>（2）考虑差分方程$𝑦[𝑛] − 𝑎𝑦[𝑛 − 1] &#x3D; 𝑥[𝑛]$，其中|𝑎| &lt; 1。取𝑎 &#x3D;0.2，编程求解该方程所描述系统的频率响应，并：<br>（a）画出系统的幅频和相频特性曲线；<br>（b）求解系统的单位脉冲响应并绘制出图形</p><p><img src="/img/file-20250414112640663.png"><br><img src="/img/file-20250414112651331.png"></p><p>（3）设离散时间双边指数衰减信号$𝑥[𝑛] &#x3D; e^{−2|𝑛|}, 𝑦[𝑛] &#x3D; 𝑥[𝑛] ∗ 𝑥[𝑛]$，请<br>（a）编程用卷积性质求解$𝑌(e^{j𝜔})$与$𝑦[𝑛]$，并绘制$𝑥[𝑛]$、$|𝑌(e^{j𝜔})|$和$𝑦[𝑛]$的图像；<br>（b）编程用时域卷积求解$𝑦[𝑛]$，绘制$𝑦[𝑛]$的图像，并与（a）的结果比较</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>信号与系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab3</title>
    <link href="/2025/03/12/OS-lab3/"/>
    <url>/2025/03/12/OS-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lab3：从实模式到保护模式"><a href="#OS-Lab3：从实模式到保护模式" class="headerlink" title="OS_Lab3：从实模式到保护模式"></a>OS_Lab3：从实模式到保护模式</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li><p>DDL：2025.4.6</p></li><li><p>提交内容：2+1个任务的代码和实验报告 传课程邮箱<a href="https://gitee.com/link?target=mailto:os_sysu_lab@163.com">os_sysu_lab@163.com</a>+实验报告pdf–提交到<a href="https://inbox.weiyun.com/NuWl0loN">腾讯微云</a></p></li><li><p><strong>材料的Example的代码放置在<code>src</code>目录下</strong>。</p></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>学习如何从16位的实模式跳转到32位的保护模式，然后在平坦模式下运行32位系统。同时学习如何使用I&#x2F;O端口和硬件交互，为后面保护模式编程打下基础</p><h2 id="基础学习"><a href="#基础学习" class="headerlink" title="基础学习"></a>基础学习</h2><h3 id="突破512字节的限制"><a href="#突破512字节的限制" class="headerlink" title="突破512字节的限制"></a>突破512字节的限制</h3><p>​我们在之前学到了计算机在启动的最后只会自动加载MBR（512字节）到内存中运行，然而这个空间是很小的，所以在实际应用中，MBR只负责定义了一些基本信息，如磁盘大小、扇区大小等。</p><p>​在运行操作系统前，需要将操作系统内核程序从外存加载到内存中，但这个空间大小无疑是较大的，因而在系统内核加载前，我们的MBR不再是输出“hello world”，而是<strong>将一段程序从外存加载到内存</strong>（大小无512Bytes限制）。这段程序（称为<strong>bootloader</strong>）在内存足够的前提下可以尽量大一点–可以实现：从实模式跳转到保护模式、加载操作系统内核等。</p><p>​无论是MBR还是bootloader，其最开始都是存放在<strong>磁盘</strong>（外存）上的。而MBR和bootloader只有被加载到内存中才可以被执行，除了MBR外，计算机是不会去外存找程序执行的。<strong>MBR</strong>是在计算机启动时被计算机<strong>自动加载到0x7C00处</strong>执行。此后，计算机的任何行为都由我们的程序来控制。也就是说，<u>我们需要自己从外存中加载程序到内存中运行。</u>–学习如何读写硬盘！</p><h3 id="LBA方式读写硬盘"><a href="#LBA方式读写硬盘" class="headerlink" title="LBA方式读写硬盘"></a>LBA方式读写硬盘</h3><h4 id="读写I-O端口"><a href="#读写I-O端口" class="headerlink" title="读写I&#x2F;O端口"></a>读写I&#x2F;O端口</h4><ul><li>硬盘属于外设，<u>CPU和外设的交换</u>通过<strong>I&#x2F;O端口</strong>进行。</li><li>I&#x2F;O端口是一些<strong>寄存器</strong>，位于I&#x2F;O接口电路中。当需要进行数据交换时，我们先将命令和数据放入到指定的I&#x2F;O端口中，等待外设处理完后再从指定的端口取出处理结果。指定的端口也可以获取外设的状态。</li></ul><blockquote><p>（指定–数据交换的I&#x2F;O端口已经被预先规定好了）</p></blockquote><ul><li><p>和寄存器编址很相似，每一个端口在I&#x2F;O电路中都会被<strong>统一编址</strong>。</p><ul><li><p>主硬盘分配的端口地址是0x1f0<del>0x1f7，从硬盘分配的端口地址是0x170</del>0x177</p></li><li><p>由于端口是独立编址的，因此我们<strong>无法使用mov指令来对端口赋值</strong>，可以使用in（读），out（写）指令。</p></li><li><p>值得注意的是：<strong>in指令的源操作数只能是立即数或dx，目的操作数只能是ax和al；out指令的源操作数只能是al或ax，目的操作数只能是立即数或dx</strong></p></li><li><p>例子：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; in指令</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x21</span> <span class="hljs-comment">; 表示从0x21端口读取一字节数据到al</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0x21</span> <span class="hljs-comment">; 表示从端口地址0x21读取1字节数据到al，从端口地址0x22读取1字节到ah</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0x379</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span>  <span class="hljs-comment">; 从端口0x379读取1字节到al</span><br><br><span class="hljs-comment">; out指令</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x21</span>, <span class="hljs-built_in">al</span> <span class="hljs-comment">; 将al的值写入0x21端口</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x21</span>, <span class="hljs-built_in">ax</span> <span class="hljs-comment">; 将ax的值写入端口地址0x21开始的连续两个字节</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x378</span><br><span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">ax</span>  <span class="hljs-comment">; 将ah和al分别写入端口0x379和0x378</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="读写硬盘"><a href="#读写硬盘" class="headerlink" title="读写硬盘"></a>读写硬盘</h4><ul><li>硬盘的读写是以块为单位的，块在硬盘中也被称为扇区，一般的扇区大小是512字节。</li><li>LBA的全称是Logical Block Addressing, <strong>逻辑块寻址模式</strong>。</li><li>硬盘的物理结构包括<strong>磁头、扇区和柱面</strong>（CHS），通过CHS就可以定位磁盘上的数据–在访问硬盘时手动指定磁头、磁道和柱面。</li></ul><p><img src="/img/%E7%A1%AC%E7%9B%98%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84.png" alt="硬盘内部示意图"></p><ul><li>另一种方法：LBA模式。此模式下磁盘的地址空间被划分一个个的逻辑块，访问时<u>只需要指定对应磁盘地址对应的逻辑块</u>即可。</li></ul><blockquote><p>在实模式下，还有利用BIOS中断来读取硬盘的方式，称为CHS模式。需要手动将逻辑扇区号转化为磁盘对应的磁头、磁道和柱面，比较麻烦。这里不使用BIOS中断的原因是因为BIOS中断是16位程序，在保护模式下无法使用。有兴趣的同学可以自行探索“<strong>通过BIOS中断读取硬盘</strong>”</p></blockquote><p>使用LBA读取硬盘的方式：</p><ul><li><p>设置<strong>起始的逻辑扇区号</strong>。由于扇区的读写是连续的，因此只要给出第一个扇区的编号就好了。此处使用的是LBA28（28表示使用28位来表示逻辑扇区的编号）的方式来读取硬盘–但IO端口一次只能读取8位，所以要分<strong>四段</strong>写入端口。</p><ul><li>逻辑扇区的0<del>7位被写入0x1F3端口，8</del>15位被写入0x1F4端口，16~23位被写入0x1F5端口，最后4位被写入0x1F6端口的低4位。</li></ul><table><thead><tr><th align="left">端口地址</th><th align="left">数据位范围</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0x1F3</td><td align="left">0~7</td><td align="left">逻辑扇区号的低 8 位</td></tr><tr><td align="left">0x1F4</td><td align="left">8~15</td><td align="left">逻辑扇区号的中间 8 位</td></tr><tr><td align="left">0x1F5</td><td align="left">16~23</td><td align="left">逻辑扇区号的高 8 位</td></tr><tr><td align="left">0x1F6</td><td align="left">24~27</td><td align="left">逻辑扇区号的最高 4 位</td></tr></tbody></table><ul><li>0x1F6的8个位表示如下</li></ul></li></ul><p><img src="/img/0x1f6%E7%AB%AF%E5%8F%A3.png" alt="0x1f6端口"></p><ul><li><p>将要读取的扇区数量写入0x1F2端口。<strong>8位端口</strong>，每次最多只能读写255个扇区</p></li><li><p>向0x1F7端口写入0x20，请求硬盘读。</p></li><li><p>等待其他读写操作完成。</p></li></ul><p><img src="/img/0x1f7.png" alt="0x1f7"></p><ul><li>若在第四步中检测到其他操作已经完成，那么我们就可以正式从硬盘中读取数据。</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_read_hard_disk:</span>                           <br><span class="hljs-comment">; 从硬盘读取一个逻辑扇区</span><br><br><span class="hljs-comment">; 参数列表</span><br><span class="hljs-comment">; ax=逻辑扇区号0~15位</span><br><span class="hljs-comment">; cx=逻辑扇区号16~28位</span><br><span class="hljs-comment">; ds:bx=读取出的数据放入地址</span><br><br><span class="hljs-comment">; 返回值</span><br><span class="hljs-comment">; bx=bx+512</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f3</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>    <span class="hljs-comment">; LBA地址7~0</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; 0x1f4</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">ah</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>    <span class="hljs-comment">; LBA地址15~8</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">cx</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; 0x1f5</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>    <span class="hljs-comment">; LBA地址23~16</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; 0x1f6</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">ah</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x0f</span><br>    <span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0xe0</span>   <span class="hljs-comment">; LBA地址27~24</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f2</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>, <span class="hljs-built_in">al</span>   <span class="hljs-comment">; 读取1个扇区</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f7</span>    <span class="hljs-comment">; 0x1f7</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0x20</span>     <span class="hljs-comment">;读命令</span><br>    <span class="hljs-keyword">out</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">al</span><br><br>    <span class="hljs-comment">; 等待处理其他操作</span><br><span class="hljs-symbol">  .waits:</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">dx</span>        <span class="hljs-comment">; dx = 0x1f7</span><br>    <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x88</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x08</span><br>    <span class="hljs-keyword">jnz</span> .waits                         <br>    <br><br>    <span class="hljs-comment">; 读取512字节到地址ds:bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">256</span>   <span class="hljs-comment">; 每次读取一个字，2个字节，因此读取256次即可          </span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">0x1f0</span><br><span class="hljs-symbol">  .readw:</span><br>    <span class="hljs-keyword">in</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">loop</span> .readw<br>      <br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>保护模式，是一种在80286系列之后，基于x86架构的CPU操作模式。在80286及以后，保护模式的引入使得内存地址改为32位，程序至少可以访问到2^32&#x3D;4G的内存空间</p><p>保护模式与实模式相比，主要有两个差别。</p><ul><li>保护模式提供了<strong>段间的保护机制</strong>，防止程序间胡乱访问地址带来的问题。</li><li>保护模式访问的<strong>内存空间变大</strong>，32位地址线最大支持4G内存空间。</li></ul><h4 id="从实模式到保护模式"><a href="#从实模式到保护模式" class="headerlink" title="从实模式到保护模式"></a>从实模式到保护模式</h4><p><u>在保护模式下，所有的程序都会运行在自己的段中，一旦程序错误地访问其他段的地址空间，那么CPU就会产生异常来阻止程序访问。</u>可以简单地理解为保护模式保护的是段地址空间，阻止程序越界访问。</p><p>CPU需要知道当前运行中程序的段地址空间信息，然后才能执行地址保护。段地址空间信息是通过<strong>段描述符</strong>(segment descriptor)来给出的，包含了<strong>段基地址</strong>(段的起始地址)、<strong>段界限</strong>(段的长度)等，共计64字节</p><p><img src="/img/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="段描述符"></p><ul><li><strong>段基地址</strong>。段基地址共32位，是<strong>段的起始地址</strong>，被拆分成三部分放置。</li><li><strong>G位</strong>。G表示<strong>粒度</strong>， G&#x3D;0表示段界限以<strong>字节</strong>为单位， G&#x3D;1表示段界限以<strong>4KB</strong>为单位。</li><li><strong>D&#x2F;B位</strong>。D&#x2F;B位是<u>默认操作数的大小或默认堆栈指针的大小</u>，在保护模式下，该位置为1，表示32位。</li><li><strong>L位</strong>。L位是 <strong>64 位代码段标志</strong>，由于这里我们使用的是32位的代码，所以L置0。</li><li><strong>AVL</strong>。AVL位是保留位。</li><li><strong>段界限</strong>。段界限表示段的偏移地址范围，我们在后面详细讨论这个问题。</li><li><strong>P位</strong>。P位是段存在位， P&#x3D;1表示段存在， P&#x3D;0表示段不存在。</li><li><strong>DPL</strong>。DPL指明访问该段必须有的最低优先级，优先级从0-3依次降低，即0拥有最高优先级，3拥有最低优先级。</li><li><strong>S位</strong>。S位是描述符类型。S&#x3D;0表示该段是系统段，S&#x3D;1表示该段位代码段或数据段。</li><li><strong>TYPE</strong>。TYPE指示代码段或数据段的类型，如下所示。</li></ul><table><thead><tr><th>第11位(X)</th><th>第10位(E)</th><th>第9位(W)</th><th>第8位(A)</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>*</td><td>只读，向上扩展</td></tr><tr><td>0</td><td>0</td><td>1</td><td>*</td><td>读写，向上扩展</td></tr><tr><td>0</td><td>1</td><td>0</td><td>*</td><td>只读，向下扩展</td></tr><tr><td>0</td><td>1</td><td>1</td><td>*</td><td>读写，向下扩展</td></tr><tr><td>1</td><td>0</td><td>0</td><td>*</td><td>只执行，非一致代码段</td></tr><tr><td>1</td><td>0</td><td>1</td><td>*</td><td>执行、可读，非一致代码段</td></tr><tr><td>1</td><td>1</td><td>0</td><td>*</td><td>只执行，一致代码段</td></tr><tr><td>1</td><td>1</td><td>1</td><td>*</td><td>执行、可读、一致代码段</td></tr></tbody></table><p>A位表示是否被使用过，A&#x3D;1表示使用，A&#x3D;0表示未被使用，由<strong>CPU</strong>负责设置，我们不需要去管</p><p><strong>向上</strong>扩展和<strong>向下</strong>扩展指的是<strong>段的线性基地址</strong>和<strong>段的线性尾地址</strong>的大小关系</p><p>保护模式的寻址过程：线性地址&#x3D;base+offset</p><p>保护模式下，我们在指令中给出的都是偏移地址，偏移地址和段线性基地址相加后得到线性地址，线性地址通过<strong>地址变换部件MMU</strong>后得到实际的物理地址。<br>$$<br>物理地址&#x3D;f(线性地址)<br>$$<br>但在此时我们并未开启分页机制，所以是恒等变换x&#x3D;f(x) –&gt;线性地址</p><p>对于一个向上扩展的段，如代码段和数据段，段界限给出的是最大的偏移量，寻址时满足下面的条件。<br>$$<br>0\le offset +length\le(段界限+1)*粒度<br>$$<br>对于一个向下扩展的段，如栈段，段界限给出的是最小的偏移量，寻址时满足如下条件。<br>$$<br>(段界限+1)*粒度\le offset-length\le\text{0xFFFFFFFF}<br>$$</p><p>在保护模式，所有<strong>段描述符</strong>都会被<strong>集中放置</strong>，这个集中放置的区域被称为<strong>全局描述符表</strong>（GDT）。</p><p>保护模式的内存地址扩展到32位，所以可以使用32位的寄存器。保护模式下<strong>段寄存器</strong>仍在使用，但保存的不再是段地址，而是<strong>段选择子</strong>（GDT的索引），用于指示给CPU寻址时使用的是哪个段。</p><p><img src="/img/image-20250320143535634.png" alt="image-20250320143535634"></p><ul><li>第15-3位是<strong>段描述符的索引</strong>，表示选择子指向的段描述符是段描述符表中的第几个，编号从 0 开始。</li><li>第2位用来<strong>指示描述符表</strong>，0表示描述符表是 GDT。</li><li>第1-0位是<strong>请求特权级</strong>，特权级编号为 0-3，权限依次降低，<strong>0权限最高</strong>。</li></ul><p>保护模式下的寻址：段地址+偏移地址–&gt;表示为 <strong>选择子:偏移地址</strong></p><p>每个段寄存器都会有一个64位的不可见的部分，这部分被称为描述符高速缓存器。<em>当我们将选择子送入段寄存器时，CPU会自动从描述符表中加载对应的段描述符到描述符高速缓存器中。此后，当需要使用段寄存器时，CPU会直接从描述符高速缓存器中取出相应的内容，无需重新在描述符表中查找对应的段描述符。</em></p><p>CPU向下兼容，Intel 80286以后的CPU首先进入实模式，然后通过切换机制再进入到保护模式。也就是说在BIOS加电启动后，需要在实模式下的<strong>MBR</strong>中<u>编写16位进入保护模式的代码</u>，然后再跳转到保护模式，执行接下来的32位代码。</p><p>steps:</p><ul><li><p><strong>准备GDT，用lgdt指令加载GDTR信息</strong>。</p></li><li><p><strong>打开第21根地址线</strong>。</p><ul><li><p>实模式下，第21根地址线的值恒为0，使得当访问越界超过1MB时，自然溢出使得地址的值仍然小于1MB（取模）</p></li><li><p>所以要进入保护模式，需要打开第21根地址线–开关位于南桥芯片的端口A20，使用in、out指令可以对主板端口进行<strong>读写</strong>操作</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span> <span class="hljs-comment">;南桥芯片内的端口</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span> <span class="hljs-comment">;打开A20</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>开启cr0的保护模式标志位</strong>。</p><ul><li><p>真正的开关–CR0（32bit寄存器）包含了一系列用户控制CPU操作模式和运行的标志位</p></li><li><p><strong>第0位是保护模式的开关位</strong>–PE位–PE位置1，CPU进入保护模式</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">cli</span> <span class="hljs-comment">;保护模式下中断机制尚未建立，应禁止中断</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span> <span class="hljs-comment">;设置PE位为1</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>远跳转，进入保护模式</strong>。</p></li></ul><p>GDT的起始位置和大小由我们来确定，保存在寄存器<strong>GDTR</strong>中，GDTR：</p><p><img src="/img/image-20250320144218557.png" alt="image-20250320144218557"></p><p>全集描述符表边界–GDT的边界–段界限边界</p><p>$$<br>段描述符最大数量&#x3D;\frac{2^{16}}{8}&#x3D;8192<br>$$<br>每个段描述符是64bit（8字节）</p><h2 id="Example1：-bootloader的加载"><a href="#Example1：-bootloader的加载" class="headerlink" title="Example1： bootloader的加载"></a>Example1： bootloader的加载</h2><p>内存地址安排：bootloader被安排在MBR之后，预留了<strong>5个扇区</strong>的空间</p><table><thead><tr><th>name</th><th>start</th><th>length</th><th>end</th></tr></thead><tbody><tr><td>MBR</td><td>0x7c00</td><td>0x200(512B)</td><td>0x7e00</td></tr><tr><td>bootloader</td><td>0x7e00</td><td>0xa00(512B *** 5**)</td><td>0x8800</td></tr></tbody></table><p>运行步骤：</p><ul><li><p>编译bootloader后写入到<strong>硬盘起始编号为1</strong>的扇区，共有五个扇区。</p><ul><li>编译：<code>nasm -f bin bootloader.asm -o bootloader.bin</code></li><li>加载：<code>dd if=bootloader.bin of=hd.img bs=512 count=5 seek=1 conv=notrunc</code></li></ul></li><li><p>mbr也要重新编译并写入硬盘其实编号为0的扇区</p><ul><li>编译：<code>nasm -f bin mbr.asm -o mbr.bin</code></li><li>加载：<code>dd if=mbr.bin of=hd.img bs=512 count=1 seek=0 conv=notrunc</code></li></ul><p>回顾一下对应的参数设置：<img src="/img/image-20250320164325744.png" alt="image-20250320164325744"></p></li><li><p>运行 <code>qemu-system-i386 -hda hd2.img -serial null -parallel stdio</code></p></li></ul><p>运行结果：</p><p><img src="/img/image-20250320163929392.png" alt="image-20250320163929392"></p><h2 id="Example2：进入保护模式"><a href="#Example2：进入保护模式" class="headerlink" title="Example2：进入保护模式"></a>Example2：进入保护模式</h2><p>在进入保护模式之前，我们先对我们的内存地址进行规划。</p><table><thead><tr><th>Name</th><th>Start</th><th>Length</th><th>End</th></tr></thead><tbody><tr><td>MBR</td><td>0x7c00</td><td>0x200(512B)</td><td>0x7e00</td></tr><tr><td>bootloader</td><td>0x7e00</td><td>0xa00(512B * 5)</td><td>0x8800</td></tr><tr><td>GDT</td><td>0x8800</td><td>0x80(8B * 16)</td><td>0x8880</td></tr></tbody></table><ul><li>MBR自动加载到0x7c00</li><li>bootloader在MBR中显式加载到0x7e00</li><li>GDT显示加载到0x8800</li></ul><p><code>equ</code>是汇编伪指令，e.g：编译器会在编译时将 <code>LOADER_SECTOR_COUNT</code>出现的地方替换为5 （类似与宏</p><blockquote><p>在操作系统内核设计的过程中，内存规划是一件令人苦恼的事情。从上面的例子可以看到，bootloader紧跟在MBR后面，GDT紧跟在bootloader后面，看起来非常紧凑。但是，只要其中一个发生变化，那么可能我们又要重新规划内存。也就是说，没有一种内存规划方案是完美的。</p></blockquote><p>在bootloader中跳转到保护模式：</p><ul><li>定义段描述符（代码段描述符、数据段描述符、栈段描述符和视频段描述符）</li></ul><p>平坦模式：让代码段描述符、数据段描述符和栈段描述符中的<strong>段线性基地址为0</strong> &#x3D;&gt;偏移地址和线性地址完全相同</p><blockquote><p>段的存在是为了让CPU执行段保护，放置程序越界访问；</p><p>后续实验中会采用二级分页机制，此时页保护页可以组织程序越界访问 &#x3D;》无需分段了</p></blockquote><p>视频段描述符是<strong>显存所在的内存区域</strong>的段描述符。注意，<strong>GDT的第0个描述符必须是全0的描述符</strong>。接着，在GDT中依次放入0描述符，数据段描述符、堆栈段描述符、显存段描述符和代码段描述符</p><p>运行结果：</p><p><img src="/img/image-20250320171528591.png" alt="image-20250320171528591"></p><p>如何在gdb中使用info registers查看寄存器</p><ul><li>要记得在qemu启动时加入 <code>-s -S</code> 参数: <code>qemu-system-i386 -hda hd.img -serial null -parallel stdio -s -S</code></li><li>再启动gdb，并且连接端口 <code>target remote:1234</code></li><li>在输入 <code>info registers</code>可以查看</li></ul><p><img src="/img/image-20250320172738614.png" alt="image-20250320172738614"></p><ul><li>执行程序之后，发现寄存器发生了很大的变化</li></ul><p><img src="/img/image-20250320172319147.png" alt="image-20250320172319147"></p><p>ps：</p><table><thead><tr><th>gdb指令</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>break *adress或b *address</td><td>在地址adress处设置断点。</td><td>break *0x7c00 b *0x7c00</td></tr><tr><td>break symbol或b symbol</td><td>在符号symbol处设置断点，例如symbol一般是函数名。</td><td>break setup_kernel b setup_kernel</td></tr><tr><td>break filename:line_number</td><td>在文件filename处的第line_numer行设置断点</td><td>b mbr.asm:12</td></tr><tr><td>add-symbol-file filename address</td><td>加载符号表filename到地址address处</td><td>add-symbol-file mbr.symbol 0x7c00</td></tr><tr><td>x&#x2F;FMT address</td><td>address是内存地址，FMT格式是重复的单元个数+格式+大小。 重复的单元个数是一个数字，表示我们希望查看多少个单元。正数表示从address向后查看。负数表示从address向前查看。 格式是一个字符，可以是o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string)。 大小是一个字符，可以是b(byte, 1 byte), h(halfword, 2 byte), w(word, 4 byte), g(giant, 8 bytes)。</td><td>x&#x2F;5xw 0x8032 x&#x2F;10i 0x7c00</td></tr><tr><td>continue或c</td><td>继续执行正在调试的程序到断点处暂停。</td><td></td></tr><tr><td>step或s</td><td>执行一条C语句，如果遇到函数调用语句，则会进入函数体中。</td><td></td></tr><tr><td>next或n</td><td>执行一条C语句，函数调用语句不会进入函数体，把函数当成一条语句执行。</td><td></td></tr><tr><td>stepi或si</td><td>执行一条汇编语句，如果遇到函数调用语句，则会进入函数体中。</td><td></td></tr><tr><td>nexti或ni</td><td>执行一条汇编语句，函数调用语句不会进入函数体，把函数当成一条语句执行。</td><td></td></tr><tr><td>info registers</td><td>查看所有寄存器的值</td><td></td></tr><tr><td>layout layout_name</td><td>layout_name包含src，asm，split，regs。 src显示源代码窗口和命令窗口，asm显示汇编代码窗口和命令窗口，split显示源代码窗口、汇编代码窗口和命令窗口，regs显示寄存器窗口。</td><td>layout split</td></tr><tr><td>focus layout_window</td><td>转换当前窗口到layout窗口，layout_window包含src，asm，regs，cmd。任何时刻gdb的当前窗口只有一个，并且使用方向键的效果只会在当前窗口处显示。</td><td>focus cmd</td></tr><tr><td>file symbol_file</td><td>加载符号表，为gdb提供debug信息。</td><td>file ..&#x2F;build&#x2F;kernel.o</td></tr><tr><td>set disassembly-flavor intel</td><td>设置汇编代码格式为intel风格</td><td></td></tr><tr><td>set architecture name</td><td>设置指令对应的CPU架构，name包含i8086(16位)，i386(32位)</td><td>set architecture i386</td></tr></tbody></table><h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务 1"></a>任务 1</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>复现Example 1，说说你是怎么做的并提供结果截图，也可以参考Ucore、Xv6等系统源码，实现自己的LBA方式的磁盘访问。</p><p>提示：部分需要的文件存放在<code>src/example-1</code>下，请根据需要将其放置于自己创建的lab3文件夹下。</p><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>在Example1中，我们使用了LBA28的方式来读取硬盘。此时，我们只要给出逻辑扇区号即可，但需要手动去读取I&#x2F;O端口。然而，BIOS提供了实模式下读取硬盘的中断，其不需要关心具体的I&#x2F;O端口，只需要给出逻辑扇区号对应的磁头（Heads）、扇区（Sectors）和柱面（Cylinder）即可，又被称为CHS模式。现在，同学们需要&#x3D;&#x3D;将LBA28读取硬盘的方式换成CHS读取&#x3D;&#x3D;，同时给出逻辑扇区号向CHS的转换公式。最后说说你是怎么做的并提供结果截图。</p><p>勘误：《于渊：一个操作系统的实现2》P183-184给的是读取软盘的计算公式，而我们读取的是硬盘，因此不适用。参考资料变更如下。</p><ul><li><a href="https://gitee.com/link?target=https://blog.csdn.net/G_Spider/article/details/6906184">LBA向CHS模式的转换</a></li><li><a href="https://gitee.com/link?target=https://blog.csdn.net/brainkick/article/details/7583727">int 13h中断</a></li></ul><p>其中，关键参数如下。</p><table><thead><tr><th>参数</th><th>数值</th></tr></thead><tbody><tr><td>驱动器号（DL寄存器）</td><td>80h</td></tr><tr><td>每磁道扇区数</td><td><strong>63</strong></td></tr><tr><td>每柱面磁头数（每柱面总的磁道数）</td><td>18</td></tr></tbody></table><h3 id="LBA向CHS模式转换："><a href="#LBA向CHS模式转换：" class="headerlink" title="LBA向CHS模式转换："></a>LBA向CHS模式转换：</h3><ul><li>LBA值需要通过运算间接的粗cylinder、head、sector这三个变量的值</li></ul><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><strong>cylinder</strong>：磁盘的<strong>柱面</strong></li><li><strong>head</strong>：磁盘的<strong>磁头</strong>，每张磁片有两个磁头</li><li><strong>sector</strong>：磁盘<strong>扇区</strong>，这里指物理扇区，编号从 <strong>1 - 63</strong>，每条 track 的最大 sector 数 63</li><li><strong>SPT</strong>（sector_per_track）：每磁道上的 sector 数</li><li><strong>HPC</strong>（head_per_cylinder）：每个 cylinder 的 head 数量，这个数量应该是<strong>磁片数 * 2</strong></li></ul><h4 id="LBA寻址"><a href="#LBA寻址" class="headerlink" title="LBA寻址"></a>LBA寻址</h4><p>LBA的扇区从0开始计算。<br>&#x3D;&#x3D;LBA &#x3D; (cylinder * HPC + head) * SPT + sector - 1&#x3D;&#x3D;</p><ul><li>先计算track的数量，再加上物理扇区（从1开始编号），转换为LBA扇区需要-1</li><li>track 的数量计算方式为：<code>cylinder * HPC（head_per_cylinder）+ head</code></li></ul><h4 id="LBA2CHS"><a href="#LBA2CHS" class="headerlink" title="LBA2CHS"></a>LBA2CHS</h4><ol><li>计算cylinder：<code>cylinder=LBA/(SPT*HPC)</code><ul><li><code>SPT*HPC</code>这部分计算的是每个cylinder有多少个扇区</li><li>然后再计算在磁盘内需要多少个柱面表达</li></ul></li><li>计算head：<code>head=(LBA/SPT)%HPC</code><ul><li>在求出磁盘柱面的情况下，我们需要求得磁盘的磁头</li><li><code>LBA/SPT</code>这步在计算磁盘内有多少head</li><li>然后再计算出在一个柱面中的磁头编号</li></ul></li><li>计算sector：sector&#x3D;LBA%SPT+1<ul><li><code>LBA % SPT</code> 这步计算可以得出逻辑的扇区号</li><li>然后由于物理的扇区是从1开始的，所以要<code>+1</code></li></ul></li></ol><p>Resources：<br><a href="https://blog.csdn.net/haiross/article/details/38661051">代码实现之磁盘的 LBA 寻址转换为 CHS 寻址_lba和cly-CSDN博客</a><br><a href="https://www.cnblogs.com/mlzrq/p/10223053.html">读取磁盘：CHS方式 - 猛练自然强 - 博客园</a></p><p>实现过程：<br>直接使用int 13h中断模式中的ah&#x3D;02h功能（读扇区）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">功能<span class="hljs-number">02H</span>： <br>功能描述：读扇区 <br>入口参数：<span class="hljs-number">AH</span>＝<span class="hljs-number">02H</span> <br><span class="hljs-built_in">AL</span>＝扇区数 <br><span class="hljs-number">CH</span>＝柱面 <br><span class="hljs-built_in">CL</span>＝扇区 <br><span class="hljs-number">DH</span>＝磁头 <br><span class="hljs-built_in">DL</span>＝驱动器，<span class="hljs-number">00H</span>~<span class="hljs-number">7FH</span>：软盘；<span class="hljs-number">80H</span>~<span class="hljs-number">0FFH</span>：硬盘 <br><span class="hljs-symbol">ES:</span><span class="hljs-built_in">BX</span>＝缓冲区的地址 <br>出口参数：CF＝<span class="hljs-number">0</span>——操作成功，<span class="hljs-number">AH</span>＝<span class="hljs-number">00H</span>，<span class="hljs-built_in">AL</span>＝传输的扇区数，否则，<span class="hljs-number">AH</span>＝状态代码，参见功能号<span class="hljs-number">01H</span>中的说明<br></code></pre></td></tr></table></figure><p>关键参数参考：</p><table><thead><tr><th>参数</th><th>数值</th></tr></thead><tbody><tr><td>驱动器号（DL寄存器）</td><td>80h</td></tr><tr><td>每磁道扇区数</td><td><strong>63</strong></td></tr><tr><td>每柱面磁头数（每柱面总的磁道数）</td><td>18</td></tr><tr><td>扇区号（通过LBA地址+1得到物理地址CSH）</td><td>2</td></tr><tr><td>柱面号</td><td>0</td></tr><tr><td>缓冲区地址(bootloader加载地址)</td><td>0x7e00</td></tr></tbody></table><p>代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">asm_read_hard_disk:</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x02</span> <span class="hljs-comment">;设置模式</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1</span> <span class="hljs-comment">;读取扇区数</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">0x80</span> <span class="hljs-comment">;磁头</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0x7e00</span> <span class="hljs-comment">;缓冲区地址</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span>  <span class="hljs-comment">;柱面号</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span> <span class="hljs-comment">;扇区号？</span><br><br>  <span class="hljs-keyword">int</span> <span class="hljs-number">13h</span><br></code></pre></td></tr></table></figure><p>结果截图：</p><p><img src="/img/image-20250324213555322.png" alt="image-20250324213555322"></p><h2 id="任务-2"><a href="#任务-2" class="headerlink" title="任务 2"></a>任务 2</h2><p>复现Example 2，使用gdb或其他debug工具在进入保护模式的4个重要步骤上<strong>设置断点</strong>，并结合代码、寄存器的内容等来分析这4个步骤，最后附上结果截图。gdb的使用可以参考appendix的“debug with gdb and qemu”部份。</p><p>提示：部分需要的文件存放在<code>src/example-2</code>下，请根据需要将其放置于自己创建的lab3文件夹下。</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>可以直接make run；<br>结果截图参见上面的Example2部分。<br><img src="/img/image-20250320171528591.png" alt="image-20250320171528591"></p><h3 id="GDB调试方法"><a href="#GDB调试方法" class="headerlink" title="GDB调试方法"></a>GDB调试方法</h3><p>resources：<br><a href="https://gitee.com/kpyang5/sysu-2025-spring-operating-system/blob/main/appendix/debug_with_gdb_and_qemu/README.md#%E5%AE%89%E8%A3%85215%E7%89%88%E6%9C%AC%E7%9A%84nasm">appendix&#x2F;debug_with_gdb_and_qemu&#x2F;README.md · young&#x2F;sysu-2025-spring-operating-system - 码云 - 开源中国</a><br><a href="https://blog.csdn.net/qq_51753728/article/details/142262405">Makefile(超详细一文读懂)-CSDN博客</a></p><p>回顾之前简单的调试：</p><ul><li>在qemu启动的前提下，打开一个新的终端，并输入gdb进入gdb调试</li><li>在gdb下，连接已经启动的qemu进行调试： <code>target remote:1234</code></li><li>设置断点：<code>break func</code></li><li>输入<code>c</code>（continue）运行</li></ul><h4 id="生成符号表"><a href="#生成符号表" class="headerlink" title="生成符号表"></a>生成符号表</h4><ul><li>可以使用gdb在debug过程中查看源代码&#x3D;&gt;提供相关的信息&#x3D;&gt;符号表（ELF格式）</li><li>制作符号表：<ul><li>先编译汇编代码生成可重定向文件（ELF文件）</li><li>使用这个可重定向文件生成可执行文件和bin格式文件</li></ul></li></ul><p>以example-2为例：</p><ul><li>删除<code>*.asm</code>中的<code>org</code>语句，后续会在链接的过程中指定他们代码和数据的起始地址</li><li>编译mbr.asm生成.o文件 。<code>-g</code>参数是为了加上debug信息</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nasm -o mbr<span class="hljs-selector-class">.o</span> -<span class="hljs-selector-tag">g</span> -f elf32 mbr<span class="hljs-selector-class">.asm</span> <br></code></pre></td></tr></table></figure><ul><li>为<code>mbr.o</code>文件指定起始地址为<code>0x7c00</code>，分别链接生成可执行文件<code>mbr.symbol</code>和<code>mbr.bin</code></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld -o mbr<span class="hljs-selector-class">.symbol</span> -melf_i386 -N mbr<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7c00<br>ld -o mbr<span class="hljs-selector-class">.bin</span> -melf_i386 -N mbr<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7c00 <span class="hljs-attr">--oformat</span> binary<br></code></pre></td></tr></table></figure><ul><li>对bootloader.asm重复同样的工作</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nasm -o bootloader<span class="hljs-selector-class">.o</span> -<span class="hljs-selector-tag">g</span> -f elf32 bootloader<span class="hljs-selector-class">.asm</span> <br>ld -o bootloader<span class="hljs-selector-class">.symbol</span> -melf_i386 -N bootloader<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7e00<br>ld -o bootloader<span class="hljs-selector-class">.bin</span> -melf_i386 -N bootloader<span class="hljs-selector-class">.o</span> -Ttext <span class="hljs-number">0</span>x7e00 <span class="hljs-attr">--oformat</span> binary<br></code></pre></td></tr></table></figure><ul><li>将mbr.bin和bootloader.bin都载入磁盘</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=mbr.bin <span class="hljs-attribute">of</span>=hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=1 <span class="hljs-attribute">seek</span>=0 <span class="hljs-attribute">conv</span>=notrunc<br>dd <span class="hljs-attribute">if</span>=bootloader.bin <span class="hljs-attribute">of</span>=hd.img <span class="hljs-attribute">bs</span>=512 <span class="hljs-attribute">count</span>=5 <span class="hljs-attribute">seek</span>=1 <span class="hljs-attribute">conv</span>=notrunc<br></code></pre></td></tr></table></figure><p>执行完这些之后会发现生成了这些文件：</p><p><img src="/img/image-20250325085117185.png" alt="image-20250325085117185"></p><p>设置断点：</p><p>在mbr的第一条指令处设置断点</p><p><img src="/img/image-20250325085326131.png" alt="image-20250325085326131"></p><p>打开显示源代码的窗口：</p><p><img src="/img/image-20250325085405878.png" alt="image-20250325085405878"></p><p>加载MBR对应的符号表，可以在src窗口看到我们的源代码</p><p>&#x3D;&#x3D;B+表示断点，白色窗口表示下一条要执行的指令&#x3D;&#x3D;</p><p><img src="/img/image-20250325085657137.png" alt="image-20250325085657137"></p><p>窗口之间跳转：<br>注意，我们现在有两个窗口，一个是输入命令的cmd窗口，一个是显示源代码的src窗口。而方向键的效果只会在当前窗口起作用，并且当前窗口只有一个。在src窗口下，<strong>上下键的作用是上下滚动代码</strong>，<strong>在cmd窗口下，上键的作用是找到之前执行的命令</strong>。如果想要在两个窗口之前切换，可以使用<code>focus</code>命令，例如切换当前窗口到cmd窗口。</p><p><img src="/img/image-20250325090100161.png" alt="image-20250325090100161"></p><p><img src="/img/image-20250325090218168.png" alt="image-20250325090218168"></p><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="进入保护模式的四个步骤"><a href="#进入保护模式的四个步骤" class="headerlink" title="进入保护模式的四个步骤"></a>进入保护模式的四个步骤</h4><ul><li><strong>准备GDT，用lgdt指令加载GDTR信息</strong>。</li><li><strong>打开第21根地址线</strong>。</li><li><strong>开启cr0的保护模式标志位</strong>。</li><li><strong>远跳转，进入保护模式</strong>。</li></ul><h4 id="更加详细的基本调试思路"><a href="#更加详细的基本调试思路" class="headerlink" title="更加详细的基本调试思路"></a>更加详细的基本调试思路</h4><ol><li><strong>qemu启动</strong>。我们先在一个Terminal下启动qemu，注意，qemu运行的参数需要加上<code>-s -S</code>参数，且在gdb启动之前不能关闭qemu。</li><li><strong>gdb启动</strong>。在另一个Terminal下启动gdb并<strong>连接</strong>上第1步启动的qemu。（如target remote:1234)</li><li><strong>加载符号表</strong>。&#x3D;&#x3D;符号表&#x3D;&#x3D;会为gdb提供源代码和标识符等debug信息。</li><li><strong>设置断点</strong>。gdb运行到我们设置的断点处会暂停，我们会在我们感兴趣的代码地址处设置断点，断点一般是我们认为bug出现的地方。</li><li><strong>运行至断点处</strong>。使用命令跳过其他我们不感兴趣的代码，使代码一直执行到我们设置的断点处暂停。</li><li><strong>查看寄存器或特定地址的值</strong>。我们可以在gdb暂停的地方查看寄存器或特定地址的值，并根据输出来判断前面执行的代码是否出现bug。</li><li><strong>单步调试跟踪</strong>。gdb在断点处暂停后，我们可以一条一条语句地执行来跟踪程序的运行逻辑，gdb每执行条语句就会暂停。</li><li><strong>重复3、4、5、6一直到bug解决</strong>。这个过程可能需要反复执行，但不一定是按照{3,4,5,6}{3,4,5,6}的顺序，可以是{3,4,6,5,6,6,6,5,3,4,5}{3,4,6,5,6,6,6,5,3,4,5}。</li></ol><h4 id="实验断点设置："><a href="#实验断点设置：" class="headerlink" title="实验断点设置："></a>实验断点设置：</h4><p>在mbr的初始地址设置断点：</p><p><img src="/img/image-20250325102422602.png" alt="image-20250325102422602"></p><p>键入<code>c</code>之后，成功初始化</p><p><img src="/img/image-20250325102509957.png" alt="image-20250325102509957"></p><p>然后打开源代码窗口，并加载MBR对应的符号表</p><p><img src="/img/image-20250325102602634.png" alt="image-20250325102602634"></p><p>然后为bootloader设置断点，对应情况如下：</p><ul><li>这里<strong>断点位置的查找</strong>（偏移量的计算）使用了<code>nasm -f bin -l bootloader.lst bootloader.asm</code>命令，可以生成一个对应的<strong>列表文件</strong>，会显示&#x3D;&#x3D;每条指令的偏移量&#x3D;&#x3D;</li><li>另一种方法是使用反汇编（objdump）–输出结果会呈现在终端中<code>objdump -D -b binary -m i386 -M intel bootloader.bin</code></li></ul><p><img src="/img/image-20250325102052040.png" alt="image-20250325102052040"></p><ul><li>到达第一个起始点：</li></ul><p><img src="/img/image-20250325103125494.png" alt="image-20250325103125494"></p><p>此时的寄存器内容：</p><p><img src="/img/image-20250325103155996.png" alt="image-20250325103155996"></p><p><img src="/img/image-20250325103217047.png" alt="image-20250325103217047"></p><p><img src="/img/image-20250325103229067.png" alt="image-20250325103229067"><br>栈顶指针指向0x7c00，下一条执行的指令</p><ul><li>到达第二个断点–初始设置GDTR之前</li></ul><p><img src="/img/image-20250325103308463.png" alt="image-20250325103308463"></p><p>寄存器内容：</p><p><img src="/img/image-20250325103324172.png" alt="image-20250325103324172"></p><p><img src="/img/image-20250325103341062.png" alt="image-20250325103341062"></p><p><img src="/img/image-20250325103354840.png" alt="image-20250325103354840"></p><ul><li>第三个断点–GDTR设置后，打开第21根地址线之前<br><img src="/img/file-20250330212542533.png"></li></ul><p><img src="/img/image-20250325103450079.png" alt="image-20250325103450079"></p><p>寄存器内容：</p><p><img src="/img/image-20250325103511283.png" alt="image-20250325103511283"></p><p><img src="/img/image-20250325103521281.png" alt="image-20250325103521281"></p><p><img src="/img/image-20250325103529256.png" alt="image-20250325103529256"></p><ul><li>第四个断点–打开第21根地址线之后，设置保护模式PE位之前</li></ul><p><img src="/img/image-20250325103605882.png" alt="image-20250325103605882"></p><p><img src="/img/image-20250325103620227.png" alt="image-20250325103620227"></p><p><img src="/img/image-20250325103627936.png" alt="image-20250325103627936"></p><ul><li>第五个断点–设置PE位之后，进入保护模式之前</li></ul><p><img src="/img/image-20250325103649298.png" alt="image-20250325103649298"></p><p>寄存器内容：</p><p><img src="/img/image-20250325103703503.png" alt="image-20250325103703503"></p><p><img src="/img/image-20250325103719845.png" alt="image-20250325103719845"></p><h6 id="可以看到这里cr0位改变了，成功设置"><a href="#可以看到这里cr0位改变了，成功设置" class="headerlink" title="可以看到这里cr0位改变了，成功设置"></a>可以看到这里cr0位改变了，成功设置</h6><p>进入保护模式前：</p><p><img src="/img/image-20250325103805259.png" alt="image-20250325103805259"></p><ul><li>执行到最后（进入保护模式）</li></ul><p>可以看到<strong>多呈现了一行输出</strong>–成功进入保护模式</p><p><img src="/img/image-20250325103857556.png" alt="image-20250325103857556"></p><h4 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h4><h5 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h5><p><code>Makefile</code> 是 <code>make</code> 命令所读取的配置文件，包含了构建项目的规则。其主要作用是<strong>检查项目文件的依赖关系</strong>，<strong>自动执行必要的命令</strong>，从而<strong>更新目标文件</strong>。一般来说，Makefile 主要包括以下三部分内容：</p><ul><li>目标：需要生成的文件，例如可执行文件。</li><li>依赖：生成目标所依赖的文件或目标。</li><li>命令：构建目标时需要执行的命令。</li></ul><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target</span>:dependencies<br><span class="hljs-keyword">command</span><br></code></pre></td></tr></table></figure><ul><li><strong>target</strong>：目标文件，可以是一个目标文件或一个动作名称（例如：<code>all</code>, <code>clean</code>）。</li><li><strong>dependencies</strong>：生成目标所依赖的文件或其他目标。</li><li><strong>command</strong>：构建目标的命令，必须以 <code>Tab</code> 键开头。</li></ul><p>变量的使用：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">VarName</span><span class="hljs-operator">=</span>var<br></code></pre></td></tr></table></figure><p>使用的时候：<code>$(VarName)</code><br>例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">CC = g++<br>CFLAGS = -Wall -<span class="hljs-selector-tag">g</span><br> <br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span><br>    $(CC) $(CFLAGS) -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> -o <span class="hljs-selector-tag">main</span>.o<br></code></pre></td></tr></table></figure><p>常用的内置变量：</p><ul><li><code>$@</code>：表示<strong>目标文件</strong>。</li><li><code>$^</code>：表示<strong>所有的依赖文件</strong>。</li><li><code>$&lt;</code>：表示<strong>第一个依赖文件</strong>。</li></ul><p>伪目标：一种&#x3D;&#x3D;命令名称&#x3D;&#x3D;<br>例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm -f *.o main<br></code></pre></td></tr></table></figure><p><strong>方式一：Makefile+直接编译链接（不推荐）</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app:add<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> multi<span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc add<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> multi<span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o app<br></code></pre></td></tr></table></figure><p><strong>方式二：Makefile+编译+链接</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app:add<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span><br>gcc add<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span> multi<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -o app<br> <br>add<span class="hljs-selector-class">.o</span>:add<span class="hljs-selector-class">.c</span><br>gcc -c add<span class="hljs-selector-class">.c</span> -o add<span class="hljs-selector-class">.o</span><br> <br><span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span>:<span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span><br>gcc -c <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.o</span><br> <br>multi<span class="hljs-selector-class">.o</span>:multi<span class="hljs-selector-class">.c</span><br>gcc -c multi<span class="hljs-selector-class">.c</span> -o multi<span class="hljs-selector-class">.o</span><br> <br>sub<span class="hljs-selector-class">.o</span>:sub<span class="hljs-selector-class">.c</span><br>gcc -c sub<span class="hljs-selector-class">.c</span> -o sub<span class="hljs-selector-class">.o</span><br> <br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>:<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -o <span class="hljs-selector-tag">main</span>.o<br></code></pre></td></tr></table></figure><p><strong>方式三：Makefile+变量</strong><br>知识点：<br>自定义变量：</p><ul><li>变量名&#x3D;变量值，如var&#x3D;hello<br>预定义变量：</li><li>AR : 归档维护程序的名称，默认值为 ar</li><li>CC : C 编译器的名称，默认值为 cc</li><li>CXX : C++ 编译器的名称，默认值为 g++</li><li>$@ : 目标的完整名称</li><li>$&lt; : 第一个依赖文件的名称</li><li>$^: 所有的依赖文件<br>例子：</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src=add.o div.o multi.o sub.o main.o<br>target=app<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(src)</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">add.o:add.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">div.o:div.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">multi.o:multi.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">sub.o:sub.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">main.o:main.c</span><br><span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p><strong>方式四：Makefile+模式匹配</strong><br><strong>方法五：Makefile + 函数</strong></p><h5 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h5><ul><li><code>make</code>或<code>make run</code>。使用qemu启动<code>hd.img</code>，在此命令执行前应该执行<code>make build</code>。</li><li><code>make debug</code>。启动qemu并开启gdb调试。</li><li><code>make build</code>。编译代码并写入<code>hd.img</code>。</li><li><code>make clean</code>。清除当前文件夹下以<code>.bin</code>结尾的文件。（也可以自己设置，比如.o结尾，.exe结尾的文件等等）</li></ul><p>gdb的命令也可以预先写到文件中，在启动gdb后会自动加载执行<br>比如：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">target remote:1234<br>set disassembly-flavor intel<span class="hljs-built_in"></span><br><span class="hljs-built_in">add-symbol-file </span>mbr.symbol 0x7c00<span class="hljs-built_in"></span><br><span class="hljs-built_in">add-symbol-file </span>bootloader.symbol 0x7c00<br></code></pre></td></tr></table></figure><h2 id="任务-3（选做）"><a href="#任务-3（选做）" class="headerlink" title="任务 3（选做）"></a>任务 3（选做）</h2><p>改造“Lab2-Assignment 4”为32位代码，即在保护模式后执行自定义的汇编程序。</p><p>resources：<br><a href="https://blog.csdn.net/abc123lzf/article/details/109289567">x86保护模式——全局描述符表GDT详解_gdt全局描述符表 作用-CSDN博客</a></p><h3 id="GDT介绍"><a href="#GDT介绍" class="headerlink" title="GDT介绍"></a>GDT介绍</h3><p>GDT全称：全局描述符表<br>GDT的数据结构是一个描述符数组，每个描述符8个字节，可以存放在内存当中任意位置</p><p><strong>实模式</strong>下的初始化代码，主要完成三件事：</p><ol><li>初始化段描述符</li><li>初始化GDT的基址，并存放到GDTR寄存器</li><li><strong>切换到保护模式</strong>（打开A20地址线，将CR0寄存器第0位设置为1），并跳转到负责打印字符串的代码段。</li></ol><p>现在为止学到的：<br>从MBR加载bootloader，bootloader理论上是没有字节限制的，可以占据多个扇区，并完成很多功能，然后再将控制权交给操作系统<br>运行MBR是16位实模式，运行bootloader时通过执行对应的一组指令切换到32位保护模式，才开始加载内核进入内存，并且<strong>开始执行用户程序</strong>（本task要学习实现的）。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>参照原本的bootloader代码，<br>示例代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;# 初始设置和显示信息 #</span><br><span class="hljs-meta">%include</span> <span class="hljs-string">&quot;boot.inc&quot;</span><br><span class="hljs-comment">;org 0x7e00 这里注释掉，因为会通过命令行设置起到同样作用的命令</span><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span> <span class="hljs-comment">;显存地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x03</span> <span class="hljs-comment">;青色</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, bootloader_tag_end - bootloader_tag <span class="hljs-comment">;计算要打印的字符串长度</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ebx</span> <span class="hljs-comment">;置0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, bootloader_tag <span class="hljs-comment">;将字符串移动到寄存器内（指针）</span><br><span class="hljs-symbol">output_bootloader_tag:</span> <span class="hljs-comment">;循环输出</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span>[<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">loop</span> output_bootloader_tag<br><span class="hljs-comment">;# 初始设置和显示信息 #</span><br><br><span class="hljs-comment">;# 局描述符表GDT设置 #</span><br><span class="hljs-comment">;空描述符--GDT的第一个条目必须为空</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x00</span>],<span class="hljs-number">0x00</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x04</span>],<span class="hljs-number">0x00</span>  <br><br><span class="hljs-comment">;创建描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x08</span>],<span class="hljs-number">0x0000ffff</span>    <span class="hljs-comment">; 基地址为0，段界限为0xFFFFF</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x0c</span>],<span class="hljs-number">0x00cf9200</span>    <span class="hljs-comment">; 粒度为4KB，存储器段描述符 </span><br><br><span class="hljs-comment">;建立保护模式下的堆栈段描述符      </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x10</span>],<span class="hljs-number">0x00000000</span>    <span class="hljs-comment">; 基地址为0x00000000，界限0x0 </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x14</span>],<span class="hljs-number">0x00409600</span>    <span class="hljs-comment">; 粒度为1个字节</span><br><br><span class="hljs-comment">;建立保护模式下的显存描述符   </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x18</span>],<span class="hljs-number">0x80007fff</span>    <span class="hljs-comment">; 基地址为0x000B8000，界限0x07FFF </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x1c</span>],<span class="hljs-number">0x0040920b</span>    <span class="hljs-comment">; 粒度为字节</span><br><br><span class="hljs-comment">;创建保护模式下平坦模式代码段描述符</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x20</span>],<span class="hljs-number">0x0000ffff</span>    <span class="hljs-comment">; 基地址为0，段界限为0xFFFFF</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> [GDT_START_ADDRESS+<span class="hljs-number">0x24</span>],<span class="hljs-number">0x00cf9800</span>    <span class="hljs-comment">; 粒度为4kb，代码段描述符 </span><br><br><span class="hljs-comment">;# 局描述符表GDT设置 #</span><br><br><span class="hljs-comment">;#加载GDTR并准备切换到保护模式#</span><br><span class="hljs-comment">;准备GDTR B+ 1</span><br><span class="hljs-comment">;初始化描述符表寄存器GDTR</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [pgdt], <span class="hljs-number">39</span>      <span class="hljs-comment">;描述符表的界限   </span><br><span class="hljs-keyword">lgdt</span> [pgdt] <span class="hljs-comment">;加载GDTR寄存器，告诉CPU GDT的位置和大小</span><br><span class="hljs-comment">;打开第21根地址线，B+ 2      </span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0x92</span>                         <span class="hljs-comment">;南桥芯片内的端口 </span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0000_0010B</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">0x92</span>,<span class="hljs-built_in">al</span>                        <span class="hljs-comment">;打开A20</span><br><span class="hljs-comment">;设置保护模式标志位 B+ 3</span><br><span class="hljs-keyword">cli</span>                                <span class="hljs-comment">;禁用中断，中断机制尚未工作</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">cr0</span><br><span class="hljs-keyword">or</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cr0</span>,<span class="hljs-built_in">eax</span>                        <span class="hljs-comment">;设置PE位</span><br><span class="hljs-comment">;#加载GDTR并准备切换到保护模式#   </span><br><br><span class="hljs-comment">;以下进入保护模式 B+ 4</span><br><span class="hljs-keyword">jmp</span> <span class="hljs-built_in">dword</span> CODE_SELECTOR:protect_mode_begin <span class="hljs-comment">;远跳转，同时清空CPU流水线并加载CS寄存器为代码段选择子</span><br><br><span class="hljs-comment">;16位的描述符选择子：32位偏移</span><br><span class="hljs-comment">;清流水线并串行化处理器</span><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">32</span>]           <br><span class="hljs-symbol">protect_mode_begin:</span>    <span class="hljs-comment">;进入保护模式                          </span><br><span class="hljs-comment">;保护模式下的初始化</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, DATA_SELECTOR                     <span class="hljs-comment">;加载数据段(0..4GB)选择子</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, STACK_SELECTOR<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, VIDEO_SELECTOR<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-comment">;保护模式必须通过GDT描述符来访问内存，不能直接使用段地址</span><br><span class="hljs-comment">;32位模式下使用32位寄存器(eax)而不是16位(ax)</span><br><span class="hljs-comment">;显存访问需要通过专门的显存段描述符</span><br><span class="hljs-comment">;这里开始执行自己的程序--所以我们只需要修改这部分就好了，同时要保证这部分是32位的</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, protect_mode_tag_end - protect_mode_tag<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">80</span> * <span class="hljs-number">2</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, protect_mode_tag<br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x3</span><br><span class="hljs-symbol">output_protect_mode_tag:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [<span class="hljs-built_in">esi</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span>[<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">ebx</span>], <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">loop</span> output_protect_mode_tag<br><span class="hljs-comment">;=======up======|same|======up===========</span><br><span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">; 死循环</span><br><br><span class="hljs-comment">;数据定义</span><br>pgdt <span class="hljs-built_in">dw</span> <span class="hljs-number">0</span><br>     <span class="hljs-built_in">dd</span> GDT_START_ADDRESS<br><br>bootloader_tag <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;run bootloader&#x27;</span><br><span class="hljs-symbol">bootloader_tag_end:</span><br><br>protect_mode_tag <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;enter protect mode&#x27;</span><br><span class="hljs-symbol">protect_mode_tag_end:</span><br></code></pre></td></tr></table></figure><p>my_program：前面的部分和上面基本完全一样，下面只展示我的程序部分</p><ol><li>初始化弹射字符变量–存储在内存中（<strong>保护模式下更倾向于使用内存变量而不是寄存器存储状态</strong>）</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [row], <span class="hljs-number">2</span>        <span class="hljs-comment">; 初始行位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [col], <span class="hljs-number">0</span>        <span class="hljs-comment">; 初始列位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [row_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 行方向增量 (1=向下)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [col_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 列方向增量 (1=向右)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [char_color], <span class="hljs-number">0x0A</span>  <span class="hljs-comment">; 字符颜色 (亮绿色)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> [char_value], <span class="hljs-string">&#x27;0&#x27;</span>   <span class="hljs-comment">; 显示字符</span><br></code></pre></td></tr></table></figure><p>使用：<code>mov &lt;mem&gt;, &lt;con&gt;</code>，将常数存储到&#x3D;&#x3D;内存地址row&#x3D;&#x3D;处，并通过<code>byte</code>指定操作数大小为1字节。<br>2. 边界检查</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bounce_loop:</span><br><span class="hljs-keyword"></span>    <span class="hljs-comment">; 检查上下边界</span><br>    mov al, [row]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_up </span>      <span class="hljs-comment">; 如果行 &lt;= 0，需要向下反弹</span><br>    cmp al, <span class="hljs-number">24</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_down </span>    <span class="hljs-comment">; 如果行 &gt;= 24，需要向上反弹</span><br>    <br>    <span class="hljs-comment">; 检查左右边界</span><br>    mov al, [col]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_right </span>   <span class="hljs-comment">; 如果列 &lt;= 0，需要向右反弹</span><br>    cmp al, <span class="hljs-number">79</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_left </span>    <span class="hljs-comment">; 如果列 &gt;= 79，需要向左反弹</span><br>    <br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display </span>        <span class="hljs-comment">; 通过所有边界检查，显示字符</span><br></code></pre></td></tr></table></figure><p>这里将模板内存地址中存储的值取出到寄存器内，再进行比较。其余的内容差不多。<br>3. 显存位置计算</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">movzx</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">byte</span> [row]    <span class="hljs-comment">; 获取当前行</span><br><span class="hljs-keyword">imul</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">80</span>             <span class="hljs-comment">; ebx = row * 80</span><br><span class="hljs-keyword">movzx</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">byte</span> [col]    <span class="hljs-comment">; 获取当前列</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ecx</span>             <span class="hljs-comment">; ebx = row * 80 + col</span><br><span class="hljs-keyword">shl</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">1</span>               <span class="hljs-comment">; ebx = 2 * (row * 80 + col)</span><br></code></pre></td></tr></table></figure><p>使用32位寄存器代替原本的16位寄存器。<br>4. 显存写入<br>区别是32位一次可以写入两个字节，所以我们分别对ah和al进行赋值之后，一起存储到gs中</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, [char_color]     <span class="hljs-comment">; 设置字符颜色</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [char_value]     <span class="hljs-comment">; 设置字符值</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">ebx</span>], <span class="hljs-built_in">ax</span>    <span class="hljs-comment">; 写入显存</span><br></code></pre></td></tr></table></figure><ol start="5"><li>位置更新<br>内存上的值要进行计算，需要提取到寄存器之后再计算。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [row]<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>, [row_dir]        <span class="hljs-comment">; 根据行方向增量更新行</span><br><span class="hljs-keyword">mov</span> [row], <span class="hljs-built_in">al</span><br>    <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, [col]<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>, [col_dir]        <span class="hljs-comment">; 根据列方向增量更新列</span><br><span class="hljs-keyword">mov</span> [col], <span class="hljs-built_in">al</span><br>    <br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> [char_color]    <span class="hljs-comment">; 改变颜色</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span> [char_value]    <span class="hljs-comment">; 改变字符</span><br></code></pre></td></tr></table></figure><ol start="5"><li>延时实现<br>旧的代码中我使用的是bios int15h中断功能，但是这是实模式专属的，在保护模式无法使用。因此要切换成<strong>循环计数</strong>（纯软件延时）的方式（之前在实模式尝试过这种方式，但是延时效果比较差，应该是空间不够大）</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">mov ecx, <span class="hljs-number">2000000</span>         <span class="hljs-comment">; 延时计数器</span><br><span class="hljs-symbol">delay_loop:</span><br>    <span class="hljs-keyword">nop </span>                     <span class="hljs-comment">; 空操作</span><br>    loop delay_loop          <span class="hljs-comment">; 循环直到ecx为0</span><br></code></pre></td></tr></table></figure><p>整个程序：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">; =========== 弹射字符动画 (32-bit) ===========</span><br><br><span class="hljs-comment">; 初始化弹射字符变量--存储在内存中</span><br>mov <span class="hljs-keyword">byte </span>[row], <span class="hljs-number">2</span>        <span class="hljs-comment">; 初始行位置</span><br>mov <span class="hljs-keyword">byte </span>[col], <span class="hljs-number">0</span>        <span class="hljs-comment">; 初始列位置</span><br>mov <span class="hljs-keyword">byte </span>[row_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 行方向增量 (1=向下)</span><br>mov <span class="hljs-keyword">byte </span>[col_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 列方向增量 (1=向右)</span><br>mov <span class="hljs-keyword">byte </span>[char_color], <span class="hljs-number">0x0A</span>  <span class="hljs-comment">; 字符颜色 (亮绿色)</span><br>mov <span class="hljs-keyword">byte </span>[char_value], <span class="hljs-string">&#x27;0&#x27;</span>   <span class="hljs-comment">; 显示字符</span><br><br><span class="hljs-comment">; 主弹射循环</span><br><span class="hljs-keyword">bounce_loop:</span><br><span class="hljs-keyword"></span>    <span class="hljs-comment">; 检查上下边界</span><br>    mov al, [row]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_up </span>      <span class="hljs-comment">; 如果行 &lt;= 0，需要向下反弹</span><br>    cmp al, <span class="hljs-number">24</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_down </span>    <span class="hljs-comment">; 如果行 &gt;= 24，需要向上反弹</span><br>    <br>    <span class="hljs-comment">; 检查左右边界</span><br>    mov al, [col]<br>    cmp al, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle </span><span class="hljs-keyword">bounce_right </span>   <span class="hljs-comment">; 如果列 &lt;= 0，需要向右反弹</span><br>    cmp al, <span class="hljs-number">79</span><br>    <span class="hljs-keyword">jge </span><span class="hljs-keyword">bounce_left </span>    <span class="hljs-comment">; 如果列 &gt;= 79，需要向左反弹</span><br>    <br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display </span>        <span class="hljs-comment">; 通过所有边界检查，显示字符</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_up:</span><br>    mov <span class="hljs-keyword">byte </span>[row_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 将行方向改为向下(正)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_down:</span><br>    mov <span class="hljs-keyword">byte </span>[row_dir], -<span class="hljs-number">1</span>   <span class="hljs-comment">; 将行方向改为向上(负)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_right:</span><br>    mov <span class="hljs-keyword">byte </span>[col_dir], <span class="hljs-number">1</span>    <span class="hljs-comment">; 将列方向改为向右(正)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_left:</span><br>    mov <span class="hljs-keyword">byte </span>[col_dir], -<span class="hljs-number">1</span>   <span class="hljs-comment">; 将列方向改为向左(负)</span><br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">display</span><br><span class="hljs-keyword"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">display:</span><br>    <span class="hljs-comment">; 计算显存位置</span><br>    <span class="hljs-keyword">movzx </span>ebx, <span class="hljs-keyword">byte </span>[row]    <span class="hljs-comment">; 获取当前行</span><br>    imul ebx, <span class="hljs-number">80</span>             <span class="hljs-comment">; ebx = row * 80</span><br>    <span class="hljs-keyword">movzx </span>ecx, <span class="hljs-keyword">byte </span>[col]    <span class="hljs-comment">; 获取当前列</span><br>    <span class="hljs-keyword">add </span>ebx, ecx             <span class="hljs-comment">; ebx = row * 80 + col</span><br>    <span class="hljs-keyword">shl </span>ebx, <span class="hljs-number">1</span>               <span class="hljs-comment">; ebx = 2 * (row * 80 + col)</span><br>    <br>    <span class="hljs-comment">; 显示字符</span><br>    mov ah, [char_color]     <span class="hljs-comment">; 设置字符颜色</span><br>    mov al, [char_value]     <span class="hljs-comment">; 设置字符值</span><br>    mov word [gs:ebx], ax    <span class="hljs-comment">; 写入显存</span><br>    <br>    <span class="hljs-comment">; 更新位置</span><br>    mov al, [row]<br>    <span class="hljs-keyword">add </span>al, [row_dir]        <span class="hljs-comment">; 根据行方向增量更新行</span><br>    mov [row], al<br>    <br>    mov al, [col]<br>    <span class="hljs-keyword">add </span>al, [col_dir]        <span class="hljs-comment">; 根据列方向增量更新列</span><br>    mov [col], al<br>    <br>    <span class="hljs-comment">; 更新字符外观</span><br>    inc <span class="hljs-keyword">byte </span>[char_color]    <span class="hljs-comment">; 改变颜色</span><br>    inc <span class="hljs-keyword">byte </span>[char_value]    <span class="hljs-comment">; 改变字符</span><br>    cmp <span class="hljs-keyword">byte </span>[char_value], <span class="hljs-string">&#x27;9&#x27;</span>+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">jne </span><span class="hljs-keyword">add_delay</span><br><span class="hljs-keyword"></span>    mov <span class="hljs-keyword">byte </span>[char_value], <span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-comment">; 如果超过&#x27;9&#x27;，重置为&#x27;0&#x27;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">add_delay:</span><br>    <span class="hljs-comment">; 保护模式下的延时循环</span><br>    mov ecx, <span class="hljs-number">2000000</span>         <span class="hljs-comment">; 延时计数器</span><br><span class="hljs-symbol">delay_loop:</span><br>    <span class="hljs-keyword">nop </span>                     <span class="hljs-comment">; 空操作</span><br>    loop delay_loop          <span class="hljs-comment">; 循环直到ecx为0</span><br>    <br>    <span class="hljs-keyword">jmp </span><span class="hljs-keyword">bounce_loop </span>         <span class="hljs-comment">; 继续主循环</span><br><br><span class="hljs-comment">; 保护模式下存储变量的数据区</span><br>row         db <span class="hljs-number">0</span>  <span class="hljs-comment">; 当前行位置</span><br>col         db <span class="hljs-number">0</span>  <span class="hljs-comment">; 当前列位置</span><br>row_dir     db <span class="hljs-number">0</span>  <span class="hljs-comment">; 行方向</span><br>col_dir     db <span class="hljs-number">0</span>  <span class="hljs-comment">; 列方向</span><br>char_color  db <span class="hljs-number">0</span>  <span class="hljs-comment">; 字符颜色</span><br>char_value  db <span class="hljs-number">0</span>  <span class="hljs-comment">; 字符值</span><br><br>protect_mode_tag db <span class="hljs-string">&#x27;enter protect mode&#x27;</span><br><span class="hljs-symbol">protect_mode_tag_end:</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI-Lab2</title>
    <link href="/2025/03/11/AI-lab2/"/>
    <url>/2025/03/11/AI-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>常量：任何类型的实体</p></li><li><p>变量：x,y未知量</p></li><li><p>项：谓词、变量的参数项，由递归定义</p><ul><li>变量是项（可以看成是0元函数）</li><li>t1，t2，t3……tn是项，f是n元函数，则f(t1,t2,,,,tn)也是项</li><li>一阶逻辑中<strong>谓词不是项</strong>，即不能作为函数&#x2F;谓词的参数，也就是不存在f(P(x))这种复合方式，但是二阶逻辑中是可以的</li></ul></li><li><p>谓词：谓词是对其参数的</p><ul><li>零元谓词：退化为命题</li><li>单元谓词：只有一个参数，表示参数具备某种属性</li><li>多元谓词：多个参数，表示参数之间的关系</li></ul></li><li><p>事实：谓词中变量实例化后得到的事实</p></li><li><p>规则：公式，通过递归定义</p></li><li><p>可满足性：对该可满足性问题，只要能找到一组赋值，使得这个公式成立，这个公式就是可满足的</p></li><li><p>逻辑蕴含和逻辑推论</p><ul><li>逻辑蕴含S |&#x3D; α指对于<strong>任意变量赋值</strong>，如果S正确，则α也正确</li><li>逻辑推论S |- α指<strong>存在一条推理路径</strong>，从S出发，推导证明α</li></ul></li><li><p>一阶逻辑中谓词不是项，即不能作为函数&#x2F;谓词的参数，也就是不存在f(P(x))这种复合方式，但是二阶逻辑中是可以的</p></li></ul><h2 id="归结算法"><a href="#归结算法" class="headerlink" title="归结算法"></a>归结算法</h2><h3 id="归结反演："><a href="#归结反演：" class="headerlink" title="归结反演："></a>归结反演：</h3><p>steps:</p><ol><li>将α取否定，放到KB中</li><li>将更新的KB转换为clausal form得到新的子句集S</li><li>反复调用单步归结<ul><li>如果得到空子句，即S|- ()，说明KB ∧¬α 不可满足，算法终止，可得KB |&#x3D; α</li><li>如果一直归结直到不产生新的子句，在这个过程中没有得到空子句，则KB |&#x3D; α不成立</li></ul></li></ol><p><strong>clausal form–便于计算机处理的形式</strong></p><ul><li>每一个子句对应一个<strong>元组</strong>，元组中的每一个元素是一个原子公式或原子公式的否定，元素之间的关系是<strong>析取关系</strong>，表示只要一个原子成立，即子句成立。<ul><li>ps：元组是用<strong>逗号</strong>分隔的，<u>即使只有一个元素，也需要在元素后面加上逗号</u>，以区分它与普通变量的不同</li><li>元组的集合组合子句集S，子句集中的每个句子之间是<strong>合取关系</strong></li></ul></li><li>单步归结：<ul><li>从两个子句中分贝寻找相同的原子及其对应的原子否定（只能找其中一组，如果出现两组互补对不可以同时归结）</li><li>去掉该互补对，并将剩余元素合并为新子句</li></ul></li></ul><p>举例：<img src="/img/image-20250310164756545.png" alt="example_归结"></p><h2 id="最一般合一算法"><a href="#最一般合一算法" class="headerlink" title="最一般合一算法"></a>最一般合一算法</h2><h3 id="合一"><a href="#合一" class="headerlink" title="合一"></a>合一</h3><ul><li><p>通过<strong>变量替换</strong>使得两个子句能够被归结（有相同的原子），所以合一也被定义为使得两个原子公式等价的一组变量替换&#x2F;赋值</p></li><li><p>由于一阶逻辑中存在变量，所以归结之前需要进行合一，如<code>(P(john),Q(fred),R(x))</code>和<code>(¬P(y),R(susan),R(y))</code>两个子句中，我们无法找到一样的原子及其对应的否定，但是不代表它们不能够归结</p></li><li><p>通过将y替换为john（替换一定要<strong>全部替换</strong>），我们得到了<code>(P(john),Q(fred),R(x))</code>和<code>(¬P(john),R(susan),R(john))</code>，此时我们两个子句分别存在原子P(john)和它的否定<code>¬P(john)</code>，可以进行归结</p></li></ul><h3 id="最一般合一"><a href="#最一般合一" class="headerlink" title="最一般合一"></a>最一般合一</h3><p>指使得两个原子公式等价，最简单的一组变量替换</p><ul><li>输入：两个原子公式，它们有相同的谓词，不同的参数项和‘’¬“</li><li>输出：一组变量替换&#x2F;赋值</li><li>流程：<img src="/img/image-20250310165405419.png" alt="最一般合一算法流程"></li></ul><p><strong>Tips:变量替换是从两个原子公式中找到的，但是最后要施加给整个子句的</strong></p><h2 id="一阶逻辑归结算法："><a href="#一阶逻辑归结算法：" class="headerlink" title="一阶逻辑归结算法："></a>一阶逻辑归结算法：</h2><p><img src="/img/image-20250310165631716.png" alt="一阶逻辑归结算法"></p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>存储<strong>公式</strong>的python数据结构</p><ul><li><p>用字符串存储</p></li><li><p>符号¬用‘~’代替</p></li><li><p><strong>谓词</strong>的<strong>首字母大写</strong>, 例如用A, B, C, P1, P2, Student等表示; 谓词的每个参数之间用逗号“,”间隔且不加空格</p></li><li><p><strong>常量</strong>用小写单词或a, b, c等小写字母表示;</p></li><li><p>本次作业的公式中不含∃,∀量词符号</p><ul><li><p>例子: ¬child存储为 “~child” boy存储为“boy”</p></li><li><p>几个公式: “R(a)”, “~P(a,zz)”, “Student(tony)”. 这里应该将a,tony看做常量,将zz看做变量</p></li></ul></li></ul><p>存储<strong>子句</strong>的python数据结构</p><ul><li>用tuple的方式存储<ul><li>例子: </li><li>¬child˅¬male˅boy存储为(‘<del>child’, ‘</del>male’, ‘boy’)</li><li>¬S(z) ˅ L(z, snow)存储为(‘~S(z)’, ‘L(z,snow)’)</li></ul></li></ul><p>存储<strong>子句集</strong>的python数据结构</p><ul><li><p>子句集用<strong>set</strong>（可以去重）的方式存储, 每个元素是子句(元组)</p></li><li><p>小心归结的时候重复生成一样的子句</p></li></ul><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="实验一：命题逻辑的归结推理"><a href="#实验一：命题逻辑的归结推理" class="headerlink" title="实验一：命题逻辑的归结推理"></a>实验一：命题逻辑的归结推理</h2><h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><p>编写函数<code>ResolutionProp</code>实现命题逻辑的归结推理，函数要点如下：</p><ul><li>输入为子句集, 每个子句中的元素是原子命题或其否定.</li></ul><ul><li>输出归结推理的过程, <strong>每个归结步骤存为字符串</strong>, 将所有归结步骤按序存到一个列表中并返回, 即返回的数据类型为 <code>list[str]</code>.</li><li>一个归结步骤的格式为 <code>步骤编号 R[用到的子句编号] = 子句</code>. 如果一个字句包含多个公式，则每个公式用编号 <code>a,b,c...</code>区分，如果一个字句仅包含一个公式，则不用编号区分.（见课件和例题）</li></ul><p>例子: 输入子句集</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">KB</span> = &#123;(FirstGrade,), (~FirstGrade,Child), (~Child,)&#125;<br></code></pre></td></tr></table></figure><p>则调用 <code>ResolutionProp(KB)</code>后返回推理过程的列表如下:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(FirstGrade,),<br><span class="hljs-symbol">2 </span>(~FirstGrade,Child)<br><span class="hljs-symbol">3 </span>(~Child,),<br><span class="hljs-symbol">4 </span>R[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>a] = (Child,),<br><span class="hljs-symbol">5 </span>R[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] = ()<br></code></pre></td></tr></table></figure><h3 id="ResolutionProp-函数"><a href="#ResolutionProp-函数" class="headerlink" title="ResolutionProp()函数"></a><code>ResolutionProp()</code>函数</h3><p>working on…</p><ul><li>这里我们设置了两个字典用于存储子句的编号以及子句中元素的编号，方便后续打印；同时先将基本的子句集列举出来</li><li>设置<code>processed_KB</code>用于记录已经归结过的子句，同时建立一个<code>new_KB</code>用于记录每轮新增子句，原KB用于不断更新–保存旧子句和加入新子句</li><li>在进行归结时，需要将完整子句集与新增子句集进行归结，进行归结的子句需要没被归结过–也就是不在processed_KB之中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResolutionProp</span>(<span class="hljs-params">KB</span>):<br>    steps = []<br>    k = <span class="hljs-number">1</span><br>    clause_dict = &#123;&#125;  <span class="hljs-comment"># 记录子句及其编号--同时加入新增语句</span><br>    clause_labels = &#123;&#125;  <span class="hljs-comment"># 记录子句内元素的编号</span><br>    <br>    <span class="hljs-comment"># 初始化子句编号,同时将子句集列举出来</span><br>    <span class="hljs-keyword">for</span> clause <span class="hljs-keyword">in</span> KB:<br>        clause_dict[clause] = k<br>        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> <span class="hljs-subst">&#123;clause&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clause) &gt; <span class="hljs-number">1</span>: <span class="hljs-comment">#有多个元素的子句编号a,b...</span><br>            clause_labels[clause] = &#123;ele: <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i) <span class="hljs-keyword">for</span> i, ele <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(clause)&#125; <br>        k += <span class="hljs-number">1</span><br>    <br>    clauses = <span class="hljs-built_in">list</span>(KB)<br>    processed_KB = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 记录已经归结过的子句--保证不会重复归结</span><br>    new_KB = <span class="hljs-built_in">set</span>(clauses)  <span class="hljs-comment"># 初始子句集--需要进行更新</span><br>    <br>    <span class="hljs-keyword">while</span> new_KB:<br>        current_clauses = <span class="hljs-built_in">list</span>(new_KB)  <span class="hljs-comment"># 当前需要归结的新子句--上一轮生成的语句</span><br>        new_KB.clear() <br>        <br>            <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(current_clauses)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(clauses)):  <span class="hljs-comment"># 之前的子句 + 新生成的子句</span><br>                <span class="hljs-keyword">if</span> current_clauses[i] == clauses[j]:  <span class="hljs-comment"># 避免自身归结</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> current_clauses[i] <span class="hljs-keyword">in</span> processed_KB : <span class="hljs-comment"># 这里是防止出现重复归结</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> clauses[j] <span class="hljs-keyword">in</span> processed_KB :<br>                    <span class="hljs-keyword">continue</span><br>                <br>                res, resolved_literals = resolve(current_clauses[i], clauses[j])<br>                <span class="hljs-keyword">if</span> res <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    clause1_id = <span class="hljs-built_in">str</span>(clause_dict[current_clauses[i]])<br>                    clause2_id = <span class="hljs-built_in">str</span>(clause_dict[clauses[j]])<br>                    <br>                    <span class="hljs-comment"># 处理字句编号</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(current_clauses[i]) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> resolved_literals[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> clause_labels[current_clauses[i]]:<br>                        clause1_id += clause_labels[current_clauses[i]][resolved_literals[<span class="hljs-number">0</span>]]<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clauses[j]) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> resolved_literals[<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> clause_labels[clauses[j]]:<br>                        clause2_id += clause_labels[clauses[j]][resolved_literals[<span class="hljs-number">1</span>]]<br>                    <span class="hljs-comment">#在这里把已经归结的加入</span><br>                    processed_KB.add(current_clauses[i])<br>                    processed_KB.add(clauses[j])<br>                    <br>                    <span class="hljs-keyword">if</span> res == ():<span class="hljs-comment">#空子句</span><br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>] = ()&quot;</span>)<br>                        <span class="hljs-keyword">return</span> steps<br>                    <br>                    <span class="hljs-keyword">if</span> res <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> clause_dict:<br>                        clause_dict[res] = k<br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &gt; <span class="hljs-number">1</span>:<br>                            clause_labels[res] = &#123;lit: <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i) <span class="hljs-keyword">for</span> i, lit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(res)&#125;<br>                        new_KB.add(res)<br>                        clauses.append(res)<br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>] = <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br>                        k += <span class="hljs-number">1</span><br>        <br>            <br>        <span class="hljs-comment">#clauses.extend(current_clauses)  # 将新子句加入原始子句集中</span><br><br>    <br>    <span class="hljs-keyword">return</span> steps<br></code></pre></td></tr></table></figure><h3 id="resolve-函数"><a href="#resolve-函数" class="headerlink" title="resolve()函数"></a><strong><code>resolve()</code>函数</strong></h3><p>！这个函数主要用于做<strong>单步归结</strong> ！</p><p>思路：</p><ul><li>遍历子句1中的所有元素，对每一个元素都取反，查看这个取反的元素是否在子句2中，如果存在，说明找到了一组互补对，进行归结，并返回新的子句集（合并并去掉互补对）以及互补对；如果取反的元素不在子句2中继续遍历。</li><li>如果遍历到结尾都没有找到，说明这两句无法进行归结，返回空。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">clause1, clause2</span>):<br>    <span class="hljs-keyword">for</span> literal <span class="hljs-keyword">in</span> clause1:<br>        complement = <span class="hljs-string">f&quot;~<span class="hljs-subst">&#123;literal&#125;</span>&quot;</span> <span class="hljs-keyword">if</span> literal[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;~&#x27;</span> <span class="hljs-keyword">else</span> literal[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> complement <span class="hljs-keyword">in</span> clause2:<br>            <span class="hljs-comment"># 新的子句应该去除字面量和互补字面量</span><br>            new_clause = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(clause1).union(<span class="hljs-built_in">set</span>(clause2)) - &#123;literal, complement&#125;))<br>            <br>            <span class="hljs-comment"># 如果新子句为空，返回空子句</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> new_clause:<br>                <span class="hljs-keyword">return</span> (), (literal, complement)<br>            <span class="hljs-keyword">return</span> new_clause, (literal, complement)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>其他注意点：</p><ul><li>子句是元组，但由于元组是一种不可修改的数据结构，我们需要在合并子句集的时候就去除互补对。</li></ul><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h3><p>main函数比较简单，只需要设置好子句集，然后调用<code>ResolutionProp</code>函数，再输出steps这个字符串列表就好了。可以增加一些新例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    KB = &#123;<br>        (<span class="hljs-string">&#x27;FirstGrade&#x27;</span>,), <br>        (<span class="hljs-string">&#x27;~FirstGrade&#x27;</span>, <span class="hljs-string">&#x27;Child&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~Child&#x27;</span>,)<br>    &#125;<br>    KB1=&#123;<br>        (<span class="hljs-string">&#x27;a&#x27;</span>,),<br>        (<span class="hljs-string">&#x27;b&#x27;</span>,)<br>    &#125;<br>    KB2 = &#123;<br>        (<span class="hljs-string">&#x27;A&#x27;</span>,), <br>        (<span class="hljs-string">&#x27;~A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~B&#x27;</span>,)<br>    &#125;<br>    KB3 = &#123;<br>        (<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-string">&#x27;Q&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~P&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~Q&#x27;</span>, <span class="hljs-string">&#x27;R&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~R&#x27;</span>,)<br>    &#125;<br>    KB4 = &#123;<br>        (<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~A&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~B&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>), <br>        (<span class="hljs-string">&#x27;~C&#x27;</span>, <span class="hljs-string">&#x27;~D&#x27;</span>)<br>    &#125;<br>    steps = ResolutionProp(KB)<br>    <span class="hljs-keyword">for</span> step <span class="hljs-keyword">in</span> steps:<br>        <span class="hljs-built_in">print</span>(step)<br></code></pre></td></tr></table></figure><h2 id="实验二：最一般合一算法"><a href="#实验二：最一般合一算法" class="headerlink" title="实验二：最一般合一算法"></a>实验二：最一般合一算法</h2><p>编写函数 <code>MGU</code>实现最一般合一算法. 该函数要点如下:</p><ul><li>输入为<strong>两个原子公式</strong>, 它们的<strong>谓词相同</strong>. 其数据类型为 <code>str</code>, 格式详见课件.</li><li>输出最一般合一的结果, 数据类型为 <code>dict</code>, 格式形如**{变量: 项, 变量: 项}**, 其中的变量和项均为字符串.</li><li>若不存在合一, 则返回空字典.</li></ul><p>例子:</p><p>调用 <code>MGU(&#39;P(xx,a)&#39;, &#39;P(b,yy)&#39;)</code>后返回字典 <code>&#123;&#39;xx&#39;:&#39;b&#39;, &#39;yy&#39;:&#39;a&#39;&#125;</code>.</p><p>调用 <code>MGU(&#39;P(a,xx,f(g(yy)))&#39;, &#39;P(zz,f(zz),f(uu))&#39;)</code>后返回字典 <code>&#123;&#39;zz&#39;:&#39;a&#39;, &#39;xx&#39;:&#39;f(a)&#39;, &#39;uu&#39;:&#39;g(yy)&#39;&#125;</code>.</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ol><li>只含一个元素的 <code>tuple</code>类型要在末尾加 <code>,</code>. 例如 <code>(&#39;a&#39;)</code>是错误的写法, 而正确的写法是 <code>(&#39;a&#39;,)</code>.</li><li><code>&#123;&#125;</code>会被解释成空字典. 若要定义空集合请用 <code>set()</code>.</li></ol><p>这一部分只写了一个函数（MGU）和一个辅助函数（用于判断是否含有变量）</p><h3 id="MGU-literal1-literal2"><a href="#MGU-literal1-literal2" class="headerlink" title="MGU(literal1,literal2)"></a>MGU(literal1,literal2)</h3><p>实现思路：</p><ul><li>输入：两个谓词相同的原子公式（字符串类型）；</li><li>返回&#x2F;输出：字典，格式：{变量: 项, 变量: 项}</li></ul><ol><li>首先处理原子公式，我们需要对各个位置的变量or项进行比较，在此之前，我们可以去掉谓词<code>P()</code>，然后再使用分词器<code>split</code>来将字符串分割成列表元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#其实这部分可以直接使用find()来查找第一个左括号，再使用切片</span><br>i=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(literal1)):<br>    <span class="hljs-keyword">if</span> literal1[i]!=<span class="hljs-string">&#x27;(&#x27;</span>:<br>        i+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 去掉P(),然后使用split以逗号划分项</span><br>lit1=literal1[i+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>lit2=literal2[i+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br><br><span class="hljs-comment">#不等长无法合并--特殊情况</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lit1)!=<span class="hljs-built_in">len</span>(lit2):<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><ol start="2"><li>最重要的处理部分–主要思想就是一个个元素比较，分<strong>三类</strong>：<ul><li>两个元素都是变量–无法合一，返回None</li><li>一个元素是变量，另一个是项–用项替代变量，并加入到res字典中，同时把式子中所有相同变量用项替代</li><li>两个元素都是项–分析是不是f()或f(g())这种函数嵌套的项，如果都含有f()，需要进行<strong>递归</strong>判断（递归调用<strong>MGU()</strong>）</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#遍历两个集合</span><br>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lit1)):<br>       <span class="hljs-keyword">if</span> lit1[i]==lit2[i]:<br>           <span class="hljs-keyword">continue</span><br>       <br>       <span class="hljs-keyword">if</span> lit1[i] != lit2[i]:<br>           <span class="hljs-comment"># 查看字符串里是否存在变量？如果都是变量无法合一--单独一个变量，不是项</span><br>           v1=Check_Var(lit1[i])<br>           v2=Check_Var(lit2[i])<br>           <span class="hljs-comment">#全都含有变量，无法合一</span><br>           <span class="hljs-keyword">if</span> v1 <span class="hljs-keyword">and</span> v2:<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br>           <span class="hljs-keyword">elif</span> v1 <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> v2 <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>               <span class="hljs-keyword">if</span> v1 <span class="hljs-keyword">in</span> res:<br>                   <span class="hljs-comment">#如果v1在res中已经进行了项的替换，不能再替换成其他的</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br>               <span class="hljs-comment">#v1是变量，v2是项</span><br>               res[lit1[i]]=lit2[i]<br>               <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(lit1)):<br>                   lit1[j]=lit1[j].replace(lit1[i],lit2[i])<br>                   lit2[j]=lit2[j].replace(lit1[i],lit2[i])<br>           <span class="hljs-keyword">elif</span> v2 <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> v1 <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>               <span class="hljs-keyword">if</span> v2 <span class="hljs-keyword">in</span> res:<br>                   <span class="hljs-comment">#如果v1在res中已经进行了项的替换，不能再替换成其他的</span><br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br>               <span class="hljs-comment">#v1是变量，v2是项</span><br>               res[lit2[i]]=lit1[i]<br>               <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(lit1)):<br>                   lit1[j]=lit1[j].replace(lit2[i],lit1[i])<br>                   lit2[j]=lit2[j].replace(lit2[i],lit1[i])<br>           <span class="hljs-keyword">else</span>:<br>               <span class="hljs-comment">#单独判断--可能存在嵌套的函数项</span><br>               <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">in</span> lit1[i] <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">in</span> lit2[i]:<br>                   sub_res=MGU(lit1[i],lit2[i])<br>                   <span class="hljs-keyword">if</span> sub_res <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                       <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>                   <span class="hljs-keyword">else</span>: <br>                       res.update(sub_res)<br>               <span class="hljs-keyword">else</span>:   <br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span> <br><br></code></pre></td></tr></table></figure><h3 id="Check-Var"><a href="#Check-Var" class="headerlink" title="Check_Var()"></a>Check_Var()</h3><p>很普通的一个函数，这里我只判断了是否存在x，y，z，u这几个变量，如果有更多函数符号可以添加，或者后面修改成传递变量集（but…lazy）</p><h3 id="简单测试一下："><a href="#简单测试一下：" class="headerlink" title="简单测试一下："></a>简单测试一下：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># literal1=&#x27;P(f(zz))&#x27;</span><br>    <span class="hljs-comment"># literal2=&#x27;P(f(f(u)))&#x27;</span><br>    <span class="hljs-comment"># literal1=&#x27;P(xx,a)&#x27;</span><br>    <span class="hljs-comment"># literal2=&#x27;P(b,yy)&#x27;</span><br>    <span class="hljs-comment"># literal1=&#x27;P(zz,xx)&#x27;</span><br>    <span class="hljs-comment"># literal2=&#x27;P(a,f(zz))&#x27;</span><br>    literal1=<span class="hljs-string">&#x27;P(a,xx,f(g(yy)))&#x27;</span><br>    literal2=<span class="hljs-string">&#x27;P(zz,f(zz),f(uu))&#x27;</span><br>    res=MGU(literal1,literal2)<br>    <span class="hljs-keyword">if</span> res <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> res.items():<br>            <span class="hljs-built_in">print</span>(key,<span class="hljs-string">&quot;:&quot;</span>,value)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NO MGU found&quot;</span>)<br>        <br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">zz</span> : <span class="hljs-variable">a</span><br><span class="hljs-variable">xx</span> : <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">a</span>)</span><br><span class="hljs-variable">uu</span> : <span class="hljs-function"><span class="hljs-title">g</span>(<span class="hljs-variable">yy</span>)</span><br></code></pre></td></tr></table></figure><h2 id="一阶逻辑的归结推理"><a href="#一阶逻辑的归结推理" class="headerlink" title="一阶逻辑的归结推理"></a>一阶逻辑的归结推理</h2><p>编写函数 <code>ResolutionFOL</code>实现一阶逻辑的归结推理. 该函数要点如下:</p><ul><li>输入为子句集, <code>KB</code>子句中的<strong>每个元素是一阶逻辑公式</strong>(不含全称量词和存在量词等量词符号)</li><li>输出归结推理的过程, 每个归结步骤存为字符串, 将所有归结步骤按序存到一个列表中并返回, 即<strong>返回的数据类型</strong>为 <code>list[str]</code></li><li>一个归结步骤的格式为 <code>步骤编号 R[用到的子句编号]&#123;最一般合一&#125; = 子句</code>, 其中最一般合一输出格式为”{变量&#x3D;常量, 变量&#x3D;常量}”.如果一个字句包含多个公式，则每个公式用编号 <code>a,b,c...</code>区分，如果一个字句仅包含一个公式，则不用编号区分。</li></ul><p>例题: 输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">KB = &#123;(<span class="hljs-built_in">GradStudent</span>(sue),),(~<span class="hljs-built_in">GradStudent</span>(<span class="hljs-attribute">x</span>),<span class="hljs-built_in">Student</span>(x)),(~<span class="hljs-built_in">Student</span>(x),<span class="hljs-built_in">HardWorker</span>(x)),(~<span class="hljs-built_in">HardWorker</span>(sue),)&#125;<br></code></pre></td></tr></table></figure><p>则调用 <code>ResolutionFOL(KB)</code>后返回推理过程的列表如下:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(GradStudent(sue),)<br><span class="hljs-symbol">2 </span>(~GradStudent(x),Student(x))<br><span class="hljs-symbol">3 </span>(~Student(x),HardWorker(x))<br><span class="hljs-symbol">4 </span>(~HardWorker(sue),)<br><span class="hljs-symbol">5 </span>R[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>a]&#123;x=sue&#125; = (Student(sue),)<br><span class="hljs-symbol">6 </span>R[<span class="hljs-number">3</span>a,<span class="hljs-number">5</span>]&#123;x=sue&#125; = (HardWorker(sue),)<br><span class="hljs-symbol">7 </span>R[<span class="hljs-number">4</span>,<span class="hljs-number">6</span>] = []<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">KB = &#123;(<span class="hljs-built_in">A</span>(tony),),(<span class="hljs-built_in">A</span>(mike),),(<span class="hljs-built_in">A</span>(john),),(<span class="hljs-built_in">L</span>(tony,rain),),(<span class="hljs-built_in">L</span>(tony,snow),),(~<span class="hljs-built_in">A</span>(<span class="hljs-attribute">x</span>),<span class="hljs-built_in">S</span>(x),<span class="hljs-built_in">C</span>(x)),(~<span class="hljs-built_in">C</span>(y),~<span class="hljs-built_in">L</span>(y,rain)),(<span class="hljs-built_in">L</span>(z,snow),~<span class="hljs-built_in">S</span>(z)),(~<span class="hljs-built_in">L</span>(tony,u),~<span class="hljs-built_in">L</span>(mike,u)),(<span class="hljs-built_in">L</span>(tony,v),<span class="hljs-built_in">L</span>(mike,v)),(~<span class="hljs-built_in">A</span>(w),~<span class="hljs-built_in">C</span>(w),<span class="hljs-built_in">S</span>(w))&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(A(tony),)<br><span class="hljs-symbol">2 </span>(A(mike),)<br><span class="hljs-symbol">3 </span>(A(john),)<br><span class="hljs-symbol">4 </span>(L(tony,rain),)<br><span class="hljs-symbol">5 </span>(L(tony,snow),)<br><span class="hljs-symbol">6 </span>(~A(x),S(x),C(x))<br><span class="hljs-symbol">7 </span>(~C(y),~L(y,rain))<br><span class="hljs-symbol">8 </span>(L(z,snow),~S(z))<br><span class="hljs-symbol">9 </span>(~L(tony,u),~L(mike,u))<br><span class="hljs-symbol">10 </span>(L(tony,v),L(mike,v))<br><span class="hljs-symbol">11 </span>(~A(w),~C(w),S(w))<br><span class="hljs-symbol">12 </span>R[<span class="hljs-number">2</span>,<span class="hljs-number">11</span>a]&#123;w=mike&#125; = (S(mike),~C(mike))<br><span class="hljs-symbol">13 </span>R[<span class="hljs-number">5</span>,<span class="hljs-number">9</span>a]&#123;u=snow&#125; = (~L(mike,snow),)<br><span class="hljs-symbol">14 </span>R[<span class="hljs-number">6</span>c,<span class="hljs-number">12</span>b]&#123;x=mike&#125; = (S(mike),~A(mike),S(mike))<br><span class="hljs-symbol">15 </span>R[<span class="hljs-number">2</span>,<span class="hljs-number">14</span>b] = (S(mike),)<br><span class="hljs-symbol">16 </span>R[<span class="hljs-number">8</span>b,<span class="hljs-number">15</span>]&#123;z=mike&#125; = (L(mike,snow),)<br><span class="hljs-symbol">17 </span>R[<span class="hljs-number">13</span>,<span class="hljs-number">16</span>] = []<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">KB</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">On</span><span class="hljs-punctuation">(</span><span class="hljs-variable">tony</span><span class="hljs-operator">,</span><span class="hljs-variable">mike</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">On</span><span class="hljs-punctuation">(</span><span class="hljs-variable">mike</span><span class="hljs-operator">,</span><span class="hljs-variable">john</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">tony</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-operator">~</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">john</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-punctuation">(</span><span class="hljs-operator">~</span><span class="hljs-built_in">On</span><span class="hljs-punctuation">(</span><span class="hljs-variable">xx</span><span class="hljs-operator">,</span><span class="hljs-variable">yy</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,~</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">xx</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-built_in">Green</span><span class="hljs-punctuation">(</span><span class="hljs-variable">yy</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>(<span class="hljs-keyword">On</span>(tony,mike),),<br><span class="hljs-symbol">2 </span>(<span class="hljs-keyword">On</span>(mike,john),),<br><span class="hljs-symbol">3 </span>(Green(tony),),<br><span class="hljs-symbol">4 </span>(~Green(john),),<br><span class="hljs-symbol">5 </span>(~<span class="hljs-keyword">On</span>(xx,yy),~Green(xx),Green(yy)),<br><span class="hljs-symbol">6 </span>R[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>c]&#123;yy=john&#125; = (~<span class="hljs-keyword">On</span>(xx,john),~Green(xx)),<br><span class="hljs-symbol">7 </span>R[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>b]&#123;xx=tony&#125; = (~<span class="hljs-keyword">On</span>(tony,yy),Green(yy)),<br><span class="hljs-symbol">8 </span>R[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>a]&#123;xx=mike&#125; = (~Green(mike),),<br><span class="hljs-symbol">9 </span>R[<span class="hljs-number">1</span>,<span class="hljs-number">7</span>a]&#123;yy=mike&#125; = (Green(mike),),<br><span class="hljs-symbol">10 </span>R[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] = ()<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>只含一个元素的 <code>tuple</code>类型要在末尾加 <code>,</code>. 例如 <code>(&#39;x&#39;)</code>是错误的写法, 而正确的写法是 <code>(&#39;x&#39;,)</code>.</li><li><code>&#123;&#125;</code>会被解释成空字典. 若要定义空集合请用 <code>set()</code>.</li><li>请提交代码时只提交一个 <code>.py</code>代码文件, 请不要提交其他文件.</li><li>例题和作业都会进行代码测试.</li><li>上述作业的输出仅供参考。如果有不同的归结顺序，结果相同的情况，代码也算正确.</li></ol><p><img src="/img/image-20250310165631716.png" alt="一阶逻辑归结算法"></p><h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><blockquote><p>参考以及复用大部分前两个任务的代码来构建</p></blockquote><h4 id="ResolutionFOL-："><a href="#ResolutionFOL-：" class="headerlink" title="ResolutionFOL()："></a><code>ResolutionFOL()</code>：</h4><p>算法思路：</p><ul><li>将KB库以子句集的方式传入到函数中进行归结处理</li><li>对子句集反复进行单步归结，同时使用MGU算法进行合一处理</li></ul><p>具体：</p><ul><li><p>同上面的归结算法，由于输出时需要有美观的编号，我们设置了两个记录字典–<code>clause_dict</code>和<code>clause_labels</code>，前者记录子句的编号，后者记录子句中元素的编号（有多个元素的子句才需要）</p></li><li><p>类似地，先将子句集的子句进行编号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">k = <span class="hljs-number">1</span><br>clause_dict = &#123;&#125;  <span class="hljs-comment"># 记录子句及其编号--同时加入新增语句</span><br>clause_labels = &#123;&#125;  <span class="hljs-comment"># 记录子句内元素的编号</span><br><br><span class="hljs-comment"># 初始化子句编号,同时将子句集列举出来</span><br><span class="hljs-keyword">for</span> clause <span class="hljs-keyword">in</span> KB:<br>    clause_dict[clause] = k<br>    clause_str = format_clause(clause)<br>    steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> <span class="hljs-subst">&#123;clause_str&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clause) &gt; <span class="hljs-number">1</span>:<span class="hljs-comment">#有多个元素的子句编号a,b...</span><br>        clause_labels[clause] = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i, literal <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(clause):<br>            clause_labels[clause][literal] = <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i)  <br>        k += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>进入归结的主要步骤，需要维持一个已经归结的子句对的集合–保证子句对不会重复归结（这部分和上面的归结算法有点出入，前者只需要保证我归结过的句子不用再出现就可以了），但是由于我们可以对谓词P(x)赋不同的值，所以可以对他赋值后产生的新子句再次归结。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ResolutionFOL</span>(<span class="hljs-params">KB</span>):<br>    steps = []<br>    k = <span class="hljs-number">1</span><br>    clause_dict = &#123;&#125;  <span class="hljs-comment"># 记录子句及其编号--同时加入新增语句</span><br>    clause_labels = &#123;&#125;  <span class="hljs-comment"># 记录子句内元素的编号</span><br>    <br>    <span class="hljs-comment"># 初始化子句编号,同时将子句集列举出来</span><br>    <span class="hljs-keyword">for</span> clause <span class="hljs-keyword">in</span> KB:<br>        clause_dict[clause] = k<br>        clause_str = format_clause(clause)<br>        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> <span class="hljs-subst">&#123;clause_str&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(clause) &gt; <span class="hljs-number">1</span>:<span class="hljs-comment">#有多个元素的子句编号a,b...</span><br>            clause_labels[clause] = &#123;&#125;<br>            <span class="hljs-keyword">for</span> i, literal <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(clause):<br>                clause_labels[clause][literal] = <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + i)  <br>        k += <span class="hljs-number">1</span><br>    <br>    original_size = k - <span class="hljs-number">1</span>  <span class="hljs-comment"># 记录原始子句集的大小</span><br>    <span class="hljs-comment">#原始子句集</span><br>    clauses = <span class="hljs-built_in">list</span>(KB)<br>    <span class="hljs-comment"># 记录已经归结过的子句--保证不会重复归结（但问题是一阶逻辑是可以多次为量词赋值的，所有我们记录的不是归结过的单个子句，而是子句对）</span><br>    processed = <span class="hljs-built_in">set</span>()   <br>   <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_resolvents = []<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(clauses)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(clauses)):<br>                <span class="hljs-keyword">if</span> clauses[i] == clauses[j]:  <span class="hljs-comment"># 避免自身归结</span><br>                    <span class="hljs-keyword">continue</span><br>                c1 = clauses[i]<br>                c2 = clauses[j]<br>                <br>                <span class="hljs-keyword">if</span> (c1, c2) <span class="hljs-keyword">in</span> processed:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-comment">#这里加入子句对</span><br>                processed.add((c1, c2))<br>                processed.add((c2, c1))<br>                <br>                resolvents = resolve(c1, c2)<br>                <br>                <span class="hljs-keyword">for</span> resolvent_info <span class="hljs-keyword">in</span> resolvents:<br>                    <span class="hljs-comment">#由于输出需要含有合一替换，所以resolve函数有一些变化</span><br>                    resolvent, lit1, lit2, mgu = resolvent_info<br>                    <br>                    <span class="hljs-comment"># 编号</span><br>                    clause1_id = <span class="hljs-built_in">str</span>(clause_dict[c1])<br>                    clause2_id = <span class="hljs-built_in">str</span>(clause_dict[c2])<br>                    <br>                    <span class="hljs-comment"># 处理元素的编号</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c1) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> lit1 <span class="hljs-keyword">in</span> clause_labels.get(c1, &#123;&#125;):<br>                        clause1_id += clause_labels[c1][lit1]<br>                    <br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c2) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> lit2 <span class="hljs-keyword">in</span> clause_labels.get(c2, &#123;&#125;):<br>                        clause2_id += clause_labels[c2][lit2]<br>                    <br>                    <span class="hljs-comment">#MGU调用</span><br>                    mgu_str = format_mgu(mgu)<br>                    <br>                    <span class="hljs-comment"># 查看是否产生了空集</span><br>                    <span class="hljs-keyword">if</span> resolvent == ():<br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>]<span class="hljs-subst">&#123;mgu_str&#125;</span> = ()&quot;</span>)<br>                        <span class="hljs-comment"># 找到空子句，简化归结过程</span><br>                        simplified_steps = Simplify(steps, original_size)<br>                        <span class="hljs-keyword">return</span> simplified_steps<br>                    <br>                    <span class="hljs-comment"># 将新的子句加入子句集</span><br>                    <span class="hljs-keyword">if</span> resolvent <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> clause_dict:<br>                        clause_dict[resolvent] = k<br>                        <br>                        <span class="hljs-comment"># 编号</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(resolvent) &gt; <span class="hljs-number">1</span>:<br>                            clause_labels[resolvent] = &#123;&#125;<br>                            <span class="hljs-keyword">for</span> idx, lit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(resolvent):<br>                                clause_labels[resolvent][lit] = <span class="hljs-built_in">chr</span>(<span class="hljs-number">97</span> + idx)<br>                        <br>                        resolvent_str = format_clause(resolvent)<br>                        steps.append(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;k&#125;</span> R[<span class="hljs-subst">&#123;clause1_id&#125;</span>,<span class="hljs-subst">&#123;clause2_id&#125;</span>]<span class="hljs-subst">&#123;mgu_str&#125;</span> = <span class="hljs-subst">&#123;resolvent_str&#125;</span>&quot;</span>)<br>                        new_resolvents.append(resolvent)<br>                        k += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment">#不产生新子句，返回结果</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> new_resolvents:<br>            <span class="hljs-keyword">return</span> steps<br>        <br>        <span class="hljs-comment"># 扩展旧子句集</span><br>        clauses.extend(new_resolvents)<br></code></pre></td></tr></table></figure><h4 id="extract-parents"><a href="#extract-parents" class="headerlink" title="extract_parents()"></a><code>extract_parents()</code></h4><p>用于从归结步骤中提取父子句编号，用于筛选出真正有用的归结步骤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_parents</span>(<span class="hljs-params">step</span>):<br>    <span class="hljs-comment">#从归结步骤中提取父子句编号</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;R[&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> step:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-comment"># 提取R[]内的内容</span><br>    relation_part = step[step.index(<span class="hljs-string">&quot;R[&quot;</span>) + <span class="hljs-number">2</span>:step.index(<span class="hljs-string">&quot;]&quot;</span>)]<br>    parents = relation_part.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 提取数字部分</span><br>    parent1 = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> c.isdigit()))<br>    parent2 = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> c.isdigit()))<br>    <br>    <span class="hljs-comment"># 提取字母后缀</span><br>    parent1_suffix = <span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> c.isalpha())<br>    parent2_suffix = <span class="hljs-string">&#x27;&#x27;</span>.join(c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> parents[<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> c.isalpha())<br>    <br>    <span class="hljs-keyword">return</span> parent1, parent2, parent1_suffix, parent2_suffix<br></code></pre></td></tr></table></figure><h4 id="get-step-number-step"><a href="#get-step-number-step" class="headerlink" title="get_step_number(step)"></a><code>get_step_number(step)</code></h4><p>获取编号，把step的第一个标号提取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_step_number</span>(<span class="hljs-params">step</span>): <span class="hljs-comment">#获取编号</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(step.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="Simplify-steps-original-size"><a href="#Simplify-steps-original-size" class="headerlink" title="Simplify(steps, original_size)"></a><strong>Simplify</strong>(steps, original_size)</h4><p>简化归结过程–把又臭又长的过程删减成有用的过程</p><ul><li>记录初始子句集（也就是KB库转换的最初的子句集）</li><li>同时建立一个存储有用子句的集合</li><li>在旧的step的基础上进行筛选，同时创建新的编号，创建num2idx字典，用于存储编号到索引的映射</li><li>为了简化过程，我们是从空子句开始回溯，找到能得到空子句的核心步骤。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Simplify</span>(<span class="hljs-params">steps, original_size</span>): <span class="hljs-comment">#简化归结过程--把又臭又长的过程删减成有用的过程</span><br>    base_process = steps[<span class="hljs-number">0</span>:original_size]  <span class="hljs-comment"># 初始子句集</span><br>    useful_steps = []  <span class="hljs-comment"># 有用子句集</span><br>    <br>    <span class="hljs-comment"># 创建编号到索引的映射</span><br>    number_to_index = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i, step <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(steps):<br>        number = get_step_number(step)<br>        number_to_index[number] = i<br>    <br>    <span class="hljs-comment"># 从空子句开始，队列中存放需要处理的子句编号</span><br>    number = [get_step_number(steps[-<span class="hljs-number">1</span>])]  <span class="hljs-comment"># 空子句的编号</span><br>    processed = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 已处理的子句编号</span><br>    <br>    <span class="hljs-keyword">while</span> number:<br>        number0 = number.pop(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 提取队列首元素</span><br>        <span class="hljs-keyword">if</span> number0 <span class="hljs-keyword">in</span> processed:  <span class="hljs-comment"># 避免处理已处理的子句</span><br>            <span class="hljs-keyword">continue</span><br>            <br>        processed.add(number0)<br>        step_index = number_to_index[number0]<br>        step = steps[step_index]<br>        <br>        <span class="hljs-keyword">if</span> step_index &gt;= original_size:  <span class="hljs-comment"># 非原始子句才加入useful_steps</span><br>            useful_steps.append(step)<br>            <br>        <span class="hljs-comment"># 获取父子句编号</span><br>        parent_info = extract_parents(step)<br>        <span class="hljs-keyword">if</span> parent_info[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            num1, num2 = parent_info[<span class="hljs-number">0</span>], parent_info[<span class="hljs-number">1</span>]<br>            <br>            <span class="hljs-comment"># 如果不是初始子句，加入队列</span><br>            <span class="hljs-keyword">if</span> num1 &gt; original_size <span class="hljs-keyword">and</span> num1 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> processed:<br>                number.append(num1)<br>            <span class="hljs-keyword">if</span> num2 &gt; original_size <span class="hljs-keyword">and</span> num2 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> processed:<br>                number.append(num2)<br>    <br>    <span class="hljs-comment"># 结果需要反转--回溯</span><br>    useful_steps.reverse()<br>    <br>    <span class="hljs-comment"># 得到新的归结过程：原始子句 + 有用子句</span><br>    final_steps = base_process + useful_steps<br>    <br>    <span class="hljs-comment"># 创建新旧编号的映射</span><br>    old_to_new = &#123;&#125;<br>    <span class="hljs-keyword">for</span> i, step <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(final_steps):<br>        old_num = get_step_number(step)<br>        new_num = i + <span class="hljs-number">1</span><br>        old_to_new[old_num] = new_num<br>    <br>    <span class="hljs-comment"># 将归结过程重新编号</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(original_size, <span class="hljs-built_in">len</span>(final_steps)):<br>        step = final_steps[i]<br>        parent_info = extract_parents(step)<br>        <br>        <span class="hljs-keyword">if</span> parent_info[<span class="hljs-number">0</span>] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            old_num1, old_num2 = parent_info[<span class="hljs-number">0</span>], parent_info[<span class="hljs-number">1</span>]<br>            suffix1, suffix2 = parent_info[<span class="hljs-number">2</span>], parent_info[<span class="hljs-number">3</span>]<br>            <br>            <span class="hljs-comment"># 获取新编号</span><br>            new_num1 = old_to_new[old_num1]<br>            new_num2 = old_to_new[old_num2]<br>            <br>            <span class="hljs-comment"># 构造新的引用字符串</span><br>            old_ref = <span class="hljs-string">f&quot;R[<span class="hljs-subst">&#123;old_num1&#125;</span><span class="hljs-subst">&#123;suffix1&#125;</span>,<span class="hljs-subst">&#123;old_num2&#125;</span><span class="hljs-subst">&#123;suffix2&#125;</span>]&quot;</span><br>            new_ref = <span class="hljs-string">f&quot;R[<span class="hljs-subst">&#123;new_num1&#125;</span><span class="hljs-subst">&#123;suffix1&#125;</span>,<span class="hljs-subst">&#123;new_num2&#125;</span><span class="hljs-subst">&#123;suffix2&#125;</span>]&quot;</span><br>            <br>            <span class="hljs-comment"># 替换引用</span><br>            final_steps[i] = final_steps[i].replace(old_ref, new_ref)<br>        <br>        <span class="hljs-comment"># 更新步骤编号</span><br>        old_step_num = get_step_number(final_steps[i])<br>        new_step_num = i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> old_step_num != new_step_num:<br>            final_steps[i] = <span class="hljs-built_in">str</span>(new_step_num) + final_steps[i][<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(old_step_num)):]<br>    <br>    <span class="hljs-keyword">return</span> final_steps<br><br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cs50-Ai-Machine-Learning</title>
    <link href="/2025/03/06/cs50-ai-Machine-Learning/"/>
    <url>/2025/03/06/cs50-ai-Machine-Learning/</url>
    
    <content type="html"><![CDATA[<h1 id="Machine-Learning"><a href="#Machine-Learning" class="headerlink" title="Machine Learning"></a>Machine Learning</h1><ul><li>机器学习为计算机提供数据，而非确切的指令，通过这些数据，计算机学习去识别模式并自行执行</li></ul><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><ul><li>监督学习是指计算机<strong>基于输入-输出对数据集</strong>来学习函数映射。</li><li>监督意味着这些数据已经有了确切的标签or分类</li></ul><h3 id="分类学习：最近邻居分类"><a href="#分类学习：最近邻居分类" class="headerlink" title="分类学习：最近邻居分类"></a>分类学习：最近邻居分类</h3><ul><li>为相关变量分配<strong>最近的观察值</strong></li></ul><p><img src="/img/nearestneighbor.png" alt="Nearest Neighbor Classification"></p><p>比如这张图，根据最近观察值策略，可能会认为他是红色的；然而从更大角度来看，它周围蓝色点居多，我们直觉地认为，蓝色可能是更好的预测，即时最近的观察值是红色的（局限性or不准确）</p><ul><li>优化：k最近邻居分类，根据点最近的k个邻居的值来判断。缺点是需要消耗计算力去测量各个点到相关点的距离。（进一步可以通过剪枝或更符合的数据结构加速）<ul><li><strong>选择k值</strong>：k是一个超参数，表示需要考虑的最近邻居的数量。k的选择会影响模型的性能：<ul><li>如果k太小，模型可能会过拟合，对噪声敏感。</li><li>如果k太大，模型可能会欠拟合，忽略数据的局部特征。</li></ul></li></ul></li></ul><h3 id="感知器学习"><a href="#感知器学习" class="headerlink" title="感知器学习"></a>感知器学习</h3><ul><li>神经网络：由一个或多个神经元组成，而一个神经元包含输入、输出和内部处理器</li><li>感知器（perceptron）：单层感知器（包含输入和输出层，且二者直接相连）、多层感知器（多层计算）</li><li>与最近邻策略相反，解决分类问题的另一种方法是将数据作为一个整体来查看，并尝试创建一个<strong>决策边界</strong>–二分类的线性分类模型</li></ul><p><img src="/img/decisionboundary.png" alt="Decision Boundary"></p><p>缺点：数据很混乱，很少能画一条线并将类整齐地划分为两个观测值而没有任何错误。</p><p>将各个参数与对应的权重相乘之后相加，输入到激活函数，通过判断是否超过阈值得到期望。</p><p>例子：</p><ul><li>输入–x1&#x3D;humidity（湿度）；x2&#x3D;pressure（压力）；函数h(x1,x2)</li><li>该函数对每个输入进行加权，并添加一个常数，产生如下的线性方程： <ul><li>Rain w₀ + w₁x₁ + w₂x₂ ≥ 0</li><li>No Rain otherwise</li></ul></li></ul><p><img src="/img/perceptronlearning.png" alt="Perceptron Learning Rule"></p><p>这里的y代表观测值，而h(x)代表估计值，如果他们误差较大，说明要调整这个数据的权重</p><ul><li><p>如果它们<strong>相同</strong>，则整个项等于零，因此<strong>权重不会改变</strong>。如果我们低估了（在观察到 Rain 时调用 No Rain），那么括号中的值将为 1，权重将增加新的值α学习系数。如果我们高估（在观察到 No Rain 时调用 Rain），则括号中的值将为 -1，权重将减少 x 的值，缩放 α。α越高，每个新事件对权重的影响就越大。</p></li><li><p>结果是一个阈值函数，一旦超过设定的值函数值就会发生跳跃</p><ul><li>硬性阈值<img src="/img/hardthreshold.png" alt="Hard Threshold"></li><li>软性阈值    <img src="/img/softthreshold.png" alt="软阈值"></li></ul></li></ul><p>​软性阈值会存在中间过渡的值</p><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>这种方法是在决策边界附件使用一个<strong>额外的向量</strong>（支持向量），以便在分离数据时做出最佳决策–<strong>Maximum Margin Separator</strong></p><p>优点：可以表示两个维度以上的决策边界，以及非线性决策边界</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>回归是函数的监督学习任务，它将输入点映射到连续值。</p><p>目标不是在观察类型之间进行分离，而是根据输入预测输出的值</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><h4 id="0-1损失函数"><a href="#0-1损失函数" class="headerlink" title="0-1损失函数"></a>0-1损失函数</h4><ul><li>L(预测，损失)：当实际&#x3D;预测，则L&#x3D;0；否则，L&#x3D;1</li></ul><p><img src="/img/01loss.png" alt="0-1 Loss Function"></p><ul><li>预测连续值时，可以使用L1和L2损失函数，更加看重每个预测域观测值之间的差异程度。<ul><li>L1：L(实际，预测)&#x3D;|实际-预测|</li><li>L2：L(实际，预测）&#x3D;|实际-预测|²</li></ul></li></ul><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>过拟合是指模型与训练数据的你和非常好，以至于无法推广到其他数据集。</p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化是惩罚更复杂的假设以支持更简单、更一般的假设的过程。我们使用正则化来避免过拟合。</p><p><code>cost(h) = loss(h) + λcomplexity(h)</code></p><p>测试我们是否过度拟合模型的一种方法是使用 <strong>Holdout Cross Validation</strong>。在这种技术中，我们将所有数据一分为二：<strong>训练集</strong>和测试<strong>集</strong>。我们在训练集上运行学习算法，然后查看它对测试集中数据的预测能力如何。这里的想法是，通过测试训练中未使用的数据，我们可以衡量学习的泛化程度。</p><p>保持交叉验证的缺点是，我们无法使用一半的数据来训练模型，因为它用于评估目的。解决这个问题的一种方法是使用 <strong>k-Fold\ 交叉验证</strong>。在这个过程中，我们将数据分成 k 个集合。我们运行训练 k 次，每次都省略一个数据集并将其用作测试集。我们最终对模型进行了 k 种不同的评估，我们可以对模型进行平均并估计我们的模型如何泛化而不会丢失任何数据。</p><h3 id="强度学习"><a href="#强度学习" class="headerlink" title="强度学习"></a>强度学习</h3><p>在每次行动过后，agent会得到反馈（正反馈或负反馈</p><p><img src="/img/reinforcement.png" alt="Reinforcement Learning"></p><h3 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h3><ul><li>Set of states <strong>S</strong></li><li>Set of actions <strong>Actions(S)</strong></li><li>Transition model <strong>P(s’ | s, a)</strong></li><li>Reward function <strong>R(s, a, s’)</strong></li></ul><h3 id="Q学习"><a href="#Q学习" class="headerlink" title="Q学习"></a>Q学习</h3><p>函数 Q(s, a) 输出在状态 <em>s</em> 下采取行动 <em>a</em> 的值的估计值</p><p>模型从所有估计值等于0开始，当执行作并收到奖励时，该函数会执行两项作：</p><p>1） 它根据当前奖励和预期的未来奖励估计 <strong>Q（s， a）</strong> 的值，以及</p><p> 2） 更新 <strong>Q（s， a）</strong> 以同时考虑旧估计值和新估计值。</p><p><img src="/img/qlearning.png" alt="Q 学习公式"></p><p>训练强化学习模型的另一种方法是，不是在每次移动时提供反馈，而是在整个过程结束时提供反馈</p><h2 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h2><ul><li>没有人为进行分类，只有输入数据，AI会学习这些数据中的模式</li></ul><p>聚类：</p><p>获取输入数据并将其组织成组，以便相似的对象最终属于同一组</p><p>K-means聚集</p><p>它映射一个空间中的所有数据点，然后在空间中随机放置 k 个集群中心（由程序员决定多少个，这是我们在左侧看到的起始状态）。每个集群中心只是空间中的一个点。然后，每个聚类都会分配最接近其中心的所有点，而不是任何其他中心（这是中间的图片）。然后，在迭代过程中，聚类中心移动到所有这些点的中间（右侧的状态），然后再次将点重新分配给现在最靠近它们的聚类。当重复该过程后，每个点都保持在与之前相同的集群中时，我们已经达到了平衡，算法结束了，给我们留下了在集群之间划分的点。</p><h1 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h1><h2 id="shopping"><a href="#shopping" class="headerlink" title="shopping"></a>shopping</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当用户在线购物时，并非所有人最终都会购买东西。事实上，在线购物网站的大多数访问者可能不会在网络浏览会话期间进行购买。不过，购物网站能够预测用户是否打算进行购买可能很有用：也许向用户显示不同的内容，例如，如果网站认为用户不打算完成购买，则向用户显示折扣优惠。网站如何确定用户的购买意向？这就是机器学习的用武之地。</p><p>您在此问题中的任务是构建一个最近邻分类器来解决此问题。给定有关用户的信息 — 他们访问了多少个页面，他们是否在周末购物，他们正在使用什么 Web 浏览器等 — 您的分类器将预测用户是否会进行购买。您的分类器不会完全准确 — 完美地模拟人类行为是一项远远超出本课程范围的任务 — 但它应该比随机猜测要好。为了训练您的分类器，我们将为您提供来自某个购物网站的一些数据，这些数据来自大约 12000 个用户会话。</p><p>我们如何衡量此类系统的准确性？如果我们有一个测试数据集，我们可以对数据运行分类器，并计算我们正确分类用户意图的时间比例。这将为我们提供一个准确率。但这个数字可能有点误导。例如，想象一下，如果大约 15% 的用户最终完成了购买。如果分类器始终预测用户不会完成购买，那么，我们将衡量为 85% 的准确率：它唯一错误分类的用户是 15% 的用户。虽然 85% 的准确率听起来不错，但这似乎不是一个非常有用的分类器。</p><p>相反，我们将测量两个值：灵敏度（也称为“真阳性率”）和特异性（也称为“真阴性率”）。敏感度是指正确识别的正面示例的比例：换句话说，正确识别完成购买的用户比例。特异性是指被正确识别的负面示例的比例：在这种情况下，未完成购买但被正确识别的用户比例。因此，我们之前的 “always guess no” 分类器将具有完美的特异性 （1.0），但没有灵敏度 （0.0）。我们的目标是构建一个在这两个指标上都执行合理的分类器。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ul><li><p>shopping.csv文件中是数据集</p><ul><li>前六列衡量了用户在会话中访问的不同类型页面</li><li><code>Administrative</code>、<code>Informational</code>、<code>ProductRelated</code>列指示下的值代表用户访问过多少这类型的页面</li><li><code>_Duration</code>列指示了用户留存时间</li><li><code>BounceRates</code>，<code>ExitRates</code>和<code>PageValues</code>衡量来自谷歌评估的有关用户访问的页面信息</li><li><code>SpecialDay</code>评估了用户访问日期和特殊日期的接近程度</li><li>还有一些有关用户的属性</li><li><code>VisitorType</code>指示了是回头客或新用户</li><li><code>Weekend</code>是布尔值，代表是否在周末进行访问</li><li>最后还有一个指示用户是否购买的列 <code>Revenue</code></li></ul></li><li><p>shopping.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    <span class="hljs-comment"># Check command-line arguments</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">2</span>:<br>        sys.exit(<span class="hljs-string">&quot;Usage: python shopping.py data&quot;</span>)<br><br>    <span class="hljs-comment"># Load data from spreadsheet and split into train and test sets</span><br>    evidence, labels = load_data(sys.argv[<span class="hljs-number">1</span>])<br>    X_train, X_test, y_train, y_test = train_test_split(<br>        evidence, labels, test_size=TEST_SIZE<br>    )<br><br>    <span class="hljs-comment"># Train model and make predictions</span><br>    model = train_model(X_train, y_train)<br>    predictions = model.predict(X_test)<br>    sensitivity, specificity = evaluate(y_test, predictions)<br><br>    <span class="hljs-comment"># Print results</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Correct: <span class="hljs-subst">&#123;(y_test == predictions).<span class="hljs-built_in">sum</span>()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Incorrect: <span class="hljs-subst">&#123;(y_test != predictions).<span class="hljs-built_in">sum</span>()&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;True Positive Rate: <span class="hljs-subst">&#123;<span class="hljs-number">100</span> * sensitivity:<span class="hljs-number">.2</span>f&#125;</span>%&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;True Negative Rate: <span class="hljs-subst">&#123;<span class="hljs-number">100</span> * specificity:<span class="hljs-number">.2</span>f&#125;</span>%&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>load_data</code>函数用来加载数据和分割数据</p><p><code>train_model</code>函数是用来训练的，会对测试集的输入做出预测</p><p><code>evaluate</code>函数用于检测敏感度和特异性</p></li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="load-data-函数"><a href="#load-data-函数" class="headerlink" title="load_data 函数"></a><code>load_data</code> 函数</h4><p><code>load_data</code> 函数应接受一个 CSV 文件名作为参数，打开该文件，并返回一个元组 <code>(evidence, labels)</code>。<code>evidence</code> 应是一个包含所有数据点证据的列表，<code>labels</code> 应是一个包含所有数据点标签的列表。</p><p>由于每一行数据对应一个证据和一个标签，<code>evidence</code> 列表和 <code>labels</code> 列表的长度应等于 CSV 文件中的行数（不包括标题行）。列表的顺序应与用户在电子表格中的顺序一致。也就是说，<code>evidence[0]</code> 应是第一个用户的证据，<code>labels[0]</code> 应是第一个用户的标签。</p><p><code>evidence</code> 列表中的每个元素应是一个长度为 17 的列表，对应电子表格中除最后一列（标签列）外的每一列。证据列表中的值应与电子表格中的列顺序一致。你可以假设 <code>shopping.csv</code> 中的列顺序始终不变。</p><p>请注意，为了构建最近邻分类器，所有数据都必须是数值类型。确保你的值具有以下类型：</p><ul><li><code>Administrative</code>, <code>Informational</code>, <code>ProductRelated</code>, <code>Month</code>, <code>OperatingSystems</code>, <code>Browser</code>, <code>Region</code>, <code>TrafficType</code>, <code>VisitorType</code>, 和 <code>Weekend</code> 应为 <code>int</code> 类型。</li><li><code>Administrative_Duration</code>, <code>Informational_Duration</code>, <code>ProductRelated_Duration</code>, <code>BounceRates</code>, <code>ExitRates</code>, <code>PageValues</code>, 和 <code>SpecialDay</code> 应为 <code>float</code> 类型。</li><li><code>Month</code> 应为 0（一月）到 11（十二月）。</li><li><code>VisitorType</code> 应为 1（返回访客）或 0（非返回访客）。</li><li><code>Weekend</code> 应为 1（用户在周末访问）或 0（否则）。</li></ul><p><code>labels</code> 中的每个值应为整数 1（用户完成购买）或 0（否则）。</p><p>例如，第一个证据列表的值应为 <code>[0, 0.0, 0, 0.0, 1, 0.0, 0.2, 0.2, 0.0, 0.0, 1, 1, 1, 1, 1, 1, 0]</code>，第一个标签的值应为 <code>0</code>。</p><p>更加顺序化：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">evidence should be <span class="hljs-keyword">a</span> list <span class="hljs-keyword">of</span> lists, where <span class="hljs-keyword">each</span> list <span class="hljs-keyword">contains</span> <span class="hljs-keyword">the</span><br>    following values, <span class="hljs-keyword">in</span> order:<br>        - Administrative, <span class="hljs-keyword">an</span> integer0<br>        - Administrative_Duration, <span class="hljs-keyword">a</span> floating point number1<br>        - Informational, <span class="hljs-keyword">an</span> integer2<br>        - Informational_Duration, <span class="hljs-keyword">a</span> floating point number3<br>        - ProductRelated, <span class="hljs-keyword">an</span> integer4<br>        - ProductRelated_Duration, <span class="hljs-keyword">a</span> floating point number5<br>        - BounceRates, <span class="hljs-keyword">a</span> floating point number6<br>        - ExitRates, <span class="hljs-keyword">a</span> floating point number7<br>        - PageValues, <span class="hljs-keyword">a</span> floating point number8<br>        - SpecialDay, <span class="hljs-keyword">a</span> floating point number9<br>        - Month, <span class="hljs-keyword">an</span> index <span class="hljs-built_in">from</span> <span class="hljs-number">0</span> (January) <span class="hljs-built_in">to</span> <span class="hljs-number">11</span> (December)<span class="hljs-number">10</span><br>        - OperatingSystems, <span class="hljs-keyword">an</span> integer11<br>        - Browser, <span class="hljs-keyword">an</span> integer12<br>        - Region, <span class="hljs-keyword">an</span> integer13<br>        - TrafficType, <span class="hljs-keyword">an</span> integer14<br>        - VisitorType, <span class="hljs-keyword">an</span> <span class="hljs-keyword">integer</span> <span class="hljs-number">0</span> (<span class="hljs-keyword">not</span> returning) <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> (returning)<span class="hljs-number">15</span><br>        - Weekend, <span class="hljs-keyword">an</span> <span class="hljs-keyword">integer</span> <span class="hljs-number">0</span> (<span class="hljs-keyword">if</span> <span class="hljs-literal">false</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> (<span class="hljs-keyword">if</span> <span class="hljs-literal">true</span>)<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h4 id="train-model-函数"><a href="#train-model-函数" class="headerlink" title="train_model 函数"></a><code>train_model</code> 函数</h4><p><code>train_model</code> 函数应接受一个证据列表和一个标签列表，并返回一个基于该训练数据训练的 scikit-learn 最近邻分类器（k&#x3D;1 的 k-最近邻分类器）。</p><p>请注意，我们已经为你导入了 <code>from sklearn.neighbors import KNeighborsClassifier</code>。你应在此函数中使用 <code>KNeighborsClassifier</code>。</p><h4 id="evaluate-函数"><a href="#evaluate-函数" class="headerlink" title="evaluate 函数"></a><code>evaluate</code> 函数</h4><p><code>evaluate</code> 函数应接受一个标签列表（测试集中用户的真实标签）和一个预测列表（分类器预测的标签），并返回两个浮点值 <code>(sensitivity, specificity)</code>。</p><ul><li><code>sensitivity</code> 应为 0 到 1 之间的浮点值，表示“真正例率”：实际为正例的标签中被准确识别的比例。</li><li><code>specificity</code> 应为 0 到 1 之间的浮点值，表示“真负例率”：实际为负例的标签中被准确识别的比例。</li></ul><p>你可以假设每个标签为 1（正例，用户完成购买）或 0（负例，用户未完成购买）。你可以假设真实标签列表至少包含一个正例和一个负例。</p><h3 id="指导"><a href="#指导" class="headerlink" title="指导"></a>指导</h3><ol><li><p><strong><code>load_data</code> 函数</strong>：</p><ul><li>使用 Python 的 <code>csv</code> 模块或 <code>pandas</code> 库读取 CSV 文件。</li><li>遍历每一行数据，将除最后一列外的所有列转换为适当的类型，并存储在 <code>evidence</code> 列表中。</li><li>将最后一列（标签列）转换为整数，并存储在 <code>labels</code> 列表中。</li><li>确保所有数据的类型正确，特别是 <code>Month</code>、<code>VisitorType</code> 和 <code>Weekend</code> 的转换。</li></ul></li><li><p><strong><code>train_model</code> 函数</strong>：</p><ul><li>使用 <code>KNeighborsClassifier</code> 创建一个 k&#x3D;1 的最近邻分类器。</li><li>使用 <code>fit</code> 方法将证据和标签作为训练数据拟合模型。</li><li>返回训练好的模型。</li></ul></li><li><p><strong><code>evaluate</code> 函数</strong>：</p><ul><li>计算真正例（True Positives, TP）、真负例（True Negatives, TN）、假正例（False Positives, FP）和假负例（False Negatives, FN）。</li><li>使用公式 <code>sensitivity = TP / (TP + FN)</code> 计算敏感度。</li><li>使用公式 <code>specificity = TN / (TN + FP)</code> 计算特异性。</li><li>返回计算得到的敏感度和特异性。</li></ul></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保数据类型转换正确，特别是 <code>Month</code>、<code>VisitorType</code> 和 <code>Weekend</code> 的转换。</li><li>在 <code>evaluate</code> 函数中，确保正确处理边界情况，例如所有预测都为正例或负例的情况。</li><li>使用适当的库函数和方法来简化代码，例如 <code>pandas</code> 的 <code>read_csv</code> 函数和 <code>scikit-learn</code> 的 <code>KNeighborsClassifier</code>。</li></ul><p>通过这些步骤，你应该能够成功实现 <code>load_data</code>、<code>train_model</code> 和 <code>evaluate</code> 函数。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_lab2</title>
    <link href="/2025/03/05/OS-lab2/"/>
    <url>/2025/03/05/OS-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="OS-Lab2"><a href="#OS-Lab2" class="headerlink" title="OS_Lab2"></a>OS_Lab2</h1><h2 id="实验概述"><a href="#实验概述" class="headerlink" title="实验概述"></a>实验概述</h2><p>在本次实验中，同学们会学习到x86汇编、计算机的启动过程、IA-32处理器架构和字符显存原理。根据所学的知识，同学们能自己编写程序，并且让计算机在启动后加载运行，增进对计算机启动过程的理解，为后面编写操作系统加载程序奠定基础。同时，同学们将学习使用gdb来调试程序的基本方法。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>DDL：2025.3.23</p><p>提交内容：将<strong>3+1（选做）个任务的代码</strong>和<strong>实验报告</strong>放到<strong>压缩包</strong>中，命名为“<strong>lab2-姓名-学号</strong>”，提交到实验课程邮箱：<a href="mailto:&#111;&#x73;&#x5f;&#115;&#121;&#x73;&#x75;&#x5f;&#108;&#97;&#x62;&#x40;&#49;&#x36;&#x33;&#46;&#99;&#111;&#109;">os_sysu_lab@163.com</a>。</p><p>将实验报告的pdf提交至 <a href="http://inbox.weiyun.com/zPIW1se1">http://inbox.weiyun.com/zPIW1se1</a></p><h2 id="实验入门"><a href="#实验入门" class="headerlink" title="实验入门"></a>实验入门</h2><ul><li>从汇编语言开始–汇编语言提供了一些特权指令，而高级指令并未提供对应的指令。</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ul><li><p>IA-32处理器：从Intel 80386开始到32位的奔腾4处理器</p></li><li><p>Intel 32位的处理器也被称为x86处理器</p></li><li><p>IA-32处理器有三种基本操作模式：<em><strong>保护模式*、*实地址模式</strong></em>(简称实模式)和<strong>系统管理模式</strong>。</p></li><li><p>IA-32的重要组成部分：</p><ul><li>地址空间：保护模式：使用32位地址总线、32位寄存器；实模式：20位地址总线、16位寄存器</li><li>基本寄存器：IA-32处理器主要有8个通用寄存器eax, ebx, ecx, edx, ebp, esp, esi, edi、6个<strong>段寄存器cs, ss, ds, es, fs, gs</strong>、标志寄存器eflags、指令地址寄存器eip。</li><li>通用寄存器：通用寄存器有8个，分别是eax, ebx, ecx, edx, ebp, esp, esi, edi，均是<strong>32位寄存器</strong>。<ul><li>通用寄存器用于<strong>算术运算和数据传输</strong>。32位寄存器用于保护模式，为了兼容16位的实模式，每一个32位寄存器又<strong>可以拆分成16位寄存器和8位寄存器</strong>来访问。</li></ul></li></ul></li></ul><table><thead><tr><th>0-31位</th><th>0-15位</th><th>8-15位</th><th>0-7位</th></tr></thead><tbody><tr><td>eax</td><td>ax</td><td>ah</td><td>al</td></tr><tr><td>ebx</td><td>bx</td><td>bh</td><td>bl</td></tr><tr><td>ecx</td><td>cx</td><td>ch</td><td>cl</td></tr><tr><td>edx</td><td>dx</td><td>dh</td><td>dl</td></tr></tbody></table><p>esi，edi，ebp和esp并无8位的寄存器访问方式</p><table><thead><tr><th>0-31位</th><th>0-15位</th></tr></thead><tbody><tr><td>esi</td><td>si</td></tr><tr><td>edi</td><td>di</td></tr><tr><td>esp</td><td>sp</td></tr><tr><td>ebp</td><td>bp</td></tr></tbody></table><h4 id="通用寄存器的特殊用法："><a href="#通用寄存器的特殊用法：" class="headerlink" title="通用寄存器的特殊用法："></a>通用寄存器的特殊用法：</h4><ul><li><strong>eax</strong>在<strong>乘法和除法</strong>指令中被自动使用，通常称之为<strong>扩展累加寄存器</strong>。</li></ul><ul><li><p>ecx在loop指令中默认为循环计数器。</p></li><li><p>esp用于<strong>堆栈寻址</strong>。因此，我们绝对不可以随意使用esp。</p></li><li><p>esi和edi通常用于<strong>内存数据的高速传送</strong>，通常称之为扩展源指针和扩展目的指针寄存器。</p></li><li><p>ebp通常出现在高级语言翻译成的汇编代码中，用来引用函数参数和局部变量。除非用于高级语言的设计技巧中，ebp不应该在算术运算和数据传送中使用。ebp一般称之为扩展帧指针寄存器。</p></li><li><p><strong>段寄存器</strong>。段寄存器有cs, ss, ds, es, fs, gs，用于存放<strong>段的基地址</strong>，段实际上就是一块连续的内存区域。</p></li><li><p><strong>指令指针</strong>。<strong>eip存放下一条指令的地址</strong>。有些机器指令可以改变eip的地址，导致程序向新的地址进行转移，如ret指令。</p></li><li><p><strong>状态寄存器</strong>。eflags存放CPU的一些状态标志位。下面提到的标志如进位标志实际上是eflags的某一个位。常用的标志位如下。</p><ul><li>进位标志(CF)。在无符号算术运算的结果无法容纳于目的操作数时被置1。</li><li>溢出标志(OF)。在有符号算术运算的结果无法容纳于目的操作数时被置1。</li><li>符号标志(SF)。在算术或逻辑运算产生的结果为负时被置1。</li><li>零标志(ZF)。在算术或逻辑运算产生的结果为0时被置1。</li></ul></li></ul><h3 id="实地址模式"><a href="#实地址模式" class="headerlink" title="实地址模式"></a>实地址模式</h3><ul><li>如上述所说，实地址模式的寄存器都是16位的，因此名称都不带e</li><li>实地址的地址线是20位的，但寄存器都是16位的–采用“<strong>段地址+偏移地址</strong>”</li></ul><p>$$<br>物理地址&#x3D;(段地址&lt;&lt;4)+偏移地址<br>$$</p><p>段寄存器也有约定俗成的规则。一个典型的程序有3个段，数据段、代码段和堆栈段。</p><ul><li>cs包含16位代码段的基地址。</li><li>ds包含16位数据段的基地址。</li><li>ss包含一个16位堆栈段的基地址。</li><li>es、fs和gs可以指向其他数据段的基地址。</li></ul><p>由于段地址必须通过段寄存器给出，因此下面直接用“段寄存器”来代替“段地址”，即物理地址可表示为“段寄存器:偏移地址”。</p><h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><ul><li>汇编代码一般保存在以 <code>.s</code> 或 <code>.asm</code> 为后缀的文件中。（我们可以在终端采用特定命令将高级语言代码转换为汇编代码）</li></ul><table><thead><tr><th>寄存器</th><th>作用</th></tr></thead><tbody><tr><td>ax</td><td>累加寄存器</td></tr><tr><td>cx</td><td>计数寄存器</td></tr><tr><td>dx</td><td>数据寄存器</td></tr><tr><td>ds</td><td>数据段寄存器</td></tr><tr><td>es</td><td>附加段寄存器</td></tr><tr><td>bx</td><td><strong>基地址</strong>寄存器</td></tr><tr><td>si</td><td>源变址寄存器</td></tr><tr><td>di</td><td>目的变址寄存器</td></tr><tr><td>cs</td><td>代码段寄存器</td></tr><tr><td>ip</td><td>指令指针寄存器</td></tr><tr><td>ss</td><td>栈段寄存器</td></tr><tr><td>sp</td><td>栈指针寄存器</td></tr><tr><td>bp</td><td>基指针寄存器</td></tr><tr><td>flags</td><td>标志寄存器</td></tr></tbody></table><ul><li>汇编注释：在汇编代码中使用<strong>分号</strong> <code>;</code>来注释</li><li>在汇编代码中，<strong>一行只能写一条汇编语句</strong>而<strong>无需以任何符号结尾</strong><ul><li>例子：<code>add eax,3 ;这是注释</code></li></ul></li></ul><h4 id="nasm汇编–标识符"><a href="#nasm汇编–标识符" class="headerlink" title="nasm汇编–标识符"></a>nasm汇编–标识符</h4><ul><li>标识符用来表示变量、常量、过程或代码标号<ul><li>标识符包含1-247个字符</li><li>对大小写不敏感！</li><li>标识符第一个字符必须是字母、下划线或@；不可以是数字</li><li>标识符不能与汇编器的保留字相同。</li></ul></li></ul><h4 id="nasm汇编–标号"><a href="#nasm汇编–标号" class="headerlink" title="nasm汇编–标号"></a>nasm汇编–标号</h4><ul><li>标号是<strong>充当指令或数据位置标记</strong>的标识符；标号的值就是其后指令或数据的<strong>起始地址</strong>（偏移地址）</li><li><strong>数据标号</strong>标识了<strong>变量的地址</strong>，为在代码中引用该变量提供了方便。</li></ul><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>db</td><td>一个字节</td></tr><tr><td>dw</td><td>一个字，2个字节</td></tr><tr><td>dd</td><td>双字，4个字节</td></tr></tbody></table><p>例子：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">array dw 1024, 2048<br>      dw 4096, 8192<br>  <span class="hljs-built_in"></span><br><span class="hljs-built_in">array </span>dw 1024, 2048, 4096, 8192 ;和上面是同样的<br></code></pre></td></tr></table></figure><p>对应了：</p><p>array[0] &#x3D; 1024<br>array[1] &#x3D; 2048<br>array[2] &#x3D; 4096<br>array[3] &#x3D; 8192</p><ul><li>代码标号：代码标号标识了<strong>汇编指令的起始地址</strong>，通常作为<strong>跳转指令的操作数</strong>。</li><li>代码标号后面必须要有冒号 <code>:</code> ；但数据标号后面没有</li></ul><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>&lt;reg&gt;</code></td><td>寄存器，如ax，bx等</td></tr><tr><td><code>&lt;mem&gt;</code></td><td>内存地址，如标号var1，var2等</td></tr><tr><td><code>&lt;con&gt;</code></td><td>立即数，如3，9等</td></tr></tbody></table><ul><li><code>mov</code>指令：将<strong>源操作数</strong>的内容复制到<strong>目的操作数</strong>中</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;<span class="hljs-keyword">reg</span>&gt;<br><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;<span class="hljs-keyword">reg</span>&gt;<br><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;mem&gt;<br><span class="hljs-keyword">mov</span> &lt;mem&gt;, &lt;<span class="hljs-keyword">reg</span>&gt;<br><span class="hljs-keyword">mov</span> &lt;<span class="hljs-keyword">reg</span>&gt;, &lt;con&gt;<br><span class="hljs-keyword">mov</span> &lt;mem&gt;, &lt;con&gt;<br></code></pre></td></tr></table></figure><p>Intel汇编中，前者是目的操作数，后者是源操作数</p><h4 id="nasm汇编–内存寻址方法"><a href="#nasm汇编–内存寻址方法" class="headerlink" title="nasm汇编–内存寻址方法"></a>nasm汇编–内存寻址方法</h4><ul><li><p>寄存器寻址：<code>mov ax,cx</code></p></li><li><p>立即数寻址：<code>mov ax,7</code> or <code>mov ax,tag</code> (tag表示的是标号)</p></li><li><p>直接寻址：<code>mov ax, [0x5c00] ; ax = 0xFF</code></p><ul><li><p><strong>在根据偏移地址去取内存中的变量时，要加上 <code>[]</code>，否则就只是将变量地址放到寄存器中</strong></p><p><code>mov ax, [tag] ; ax = 0xFF</code></p></li><li><p>我们指令中如果没有显式指定段地址，那么我们的地址就是偏移地址</p></li><li><p>访问数据段，使用段寄存器ds。</p></li><li><p>访问代码段，使用段寄存器cs。</p></li></ul><ul><li>访问栈段，使用段寄存器ss。</li></ul></li><li><p>基址寻址：基址寻址使用<strong>基址寄存器和立即数</strong>来构成真实的偏移地址</p><ul><li>基址寄存器只能是bx或bp；用bx做基址寄存器时，段地址寄存器默认为ds，使用bp时默认为ss</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 使用bx做基址寄存器时段寄存器为ds存放的内容</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>]<br><span class="hljs-comment">; 使用bp做基址寄存器时段寄存器为ss存放的内容</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bp</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><ul><li><p>变址寻址：变址寻址使用<strong>变址寄存器和立即数</strong>来构成真实的偏移地址。</p><ul><li><p>变址寄存器只能是 <code>si</code>或 <code>di</code>，默认段寄存器为 <code>ds</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">si</span> + <span class="hljs-number">4</span> * <span class="hljs-number">4</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">di</span>], <span class="hljs-number">0x5</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>基址变址寻址:我们通过基址寄存器、变址寄存器、立即数来构成真实的偏移地址。默认段地址由基址寄存器的类型确定，即 <code>bx</code>对应 <code>ds</code>、<code>bp</code>对应 <code>ss</code>，如下所示。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-built_in">si</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span> + <span class="hljs-built_in">di</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bx</span> + <span class="hljs-built_in">si</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-built_in">si</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [<span class="hljs-built_in">bp</span> + <span class="hljs-built_in">di</span> + <span class="hljs-number">5</span> * <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure></li></ul><h4 id="x86汇编–算数和逻辑指令"><a href="#x86汇编–算数和逻辑指令" class="headerlink" title="x86汇编–算数和逻辑指令"></a>x86汇编–算数和逻辑指令</h4><ol><li><p><strong>add</strong>指令：前面是目的操作数，所以const不可以在前面。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">add</span> &lt;reg&gt;, &lt;reg&gt;<br><span class="hljs-built_in">add</span> &lt;reg&gt;, &lt;mem&gt;<br><span class="hljs-built_in">add</span> &lt;mem&gt;, &lt;reg&gt;<br><span class="hljs-built_in">add</span> &lt;reg&gt;, &lt;con&gt;<br><span class="hljs-built_in">add</span> &lt;mem&gt;, &lt;con&gt;<br>; e.g.<br><span class="hljs-built_in">add</span> ax, 10 ; eax := eax + 10<br><span class="hljs-built_in">add</span> byte[tag], al<br></code></pre></td></tr></table></figure></li><li><p><strong>sub</strong>指令：类似于add</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> &lt;<span class="hljs-title">reg</span>&gt;, &lt;<span class="hljs-title">reg</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">reg</span>&gt;, &lt;<span class="hljs-title">mem</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">mem</span>&gt;, &lt;<span class="hljs-title">reg</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">reg</span>&gt;, &lt;<span class="hljs-title">con</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">sub</span> &lt;<span class="hljs-title">mem</span>&gt;, &lt;<span class="hljs-title">con</span>&gt;</span><br><span class="hljs-function"></span>; e.g.<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">al</span>, <span class="hljs-title">ah</span> </span>; al := al - ah<br><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">ax</span>, 126</span><br></code></pre></td></tr></table></figure></li><li><p><strong>imul</strong>是整数相乘指令，它有<strong>两种指令格式</strong>，一种为两个操作数，将两个操作数的值相乘，并将结果保存在第一个操作数中，<strong>第一个操作数必须为寄存器</strong>；第二种格式为三个操作数，其语义为：将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，<strong>第一个操作数必须为寄存器</strong>。</p></li></ol><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br>imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br>imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br>imul <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br>; e.g.<br>imul eax, [var] ; <span class="hljs-attr">eax</span> <span class="hljs-operator">=</span> eax <span class="hljs-operator">*</span> [var]<br>imul esi, edi, <span class="hljs-number">25</span> ; <span class="hljs-attr">esi</span> <span class="hljs-operator">=</span> edi <span class="hljs-operator">*</span> <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><ol start="4"><li><p>idiv完成整数除法操作，idiv<strong>只有一个操作数</strong>，此操作数为除数，而<strong>被除数</strong>则为 <code>edx:eax</code>中的内容（一个64位的整数），操作的结果有两部分：商和余数，其中<strong>商</strong>放在<strong>eax寄存器</strong>中，而<strong>余数</strong>则放在<strong>edx寄存器</strong>中</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">idiv</span> &lt;reg&gt; <span class="hljs-comment">;这里给出的是除数</span><br><span class="hljs-keyword">idiv</span> &lt;mem&gt;<br><span class="hljs-comment">; e.g.</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">dword</span>[var]<br></code></pre></td></tr></table></figure></li><li><p>inc，dec指令分别表示自增1或自减1</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">inc</span> &lt;reg&gt;<br><span class="hljs-keyword">inc</span> &lt;mem&gt;<br><span class="hljs-keyword">dec</span> &lt;reg&gt;<br><span class="hljs-keyword">dec</span> &lt;mem&gt;<br><span class="hljs-comment">; e.g.</span><br><span class="hljs-keyword">dec</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">byte</span>[tag]<br></code></pre></td></tr></table></figure></li><li><p>and, or, xor分别表示将两个操作数逻辑与、逻辑或和逻辑异或后放入到第一个操作数中</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><span class="hljs-built_in">and</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><span class="hljs-built_in">or</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;mem&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;reg&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;reg&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br><span class="hljs-built_in">xor</span> <span class="hljs-symbol">&lt;mem&gt;</span>, <span class="hljs-symbol">&lt;con&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>not表示对操作数每一位取反</p></li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">not &lt;reg&gt;<br>not &lt;mem&gt;<br><span class="hljs-comment">; e.g.</span><br>not ax<br>not word[tag] <span class="hljs-comment">; 取反一个字,2个字节</span><br>not <span class="hljs-keyword">byte[tag] </span><span class="hljs-comment">; 取反一个字节</span><br>not dword[tag] <span class="hljs-comment">; 取反一个双字，4个字节</span><br></code></pre></td></tr></table></figure><ol start="8"><li>neg表示取负</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">neg <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span><br>neg <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="9"><li>shl,shr表示逻辑左移和逻辑右移</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">; cl是寄存器ecx的低8位寄存器<br><br>shl <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shl <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shl <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, cl<br>shl <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, cl<br><br>shr <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shr <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">con</span>&gt;</span><br>shr <span class="hljs-tag">&lt;<span class="hljs-name">reg</span>&gt;</span>, cl<br>shr <span class="hljs-tag">&lt;<span class="hljs-name">mem</span>&gt;</span>, cl<br></code></pre></td></tr></table></figure><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul><li><p>jmp无条件跳转–<code>jmp &lt;label&gt;</code></p></li><li><p>jcondition有条件跳转</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">je &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when equal</span><br>jne &lt;<span class="hljs-type">label</span>&gt;  <span class="hljs-comment">; jump when not equal</span><br>jz &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when last result was zero</span><br>jg &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when greater than</span><br>jge &lt;<span class="hljs-type">label</span>&gt;  <span class="hljs-comment">; jump when greater than or equal to</span><br>jl &lt;<span class="hljs-type">label</span>&gt;   <span class="hljs-comment">; jump when less than</span><br>jle &lt;<span class="hljs-type">label</span>&gt;  <span class="hljs-comment">; jump when less than or equal to</span><br></code></pre></td></tr></table></figure></li><li><p>cmp指令：操作数1-操作数2，结果与机器状态寄存器eflags中的条件码比较</p></li></ul><h4 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h4><ul><li>栈的增长方式是从高地址向低地址增长</li><li>push指令：将操作数压入内存的栈中；可以对reg，mem，con做</li><li>pop指令：将栈顶的数据放入到操作数中；reg，mem</li><li>pushad指令是将ax, cx, dx, bx, sp, bp, si, di 依次压入栈中。</li><li><code>popad</code>指令是对栈指令一系列的pop操作，pop出的数据放入到di, si, bp, sp, bx, dx, cx, ax中。</li></ul><h4 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h4><p>call和ret指令是用来实现子过程(或者称函数，过程，意思相同)调用和返回。call指令首先将当前eip的内容入栈，然后将操作数的内容放入到eip中。ret指令将栈顶的内容弹出栈，放入到eip中。</p><h2 id="计算机开机启动过程"><a href="#计算机开机启动过程" class="headerlink" title="计算机开机启动过程"></a>计算机开机启动过程</h2><ul><li>计算机的启动需要程序加载，而计算机不启动则无法运行程序。</li><li>加电开机–BIOS启动–加载MBR–硬盘启动–内核启动</li></ul><h2 id="Example1：Hello-World"><a href="#Example1：Hello-World" class="headerlink" title="Example1：Hello World"></a>Example1：Hello World</h2><ul><li>task：在MBR被加载到内存地址0x7c00之后，向屏幕输出蓝色的Hello World</li><li>为了便于控制显示，IA-32处理器将显示矩阵映射到了内存<strong>0xB8000~0xBFFFF</strong>处，称为显存地址。</li><li>在文本模式下，控制器的<strong>最小可控制单位为字符</strong>，每一个显示字符自上向下，从左到右依次使用显存地址中的<strong>两个字节</strong>表示–低字节表示所要<strong>显示的字符</strong>，高字节表示字符的<strong>颜色属性</strong>。</li></ul><p><img src="/img/%E6%98%BE%E5%AD%98%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="显存对应关系"></p><p>字符的颜色属性的字节高四位为背景色，低四位为前景色，具体如下：</p><p><img src="/img/%E5%AD%97%E7%AC%A6%E5%B1%9E%E6%80%A7%E5%AF%B9%E5%BA%94%E8%A1%A8.png" alt="字符属性对应表"></p><ul><li><p>我们使用的是二维的点，但是在栈上是线性的 &#x3D;》转换为一维的点</p><p>$$<br>\text{显存起始位置}&#x3D;\text{0xB8000}+2\cdot(80\cdot x+y)<br>$$</p><p>(x,y)&#x3D;(row,col)，公式中的乘2是因为每个显示字符会使用两个字节表示</p></li></ul><p>编写MBR：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">org <span class="hljs-number">0x7c00</span> <span class="hljs-comment">; MBR被加载到内存地址0x7c00</span><br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>] <span class="hljs-comment">; 指定代码在16位实模式下运行</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span> <span class="hljs-comment">; eax = 0 相当于mov ax,0，但是前者机器码更短，执行更快</span><br><span class="hljs-comment">; 初始化段寄存器, 段地址全部设为0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">fs</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">; 初始化栈指针</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span> <span class="hljs-comment">;0xb800是显存的段地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">;ah高位，al低位</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x01</span> <span class="hljs-comment">;蓝色--背景色是黑色，字是蓝色--0000 0001=0x01</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;H&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">0</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;e&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">1</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">2</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">3</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27; &#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">5</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;W&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">6</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;o&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">7</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;r&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">8</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;l&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">9</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;d&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span> * <span class="hljs-number">10</span>], <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">; 死循环</span><br><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span> - ($ - $$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>, <span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p><code>org</code>是汇编语言中的<strong>伪指令</strong>，用于指令程序 <code>&lt;u&gt;</code>加载到内存中的起始地址 <code>&lt;/u&gt;</code></p><p><code>0x7c00</code> 是 BIOS 将引导扇区加载到内存中的固定地址。BIOS 在启动时会自动<strong>将磁盘的第一个扇区（512字节）加载到内存地址 <code>0x7c00</code> 处</strong>，然后从这里开始执行。</p><p>6个<strong>段寄存器cs, ss, ds, es, fs, gs</strong></p><p>由于汇编不允许使用立即数直接对段寄存器赋值，所以要借助ax，在第三行给ax赋值为0之后，再让ax给段寄存器赋值</p><p><code>$</code>表示当前汇编地址，<code>$$</code>表示代码开始的汇编地址。<code>times 510 - ($ - $$) db 0</code>表示填充字符0直到第510个字节</p><ul><li><p>利用nasm汇编器来将代码编译成二进制文件：</p><p><code>nasm -f bin mbr.asm -o mbr.bin</code></p><ul><li><code>-f</code>参数制定了输出文件格式</li><li><code>-o</code>指定的是输出的文件名</li></ul><p><img src="/img/image-20250305172419639.png" alt="image-20250305172419639"></p></li><li><p>生成MBR后，将其写入到硬盘的首扇区。</p><ul><li><p>创建一个虚拟磁盘– <code>qemu-img create filename [size]</code></p><ul><li>qemu-img create hd.img 10m</li></ul></li><li><p>将MBR写入 <code>hd.img</code>的首扇区–使用 <code>dd</code>命令<br><code>dd if=mbr.bin of=hd.img bs=512 count=1 seek=0 conv=notrunc</code></p><ul><li><code>if</code>表示输入文件。</li><li><code>of</code>表示输出文件。</li><li><code>bs</code>表示块大小，以字节表示。</li><li><code>count</code>表示写入的块数目。</li><li><code>seek</code>表示越过输出文件中多少块之后再写入。</li><li><code>conv=notrunc</code>表示不截断输出文件，如果不加上这个参数，那么硬盘在写入后多余部份会被截断。</li></ul></li><li><p>启动qemu来模拟计算机启动：</p><p><code>qemu-system-i386 -hda hd.img -serial null -parallel stdio</code></p><ul><li><code>-hda hd.img</code>表示将文件 <code>hd.img</code>作为<strong>第0号磁盘映像</strong>。</li><li><code>-serial dev</code>表示重定向虚拟串口到空设备中。</li><li><code>-parallel stdio </code>表示重定向虚拟并口到主机标准输入输出设备中。</li><li><a href="https://c.biancheng.net/view/8123.html">GDB是什么？ - C语言中文网</a> 更多参数详见文档</li></ul></li></ul></li></ul><p><img src="/img/9cbfaf1fe8a7437aae3bc3d5cfd9aa9.png" alt="9cbfaf1fe8a7437aae3bc3d5cfd9aa9"></p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>使用gdb来配合qemu来进行debug，需要在qemu的启动命令中加入 <code>-s -S</code>参数，举例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">qemu-<span class="hljs-keyword">system</span>-i386 -hda hd.img -s -S -parallel stdio -<span class="hljs-type">serial</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>在另一个终端进入gdb，让gdb连接上qemu：<code>target remote:1234</code></p><p><a href="https://c.biancheng.net/view/8123.html">GDB是什么？ - C语言中文网</a></p><p>本次实验会用到的指令：</p><table><thead><tr><th>gdb指令</th><th>含义</th></tr></thead><tbody><tr><td>b *address</td><td>在内存地址address中设置断点</td></tr><tr><td>r</td><td>运行程序</td></tr><tr><td>c</td><td>继续运行</td></tr><tr><td>p *addr</td><td>打印地址的值</td></tr><tr><td>info registers</td><td>查看寄存器</td></tr><tr><td>x&#x2F;10i $pc</td><td>显示从程序计数器的地址开始的10条汇编指令</td></tr><tr><td>set disassembly-flavor intel</td><td>设置gdb反汇编的语法为intel风格</td></tr></tbody></table><h2 id="任务1-MBR"><a href="#任务1-MBR" class="headerlink" title="任务1 MBR"></a>任务1 MBR</h2><h3 id="1-1-复现example1"><a href="#1-1-复现example1" class="headerlink" title="1.1 复现example1"></a>1.1 复现example1</h3><p>done！<img src="/img/9cbfaf1fe8a7437aae3bc3d5cfd9aa9.png" alt="9cbfaf1fe8a7437aae3bc3d5cfd9aa9"></p><h3 id="1-2-修改example1的代码"><a href="#1-2-修改example1的代码" class="headerlink" title="1.2 修改example1的代码"></a>1.2 修改example1的代码</h3><p>修改Example 1的代码，使得MBR被加载到0x7C00后在(12,12)处开始输出你的学号。注意，你的学号显示的前景色和背景色必须和教程中不同。说说你是怎么做的，并将结果截图。</p><p>编译汇编文件：<code>nasm -f bin mbr.asm -o mbr2.bin</code></p><p>创建虚拟磁盘：<code> qemu-img create hd.img 10m</code></p><p>将MBR写入hd.img的首扇区： <code>dd if=mbr2.bin of=hd.img bs=512 count=1 seek=0 conv=notrunc</code></p><p>启动qemu：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">qemu-<span class="hljs-keyword">system</span>-i386 -hda hd.img -<span class="hljs-type">serial</span> <span class="hljs-keyword">null</span> -parallel stdio<br></code></pre></td></tr></table></figure><p>结果：<img src="/img/image-20250305180510397.png" alt="image-20250305180510397"></p><h2 id="任务2-实模式中断"><a href="#任务2-实模式中断" class="headerlink" title="任务2 实模式中断"></a>任务2 实模式中断</h2><h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p><a href="https://blog.csdn.net/kakitgogogo/article/details/52804340">INT10H中断服务详解-CSDN博客</a></p><table><thead><tr><th>AH</th><th>功 能</th><th>调用参数</th><th>返回参数 &#x2F; 注释</th></tr></thead><tbody><tr><td>1</td><td>置光标类型</td><td>（CH）0―3 &#x3D; 光标开始行 　　（CL）0―3 &#x3D; 光标结束行</td><td></td></tr><tr><td>2</td><td>置光标位置</td><td>BH &#x3D; 页号 　　DH &#x3D; 行 　　DL &#x3D; 列</td><td></td></tr><tr><td>3</td><td>读光标位置</td><td>BH &#x3D; 页号</td><td>CH &#x3D; 光标开始行 　CL &#x3D; 光标结束行 　DH &#x3D; 行 　DL &#x3D; 列</td></tr><tr><td>4</td><td>读光笔位置</td><td></td><td>AH&#x3D;0 光笔未触发 &#x3D;1 光笔触发 CH&#x3D;象素行 BX&#x3D;象素列 DH&#x3D;字符行 DL&#x3D;字符列</td></tr><tr><td>5</td><td>显示页</td><td>AL &#x3D; 显示页号</td><td></td></tr><tr><td>6</td><td>屏幕初始化或上卷</td><td>AL &#x3D; 上卷行数 　　AL &#x3D;0全屏幕为空白 　　BH &#x3D; 卷入行属性 　　CH &#x3D; 左上角行号 　　CL &#x3D; 左上角列号 　　DH &#x3D; 右下角行号 　　DL &#x3D; 右下角列号</td><td></td></tr><tr><td>7</td><td>屏幕初始化或下卷</td><td>AL &#x3D; 下卷行数 　　AL &#x3D; 0全屏幕为空白 　　BH &#x3D; 卷入行属性 　　CH &#x3D; 左上角行号 　　CL &#x3D; 左上角列号 　　DH &#x3D; 右下角行号 　　DL &#x3D; 右下角列号</td><td></td></tr><tr><td>8</td><td>读光标位置的属性和字符</td><td>BH &#x3D; 显示页</td><td>AH &#x3D; 属性 　AL &#x3D; 字符</td></tr><tr><td>9</td><td>在光标位置显示字符及其属性</td><td>BH &#x3D; 显示页 　　AL &#x3D; 字符 　　BL &#x3D; 属性 　　CX &#x3D; 字符重复次数</td><td></td></tr><tr><td>A</td><td>在光标位置只显示字符</td><td>BH &#x3D; 显示页 　　AL &#x3D; 字符 　　CX &#x3D; 字符重复次数</td><td></td></tr><tr><td>E</td><td>显示字符(光标前移)</td><td>AL &#x3D; 字符 　　BL &#x3D; 前景色</td><td>光标跟随字符移动</td></tr><tr><td>13</td><td>显示字符串</td><td>ES:BP &#x3D; 串地址 　　CX &#x3D; 串长度 　　DH， DL &#x3D; 起始行列 　　BH &#x3D; 页号 　　AL &#x3D; 0，BL &#x3D; 属性 　　串：Char，char，……，char 　　AL &#x3D; 1，BL &#x3D; 属性 　　串：Char，char，……，char 　　AL &#x3D; 2 　　串：Char，attr，……，char，attr 　　AL &#x3D; 3 　　串：Char，attr，……，char，attr</td><td>光标返回起始位置  　光标跟随移动   　光标返回起始位置   　光标跟随串移动</td></tr></tbody></table><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>应用举例：<a href="https://www.cnblogs.com/b1ing/p/13044913.html">汇编语言——一些中断的调用 - b1ing丶 - 博客园</a></p><p>本任务会用到的：</p><table><thead><tr><th>功能</th><th>功能号</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>设置光标位置</td><td>AH&#x3D;02H</td><td>BH&#x3D;页码，DH&#x3D;行，DL&#x3D;列</td><td>无</td></tr><tr><td>获取光标位置和形状</td><td>AH&#x3D;03H</td><td>BX&#x3D;页码</td><td>AX&#x3D;0，CH&#x3D;行扫描开始，CL&#x3D;行扫描结束，DH&#x3D;行，DL&#x3D;列</td></tr><tr><td>在当前光标位置写字符和属性</td><td>AH&#x3D;09H</td><td>AL&#x3D;字符，BH&#x3D;页码，BL&#x3D;颜色，CX&#x3D;输出字符的个数</td><td>无</td></tr></tbody></table><p>中断的调用方式：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">将参数和功能号写入寄存器<br><span class="hljs-built_in">int</span> 中断号<br>从寄存器中取出返回值<br></code></pre></td></tr></table></figure><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><p>请探索实模式下的光标中断<code>int 10h</code>，<strong>实现将光标移动至(8,8)，获取并输出光标的位置</strong>。说说你是怎么做的，并将结果截图。</p><p>做法：</p><ul><li><p>利用任务1中打印到输出端的方法，先将段寄存器初始化为0，以及栈顶指向显示矩阵的首地址。</p></li><li><p>设置光标的位置：ah&#x3D;2</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">2</span>    <span class="hljs-comment">;设置光标位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;page set to be  0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>    <span class="hljs-comment">;row</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">8</span>    <span class="hljs-comment">;col</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br></code></pre></td></tr></table></figure></li><li><p>获取光标的位置：ah&#x3D;3</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">3</span>    <span class="hljs-comment">;获取光标位置和形状</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br></code></pre></td></tr></table></figure></li><li><p>再将坐标字符送到显示矩阵中存储：要注意这里的需要将二进制转换为ASCII字符</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;(&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">8</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">dh</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;0&#x27;</span>  <span class="hljs-comment">;将二进制转换为ASCII字符</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">9</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;,&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">10</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">dl</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;0&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">11</span>)],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-string">&#x27;)&#x27;</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">2</span>*(<span class="hljs-number">80</span>*<span class="hljs-number">8</span>+<span class="hljs-number">12</span>)],<span class="hljs-built_in">ax</span><br></code></pre></td></tr></table></figure></li><li><p>ending</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">jmp</span> $<br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure></li></ul><p>结果：</p><p><img src="/img/image-20250309145148543.png" alt="2"></p><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><p>利用实模式下的中断，<strong>从(8,8)开始输出你的学号</strong>。说说你是怎么做的，并将结果截图。</p><ul><li><p>光标移动到(8,8)，复用2.1任务中的指令</p></li><li><p>在光标位置输出学号，需要利用光标位置来计算显存矩阵位置的偏移量，然后循环打印学号即可，过程中要记得将地址<code>+2</code></p></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;计算偏移量--输出移动到光标处--2*(80*x+y)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">80</span><br><span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">dl</span><br><span class="hljs-keyword">adc</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">shl</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">;把学号存储在寄存器中</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,student_id<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span> <span class="hljs-comment">;长度</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x0A</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">print_loop:</span><br>    <span class="hljs-keyword">lodsb</span>   <span class="hljs-comment">;从si加载字符到al</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">0x0A</span> <br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">di</span>],<span class="hljs-built_in">ax</span> <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span>    <span class="hljs-comment">;累加，往后输出</span><br>    <span class="hljs-keyword">loop</span> print_loop<br><br><span class="hljs-keyword">jmp</span> $ <br>student_id <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;23336139&#x27;</span><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>,<span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p>光标移动到(8,8)，并从此开始输出我的学号。</p><ul><li>结果：</li></ul><p><img src="/img/image-20250306104000712.png" alt="image-20250306104000712"></p><h3 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h3><p>参考《汇编语言》第17章、<a href="https://gitee.com/link?target=https://blog.csdn.net/deniece1/article/details/103447413">键盘I&#x2F;O中断调用</a>。关于键盘扫描码，可以参考<a href="https://gitee.com/link?target=http://blog.sina.com.cn/s/blog_1511e79950102x2b0.html">键盘扫描码表</a>。</p><p>在2.1和2.2的知识的基础上，探索实模式下的键盘中断<code>int 16h</code>，<strong>利用键盘中断，实现任意 键盘输入并回显 的效果</strong>。说说你是怎么做的，并将结果截图。</p><p>INT 16H（键盘I&#x2F;O中断）<br>　 AH&#x3D;0：从键盘读入ASCII字符，放在AL中。<br>　 AH&#x3D;1：测试有无键被按下。ZF&#x3D;0，表示按过任意键，并在AL中获得该键的ASCII码。ZF&#x3D;1，未按过键。<br>　 AH&#x3D;2：读取特殊功能键的状态至AL中。</p><table><thead><tr><th>D7</th><th>D6</th><th>D5</th><th>D4</th><th>D3</th><th>D2</th><th>D1</th><th>D0</th></tr></thead><tbody><tr><td>Ins</td><td>CapsLock</td><td>NumLock</td><td>ScrollLock</td><td>Alt</td><td>Ctrl</td><td>左Shift</td><td>右Shift</td></tr></tbody></table><p>过程：</p><ul><li><p>为了在显存输出，也是类似地进行初始化。</p></li><li><p>会使用到int 16h </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">org <span class="hljs-number">0x7c00</span>      <br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>]       <br><br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 清零 ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 初始化段寄存器</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span>  <span class="hljs-comment">; 设置栈指针</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span>  <span class="hljs-comment">; 设置显存段地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x00</span>    <span class="hljs-comment">; 从键盘读取一个字符</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">0x16</span>        <span class="hljs-comment">; AL = ASCII 字符，AH = 扫描码</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0xF2</span>    <span class="hljs-comment">; 设置字符属性--颜色</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-number">0</span>], <span class="hljs-built_in">ax</span>  <span class="hljs-comment">; 将字符和属性写入显存</span><br><br><span class="hljs-keyword">jmp</span> $           <span class="hljs-comment">; 无限循环</span><br><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span>-($-$$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span>  <span class="hljs-comment">; 填充剩余空间</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>, <span class="hljs-number">0xaa</span>          <span class="hljs-comment">; 引导扇区结束标志</span><br></code></pre></td></tr></table></figure></li></ul><p>结果：</p><p><img src="/img/image-20250306114833724.png" alt="image-20250306114833724"></p><p><img src="/img/image-20250306114913976.png" alt="image-20250306114913976"></p><h2 id="任务3-汇编"><a href="#任务3-汇编" class="headerlink" title="任务3 汇编"></a>任务3 汇编</h2><p>要求：</p><ul><li>任务3使用的是32位寄存器</li><li><code>a1</code>、<code>if_flag</code>、<code>my_random</code>等都是预先定义好的变量和函数，直接使用即可。</li><li>需要补全的代码文件在 <code>assignment/student.asm</code>中。</li><li>代码编写好之后使用 <code>make run</code> 来测试代码</li><li>你可以修改 <code>test.cpp</code>中的 <code>student_setting</code>中的语句来得到你想要的 <code>a1,a2</code>。</li><li>最后附上结果截图</li></ul><h3 id="3-1-分支逻辑的实现"><a href="#3-1-分支逻辑的实现" class="headerlink" title="3.1 分支逻辑的实现"></a>3.1 分支逻辑的实现</h3><p>请将下列伪代码转换成汇编代码，并放置在标号 <code>your_if</code>之后。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">if</span> a1 &lt; <span class="hljs-number">12</span> then<br><span class="hljs-attribute">if_flag</span> = a1 / <span class="hljs-number">2</span> + <span class="hljs-number">1</span><br><span class="hljs-attribute">else</span> if a1 &lt; <span class="hljs-number">24</span> then<br><span class="hljs-attribute">if_flag</span> = (<span class="hljs-number">24</span> - a1) * a1<br><span class="hljs-attribute">else</span><br><span class="hljs-attribute">if_flag</span> = a1 &lt;&lt; <span class="hljs-number">4</span><br><span class="hljs-attribute">end</span><br></code></pre></td></tr></table></figure><p>条件分支</p><ul><li>利用跳转指令、跳跃指令、条件跳转指令</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">jmp</span> label<br></code></pre></td></tr></table></figure><ul><li>条件跳转指令：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">cmp <span class="hljs-tag">&lt;<span class="hljs-name">源操作数</span>&gt;</span>, <span class="hljs-tag">&lt;<span class="hljs-name">目标操作数</span>&gt;</span><br>jcc <span class="hljs-tag">&lt;<span class="hljs-name">目标地址</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>用于算术运算：</li></ul><table><thead><tr><th align="center">指令</th><th align="center">描述</th><th align="center">标志测试</th></tr></thead><tbody><tr><td align="center">JE&#x2F;JZ</td><td align="center">跳转等于或跳转零</td><td align="center">ZF</td></tr><tr><td align="center">JNE&#x2F;JNZ</td><td align="center">跳转不等于或跳转不为零</td><td align="center">ZF</td></tr><tr><td align="center">JG&#x2F;JNLE</td><td align="center">跳转大于或跳转不小于&#x2F;等于</td><td align="center">OF, SF, ZF</td></tr><tr><td align="center">JGE&#x2F;JNL</td><td align="center">跳转大于&#x2F;等于或不小于跳转</td><td align="center">OF, SF</td></tr><tr><td align="center">JL&#x2F;JNGE</td><td align="center">跳转小于或不大于&#x2F;等于</td><td align="center">OF, SF</td></tr><tr><td align="center">JLE&#x2F;JNG</td><td align="center">跳少&#x2F;等于或跳不大于</td><td align="center">OF, SF, ZF</td></tr></tbody></table><ul><li>逻辑运算：</li></ul><table><thead><tr><th align="center">指令</th><th align="center">描述</th><th align="center">标志测试</th></tr></thead><tbody><tr><td align="center">JE&#x2F;JZ</td><td align="center">跳转等于或跳转零</td><td align="center">ZF</td></tr><tr><td align="center">JNE&#x2F;JNZ</td><td align="center">跳转不等于或跳转不为零</td><td align="center">ZF</td></tr><tr><td align="center">JA&#x2F;JNBE</td><td align="center">跳转向上或不低于&#x2F;等于</td><td align="center">CF, ZF</td></tr><tr><td align="center">JAE&#x2F;JNB</td><td align="center">高于&#x2F;等于或不低于</td><td align="center">CF</td></tr><tr><td align="center">JB&#x2F;JNAE</td><td align="center">跳到以下或跳到不高于&#x2F;等于</td><td align="center">CF</td></tr><tr><td align="center">JBE&#x2F;JNA</td><td align="center">跳到下面&#x2F;等于或不跳到上方</td><td align="center">AF, CF</td></tr></tbody></table><p>结果代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">your_if:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,[a1] <span class="hljs-comment">;提取值</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">12</span><br><span class="hljs-symbol">    jl label</span>1<br><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">24</span><br><span class="hljs-symbol">    jl label</span>2<br><span class="hljs-symbol">    jmp label</span>3<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label1:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> [if_flag],<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">jmp</span> if_done<br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label2:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">24</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">imul</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">mov</span> [if_flag],<span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">jmp</span> if_done<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">label3:</span><br>    <span class="hljs-keyword">shl</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">4</span><br>    <span class="hljs-keyword">mov</span> [if_flag],<span class="hljs-built_in">eax</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">if_done:</span><br><br></code></pre></td></tr></table></figure><p>只要搞清楚如何分析分支跳转就可以了！</p><p>div: 只有一个操作数，计算后<strong>商</strong>放在<strong>eax寄存器</strong>中，而<strong>余数</strong>则放在<strong>edx寄存器</strong>中</p><h3 id="3-2-循环逻辑的实现"><a href="#3-2-循环逻辑的实现" class="headerlink" title="3.2 循环逻辑的实现"></a>3.2 循环逻辑的实现</h3><p>请将下列伪代码转换成汇编代码，并放置在标号 <code>your_while</code>之后。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">while</span> <span class="hljs-built_in">a2</span> &gt;= <span class="hljs-number">12</span> then<br>call my_random        <span class="hljs-comment">// my_random将产生一个随机数放到eax中返回</span><br>while_flag[<span class="hljs-built_in">a2</span> - <span class="hljs-number">12</span>] = eax<br>--<span class="hljs-built_in">a2</span><br><span class="hljs-symbol">end</span><br></code></pre></td></tr></table></figure><ul><li>​无条件循环指令</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">jmp <span class="hljs-tag">&lt;<span class="hljs-name">目标地址</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>条件循环指令</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">cmp <span class="hljs-variable">&lt;源操作数&gt;</span>, <span class="hljs-variable">&lt;目标操作数&gt;</span><br>jcc <span class="hljs-keyword">label</span><br></code></pre></td></tr></table></figure><p>结果：（更新）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">your_while:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [a2]   <span class="hljs-comment">; 读取 a2，这里不能用 eax 存储 [a2] 的值，调用 my_random 返回的随机数会覆盖 eax！！！</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loop:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">12</span><br>    <span class="hljs-keyword">jl</span> while_end    <span class="hljs-comment">; 若 a2 &lt; 12，则退出循环</span><br><br>    <span class="hljs-keyword">call</span> my_random  <span class="hljs-comment">; 产生随机数，存入 eax</span><br>    <span class="hljs-comment">; 计算 while_flag[a2 - 12] 的地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">12</span>      <span class="hljs-comment">; edx = a2 - 12</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, [while_flag]<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">ecx</span>     <span class="hljs-comment">; edx = while_flag + (a2 - 12)</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">edx</span>], <span class="hljs-built_in">al</span>    <span class="hljs-comment">; 将随机数存入 while_flag[a2 - 12]</span><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">mov</span> [a2], <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">jmp</span> <span class="hljs-keyword">loop</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">while_end:</span><br><br></code></pre></td></tr></table></figure><p>重点：</p><ul><li><p>不可以把a2的值读取到eax中</p></li><li><p>要记得把地址 *4 ，因为存储的是字节</p></li></ul><h3 id="3-3-函数的实现"><a href="#3-3-函数的实现" class="headerlink" title="3.3 函数的实现"></a>3.3 函数的实现</h3><p>请编写函数 <code>your_function</code>并调用之，函数的内容是遍历字符数组 <code>string</code>。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">your_function:</span><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; <span class="hljs-type">string</span>[i] != <span class="hljs-comment">&#x27;\0&#x27;; ++i then</span><br>pushad<br>push <span class="hljs-type">string</span>[i] <span class="hljs-keyword">to</span> stack<br><span class="hljs-keyword">call</span> print_a_char<br>pop stack<br>popad<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>结果：（更新–旧版本没意识到出错了……）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">your_function:</span><br><span class="hljs-comment">; put your implementation here</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;i设置为0</span><br><span class="hljs-symbol">loop_start:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>,[your_string]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">edx</span>+<span class="hljs-built_in">ecx</span>]<br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">je</span> function_end<br><br>    <span class="hljs-keyword">pushad</span>  <span class="hljs-comment">;保存所有通用寄存器的状态</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>     <span class="hljs-comment">;将字符压入栈中</span><br>    <span class="hljs-keyword">call</span> print_a_char  <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">4</span>   <span class="hljs-comment">;弹出</span><br>    <span class="hljs-keyword">popad</span>   <span class="hljs-comment">;恢复状态</span><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">jmp</span> loop_start<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">function_end:</span><br>    <span class="hljs-keyword">ret</span><br><br></code></pre></td></tr></table></figure><p>重点：</p><ul><li>在 32 位汇编中，栈的操作单位是 <strong>4 字节（32 位）</strong>。无论是压栈（<code>push</code>）还是弹栈（<code>pop</code>），都是以 4 字节为单位进行的。</li><li>函数要记得返回</li></ul><p>make run结果：</p><p><img src="/img/image-20250312145851121.png"></p><h2 id="任务-4-汇编小程序（选做）"><a href="#任务-4-汇编小程序（选做）" class="headerlink" title="任务 4 汇编小程序（选做）"></a>任务 4 汇编小程序（选做）</h2><p>字符弹射程序。请编写一个字符弹射程序，其从点(2,0)处开始向<strong>右下角45度</strong>开始射出，遇到边界反弹，反弹后按45度角射出，方向视反弹位置而定。同时，你可以加入一些其他效果，如变色，双向射出等。注意，你的程序应该不超过510字节，否则无法放入MBR中被加载执行。静态示例效果如下，动态效果见视频<code>assignment/assignment-4-example.mp4</code>。</p><p>实现思路：</p><ul><li><p>设置显示字符的行、列寄存器（ch-行，cl-列），然后设置两个寄存器分别用于做<strong>水平</strong>方向和<strong>竖直</strong>方向的位移（最初设置为1,1是因为我们要从(2,0)点出发往右下方45°移动</p></li><li><p>设置一个专门进行弹跳的循环</p><ul><li>判断是否到达边界，如果到达边界需要反转对应方向的增量（其实还可以直接使用neg反转）</li><li>边界调整完后进入展示循环</li></ul></li><li><p>展示循环</p><ul><li>需要计算当前字符需要被放置到的显存矩阵的位置（这里尤其要注意，我们原本放置的寄存器是8位寄存器，但是bx是16位寄存器，需要进行0扩展）</li><li>将字符和颜色传入显存矩阵</li><li>修改字符和颜色（简单地通过+1来实现）</li><li>调用<strong>延时</strong>（由于我们把延时设置为一个标签了，这时候要保存原来的值后跳转出去需要借用到<strong>栈</strong>，在调用完之后返回再弹出栈）</li></ul></li></ul><p>实验代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">org <span class="hljs-number">0x7c00</span>      <br>[<span class="hljs-meta">bits</span> <span class="hljs-number">16</span>]       <br><span class="hljs-comment">;基础设置</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 清零 ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>, <span class="hljs-built_in">ax</span>      <span class="hljs-comment">; 初始化段寄存器</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>, <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x7c00</span>  <span class="hljs-comment">; 设置栈指针</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, <span class="hljs-number">0xb800</span>  <span class="hljs-comment">; 设置显存段地址</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">gs</span>, <span class="hljs-built_in">ax</span><br><br><span class="hljs-comment">;初始化字符1：(2,0)--(ch,cl)=(row,col)</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>, <span class="hljs-number">2</span>       <span class="hljs-comment">; 初始行位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0</span>       <span class="hljs-comment">; 初始列位置</span><br><span class="hljs-comment">;增量，line1向右下移动（初始）</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 行方向增量</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 列方向增量</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x0A</span>    <span class="hljs-comment">; 字符颜色（亮绿色）</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;0&#x27;</span>     <span class="hljs-comment">; 显示的字符</span><br><br><span class="hljs-comment">;显存矩阵大小：25*80</span><br><span class="hljs-symbol">bounce_loop:</span><br>    <span class="hljs-comment">; 检查上下边界</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-number">ch</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle</span> bounce_up   <span class="hljs-comment">; 如果行 &lt;= 0，需要向下反弹</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-number">ch</span>, <span class="hljs-number">24</span><br>    <span class="hljs-keyword">jge</span> bounce_down <span class="hljs-comment">; 如果行 &gt;= 24，需要向上反弹</span><br>    <br>    <span class="hljs-comment">; 检查左右边界</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jle</span> bounce_right <span class="hljs-comment">; 如果列 &lt;= 0，需要向右反弹</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>, <span class="hljs-number">79</span><br>    <span class="hljs-keyword">jge</span> bounce_left  <span class="hljs-comment">; 如果列 &gt;= 79，需要向左反弹</span><br>    <br>    <span class="hljs-keyword">jmp</span> display     <span class="hljs-comment">; 通过所有边界检查，显示字符</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_up:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 将行方向改为向下(正)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">bounce_down:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>, -<span class="hljs-number">1</span>      <span class="hljs-comment">; 将行方向改为向上(负)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_right:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; 将列方向改为向右(正)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">bounce_left:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, -<span class="hljs-number">1</span>      <span class="hljs-comment">; 将列方向改为向左(负)</span><br>    <span class="hljs-keyword">jmp</span> display<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">display:</span><br>    <span class="hljs-comment">; 计算显存位置</span><br>    <span class="hljs-keyword">movzx</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">ch</span>    <span class="hljs-comment">; 直接用ch*80会溢出 这里不能用mov--因为类型寄存器位数不同</span><br>    <span class="hljs-keyword">imul</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">80</span> <span class="hljs-comment">; bx *=  80</span><br>    <span class="hljs-keyword">movzx</span> <span class="hljs-built_in">si</span>, <span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>, <span class="hljs-built_in">si</span>      <span class="hljs-comment">; bx = ch * 80 + cl</span><br>    <span class="hljs-keyword">shl</span> <span class="hljs-built_in">bx</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; bx = 2 * (ch * 80 + cl)</span><br>    <br>    <span class="hljs-comment">; 当下的点传入显存矩阵</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>], <span class="hljs-built_in">al</span>   <span class="hljs-comment">; 写入字符</span><br>    <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">gs</span>:<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>], <span class="hljs-number">ah</span> <span class="hljs-comment">; 写入属性（颜色）</span><br>    <br>    <span class="hljs-comment">;增量</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-number">ch</span>, <span class="hljs-number">dh</span>        <span class="hljs-comment">; 更新行位置</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">cl</span>, <span class="hljs-built_in">dl</span>        <span class="hljs-comment">; 更新列位置</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-number">ah</span>            <span class="hljs-comment">; 改变颜色</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">al</span>            <span class="hljs-comment">; 改变字符</span><br><br>    <span class="hljs-comment">; 添加延迟--需要入栈存储寄存器的值，然后使用int 15h的86功能（延时），在时延后需要将寄存器的值弹出，同时返回继续显示</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">0x86</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0x0001</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0xa120</span>   <br>    <span class="hljs-keyword">int</span> <span class="hljs-number">15h</span> <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">delay:</span><br>    <span class="hljs-keyword">loop</span> delay<br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br><br>    <span class="hljs-keyword">jmp</span> bounce_loop   <span class="hljs-comment">; 继续主循环</span><br><br><br><span class="hljs-keyword">jmp</span> $ <span class="hljs-comment">; 死循环</span><br><br><span class="hljs-built_in">times</span> <span class="hljs-number">510</span> - ($ - $$) <span class="hljs-built_in">db</span> <span class="hljs-number">0</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">0x55</span>, <span class="hljs-number">0xaa</span><br></code></pre></td></tr></table></figure><p>本任务感谢<strong>隔壁舍友L同学</strong>的鼎力支持！从她的代码中学习到了不同位数寄存器要使用<code>movzx</code>存储，同时使用<code>int 15h</code>的0x86功能来产生延时 等知识。</p><h3 id="此处同时贴上相关的知识点："><a href="#此处同时贴上相关的知识点：" class="headerlink" title="此处同时贴上相关的知识点："></a>此处同时贴上相关的知识点：</h3><h4 id="功能86H"><a href="#功能86H" class="headerlink" title="功能86H"></a><strong>功能86H</strong></h4><p><a href="https://blog.csdn.net/qq_16494381/article/details/122760587">BIOS设备中断 15号中断详解-CSDN博客</a></p><p><a href="https://blog.csdn.net/longintchar/article/details/70149027">BIOS中断实现延时-CSDN博客</a></p><p>功能描述：延迟</p><p>入口参数：AH＝86H</p><p>CX:DX＝微秒</p><p>出口参数：CF＝0——操作成功，AH＝00H</p><ul><li>总微秒数 &#x3D; CX * 65536 + DX</li><li>例如，如果CX &#x3D; 0001h，DX &#x3D; 86A0h，则延时为： 0001h * 65536 + 86A0h &#x3D; 65536 + 34464 &#x3D; 100,000微秒 &#x3D; 100毫秒</li></ul><table><thead><tr><th>延时时间</th><th>CX值</th><th>DX值</th><th>16进制总微秒</th></tr></thead><tbody><tr><td>10毫秒</td><td>0000h</td><td>2710h</td><td>0000’2710h</td></tr><tr><td>50毫秒</td><td>0000h</td><td>C350h</td><td>0000’C350h</td></tr><tr><td>100毫秒</td><td>0001h</td><td>86A0h</td><td>0001’86A0h</td></tr><tr><td>250毫秒</td><td>0003h</td><td>D090h</td><td>0003’D090h</td></tr><tr><td>500毫秒</td><td>0007h</td><td>A120h</td><td>0007’A120h</td></tr><tr><td>1秒</td><td>000Fh</td><td>4240h</td><td>000F’4240h</td></tr><tr><td>5秒</td><td>004Ch</td><td>4B40h</td><td>004C’4B40h</td></tr></tbody></table><p>代码示例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">; 延时100毫秒</span><br><span class="hljs-symbol">delay_100ms:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">86h</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">0001h</span>    <span class="hljs-comment">; 100,000微秒的高16位</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">86A0h</span>    <span class="hljs-comment">; 100,000微秒的低16位</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">15h</span><br>    <span class="hljs-keyword">ret</span><br><br><span class="hljs-comment">; 延时1秒</span><br><span class="hljs-symbol">delay_1s:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>, <span class="hljs-number">86h</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, <span class="hljs-number">000Fh</span>    <span class="hljs-comment">; 1,000,000微秒的高16位</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>, <span class="hljs-number">4240h</span>    <span class="hljs-comment">; 1,000,000微秒的低16位</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">15h</span><br>    <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><h4 id="movzx"><a href="#movzx" class="headerlink" title="movzx"></a>movzx</h4><p><a href="https://blog.csdn.net/chuanwang66/article/details/83973495">理解MOVZX指令：汇编语言数据传送的无符号扩展-CSDN博客</a></p><p>用处是将数据从源操作数复制到目的操作数，并使用零扩展将剩余高位填充为0.</p><p><code>movzx destination, source</code></p><p>代码中奖ch移动到bx，将一个8位的寄存器复制到16位寄存器并进行了零扩展。</p><p>类似：movsx（复制并进行符号扩展）</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>OS_Labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>OS_Labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid魔改记录</title>
    <link href="/2025/03/05/Fluid%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/03/05/Fluid%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol><li>创建custom文件夹以及 <code>.css</code>和 <code>.js</code>文件</li></ol><h2 id="标签变化"><a href="#标签变化" class="headerlink" title="标签变化"></a>标签变化</h2><p>离开界面和处于界面有不同文字。</p><p>参考：<a href="https://asteri5m.icu/archives/0c8538e7-5b5f-4897-8e8b-0cff84320473">Hexo&amp;Fluid魔改笔记 - Asteri5m的小破站</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 浏览器搞笑标题</span><br>varOriginTitle = <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span>;<br><span class="hljs-keyword">var</span> titleTime;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">hidden</span>) &#123;<br>$(<span class="hljs-string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&quot;/funny.ico&quot;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;╭(°A°`)╮ 页面崩溃啦 ~&#x27;</span>;<br><span class="hljs-built_in">clearTimeout</span>(titleTime);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>$(<span class="hljs-string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&quot;/img/newtubiao.png&quot;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~&#x27;</span> + <span class="hljs-title class_">OriginTitle</span>;<br>titleTime = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-title class_">OriginTitle</span>;<br>&#125;, <span class="hljs-number">2000</span>);<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后将路径添加到custom下就可以了</p><ol start="2"><li>配置obsidian中的图片路径<br>安装插件custom attachment location，同时设置如下图：<br><img src="/img/file-20250329000741766.png"><br>然后设置文件与链接中的设置：<br><img src="/img/file-20250329000655306.png"></li></ol><p>最近又莫名其妙出现了图片显示不了的问题，匪夷所思，发现root设置自己改掉了。，。，最后重新加上解决了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Writing</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">True</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">external_link:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Open external links in new tab</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">site</span> <span class="hljs-comment"># Apply to the whole site</span><br>  <span class="hljs-attr">exclude:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">render_drafts:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 修改为false</span><br><span class="hljs-attr">relative_link:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 修改为false，这是关键</span><br><span class="hljs-attr">future:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">syntax_highlighter:</span> <span class="hljs-string">highlight.js</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">auto_detect:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">wrap:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hljs:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">prismjs:</span><br>  <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span> <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>以及：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">url:</span> https:<span class="hljs-symbol">//pqcu77.github.io</span><br><span class="hljs-params">root:</span> <span class="hljs-symbol">/</span><br><span class="hljs-params">permalink:</span> <span class="hljs-meta">:year</span><span class="hljs-operator">/</span>:month<span class="hljs-operator">/</span>:day<span class="hljs-operator">/</span>:title<span class="hljs-symbol">/</span><br><span class="hljs-params">permalink_defaults:</span><br><span class="hljs-params">pretty_urls:</span><br>  <span class="hljs-params">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-params">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></code></pre></td></tr></table></figure><p>在这里添加 <code>root: /</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>record</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python_basic</title>
    <link href="/2025/03/03/python-basic/"/>
    <url>/2025/03/03/python-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-basic-for-AI-course"><a href="#Python-basic-for-AI-course" class="headerlink" title="Python-basic for AI course"></a>Python-basic for AI course</h1><p>实验课要求：</p><p>课件：<a href="https://github.com/pqcu77/2025AI/tree/main">https://github.com/pqcu77/2025AI/tree/main</a></p><h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><p>资料：<a href="https://python.iswbm.com/">https://python.iswbm.com/</a></p><p><a href="https://www.runoob.com/python3/python3-tutorial.html">https://www.runoob.com/python3/python3-tutorial.html</a></p><p><strong>常用conda命令</strong>:</p><ul><li><p><code>conda env list</code> 查看conda环境列表</p></li><li><p><code>conda create –n env_id python=3.9</code> 创建新py3.9虚</p></li></ul><p>拟环境</p><ul><li><p><code>conda activate env_id</code> 激活对应python环境</p></li><li><p><code>conda deactivate</code> 关闭对应python环境</p></li></ul><p><strong>print():</strong></p><ul><li>输入参数为要打印的对象，对象可以有多个</li><li>sep参数，默认值为” “—默认用空格隔开</li><li>end参数，默认值为 “\n”</li></ul><p><strong>input():</strong></p><ul><li>输入参数可以作为<strong>提示字符串</strong>。会打印出来“提示”用户</li><li>返回值是读入的字符串</li></ul><h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><p><strong>简单&#x2F;基本数据类型</strong></p><ul><li><p>数字</p><ul><li><p>整数</p></li><li><p>浮点数</p></li><li><p>布尔值：True &#x2F; False （注意大写）</p><ul><li>int(True)返回1，int(False)返回0</li></ul></li><li><p>字符串</p><ul><li>※空值：<strong>a &#x3D; None</strong></li></ul></li></ul></li></ul><p><strong>计算</strong></p><ul><li>整数：加（+）、减（-）、乘（*）、除（&#x2F;）、<strong>整除（&#x2F;&#x2F;）</strong>、幂（**）、<strong>模（%）</strong></li><li>浮点数：加（+）、减（-）、乘（*）、除（&#x2F;）、<strong>整除（&#x2F;&#x2F;）</strong>、幂（**）</li><li>四舍五入保留k位：round(x,k)</li></ul><p><strong>函数：</strong></p><ul><li>绝对值：abs()</li><li>最大，最小值：max(),min()</li><li>math模块</li></ul><p>**运算符：<strong>如+&#x3D;，</strong>&#x3D;等。python没有<code>++</code>，<code>--</code>运算符</p><p><strong>字符串</strong></p><ul><li><p><strong>引号</strong>括起的。可以是单引号也可以是双引号</p></li><li><p>拼接：</p><ul><li>用 <code>+</code> 来拼接—慢</li><li>用 <code>*</code> 来<strong>重复</strong>自拼接。如print(”hello”*4)</li></ul></li><li><p>大小写转换</p><ul><li>title()：首字母转换为大写</li><li>lower()</li><li>upper()</li></ul></li><li><p>常用函数</p><ul><li>删除空白：<ul><li>str.strip()  删除字符串<strong>前后</strong>的空白字符</li><li>str.rstrip() 删除字符串**后面（右边）**的空白字符<ul><li>str.lstrip() 删除字符串**前面（左边）**的空白字符</li></ul></li></ul></li><li>分割<ul><li><strong>print(sentence.split())</strong></li><li><strong>print(sentence.split(“,”))</strong></li></ul></li><li><strong>替换</strong></li></ul><p><strong>sentence &#x3D; “Life is short, you need Python.”</strong></p><p><strong>print(sentence.replace(“h”, “XD”))</strong></p><p><strong>print(sentence.replace(“short”, “long”).replace(“Python”, “C++”))</strong></p></li></ul><p><strong>类型转换</strong></p><ul><li>datatype() →如：int(),float(),str()…</li><li><code>print(int(4/3))</code></li><li></li></ul><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><ul><li>代码块与<strong>缩进</strong>；用缩进来区分关系</li><li>比较运算符</li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于 - 比较对象是否相等</td><td>(a &#x3D;&#x3D; b) 返回 False</td></tr><tr><td>!&#x3D;</td><td>不等于 - 比较两个对象是否不相等</td><td>(a !&#x3D; b) 返回 True</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td><td>(a &gt; b) 返回 False</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y</td><td>(a &lt; b) 返回 True</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于 - 返回x是否大于等于y</td><td>(a &gt;&#x3D; b) 返回 False</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于 - 返回x是否小于等于y</td><td>(a &lt;&#x3D; b) 返回 True</td></tr></tbody></table><p>逻辑控制符：and or not</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y返回 x 的值，否则返回 y 的计算值。</td><td>(a and b) 返回 20</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” - 如果 x 是 True，它返回 x的值，否则它返回 y 的计算值。</td><td>(a or b) 返回 10</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回False。如果 x 为 False，它返回 True。</td><td>not (a and b) 返回False</td></tr></tbody></table><p>分支结构：</p><ul><li><p><code>if</code> 和 <code>elif</code>，后面加冒号，无大括号</p></li><li><pre><code class="hljs">while<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>  - <span class="hljs-keyword">break</span>和<span class="hljs-keyword">continue</span>；用法类似c++<br><br>```python<br><span class="hljs-keyword">while</span> condition:<br><span class="hljs-keyword">do</span> something<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>for</code> ：常与迭代器一同使用</p><ul><li><code>range(n)</code>—从0遍历到n-1，步长为1</li><li><code>range(a,b)</code> —从a遍历到b-1。左闭右开</li><li><code>range(start,stop,step)</code> —从start遍历到stop-step，步长为step，step默认为1</li></ul></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>列表list</strong></p><ul><li>类似与数组，由一系列按特定顺序排列的元素构成</li><li>list里的元素<strong>可以是不同类型</strong></li><li>访问元素：<ul><li>索引访问：可以是<strong>非负索引</strong>也可以是<strong>负索引</strong></li></ul></li><li>修改—可以动态增删&amp;修改</li><li>添加<ul><li><code>append()</code> 在末尾添加</li><li><code>insert()</code> 插入</li></ul></li><li>删除<ul><li><code>del xxx</code> —使用del语句删除</li><li><code>remove()</code>—按值删除元素</li><li><code>pop()</code></li></ul></li><li>长度：<code>len()</code></li><li>翻转：<code>reverse()</code> —原地操作，永久修改</li><li>排序</li><li>切片<ul><li><code>list[start:end]</code>   <code>list[start:end:step]</code></li></ul></li><li>赋值（浅复制），指向同一块内存<ul><li>可以用id()函数来获取对象的内存地址</li><li>身份运算符 <code>is</code> ：x is y ⇒id(x)&#x3D;&#x3D;id(y) 表示二者指向同一块内存。</li><li><code>is</code> 和 <code>==</code> 是不一样的，后者是用于判断引用变量的值是否相等</li></ul></li><li>复制<ul><li>深复制</li><li>浅复制</li></ul></li><li>遍历： <strong><code>for ele in list:</code></strong> 前面这个是遍历全体，或者是range来选定一个范围</li></ul><h3 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h3><ul><li><strong>不可变</strong>的列表</li><li><strong>圆括号标识</strong></li></ul><h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><ul><li>无序不重复的元素序列</li></ul><h3 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h3><ul><li>键值对</li><li>访问字典中的值，dic(”key”);</li><li>修改值</li><li>添加键值对</li><li>删除键值对：del</li><li>遍历所有的键值对 <code>for key,value in dic.items():</code></li><li>遍历所有键 <code>for key in dic.keys():</code></li><li>遍历所有值 <code>for value in dic.values():</code></li></ul><p>两个字典同时遍历：</p><ul><li>以key同时遍历两个字典（两个字典长度一样，否则以最短的次数输出）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_map = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;<br>dict_map1 = &#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;hi&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> key1, key2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(dict_map.keys(), dict_map1.keys()):<br>    <span class="hljs-built_in">print</span>(key1, dict_map[key1], key2, dict_map1[key2])<br></code></pre></td></tr></table></figure><ul><li>以key、value同时遍历两个字典（两个字典长度一样，否则以最短的次数输出）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_map = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;<br>dict_map1 = &#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;hi&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(dict_map.items(), dict_map1.items()):<br>    <span class="hljs-built_in">print</span>(key, value)                    <br></code></pre></td></tr></table></figure><ul><li>逐项同时遍历两个字典（两个字典长度一样，否则以最短的次数输出）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_map = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;world&#x27;</span>&#125;<br>dict_map1 = &#123;<span class="hljs-number">3</span>: <span class="hljs-string">&#x27;hi&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> kv <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(dict_map.items(), dict_map1.items()):<br>    <span class="hljs-built_in">print</span>(kv)<br></code></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/wsq119/article/details/115221881">https://blog.csdn.net/wsq119/article/details/115221881</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>结构：def开头，函数名，括号，冒号结尾，紧跟的所有缩进构成函数体</p><ul><li>可以处理一组数据，并返回一个或一组值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_formatted_name</span>(<span class="hljs-params">first_name, last_name, middle_name=<span class="hljs-string">&#x27;&#x27;</span></span>):<br><span class="hljs-keyword">if</span> middle_name:<br>full_name = first_name + <span class="hljs-string">&#x27; &#x27;</span> + middle_name + <span class="hljs-string">&#x27; &#x27;</span> + last_name<br><span class="hljs-keyword">return</span> full_name.title()<br><span class="hljs-keyword">else</span>:<br>full_name = first_name + <span class="hljs-string">&#x27; &#x27;</span> + last_name<br><span class="hljs-keyword">return</span> first_name.title(), last_name.title()<br></code></pre></td></tr></table></figure><ul><li>用一个或多个变量存储返回的值，或直接使用返回的值</li></ul><h3 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h3><ul><li>位置实参：基于实参的顺序，将实参关联到啊哈怒火定义中的形参</li><li>默认值：具有默认值的形参<strong>需排列在参数列表后面</strong>（才能达到可以省略的目的）</li><li>关键字实参：无需考虑实参顺序。将形参变量名写出来，然后赋值</li></ul><p><img src="/img/func.png" alt="func"></p><ul><li>对某些数据类型来说，在函数内部对传入变量做的修改，会导致函数外的值夜发生修改，产生副作用（<strong>列表、字典</strong>会改，但数值、字符串不改）<ul><li>对于数值、字符串等，可以通过返回值传到函数外</li></ul></li></ul><p>如果希望不影响函数外的话：向函数传递列表副本</p><ul><li>利用切片创建副本 list_name[:]</li><li>形参前加<code>*</code>号，可以传递<strong>任意数量的实参</strong></li><li>形参前加<code>**</code>号，可以传递<strong>任意数量的关键字实参</strong></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight plaintext"><figcaption><span>Dog</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs class">class Dog():<br>def __init__(self, name, age):<br>self.name = name<br>self.age = age<br>def sit(self):<br>        print(self.name.title() + &quot; is now sitting.&quot;)<br>def roll_over(self):<br>print(self.name.title() + &quot; rolled over!&quot;)<br></code></pre></td></tr></table></figure><ul><li><p>方法<code>_init_()</code>：构造函数，创建新对象自动调用</p></li><li><p>self：</p><ul><li><strong>必须</strong>写在所有方法参数列表的<strong>第一位</strong></li><li>指代这个对象本身</li><li>以self为前缀的成员变量可供类中所有方法使用–属性</li><li>self.variable可以访问、创建与修改属性值</li></ul></li><li><p>python的类属性默认是公有属性，要标记为私有的则要在变量名或函数名前加上两个下划线 “<code>__</code>”</p></li><li><p>属性修改：<strong>最好写一个update的方法</strong></p><ul><li>也可以直接修改，但破坏了封装</li></ul></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p><code>class 子类名(父类名)</code>   </p></li><li><p>super()–在子类中通过<code>super()</code>指向父类</p></li><li><p>允许父类调用子类的方法</p></li><li><p>子类可以重写父类的方法，可以添加新的属性和方法，继承所有父类的方法</p></li></ul><h2 id="文件与异常"><a href="#文件与异常" class="headerlink" title="文件与异常"></a>文件与异常</h2><ul><li>读取文件：read()</li><li>open() ：参数是文件路径（相对路径和绝对路径都可以）<ul><li>open(“文件路径”，“模式”)，对于模式参数：<ul><li>‘r’：读取模式（默认）</li><li>‘w’：写入模式, 如果该文件已存在则打开文件，并从开头开始编辑<br>，即原有内容会被删除。如果该文件不存在，创建新文件。</li><li>‘a’：追加模式. 如果该文件已存在，文件指针将会放在文件的结尾<br>。也就是说，新的内容将会被写入到已有内容之后。如果该文件不<br>存在，创建新文件进行写入</li></ul></li></ul></li><li>with()：在不再需要访问文件后将文件关闭，无需调用close()</li><li>逐行读取 readlines()</li><li>只能将字符串写入文件，如果需要换行，记得写换行符</li></ul><h3 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h3><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a>**Python 3 中的 File 对象不支持 next() 方法。**返回文件下一行。</td></tr><tr><td align="left">6</td><td align="left">[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left">7</td><td align="left">[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td></tr><tr><td align="left">8</td><td align="left">[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left">9</td><td align="left">[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td></tr><tr><td align="left">11</td><td align="left">[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table><p>举例：</p><ul><li>读取文件：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;num.txt&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        <span class="hljs-comment">#1.打印整个文档</span><br>        <span class="hljs-comment"># num=file.read()</span><br>        <span class="hljs-comment"># print(num)</span><br>        <br>        <span class="hljs-comment">#2.逐行读取并打印</span><br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file.readlines():<br>            <span class="hljs-comment"># print(line)#这里由于没有去除换行符，会导致换行符单独占据一行</span><br>            <span class="hljs-built_in">print</span>(line.rstrip()) <span class="hljs-comment">#这样子会去掉换行符</span><br>        <br>        <br>        <br>main()<br></code></pre></td></tr></table></figure><p>情况1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>情况2.1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>情况2.2：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><ul><li>写文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;num.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file: <span class="hljs-comment">#这里设置为write模式</span><br>        file.write(<span class="hljs-string">&quot;hello world\n&quot;</span>)<br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;num.txt&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-keyword">as</span> file: <span class="hljs-comment">#设置为append模式</span><br>        file.write(<span class="hljs-string">&quot;appending...&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li><p>将函数与类存储在被称为模块的独立文件中，与主程序分离</p></li><li><p>模块式拓展名为<code>.py</code>的文件，包含要导入到程序中的代码</p></li><li><p>模块导入</p><ul><li>导入整个模块 <code>import module</code></li><li>导入部分函数或类 <code>from module_name import func</code> <code>from module_name import class_name</code></li><li><code>import module_name as nickname</code></li><li><code>from module_name import funcName as nickName</code></li><li><code>from moduleNmae import *</code></li></ul></li><li><p>导入一个模块时，该模块文件的无缩进代码将直接执行</p></li><li><p>在编写自己的模块时，模块测试代码等要记得缩进于<code>if __name__ ==</code> </p><p><code>&#39;__main__&#39;</code>:<a href="https://www.zhihu.com/question/49136398">if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘ 如何正确理解? - 知乎</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫</title>
    <link href="/2025/03/02/%E7%88%AC%E8%99%AB/"/>
    <url>/2025/03/02/%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><hr><h2 id="简单概念"><a href="#简单概念" class="headerlink" title="简单概念"></a>简单概念</h2><p>网络爬虫：模拟浏览器发送网络请求，接受请求响应，一种按一定规则，自动地抓取互联网信息的程序</p><ul><li>可以用于自动地从网络上获取信息，节省人工</li></ul><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><ul><li>可以使用python</li><li>一些可能使用到的库：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- codeing = utf-8 -*-</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup  <span class="hljs-comment"># 网页解析，获取数据</span><br><span class="hljs-keyword">import</span> re  <span class="hljs-comment"># 正则表达式，进行文字匹配`</span><br><span class="hljs-keyword">import</span> urllib.request, urllib.error  <span class="hljs-comment"># 制定URL，获取网页数据</span><br><span class="hljs-keyword">import</span> xlwt  <span class="hljs-comment"># 进行excel操作</span><br><span class="hljs-comment">#import sqlite3  # 进行SQLite数据库操作</span><br><br></code></pre></td></tr></table></figure></li><li><code># coding=utf-8</code> 或 <code># -*- coding: utf-8 -*-</code> 来指定源代码的编码方式，防止乱码</li></ul><h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><ol><li>爬取网页</li><li>逐一解析数据</li><li>保存网页</li></ol><h3 id="详细展开"><a href="#详细展开" class="headerlink" title="详细展开"></a>详细展开</h3><p><strong>爬取网页：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>):  <span class="hljs-comment"># 调用获取页面信息的函数，10次</span><br>      url = baseurl + <span class="hljs-built_in">str</span>(i * <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><p>baseurl是要爬虫的网址，加上的str(i*25)是用于 <strong>翻页</strong> ，通过这样子设置可以跳转到不同的界面</p><p><code>askURL()</code>用于请求网页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">askURL</span>(<span class="hljs-params">url</span>):<br>    head = &#123;  <span class="hljs-comment"># 模拟浏览器头部信息，向豆瓣服务器发送消息</span><br>        <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla / 5.0(Windows NT 10.0; Win64; x64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 80.0.3987.122  Safari / 537.36&quot;</span><br>    &#125;<br>    <span class="hljs-comment"># 用户代理，表示告诉豆瓣服务器，我们是什么类型的机器、浏览器（本质上是告诉浏览器，我们可以接收什么水平的文件内容）</span><br><br>    request = urllib.request.Request(url, headers=head)<br>    html = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        response = urllib.request.urlopen(request)<br>        html = response.read().decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">except</span> urllib.error.URLError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;code&quot;</span>):<br>            <span class="hljs-built_in">print</span>(e.code)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(e, <span class="hljs-string">&quot;reason&quot;</span>):<br>            <span class="hljs-built_in">print</span>(e.reason)<br>    <span class="hljs-keyword">return</span> html<br><br></code></pre></td></tr></table></figure><p>head用于模拟浏览器头部信息，相当于我们在模拟人工查询网页时目标服务器会接受到的信息</p><p>如果不写head可能会被认出来是爬虫，导致错误</p><p><strong>逐一解析数据：</strong></p><p>解析数据用到了BeautifulSoup这个库（爬虫必备库）</p><p>用正则表达式去匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">findLink = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;</span>)  <span class="hljs-comment"># 创建正则表达式对象，标售规则   影片详情链接的规则</span><br>findImgSrc = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;img.*src=&quot;(.*?)&quot;&#x27;</span>, re.S)<br>findTitle = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;title&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findRating = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findJudge = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span&gt;(\\d*)人评价&lt;/span&gt;&#x27;</span>)<br>findInq = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;inq&quot;&gt;(.*)&lt;/span&gt;&#x27;</span>)<br>findBd = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;p class=&quot;&quot;&gt;(.*?)&lt;/p&gt;&#x27;</span>, re.S)<br></code></pre></td></tr></table></figure><p>一些解释：</p><ul><li><code>r&#39;&#39;</code> ：用于表示python的原始字符串，避免 <code>\\</code> 作为转义符干扰，让正则表达式更易读</li><li><code>&lt;p class=&quot;&quot;&gt;</code><ul><li>这里匹配 <code>&lt;p&gt;</code>标签，要求 <code>class</code>属性为空</li><li>如果网页class属性省略了，还需要调整匹配方式</li></ul></li><li><code>(.*?)</code><ul><li>小括号表示一个捕获组，可以提取匹配到的内容</li><li><code>.*?</code> ：<ul><li><code>.</code> 匹配任意字符</li><li><code>*?</code> 非贪婪匹配，匹配尽可能少的字符，遇到 <code>&lt;/p&gt;</code>（结束标签）就停止</li><li><code>*</code> 表示匹配任意次数，但 <code>?</code> 让它变成非贪婪模式</li></ul></li></ul></li><li><code>re.S</code> (<code>re.DOTALL</code>)<ul><li>让 <code>.</code> 可以匹配换行符，<code>&lt;p&gt;</code>标签内部文本可以是多行的</li><li>如果没有 <code>re.S</code>，换行符 <code>\\n</code>可能会导致匹配失败</li></ul></li></ul><p><strong>保存数据：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">saveData(datalist,savepath)      <span class="hljs-comment">#2种存储方式可以只选择一种</span><br><span class="hljs-comment"># saveData2DB(datalist,dbpath)</span><br></code></pre></td></tr></table></figure><p>保存数据可以选择保存到 xls表（xlwt库支持），或者保存到sqlite数据库（sqlite3库支持）</p><ul><li>保存到xls：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params">datalist,savepath</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;save.......&quot;</span>)<br>    book = xlwt.Workbook(encoding=<span class="hljs-string">&quot;utf-8&quot;</span>,style_compression=<span class="hljs-number">0</span>) <span class="hljs-comment">#创建workbook对象</span><br>    sheet = book.add_sheet(<span class="hljs-string">&#x27;豆瓣电影Top250&#x27;</span>, cell_overwrite_ok=<span class="hljs-literal">True</span>) <span class="hljs-comment">#创建工作表</span><br>    col = (<span class="hljs-string">&quot;电影详情链接&quot;</span>,<span class="hljs-string">&quot;图片链接&quot;</span>,<span class="hljs-string">&quot;影片中文名&quot;</span>,<span class="hljs-string">&quot;影片外国名&quot;</span>,<span class="hljs-string">&quot;评分&quot;</span>,<span class="hljs-string">&quot;评价数&quot;</span>,<span class="hljs-string">&quot;概况&quot;</span>,<span class="hljs-string">&quot;相关信息&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>):<br>        sheet.write(<span class="hljs-number">0</span>,i,col[i])  <span class="hljs-comment">#列名</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">250</span>):<br>        <span class="hljs-comment"># print(&quot;第%d条&quot; %(i+1))       #输出语句，用来测试</span><br>        data = datalist[i]<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>):<br>            sheet.write(i+<span class="hljs-number">1</span>,j,data[j])  <span class="hljs-comment">#数据</span><br>    book.save(savepath) <span class="hljs-comment">#保存</span><br></code></pre></td></tr></table></figure><p><code>sheet = book.add_sheet(&#39;豆瓣电影Top250&#39;, cell_overwrite_ok=True) #创建工作表</code></p><p>创建工作表</p><p><code>col = (&quot;电影详情链接&quot;,&quot;图片链接&quot;,&quot;影片中文名&quot;,&quot;影片外国名&quot;,&quot;评分&quot;,&quot;评价数&quot;,&quot;概况&quot;,&quot;相关信息&quot;)</code></p><p>创建列</p><p>But!这个xls有点老旧的样子，在vscode和wps都没办法打开文件，所以叫ai重写了一下。改为使用openpyxl库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">saveData</span>(<span class="hljs-params">datalist, savepath</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在保存数据......&quot;</span>)<br>    wb = openpyxl.Workbook()<br>    sheet = wb.active<br>    sheet.title = <span class="hljs-string">&quot;豆瓣电影Top250&quot;</span><br>    col = [<span class="hljs-string">&quot;电影详情链接&quot;</span>, <span class="hljs-string">&quot;图片链接&quot;</span>, <span class="hljs-string">&quot;影片中文名&quot;</span>, <span class="hljs-string">&quot;影片外国名&quot;</span>, <span class="hljs-string">&quot;评分&quot;</span>, <span class="hljs-string">&quot;评价数&quot;</span>, <span class="hljs-string">&quot;概况&quot;</span>, <span class="hljs-string">&quot;相关信息&quot;</span>]<br>    sheet.append(col)<br>  <br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> datalist:<br>        sheet.append(data)<br><br>    wb.save(savepath)<br><br></code></pre></td></tr></table></figure><h2 id="开展："><a href="#开展：" class="headerlink" title="开展："></a>开展：</h2><p>（一）分析目标网站</p><p>在编写爬虫前，先查看目标网站的robots.txt文件，了解网站允许的爬取范围。同时，使用浏览器开发者工具（F12）检查页面结构，分析数据所在位置和标签特征。</p><p>（二）发送请求</p><p>利用工具向目标网站发送HTTP请求，获取网页内容。在发送请求时，要注意设置合适的请求头，模拟真实浏览器行为，避免被网站识别为爬虫。</p><p>（三）解析内容</p><p>将获取到的网页内容进行解析，提取所需数据。根据网页结构和数据特点，选择合适的解析工具和方法。</p><p>（四）存储数据</p><p>将提取到的数据存储到本地文件或数据库中，方便后续使用和分析。根据数据量和使用需求，选择合适的存储方式。</p><p>（五）处理动态内容</p><p>对于动态生成的网页内容，需要使用专门的工具模拟浏览器操作，获取完整的页面数据。在处理动态内容时，要注意页面加载时间和操作的稳定性。</p><p>（六）反爬策略应对</p><p>网站为了保护自身数据，会采取各种反爬措施。可以通过设置请求头、使用代理IP、添加延迟等方式应对反爬策略，确保爬虫的稳定运行。</p><h2 id="Requests库"><a href="#Requests库" class="headerlink" title="Requests库"></a>Requests库</h2><h3 id="七个主要方法"><a href="#七个主要方法" class="headerlink" title="七个主要方法"></a>七个主要方法</h3><p><code>req.request()</code> 构造一个请求</p><p><code>req.get()</code> 获取HTML网页</p><p><code>req.head()</code> 获取HTML网页头信息</p><p><code>req.post()</code> 向HTML网页提交POST请求</p><p><code>req.put()</code> 提交PUT请求</p><p><code>req.patch()</code> 提交局部修改请求</p><p><code>req.delete()</code> 提交删除请求</p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>$ 表示结束匹配</strong></p><table><thead><tr><th><strong>元字符</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配<strong>任意</strong>一个字符（除了换行符 <code>\\n</code>）</td><td><code>a.b</code>匹配 <code>&quot;acb&quot;</code>、<code>&quot;a2b&quot;</code></td></tr><tr><td><code>^</code></td><td>匹配<strong>行首</strong></td><td><code>^abc</code>只能匹配 <code>&quot;abc&quot;</code>在字符串开头的情况</td></tr><tr><td><code>$</code></td><td>匹配<strong>行尾</strong></td><td><code>xyz$</code>只能匹配 <code>&quot;xyz&quot;</code>在字符串结尾的情况</td></tr><tr><td><code>*</code></td><td>匹配<strong>0 或多次</strong>前面的字符</td><td><code>ab*c</code>匹配 <code>&quot;ac&quot;</code>、<code>&quot;abc&quot;</code>、<code>&quot;abbc&quot;</code></td></tr><tr><td><code>+</code></td><td>匹配<strong>1 或多次</strong>前面的字符</td><td><code>ab+c</code>匹配 <code>&quot;abc&quot;</code>、<code>&quot;abbc&quot;</code>，但不匹配 <code>&quot;ac&quot;</code></td></tr><tr><td><code>?</code></td><td>匹配<strong>0 或 1 次</strong>前面的字符</td><td><code>ab?c</code>匹配 <code>&quot;ac&quot;</code>和 <code>&quot;abc&quot;</code></td></tr><tr><td><code>&#123;m,n&#125;</code></td><td>匹配<strong>m 到 n 次</strong>前面的字符</td><td><code>ab&#123;1,3&#125;c</code>匹配 <code>&quot;abc&quot;</code>、<code>&quot;abbc&quot;</code>、<code>&quot;abbbc&quot;</code></td></tr></tbody></table><table><thead><tr><th><strong>符号</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>\\d</code></td><td>匹配<strong>数字</strong> （等价于 <code>[0-9]</code>）</td><td><code>\\d+</code>匹配 <code>&quot;123&quot;</code></td></tr><tr><td><code>\\D</code></td><td>匹配<strong>非数字</strong> （等价于 <code>[^0-9]</code>）</td><td><code>\\D+</code>匹配 <code>&quot;abc&quot;</code></td></tr><tr><td><code>\\w</code></td><td>匹配<strong>单词字符</strong> （字母、数字、下划线 <code>a-zA-Z0-9_</code>）</td><td><code>\\w+</code>匹配 <code>&quot;hello123&quot;</code></td></tr><tr><td><code>\\W</code></td><td>匹配<strong>非单词字符</strong> （等价于 <code>[^a-zA-Z0-9_]</code>）</td><td><code>\\W+</code>匹配 <code>&quot;$#@&quot;</code></td></tr><tr><td><code>\\s</code></td><td>匹配<strong>空白字符</strong> （空格、Tab、换行）</td><td><code>\\s+</code>匹配 <code>&quot; &quot;</code></td></tr><tr><td><code>\\S</code></td><td>匹配<strong>非空白字符</strong></td><td><code>\\S+</code>匹配 <code>&quot;hello&quot;</code></td></tr></tbody></table><p><code>.*</code> 默认匹配<strong>尽可能多</strong>的字符：默认为贪婪匹配</p><p>使用 <code>*?</code> 或 <code>+?</code> 让匹配 <strong>尽可能少</strong> ：非贪婪匹配</p><h3 id="Python-正则表达式常用方法"><a href="#Python-正则表达式常用方法" class="headerlink" title="Python 正则表达式常用方法"></a><strong>Python 正则表达式常用方法</strong></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>re.match(pattern, string)</code></td><td><strong>从头</strong>匹配字符串</td></tr><tr><td><code>re.search(pattern, string)</code></td><td><strong>搜索</strong>第一个匹配项</td></tr><tr><td><code>re.findall(pattern, string)</code></td><td>返回<strong>所有匹配项</strong> （列表）</td></tr><tr><td><code>re.finditer(pattern, string)</code></td><td>以迭代器返回所有匹配项</td></tr><tr><td><code>re.sub(pattern, repl, string)</code></td><td><strong>替换</strong>匹配项</td></tr><tr><td><code>re.split(pattern, string)</code></td><td><strong>分割</strong>字符串</td></tr></tbody></table><h1 id="用爬虫爬idol的照片"><a href="#用爬虫爬idol的照片" class="headerlink" title="用爬虫爬idol的照片"></a>用爬虫爬idol的照片</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_images</span>(<span class="hljs-params">keyword, num_images=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-comment"># 随机 User-Agent 列表</span><br>    user_agents = [<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0.3 Safari/605.1.15&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#x27;</span>,<br>        <span class="hljs-string">&#x27;Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1&#x27;</span><br>    ]<br><br>    <span class="hljs-comment"># 创建会话</span><br>    session = requests.Session()<br><br>    <span class="hljs-comment"># Bing图片搜索URL</span><br>    url = <span class="hljs-string">f&#x27;&lt;https://cn.bing.com/images/search?q=<span class="hljs-subst">&#123;keyword&#125;</span>&amp;form=HDRSC2&amp;first=1&gt;&#x27;</span><br><br>    <span class="hljs-comment"># 随机选择一个 User-Agent</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: random.choice(user_agents),<br>        <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;&lt;https://cn.bing.com/&gt;&#x27;</span><br>    &#125;<br><br>    <span class="hljs-comment"># 发送请求</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始发送请求...&quot;</span>)<br>        response = session.get(url, headers=headers, timeout=<span class="hljs-number">10</span>)<br>        response.raise_for_status()  <span class="hljs-comment"># 检查请求是否成功</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求成功，状态码:&quot;</span>, response.status_code)<br>    <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;请求失败: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 解析页面</span><br>    soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><br>    <span class="hljs-comment"># 提取图片URL</span><br>    image_urls = []<br>    <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;img&#x27;</span>, class_=<span class="hljs-string">&#x27;mimg&#x27;</span>):<br>        img_url = img.get(<span class="hljs-string">&#x27;src&#x27;</span>)<br>        <span class="hljs-keyword">if</span> img_url <span class="hljs-keyword">and</span> img_url.startswith((<span class="hljs-string">&#x27;http://&#x27;</span>, <span class="hljs-string">&#x27;https://&#x27;</span>)):  <span class="hljs-comment"># 过滤无效 URL</span><br>            image_urls.append(img_url)<br><br>    <span class="hljs-comment"># 创建保存图片的文件夹</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&#x27;images&#x27;</span>):<br>        os.makedirs(<span class="hljs-string">&#x27;images&#x27;</span>)<br><br>    <span class="hljs-comment"># 下载图片</span><br>    <span class="hljs-keyword">for</span> i, img_url <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(image_urls[:num_images]):  <span class="hljs-comment"># 只取前 num_images 张</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 随机延时 2~5 秒</span><br>            time.sleep(random.uniform(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br><br>            <span class="hljs-comment"># 随机选择一个 User-Agent</span><br>            headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] = random.choice(user_agents)<br><br>            <span class="hljs-comment"># 发送请求</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始下载图片 <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>: <span class="hljs-subst">&#123;img_url&#125;</span>&quot;</span>)<br>            response = session.get(img_url, headers=headers, timeout=<span class="hljs-number">10</span>)<br>            response.raise_for_status()<br><br>            <span class="hljs-comment"># 保存图片</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;images/image_<span class="hljs-subst">&#123;i&#125;</span>.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(response.content)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;下载完成: image_<span class="hljs-subst">&#123;i&#125;</span>.jpg&#x27;</span>)<br>        <span class="hljs-keyword">except</span> requests.exceptions.RequestException <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;下载失败: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    keyword = <span class="hljs-string">&#x27;姚琛&#x27;</span><br>    num_images = <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始抓取 <span class="hljs-subst">&#123;num_images&#125;</span> 张 &#x27;<span class="hljs-subst">&#123;keyword&#125;</span>&#x27; 的图片...&quot;</span>)<br>    fetch_images(keyword, num_images)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序运行结束。&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>结果：</p><p>笔记参考&amp;资料：</p><p><a href="https://blog.csdn.net/bookssea/article/details/107309591">https://blog.csdn.net/bookssea/article/details/107309591</a></p><p><a href="https://www.runoob.com/python3/python-spider-beautifulsoup.html">https://www.runoob.com/python3/python-spider-beautifulsoup.html</a></p><p><a href="https://github.com/Ehco1996/Python-crawler?tab=readme-ov-file">https://github.com/Ehco1996/Python-crawler?tab=readme-ov-file</a></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>extra learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YatCPU</title>
    <link href="/2025/02/28/YatCPU/"/>
    <url>/2025/02/28/YatCPU/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul><li><strong>单周期 CPU</strong>：本实验的目的是从零开始编写一个可以运行 RV32I 指令集程序的单周期 CPU，这个 CPU 将会是后续所有实验的基础。完成本实验之后，可以通过仿真的方式，加载运行 RV32I 程序，验证正确性。</li><li><strong>中断机制</strong>：本实验在单周期 CPU 的基础上，添加了中断控制器以及中断控制流的内容，使单周期 CPU 可以处理来自外部设备的中断，响应 IO。完成本实验之后，CPU 将具备响应 UART 数据中断、时钟中断的功能，你将可以使用 UART 端口来操作 CPU 运行中的程序。</li><li><strong>流水线 CPU</strong>：本实验在以上两个实验基础上，对 CPU 进行性能优化，从单周期的 CPU 修改为多周期以及流水线的 CPU。本实验将通过几个性能评测，来验证 CPU 性能优化的效果。</li><li><strong>总线处理</strong>：本实验在流水线 CPU 的基础上，给 CPU 添加总线功能，实现外设与 CPU 的解耦。在完成总线实验后，添加外设无需修改 CPU 本身，只需要实现总线协议并与总线对接即可。本实验目的是进一步完善 CPU 实验的总体框架，提供更贴近真实计算机系统的结构实践。</li></ul><h1 id="Lab0—get-ready-for-experiment"><a href="#Lab0—get-ready-for-experiment" class="headerlink" title="Lab0—get ready for experiment"></a>Lab0—get ready for experiment</h1><blockquote><p>chisel 3基本学习</p></blockquote><h2 id="chisel3基本语法和功能"><a href="#chisel3基本语法和功能" class="headerlink" title="chisel3基本语法和功能"></a>chisel3基本语法和功能</h2><ul><li>区别举例：想要在chisel3中使用一个常量，要写<strong>when(value&#x3D;&#x3D;&#x3D;12.U)</strong>，而不是if(value&#x3D;&#x3D;12)</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li>无符号整数**<code>UInt</code><strong>与有符号整数</strong> <code>SInt</code>** ，使用.W来指定整数位宽（<code>Uint(8.W)</code>），.U来将scala中的整数转换为chisel3的<strong>硬件整数</strong>（见我们最开始举的例子）</li><li>布尔值Bool；使用.B来转换成硬件布尔值（如**<code>true.B</code>**)</li><li>模块：声明一个模块需要<strong>继承 <code>Module</code> 类</strong>，并通过 <code>io</code> 成员声明输入输出端口。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>_<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyModule</span> **extends Module** &#123;<br>    val io = <span class="hljs-built_in">IO</span>(<span class="hljs-keyword">new</span> Bundle &#123;<br>        val in = <span class="hljs-built_in">Input</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">8.</span>W))<br>        val out = <span class="hljs-built_in">Output</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">8.</span>W))<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>组合逻辑</li></ul><p><code>val wire = Wire(UInt(8.W))  val wireinit = WireInit(0.U(8.W))</code></p><ul><li>时序电路</li><li>寄存器</li></ul><p><code>val reg = Reg(UInt(8.W))  val reginit = RegInit(0.U(8.W))</code></p><h3 id="Chisel3-项目结构"><a href="#Chisel3-项目结构" class="headerlink" title="Chisel3 项目结构"></a>Chisel3 项目结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">- labx<br>    - coremark              # CPU 性能测试<br>    - csrc                  # 存放汇编语言和 C 语言源代码<br>    - project               <span class="hljs-meta"># sbt 的插件以及配置文件</span><br>    - src <br>        - main<br>            - scala         # Chisel <span class="hljs-number">3</span> 源代码 &lt;--<br>        - resources         # 资源文件<br>        - test<br>            - scala         # Chisel <span class="hljs-number">3</span> 测试代码 <br>    - target                <span class="hljs-meta"># sbt 生成的文件</span><br>    - test_run_dir          # 运行测试时生成的文件<br>    - verilog               # Verilog 代码<br>    - vivado                <span class="hljs-meta"># tcl 脚本以及约束文件（用于自动化烧板）</span><br>    - build.sbt             <span class="hljs-meta"># sbt 配置文件</span><br>  <br></code></pre></td></tr></table></figure><ul><li>反汇编：llvm-objdump<ul><li>目标文件反汇编：<code>objdump -s -d main.o &gt; main.o.txt</code> &#x2F;&#x2F;将main.o 反汇编并将结果输出到txt文件中。</li><li>可执行文件反汇编： <code>objdump -s -d main&gt; main.txt</code></li></ul></li></ul><p><strong>objdump反汇编常用参数</strong></p><ul><li><code>objdump -d &lt;file(s)&gt;</code>: 将代码段反汇编；</li><li><code>objdump -S &lt;file(s)&gt;</code>: 将代码段反汇编的同时，将反汇编代码与源代码交替显示，编译时需要使用 <code>g</code>参数，即需要调试信息；</li><li><code>objdump -C &lt;file(s)&gt;</code>: 将C++符号名逆向解析</li><li><code>objdump -l &lt;file(s)&gt;</code>: 反汇编代码中插入文件名和行号</li><li><code>objdump -j section &lt;file(s)&gt;</code>: 仅反汇编指定的section</li></ul><h1 id="Lab1：单周期CPU"><a href="#Lab1：单周期CPU" class="headerlink" title="Lab1：单周期CPU"></a>Lab1：单周期CPU</h1><p>本实验的目的：理解 CPU 的基本结构以及 CPU 是如何执行指令的。</p><ul><li><strong>基本概念</strong>，然后会按照指令执行的步骤逐步<strong>构造数据通路和控制单元</strong>（期间会留有填写代码的任务，请记得完成），最终构造成一个<strong>简单的单周期 RISC-V 处理器。</strong></li></ul><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><ul><li>数据通路：显示数据从一个组件流向另一个组件的所有方式。</li><li>控制信号：让各个数据通路部件知道自己要干什么。CPU 原理图中的 <strong>Decoder、ALUControl、JumpJudge</strong> 三个元件都可以看作控制单元。他们接收指令并输出控制信号。</li><li>组合单元与状态单元：组合逻辑电路构成的单元叫组合单元，时序逻辑电路构成的单元叫做状态单元。<ul><li>本实验中只有<strong>寄存器</strong>属于<strong>状态单元</strong>（内存不属于 CPU 内核的范畴），其余的均为组合单元。</li><li>组合单元：输出只取决于当前的输入，并且<strong>不需要时钟作为触发条件</strong>，输入会立即（不考虑延时）反映到输出</li><li>状态单元：存储了状态，并且<strong>以时钟作为触发条件</strong>，时钟的上升沿到来时输入才会反映到输出</li></ul></li></ul><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p>我们设计的 RISC-V CPU 能执行 RISC-V 指令的一个核心子集（RV32I）：</p><ul><li>算术逻辑指令：<code>add</code>、<code>sub</code>、<code>slt</code> 等</li><li>存储器访问指令：<code>lb</code>、<code>lw</code>、<code>sb</code> 等</li><li>分支指令：<code>beq</code>、<code>jar</code> 等</li></ul><p>我们将执行指令分<strong>为五个不同的阶段</strong>：</p><ul><li>取指：从内存中获取指令数据</li><li>译码：弄清楚这条指令的意义，并读取寄存器数据</li><li>执行：用 ALU 计算结果</li><li>访存（<code>load</code>&#x2F;<code>store</code> 指令）：读写内存</li><li>回写（除了 <code>store</code> 指令外所有指令）：将结果写回寄存器</li></ul><p>下面我们先按照上述步骤<strong>逐步构建数据通路部件</strong>，<strong>然后在 CPU 顶层模块将这些数据通路部件实例化并且连接起来</strong>。（下面涉及的代码都位于 <code>lab1/src/main/scala/riscv</code> 目录下）</p><p><a href="https://blog.csdn.net/weixin_43681766/article/details/122860354">Chisel教程——02.Chisel环境配置和第一个Chisel模块的实现与测试-CSDN博客</a></p><h3 id="取指："><a href="#取指：" class="headerlink" title="取指："></a>取指：</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/1e02e04b-2e21-4de8-a487-b25c0b342f76/image.png" alt="image.png"></p><p>重点：</p><ul><li>理解各个变量都是什么。，我们需要实现的是when指令有效时，先取出pc的当前指令，然后再判断是否需要jump—也就是判断jump_flag_id是否有效，如果有效就要把pc的值换成需要jump到的地址，否则就是顺序执行pc+4；</li><li>主要pc+4这个点，chisel语言写的比较不同4.U表示无符号的整数。</li></ul><p>进行测试：<code>sbt &quot;testOnly riscv.singlecycle.InstructionFetchTest&quot;</code></p><h3 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h3><p>一些知识：</p><ul><li>多路选择器：Mux</li></ul><p><code>Mux</code>类似于传统的三元运算符，参数依次为 <code>(条件, 为真时的值, 为假时的值)</code>，建议用 <code>true.B</code>和 <code>false.B</code>来创建Chisel中的布尔值。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c37be282-9bcc-4705-8144-c6416df8b2c7/image.png" alt="image.png"></p><p>重点：</p><ul><li><p>对于ALUop2，我有个小疑惑，提供的图里是0的时候连接reg，而1连接immediate，但是实际写的时候反过来了。不太理解。<strong>已经理解了，看前面提供的代码发现，所提供的Aluop2source结构体里面，reg对应的值是0，immediate对应的是1，故要对应上。</strong></p></li><li><p>注意不要漏，所有i指令都要添加上，他甚至有一个单独的lui没有被添加，要额外加上。主要就是看那个指令有没有i标识。</p></li><li><p>对于使能指令比较简单，一开始傻傻的还去使用Mux，其实完全没有必要，因为值仅仅是真或假，直接判断是否符合就行了。Mux一般用于给条件后，读取不同值（非0,1）</p><ul><li>只有load指令可以访问内存</li><li>只有store指令可以写入到内存</li><li>故自然而然得到结果</li></ul></li><li><p>稍微困难一点点的是写回输入来源，由于有四个来源，不能使用两个通路的Mux了，要使用MuxLookup。使用指南：</p><ul><li>三个参数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>_<br><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>util._<br><br>val key = <span class="hljs-built_in">Wire</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">3.</span>W))<br>val <span class="hljs-keyword">default</span> = <span class="hljs-number">0.</span>U<br>val lookupTable = <span class="hljs-built_in">Seq</span>(<br>  <span class="hljs-number">0.</span>U -&gt; <span class="hljs-string">&quot;b000&quot;</span>.U,<br>  <span class="hljs-number">1.</span>U -&gt; <span class="hljs-string">&quot;b001&quot;</span>.U,<br>  <span class="hljs-number">2.</span>U -&gt; <span class="hljs-string">&quot;b010&quot;</span>.U,<br>  <span class="hljs-number">3.</span>U -&gt; <span class="hljs-string">&quot;b011&quot;</span>.U<br>)<br><br>val result = <span class="hljs-built_in">MuxLookup</span>(key, <span class="hljs-keyword">default</span>, lookupTable)<br></code></pre></td></tr></table></figure><ul><li>两个参数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>_<br><span class="hljs-keyword">import</span> chisel<span class="hljs-number">3.</span>util._<br><br>val key = <span class="hljs-built_in">Wire</span>(<span class="hljs-built_in">UInt</span>(<span class="hljs-number">3.</span>W))<br>val <span class="hljs-keyword">default</span> = <span class="hljs-number">0.</span>U<br>val lookupTable = <span class="hljs-built_in">Seq</span>(<br>  <span class="hljs-number">0.</span>U -&gt; <span class="hljs-string">&quot;b000&quot;</span>.U,<br>  <span class="hljs-number">1.</span>U -&gt; <span class="hljs-string">&quot;b001&quot;</span>.U,<br>  <span class="hljs-number">2.</span>U -&gt; <span class="hljs-string">&quot;b010&quot;</span>.U,<br>  <span class="hljs-number">3.</span>U -&gt; <span class="hljs-string">&quot;b011&quot;</span>.U<br>)<br><br>val result = <span class="hljs-built_in">MuxLookup</span>(key, <span class="hljs-keyword">default</span>)(lookupTable)<br></code></pre></td></tr></table></figure><p>seq表示有序集合&#x2F;序列。然后箭头左右表示的是一种映射关系。</p></li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/cf433301-39de-45c2-96fe-9525ae145101/image.png" alt="image.png"></p><ul><li>目的：给ALU的输入端口赋值。</li><li>我们要看到ALU.scala实现文件：</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/75f5ed2a-c27b-4143-b645-20e150da257d/image.png" alt="image.png"></p><p>可以看到我们需要传入的是alu执行什么功能，op1和op2，然后他会计算出结果result。至于func的来源就是ALU_control，里面有一个output是会根据指令内容来输出alu_funct。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/583e23ee-4823-4aea-8aa4-ca69b16a7691/image.png" alt="image.png"></p><p>值得注意的是，我们在得到op1和op2时，op1_source和op2_source均是指示变量（类似于bool）表示输入来源，而没有运用我们上一个模块写的 如下：（或许是还没有到组合成一个完整单周期CPU的时候，尚且在一个周期一个周期实现，且各种数据来源比较割裂）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/62affc69-210d-4c60-9ef5-9b57ae74a723/image.png" alt="image.png"></p><h3 id="访存"><a href="#访存" class="headerlink" title="访存"></a>访存</h3><ul><li>只有load和store才有访存阶段。数据从内存读到寄存器或者反过来。</li><li>判断读还是写看 memory_read_enable使能，为1则read，反之write。</li></ul><h3 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h3><p>多路选择器，决定从哪里得到写回的数据。</p><h3 id="组成CPU"><a href="#组成CPU" class="headerlink" title="组成CPU"></a>组成CPU</h3><ul><li>CPUBundle 是 CPU 和内存等外设进行数据交换的通道。</li></ul><h1 id="烧板"><a href="#烧板" class="headerlink" title="烧板"></a>烧板</h1><ol><li>生成verilator文件（运行Top.scala)</li></ol><aside>💡<p>注意：是在lab1内进行，然后z710v1_3这个包！不是z710v1.3!!!</p></aside><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/554ad192-24f8-471f-81f7-36771022fc8a/image.png" alt="image.png"></p><ol><li><strong>生成 Vivado 项目</strong></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/259f6157-65c2-40b3-b8a5-b99a37013dba/image.png" alt="image.png"></p><ol><li>生成比特流文件</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/53c8d9cd-8206-4f22-b174-1b87584763f5/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4e1943bf-e7f9-4359-a1fa-d8e922338b35/image.png" alt="image.png"></p><ol><li>烧录：由于是在wsl中进行的，会导致没有“驱动”的问题，然后发现了win上之前安装的vivado是可以连接到debian里面的，所以就直接在里面打开，根据program_device.tcl里面的指令（结合vivado中的烧录键），实际上只需要自己多输入最后那步 <code>close_hw_target</code> ，这样子能够保证vitis正常工作。</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c678f2ed-b03e-426e-a1bd-1d93015011d4/image.png" alt="image.png"></p><p>烧录结果：（后打开clock之后，会一闪一闪亮红灯）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/789c4161-6b8e-4d97-bf31-954bcc9a8d27/be3cee1cacb047c90c08ad06a6b68ee.jpg" alt="be3cee1cacb047c90c08ad06a6b68ee.jpg"></p><p>vitis显示如下：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/03254c1f-b2a3-4380-9bb6-e23dc05ed7fe/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17338008355682.png" alt="企业微信截图_17338008355682.png"></p><h2 id="实验报告："><a href="#实验报告：" class="headerlink" title="实验报告："></a>实验报告：</h2><p>合规性测试部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> TARGET_SIM=~/YatCPU/yatcpu23_new/lab1/verilog/verilator/obj_dir/VTop<br><span class="hljs-keyword">export</span> TARGETDIR=~/YatCPU/yatcpu23_new/lab1/riscv-target<br><span class="hljs-keyword">export</span> RISCV_TARGET=yatcpu<br>make<br></code></pre></td></tr></table></figure><aside>💡<p>如果要测试其他的lab要注意把路径修改了</p></aside><p>lab2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># 测试 lab2 的 CPU<br><span class="hljs-keyword">export</span> TARGET_SIM=~/YatCPU/yatcpu23_new/lab2/verilog/verilator/obj_dir/VTop<br><span class="hljs-keyword">export</span> TARGETDIR=~/YatCPU/yatcpu23_new/lab2/riscv-target<br><span class="hljs-keyword">export</span> RISCV_TARGET=yatcpu<br></code></pre></td></tr></table></figure><p>lab3:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># 测试 lab3 的 CPU<br><span class="hljs-keyword">export</span> TARGET_SIM=~/YatCPU/yatcpu23_new/lab3/verilog/verilator/obj_dir/VTop<br><span class="hljs-keyword">export</span> TARGETDIR=~/YatCPU/yatcpu23_new/lab3/riscv-target<br><span class="hljs-keyword">export</span> RISCV_TARGET=yatcpu<br></code></pre></td></tr></table></figure><p>lab1的测试结果：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9152e9ef-2e5b-4ee9-be3c-650d1784d6bd/32d668896c5b7ecbacf247af766530d.png" alt="32d668896c5b7ecbacf247af766530d.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9152e9ef-2e5b-4ee9-be3c-650d1784d6bd/32d668896c5b7ecbacf247af766530d.png" alt="32d668896c5b7ecbacf247af766530d.png"></p><h1 id="Lab2中断"><a href="#Lab2中断" class="headerlink" title="Lab2中断"></a>Lab2中断</h1><p>实验目的：</p><ul><li>学习CSR寄存器及其操作命令</li><li>中断控制器的原理和设计</li><li>编写一个简单的定时中断发生器</li></ul><h2 id="CSR寄存器的操作命令："><a href="#CSR寄存器的操作命令：" class="headerlink" title="CSR寄存器的操作命令："></a>CSR寄存器的操作命令：</h2><h3 id="回顾：中断和异常"><a href="#回顾：中断和异常" class="headerlink" title="回顾：中断和异常"></a>回顾：中断和异常</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/2d2dbece-9226-4a85-ad6a-28ff2a170cdb/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/7563df56-5735-4444-a001-17f6ca6ecd14/image.png" alt="image.png"></p><h3 id="CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。"><a href="#CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。" class="headerlink" title="CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。"></a>CSR：用来控制和保存CPU的其他功能的状态。例如终端使能状态，特权等级等。</h3><ul><li>mstatus寄存器：记录<strong>机器模式下的状态</strong>（status），如中断是否启用等。</li><li>mepc寄存器：保存了<strong>终端返回后需要执行的指令地址</strong>，当 CPU 执行中断时，<code>mepc</code> 寄存器被自动设置为当前指令的地址，如果 <code>EX</code> 阶段正在执行跳转，则设置为跳转的目标地址。</li><li>mcause寄存器：保存了中断的<strong>原因</strong></li><li>mtvec寄存器：保存了<strong>中断处理程序</strong>的地址。发生执行中断时会传给pc寄存器</li><li>中断发生时，CPU需要清空并阻塞流水线，并在CSR寄存器写入中断相关的信息。由于CSR寄存器堆实现只有一个读写端口，故需要多个周期才能写入CSR寄存器。写完后，发出控制信号，开始处理。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9f9ceea2-a7f4-4560-810d-ce43a10e3c71/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/00dc7cf5-97b3-424c-8922-a71d85ffb886/image.png" alt="image.png"></p><h3 id="中断处理程序：实现更加复杂的功能。"><a href="#中断处理程序：实现更加复杂的功能。" class="headerlink" title="中断处理程序：实现更加复杂的功能。"></a>中断处理程序：实现更加复杂的功能。</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/e0ec95e0-c34c-440a-a56a-0dfe2d089312/image.png" alt="image.png"></p><ul><li>我们可以将CSR指令分解为：CSR寄存器组，ID译码单元，EX执行单元，WB写回单元。<ul><li>CSR寄存器组需要根据<strong>ID模块译码后给出的控制信号</strong>和<strong>CSR寄存器地址</strong>来对内部寄存器进行寻址，获取其内容并修改。</li><li>ID译码单元需要识别CSR指令。（看手册）</li><li>EX执行单元：CSR 指令都是<strong>原子读写</strong>的，即一条指令的执行结果中，既要把<strong>目标 CSR 寄存器原来的内容</strong>写入到<strong>目标通用寄存器</strong>中，还要按指令语义把从目标 CSR 寄存器读出来的<strong>内容修改之后再写回给该CSR 寄存器</strong>。此时 EX 里面的 ALU 单元是<strong>空闲</strong>的，要得到写入 CSR 寄存器的值，可以复用 ALU，也可以不复用。</li><li>WB写回单元：支持 CSR 相关操作指令后，<strong>写回到目标通用寄存器</strong>的数据来源就多了一个<strong>从目标 CSR 寄存器读出来的修改前的值</strong>。</li></ul></li></ul><h2 id="中断控制器CLINT"><a href="#中断控制器CLINT" class="headerlink" title="中断控制器CLINT"></a>中断控制器CLINT</h2><blockquote><p>检测外部中断，并在中断到来并且中断使能时，中断CPU目前执行流，设置好相关的CSR信息后跳转到中断处理程序。</p></blockquote><ul><li>保存到CSR寄存器的信息：<strong>CPU执行完当前指令的下一个状态。</strong></li><li>让当前指令执行完后再跳转到中断处理程序</li></ul><h3 id="响应（硬件）中断"><a href="#响应（硬件）中断" class="headerlink" title="响应（硬件）中断"></a>响应（硬件）中断</h3><p><a href="https://blog.csdn.net/zyhse/article/details/136390088">https://blog.csdn.net/zyhse/article/details/136390088</a></p><ul><li>获取CPU下一个状态信息，一个周期内写入到相应的寄存器。</li></ul><p>写入的内容包括：mepc，mcause，mstatus。</p><ul><li><p><code>mepc</code>：保存的是中断或者异常处理完成后，CPU返回并开始执行的地址。所以对于异常和中断，<code>mepc</code> 的保存内容需要注意。</p></li><li><p><code>mcause</code>：保存的是导致中断或者异常的原因，具体内容请查阅特权级手册里的相关内容。</p></li><li><p><code>mstatus</code>：在响应中断时，需要将 <code>mstatus</code> 寄存器中的 <code>MPIE</code> 标志位设置为 <code>0</code>，禁用中断。</p><ul><li><strong>注意注意注意：这里不是自己手动地将MPIE位设置为0，是将MIE位设置为0，然后硬件会自动的把MPIE位修改</strong>然后从 <code>mtvec</code> 获取中断处理程序的地址，跳转到该地址执行进一步的中断处理</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9f234702-1688-497c-8010-651f7dc53f7e/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/cd72c169-cbfe-45be-8a44-4989200794d3/image.png" alt="image.png"></p></li></ul><p>该部分的代码截图：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/01c995c9-3901-4573-a576-d4f29ed0dba3/image.png" alt="image.png"></p><p>解释：disable_interrupt是用来修改MIE位的，并且让后续禁用中断（因为我们要保证不会发生中断嵌套）</p><p>然后看到数据中的信号连接：</p><ul><li>着重提醒mcause的原因，我们在同一个文件的最上方看到了Status的结构体定义，了解到就这么几种，并没有把所有的原因都列举出来，所以暂时只需要这样子写。（更多的mcause原因可以查看后面的截图或者直接看特权手册第二卷）</li></ul><p><strong>mstatus的指令结构：</strong></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/1f1384af-b7e5-4fe5-8998-67b49e091e5b/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/a2857746-2f3c-48b8-82ba-81bfe76bc25c/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/bf9f34e1-6e68-4368-8b05-842a2af9d624/image.png" alt="image.png"></p><h3 id="（硬件）中断返回"><a href="#（硬件）中断返回" class="headerlink" title="（硬件）中断返回"></a>（硬件）中断返回</h3><p>需要写入的寄存器：mstatus</p><p>从mepc中获取跳转目标地址（原本正常执行的下一条地址）</p><p>把 <strong>MIE</strong> 位置为 <strong>MPIE 位</strong>，那么 MPIE 为 1 的话 <code>mret</code> 就会恢复中断，如果 MPIE 为 0 的话，<code>mret</code> 则不改变 <code>mstatus</code> 的值，这也导致了我们不支持中断嵌套。</p><p>CLINT的实现：for简单—采用纯组合逻辑实现。</p><p>CLINT 需要<strong>一个周期</strong>就<strong>把多个寄存器的内容修改</strong>的功能，而<strong>正常的 CSR 指令只能对一个</strong>寄存器读-修改-写（Read-Modify-Write, RMW）。所以 CLINT 和 CSR 之间有独立的优先级更高的通路，用来<strong>快速更新</strong> CSR 寄存器的值。</p><p>一个好的解释：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/16c62b2d-399d-46fe-8508-9c953d559c9f/image.png" alt="image.png"></p><h2 id="简单的定时中断发生器"><a href="#简单的定时中断发生器" class="headerlink" title="简单的定时中断发生器"></a>简单的定时中断发生器</h2><p>MMIO的定时中断发生器—Timer</p><blockquote><p>MMIO 简单来说就是：<strong>该外设用来和 CPU 交互的寄存器是与内存一起编址的</strong>，所以 CPU 可以通过<strong>访存指令</strong>（load&#x2F;store）来修改这些寄存器的值，从而达到 CPU 和外设交互的目的。</p></blockquote><p>CPU发出的逻辑地址要发送到哪个设备，就由<strong>逻辑地址的高位</strong>作为<strong>外围设备的位选信号</strong>即可，<strong>低位</strong>则用于<strong>设备内部</strong>的寻址。</p><h2 id="实验任务："><a href="#实验任务：" class="headerlink" title="实验任务："></a>实验任务：</h2><ol><li>EX 执行单元在处理 CSR 指令时能够<strong>正确地得到写入 CSR 寄存器的数据</strong>。（done</li><li>CSR 寄存器组可以<strong>正确支持CLINT和来自CSR指令的读写操作</strong>。（done</li><li>定时中断发生器可以<strong>正确产生中断信号</strong>，并且<strong>实现 Timer 寄存器的 MMIO</strong>。</li><li>CLINT 能够<strong>正确的响应中断</strong>并且<strong>在中断结束后回到原来的执行流</strong>。（done</li></ol><p>如果能够正确完成本次实验，那么你的 CPU 就可以运行更加复杂的程序了，可以运行一下俄罗斯方块程序试试，如果想要上手玩的话，也许需要一个串口转接板，这样就可以通过电脑的键盘通过 UART 串口给程序输入字符了。</p><h3 id="任务1：EX-执行单元在处理-CSR-指令时能够正确地得到写入-CSR-寄存器的数据"><a href="#任务1：EX-执行单元在处理-CSR-指令时能够正确地得到写入-CSR-寄存器的数据" class="headerlink" title="任务1：EX 执行单元在处理 CSR 指令时能够正确地得到写入 CSR 寄存器的数据"></a>任务1：EX 执行单元在处理 CSR 指令时能够<strong>正确地得到写入 CSR 寄存器的数据</strong></h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4290bbb4-24b4-44c9-9160-13af9a9b6da6/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c3f7e361-4110-4940-aab4-ba28ad60defb/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/e585e7a2-a06a-4c05-aab6-e1dc23232281/0a3f20ee132b54699d4134c1320040d.png" alt="0a3f20ee132b54699d4134c1320040d.png"></p><p>这个地方要注意，csr寄存器的立即数和之前译码阶段的立即数是不太一样的。译码阶段取立即数主要是针对立即数长度or位置不同于一般指令的进行获取。（如图）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/918f657a-115b-4ba0-82d6-ed9486d52f0f/image.png" alt="image.png"></p><p>从上方的指令划分的图中可以看到，crs寄存器的立即数和R指令寄存器指令取寄存器数是一样的（15-19）→ 在上图也是可以看到<strong>目标寄存器的值和立即数来源都是rs1</strong>，故后面只用在此处取值就行了。唯一的区别是第二个寄存器加上原本的func7组合在一起合成了crs寄存器的func7指示。（附上译码阶段的取指令的图：其中rs1对应的数据存储到reg1_data，rs2对应的数据存储到reg2_data—但此处是应该被忽略的，因为rs2部分的数据被合并到了func7中） <strong>mips的rs，rt的位置是确定的。</strong></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/41cd5ebf-b1d8-4c44-a4b1-550bebbc029c/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/8246c754-17b2-4c49-ace1-6581ed7d8f24/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/ce9f61ea-c7ce-4fd9-9e4e-9030d6b0f349/image.png" alt="image.png"></p><p>要注意的是，uimm是15-19位的原码，而source是rs1里面的值</p><p>任务一结果：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/8c80ac24-145b-4414-8515-263cf7038800/image.png" alt="image.png"></p><h3 id="任务2：CSR-寄存器组可以正确支持CLINT和来自CSR指令的读写操作。"><a href="#任务2：CSR-寄存器组可以正确支持CLINT和来自CSR指令的读写操作。" class="headerlink" title="任务2：CSR 寄存器组可以正确支持CLINT和来自CSR指令的读写操作。"></a>任务2：CSR 寄存器组可以<strong>正确支持CLINT和来自CSR指令的读写操作</strong>。</h3><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c1ed0bf3-0f89-469a-89f3-10e24ee656b6/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4604f572-0a2d-4805-ab6e-a522ad2f8832/image.png" alt="image.png"></p><ul><li><code>CSRRegister.CycleL</code> 和 <code>CSRRegister.CycleH</code> 这两个参数通常是用于访问或设置 CSR（Control and Status Registers）寄存器中的低位和高位的值。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/0a3ec965-8a4a-46d3-be51-7b0073b5844a/image.png" alt="image.png"></p><p>首先我们看到CSR中需要我们实现的是可以正确读取CSR寄存器组的信息，并且可以正确与CLINT交互—将信息传到CLINT）</p><p>然后我们看到提示写了：如果数据线与CLINT冲突了，我们需要优先进行数据更新，这样子保证了CLINT读到的数是最新的。</p><p>我们可以借鉴已经写好的代码中判断条件的方法：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/26456738-a558-452b-b30f-c0748264ac9c/image.png" alt="image.png"></p><p>可以看到如果需要进行数据更新，要判断reg_write_enable_id是否为1，然后判断对应的地址是哪一个—&gt;对应了需要更改的那一个寄存器的值。使用Mux来进行数据选择，如果条件满足，那么输入到CLINT中的值是reg_write_data_ex，若不满足则输入旧的值（也就是前面读取的寄存器组原本的值）</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/0337e759-5933-4113-884e-ff789094a897/image.png" alt="image.png"></p><h3 id="功能3：定时中断发生器可以正确产生中断信号，并且实现-Timer-寄存器的-MMIO"><a href="#功能3：定时中断发生器可以正确产生中断信号，并且实现-Timer-寄存器的-MMIO" class="headerlink" title="功能3：定时中断发生器可以正确产生中断信号，并且实现 Timer 寄存器的 MMIO"></a>功能3：定时中断发生器可以<strong>正确产生中断信号</strong>，并且<strong>实现 Timer 寄存器的 MMIO</strong></h3><p>实现一个MMIO的定时中断发生器—timer</p><p>MMIO：该外设用来和CPU交互的寄存器一起编址，这样子CPU就可以通过访存指令来修改这些寄存器的值，从而实现CPU与外设交互。即内存映射。</p><p>没有总线时可以使用<strong>多路选择器（即现在阶段用多路选择器实现）</strong></p><p>内部逻辑：两个控制寄存器 <code>enable</code> 寄存器和 <code>limit</code> 寄存器。</p><ul><li><code>enable</code> 寄存器：控制定时中断发生器的使能，为false则不产生中断，映射到地址空间的逻辑地址为0x80000008.</li><li><code>limit</code> 寄存器：用来控制定时器的<strong>中断发生间隔</strong>。映射到地址空间逻辑地址：0x80000004。内部有个加一计数器，达到limit为标准的界限时，定时器会发生一次中断信号（enable使能）。注：产生中断信号的时长没有太大关系，但是至少应该大于一个 CPU 时钟周期，确保 CPU 能够正确捕捉到该信号即可。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/3ff93292-0ed1-4ab4-9067-d05f7ce5f71d/image.png" alt="image.png"></p><h3 id="任务4：CLINT-能够正确的响应中断并且在中断结束后回到原来的执行流（更多内容在前面中断概念处）"><a href="#任务4：CLINT-能够正确的响应中断并且在中断结束后回到原来的执行流（更多内容在前面中断概念处）" class="headerlink" title="任务4：CLINT 能够正确的响应中断并且在中断结束后回到原来的执行流（更多内容在前面中断概念处）"></a>任务4：CLINT 能够<strong>正确的响应中断</strong>并且<strong>在中断结束后回到原来的执行流（更多内容在前面中断概念处）</strong></h3><p><a href="https://www.notion.so/13c279ae70e5804f81ddd90e124a9031?pvs=21"></a></p><p>CLINT的一些理解概念：</p><ol><li><code>CLINT</code> 具有固定的优先级方案，但不支持给定特权级别内的嵌套中断（抢占）。 然而，较高的特权级别可能会抢占较低的特权级别。 <code>CLINT</code> 提供两种操作模式，<strong>直接模式</strong>和<strong>向量模式</strong>。<ul><li>在<strong>直接模式</strong>下，所有中断和异常都会捕获到 <code>mtvec.BASE</code>。</li><li>在<strong>向量模式</strong>下，异常trap到 <code>mtvec.BASE</code>，但中断将直接跳转到它们的向量表索引。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/c90f1260-7c99-43fe-a793-12f91fc1e8de/image.png" alt="image.png"></p><ol><li><p>一些代码解释：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/014468d7-0c6f-4128-b775-3af358158014/image.png" alt="image.png"></p></li></ol><p>InterruptStatus对象：</p><ul><li>定义了中断状态的常量值</li><li>None表示<strong>没有中断</strong></li><li>Timer0表示<strong>计时器0中断</strong></li><li>Ret表示<strong>返回状态</strong></li></ul><p>InterruptEntry对象：</p><ul><li>定义了中断入口地址的常量值</li><li>Timer0表示计时器0中断入口地址</li></ul><p>InterruptState对象：</p><ul><li>定义了中断状态机的不同状态</li><li>Idle：空闲状态</li><li>SyncAssert：同步断言状态</li><li>AsyncAssert：异步断言状态</li><li>MRET：表示<strong>从中断返回的状态</strong></li></ul><p>CSRState对象：</p><ul><li>定义了CSR状态机的不同状态。</li><li><code>Idle</code>: 空闲状态，值为 <code>0x0</code>。</li><li><code>Traping</code>: 陷入状态，值为 <code>0x1</code>。</li><li><code>Mret</code>: 从中断返回状态，值为 <code>0x2</code>。</li></ul><ol><li>mstatus寄存器和mcause寄存器</li></ol><p>mstatus指令结构：（我们使用到的是32位的</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/ac86d63c-db93-450c-af66-afca0d8b3780/image.png" alt="image.png"></p><p>mcause指令相关：</p><p>可能出现的机器级异常代码</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/352d620c-634d-4c50-bdf5-ebe48e1b9965/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/f6c30f66-840f-4f01-8bb3-dd88c86f1b68/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/dccae40f-4b27-4782-9a55-5e52cb8e85b2/image.png" alt="image.png"></p><p>mtvec</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/101d1622-416f-43d9-85f1-c51130896ea7/image.png" alt="image.png"></p><h1 id="Lab3流水线CPU"><a href="#Lab3流水线CPU" class="headerlink" title="Lab3流水线CPU"></a>Lab3流水线CPU</h1><h2 id="内容简介："><a href="#内容简介：" class="headerlink" title="内容简介："></a>内容简介：</h2><ul><li><strong>竞争冒险</strong>的处理是流水线 CPU 设计的难点和关键所在。</li><li>设计一个简单的三级流水线 CPU（IF、ID 和 EX 三级），它只涉及<strong>分支和跳转指令</strong>带来的控制冒险，然后，我们再将三级流水线 CPU 的 EX 级<strong>继续切分为 EX、MEM 和 WB</strong>，形成经典的<strong>五级流水线</strong>，这样做带来的数据冒险需要使用<strong>阻塞和转发技术</strong>进行处理；最后，我们将<strong>分支和跳转提前到 ID 阶段，进一步缩短分支延迟。</strong></li><li>参考资料：计组黑书4.5-4.8节</li><li>学习：<ul><li>使用流水线设计缩短关键路径</li><li>正确处理流水线阻塞与清空</li><li>使用转发逻辑减少流水线阻塞</li></ul></li></ul><h2 id="流水线寄存器："><a href="#流水线寄存器：" class="headerlink" title="流水线寄存器："></a>流水线寄存器：</h2><blockquote><p>缓存作用，切分组合逻辑，缩短关键路径。（存储该阶段产生的各种信息和数据。</p></blockquote><p>基本功能：</p><ul><li>在每一个时钟周期，根据复位（流水线清空）或阻塞（流水线暂停）的状态，将寄存器内容情况、保持或设置为新的值。输出则为其中保存的值。</li><li>为了方便复用，我们可以定义一个带参数的 <code>PipelineRegister</code> 模块，用来实现<strong>不同数据位宽</strong>的流水线寄存器。</li></ul><h3 id="task0：补充完成PipelineRegister-scala"><a href="#task0：补充完成PipelineRegister-scala" class="headerlink" title="task0：补充完成PipelineRegister.scala"></a>task0：补充完成PipelineRegister.scala</h3><ul><li><code>stall</code> 和 <code>flush</code> 分别为流水线寄存器的阻塞和清空信号，<code>in</code> 和 <code>out</code> 分别为要写入寄存器的值和寄存器的当前值。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/fe542da7-c626-465f-b174-a1ee4cbf654d/image.png" alt="image.png"></p><ul><li>解释：我们要存储结果，并且下一个阶段有可能还要用到前面那个阶段的状态信息，所以要用寄存器来传递、存储。</li></ul><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/98781a7b-ca69-4696-9949-fd8e6da27fc3/image.png" alt="image.png"></p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/9205658e-ebfb-4015-857f-cbd9e11ccd76/image.png" alt="image.png"></p><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table><thead><tr><th>特性</th><th>Scala 变量 (<code>var</code>)</th><th>Chisel 寄存器 (<code>Reg</code>)</th></tr></thead><tbody><tr><td><strong>功能</strong></td><td>软件变量，临时存储值</td><td>硬件寄存器，存储状态</td></tr><tr><td><strong>硬件生成</strong></td><td>不生成硬件</td><td>生成硬件寄存器</td></tr><tr><td><strong>值的更新</strong></td><td>随程序执行更新</td><td>时钟边沿更新</td></tr><tr><td><strong>硬件复位</strong></td><td>不支持复位行为</td><td>可设置复位值 (<code>RegInit</code>)</td></tr><tr><td><strong>用途</strong></td><td>软件逻辑辅助计算</td><td>描述硬件逻辑和状态存储</td></tr></tbody></table><h1 id="三级流水线"><a href="#三级流水线" class="headerlink" title="三级流水线"></a>三级流水线</h1><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/77588407-9a56-4bfd-a311-c27e63aa638b/image.png" alt="image.png"></p><ul><li>两组流水线寄存器：<code>IF2ID</code> 和 <code>ID2EX</code> 划分出三个阶段。（已写好）<ul><li>取指（Instruction Fetch，IF）：根据 PC 中的指令地址从内存中取出指令码；</li><li>译码（Instruction Decode，ID）：将指令码解码为控制信号并从寄存器组中读取操作数；</li><li>执行（Execute，EX）：包括 ALU 运算、访问内存和结果写回。</li></ul></li></ul><h2 id="处理竞争冒险"><a href="#处理竞争冒险" class="headerlink" title="处理竞争冒险"></a>处理竞争冒险</h2><h3 id="解决控制冒险—清空"><a href="#解决控制冒险—清空" class="headerlink" title="解决控制冒险—清空"></a>解决控制冒险—清空</h3><ul><li>由于所有数据处理都在EX阶段，不会出现数据冲突，无需考虑。我们只需处理程序跳转（beq指令等）带来的控制冒险。<ul><li>EX执行到跳转指令</li><li>EX端执行到分支指令且分支成立</li><li>发生中断，接收到CLINT发来的中断信号 <code>InterruptAssert</code> 。相当于在EX指令至上叠加了跳转指令，要丢弃之前的—IF和ID</li></ul></li><li>无论哪种情况，都是由 EX 段向 IF 段发送跳转信号 <code>jump_flag</code> 和跳转的目标地址 <code>jump_address</code>，但在 <code>jump_address</code> 写入 PC 并从该处取出指令前，流水线的 IF 和 ID 段已经各有两条不需要执行的指令，好在这两条指令的结果还没有写回，我们<strong>只需要清空对应的流水线寄存器，把它们变成两条空指令即可</strong>。</li><li>我们用一个控制单元来检测控制冒险并清空流水线，模块定义在 <code>src/main/scala/riscv/core/threestage/Control.scala</code>，为了避免此题过于简单（呵呵，我们没有提供模块接口，请根据以上分析确定模块的输入输出，在 <code>// Lab3(Flush)</code> 处将代码补充完整，并在 <code>src/main/scala/riscv/core/threestage/CPU.scala</code> 的 <code>// Lab3(Flush)</code> 处补充相关连线，使其能够通过 <code>ThreeStageCPUTest</code> 测试。</li></ul><p>control：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/68544734-4bbe-4c2a-95a8-99741b0439af/image.png" alt="image.png"></p><p>如果传入了要跳转的信号，那我们控制器需要输出信号，确保能把IF和ID两个阶段清空</p><p>CPU：与control连线。</p><p>首先要保证输入信息传入；注意的是Interrupt_flag 信号的来源</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/5a7c860b-c017-4301-a7ae-9eed85779f86/image.png" alt="image.png"></p><h2 id="五级流水线"><a href="#五级流水线" class="headerlink" title="五级流水线"></a>五级流水线</h2><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/e53ad942-ff47-49fa-8379-667fa1a0649c/five_stage_pipelined_CPU_structure.png" alt="five_stage_pipelined_CPU_structure.png"></p><blockquote><p>注意，上面的 CPU 结构图是我们完成所有实验之后的结果，在完成“缩短分支延迟”实验之前，我们 CPU 的结构将与上图稍有不同。例如，我们紧接着讨论的五级流水线 CPU 在 EX 阶段判断程序是否发生跳转，而不是 ID 阶段。</p></blockquote><ul><li>使用阻塞的方式解决数据冒险（由于数据的处理不止在执行阶段了，所以会出现数据冒险），使用**旁路和将分支跳转提前到ID阶段（这两步选做）**进一步提升效率。</li></ul><h2 id="解决数据冒险：阻塞"><a href="#解决数据冒险：阻塞" class="headerlink" title="解决数据冒险：阻塞"></a>解决数据冒险：阻塞</h2><ul><li>当处于 ID 阶段的指令要读取的寄存器依赖于 EX 或 MEM 阶段的指令时，发生数据冒险。可以保持这IF和ID阶段状态不变，直到相关数据被放出来。</li><li>位于 ID 阶段的指令和位于 WB 阶段的指令之间不会发生数据冒险，这是因为我们的寄存器组模拟实现了 <strong>Double Pumping</strong> 功能，即 WB 阶段在前半个时钟周期向寄存器组写入数据，ID 阶段在后半个时钟周期从寄存器组读出数据（读写分离）。</li><li>值得注意的是，我们在阻塞 PC 和 IF2ID 寄存器以保持 IF 和 ID 阶段不变的同时，需要<strong>清空 ID2EX 寄存器</strong>以在 EX 阶段插入空指令（“气泡”），否则 ID 阶段的指令还是会进入 EX 阶段，这样就不是“阻塞”，而变成“重复”了。</li><li><code>jalr</code> 是跳转指令，虽然它后面两条指令依赖于它写入的寄存器，但是它们本就不应该紧接着被执行，而是应该被清空，所以在第 10 个时钟周期应该清空 IF2ID 和 ID2EX 寄存器，而不是阻塞。</li></ul><aside>💡<p>特别提示：除了以上讨论的情况之外，寄存器 <code>x0</code> 在 risc-v 中具有特殊作用，以它为目标寄存器的指令的结果将被丢弃，也就是说，只依赖于 <code>x0</code> 的指令并不需要阻塞。</p></aside><table><thead><tr><th><strong>情况</strong></th><th><strong>PC阻塞</strong></th><th><strong>IF2ID阻塞</strong></th><th><strong>ID2EX清空</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>数据冒险（ID依赖EX或MEM）</strong></td><td>是</td><td>是</td><td><strong>是</strong></td><td>保持当前指令状态，防止错误执行</td></tr><tr><td>数据冒险（ID依赖WB）</td><td>否</td><td>否</td><td>否</td><td>WB 阶段支持双抽泵，不需要阻塞</td></tr><tr><td>控制冒险（跳转指令如jalr）</td><td>否</td><td>是</td><td>是</td><td>跳转指令需要清空后续流水段，移除错误指令</td></tr><tr><td><strong>依赖寄存器x0</strong></td><td>否</td><td>否</td><td>否</td><td>x0结果总是0，无需阻塞</td></tr></tbody></table><h3 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑：</strong></h3><ol><li><strong>数据冒险检测（依赖判断）</strong>：<ul><li><strong>EX 阶段的寄存器写入</strong>：如果 ID 阶段的指令需要读取的寄存器（<code>rs1_id</code> 或 <code>rs2_id</code>）依赖 <strong>EX 阶段的目标寄存器</strong>（<code>rd_ex</code>），需要阻塞。</li><li><strong>MEM 阶段的寄存器写入</strong>：如果 ID 阶段的指令依赖 MEM 阶段的<strong>目标寄存器</strong>（<code>rd_mem</code>），需要阻塞。</li></ul></li><li><strong>清空信号</strong>：<ul><li><strong>控制冒险（跳转指令）</strong>：遇到跳转信号（<code>jump_flag</code>），需要清空 IF 和 ID 阶段的指令。</li></ul></li><li><strong>阻塞信号</strong>：<ul><li><strong>PC 阻塞与 IF 阶段阻塞</strong>：在数据冒险发生时，需要阻塞 PC 和 IF 阶段，保持当前指令不变。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/b390bac4-81eb-4f10-b142-8fff15dc4c84/image.png" alt="image.png"></p><h2 id="拓展：使用旁路（转发）减少阻塞"><a href="#拓展：使用旁路（转发）减少阻塞" class="headerlink" title="拓展：使用旁路（转发）减少阻塞"></a><strong>拓展：使用旁路（转发）减少阻塞</strong></h2><ul><li>用一个<strong>控制单元</strong>来处理流水线的阻塞和清空</li><li>用一个<strong>旁路单元</strong>来检测数据冒险并发出旁路控制信号</li><li>在执行单元中根据旁路单元的控制信号使用对应的旁路数据</li></ul><p>Control：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/d00468fd-4e0c-4ba0-8f3d-423913238ec5/image.png" alt="image.png"></p><p>Forwarding：检测数据冒险（看是否存在冲突），发出转发信号。看是与那个寄存器冲突。</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/020768f4-d436-4200-b667-e990d2e82cfe/image.png" alt="image.png"></p><p>Execute：看CPU流程图，可以得知数据的来源有两类，直接得到（已经写回了的数据，直接从寄存器中得到），发生数据冒险的数据（看写到了哪个寄存器中，如果是ex2mem，则从mem转发，如果是mem2wb，就从wb转发</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/73fd5c72-194a-4538-ab08-de2d7e6b797d/image.png" alt="image.png"></p><h2 id="拓展：缩短分支延迟"><a href="#拓展：缩短分支延迟" class="headerlink" title="拓展：缩短分支延迟"></a><strong>拓展：缩短分支延迟</strong></h2><ul><li>往cpu中加入少量硬件，将分支&#x2F;跳转指令的执行从EX段提前到ID段，进而把程序跳转的损失减少到一个时钟周期</li></ul><p>Steps：</p><ul><li>把<strong>跳转</strong>的判断从EX段移到ID段</li><li>跳转的目标地址原本是在Ex段的ALU进行计算的，故我们要在ID段添加一个加法器来计算目标地址</li><li>添加<strong>额外的旁路逻辑</strong>，将前面指令的执行结果旁路到ID段给分支or跳转指令使用，如果所依赖的结果还没有产生，还需要进行阻塞</li></ul><h3 id="1-在-ID-段实现跳转判断"><a href="#1-在-ID-段实现跳转判断" class="headerlink" title="1. 在 ID 段实现跳转判断"></a>1. <strong>在 ID 段实现跳转判断</strong></h3><ul><li><p><strong>核心目标</strong>：将跳转判断逻辑（如条件跳转的比较）从 EX 段移到 ID 段。</p></li><li><p><strong>具体实现</strong>：</p><ol><li><strong>在 <code>InstructionDecode.scala</code> 中</strong>：<ul><li>定义额外的逻辑单元，用于在 ID 段进行分支条件的比较判断。</li><li>根据分支指令的操作码（opcode）和功能码（funct3），确定需要执行的比较操作（如 <code>==</code>, <code>&lt;</code>, <code>&gt;=</code> 等）。</li><li>添加对寄存器值（<code>rs1</code> 和 <code>rs2</code>）的读取和比较逻辑。</li></ul></li><li><strong>目标地址计算</strong>：<ul><li>添加一个加法器，计算跳转目标地址。跳转目标地址为：<code>PC + offset</code>，其中 <code>offset</code> 是指令中解析出的立即数（<code>imm</code>）。</li><li>在 ID 段，将 PC 和立即数相加生成跳转目标地址。</li></ul></li></ol></li><li><p><strong>示例代码</strong>（在 <code>InstructionDecode.scala</code> 中）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala<br>复制代码<br>when (isBranch) &#123;<br>  branchTarget := currentPC + imm<br>  branchTaken := (rs1Value === rs2Value) <span class="hljs-comment">// Example: BEQ condition</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>如果信号的值需要通过逻辑运算生成或在后续逻辑中被赋值，则需要使用 <code>Wire</code>。</p><hr><h3 id="2-添加旁路逻辑"><a href="#2-添加旁路逻辑" class="headerlink" title="2. 添加旁路逻辑"></a>2. <strong>添加旁路逻辑</strong></h3><ul><li><p><strong>核心目标</strong>：解决跳转判断所依赖的数据可能尚未生成的问题。</p></li><li><p><strong>具体实现</strong>：</p><ol><li>在 <code>Forwarding.scala</code> 中，扩展旁路逻辑，使得 ALU 或存储单元的输出能够在 ID 段被立即使用。</li><li>判断数据依赖的来源：<ul><li>如果依赖的数据在 EX 段，需要旁路 EX 段的 ALU 输出。</li><li>如果依赖的数据在 MEM 段，需要旁路 MEM 段的存储输出。</li></ul></li><li>阻塞处理：<ul><li>如果数据依赖尚未解决（例如还在加载数据），则插入气泡（阻塞流水线）。</li></ul></li></ol></li><li><p><strong>示例代码</strong>（在 <code>Forwarding.scala</code> 中）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala<br>复制代码<br>when (rs1Valid &amp;&amp; rs1Source === <span class="hljs-type">EX_STAGE</span>) &#123;<br>  rs1Value := exAluOutput<br>&#125;.elsewhen (rs1Valid &amp;&amp; rs1Source === <span class="hljs-type">MEM_STAGE</span>) &#123;<br>  rs1Value := memDataOutput<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="3-修改控制逻辑"><a href="#3-修改控制逻辑" class="headerlink" title="3. 修改控制逻辑"></a>3. <strong>修改控制逻辑</strong></h3><ul><li><p><strong>核心目标</strong>：更新 <code>Control.scala</code> 中的控制信号生成逻辑，以支持分支跳转在 ID 段的实现。</p></li><li><p><strong>具体实现</strong>：</p><ol><li>根据指令类型（分支&#x2F;跳转），生成额外的控制信号：<ul><li><code>branchTaken</code>：判断是否跳转。</li><li><code>branchTarget</code>：跳转的目标地址。</li></ul></li><li>在 ID 段判断后，如果确定分支成功，则向流水线发出控制信号清空后续指令（如插入气泡）。</li></ol></li><li><p><strong>示例代码</strong>（在 <code>Control.scala</code> 中）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">scala<br>复制代码<br>when (branchTaken) &#123;<br>  pcSrc := <span class="hljs-type">BRANCH_TARGET</span><br>  pipelineFlush := <span class="hljs-literal">true</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="4-测试竞争冒险"><a href="#4-测试竞争冒险" class="headerlink" title="4. 测试竞争冒险"></a>4. <strong>测试竞争冒险</strong></h3><ul><li><strong>核心目标</strong>：模拟和解决所有可能的竞争冒险情况。</li><li><strong>指导原则</strong>：<ul><li>测试分支跳转依赖前面指令的结果。例如：<ol><li><code>BEQ R1, R2, offset</code></li><li><code>ADD R1, R3, R4</code></li></ol></li><li>验证是否正确解决数据依赖问题。</li></ul></li><li><strong>测试数据冒险的关键</strong>：<ul><li>如果冒险可通过旁路解决，则确保旁路逻辑正常工作。</li><li>如果旁路无法解决，则检查阻塞是否正常。</li></ul></li></ul><h1 id="lab4：总线"><a href="#lab4：总线" class="headerlink" title="lab4：总线"></a>lab4：总线</h1><ul><li>CPU除了通过内存控制器访问内存以外，还可以通过<strong>总线</strong>访问外部设备。使用总线可以减少电路布线数量以及电路设计复杂度。避免CPU与外部直接连接。（具体的硬件操作则进一步抽象为读写硬件设备上的寄存器）</li></ul><p>在本实验中，你将学习到：</p><ul><li>AXI4-Lite <strong>总线协议原理</strong></li><li>使用<strong>状态机</strong>实现总线协议</li></ul><h2 id="总线前置知识："><a href="#总线前置知识：" class="headerlink" title="总线前置知识："></a>总线前置知识：</h2><blockquote><p>AXI4-Lite总线通信协议</p></blockquote><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/8ed1ed79-32e2-40bd-b47e-610a743bfed5/axi.png" alt="axi.png"></p><p>写地址通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/bd53bcaa-8b4a-4d82-8548-2cc7e7724220/image.png" alt="image.png"></p><p>写数据通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/1212ba2d-d2d2-4448-b215-48f548892a7f/image.png" alt="image.png"></p><p>写响应通道</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/de6abdd7-cddb-41de-80ec-f0674748aeef/image.png" alt="image.png"></p><p>读地址通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/4b332481-15c3-4cae-9152-42f3f9f751a9/image.png" alt="image.png"></p><p>读数据通道：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/bc757076-2d7d-42b6-9a56-fc5623721789/image.png" alt="image.png"></p><p>状态机：</p><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/158b0582-99d3-4e79-a174-8cfcf4599e93/axi-fsm.png" alt="axi-fsm.png"></p><ul><li>总线仲裁：所有设备在通信之前都要检测总线是都占用。**每一个设备则需要增加总线请求线以及总线授权线，连接到总线仲裁器。**在设备需要通过总线传输数据前，需要先通过总线请求线请求总线的访问权限。<strong>总线仲裁器则通过总线授权线来授予访问权限</strong>，从而避免设备之间的冲突。</li><li>总线交换机：类似于网络交换机的方式连接。不同对的设备之间可以通过交换机同时进行通信。</li></ul><h2 id="读操作："><a href="#读操作：" class="headerlink" title="读操作："></a>读操作：</h2><ol><li>IF发出取指信号，包括：读请求（valid）和读地址（pc），如果对应的主机处于空闲状态，则对本次读取做出响应（<strong>空闲→读请求状态</strong>），产生并<strong>发送读请求</strong>（ARVALID），<strong>读地址</strong>（ARADDR）</li><li>当 从机（slave）接收到读请求且处于空闲状态，则返回主机（master）读准备（ARREADY）—表示可以读取。（完成一次读地址的握手</li><li>从机（slave）开始准备需返回的数据（RDATA），读返回请求（RVALID），主机跳变到下一个<strong>读数据状态。</strong></li><li>当主机的RVALID和RREADY完成握手，主机得到目标数据，则产生读完成的信号（RREADY），把数据返还给取值模块，就完成了一次读操作，此时主机跳转回空闲状态。</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/6d60b960-c91b-441e-8ae1-95e5787c8d29/image.png" alt="image.png"></p><h2 id="写操作："><a href="#写操作：" class="headerlink" title="写操作："></a>写操作：</h2><blockquote><p>相比读多了一个接收<strong>写回复</strong>（如图）</p></blockquote><ol><li>有总线后的MMIO（已给）</li><li>把总线加到流水线上</li></ol><h2 id="实验任务：-1"><a href="#实验任务：-1" class="headerlink" title="实验任务："></a>实验任务：</h2><ol><li>完成主从设备内部的状态机（按照上面给的状态图）</li></ol><p>主从设备的状态机切换图在预备知识里面给出了，不需要自己去总结，实现所需的寄存器和模块输入输出接口已经给出，你<strong>只需要实现状态切换以及相应的握手信号</strong>。</p><h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p><a href="https://blog.csdn.net/weixin_45937291/article/details/129771811">https://blog.csdn.net/weixin_45937291/article/details/129771811</a></p><h3 id="实验指导："><a href="#实验指导：" class="headerlink" title="实验指导："></a>实验指导：</h3><p>实现 AXI4Lite 从设备模块</p><ol><li><strong>实现状态机</strong>：<ul><li>在每个状态中，根据相应的输入信号更新状态和输出信号。</li><li>例如，在 <code>ReadAddr</code> 状态中，等待 <code>ARVALID</code> 信号变高，并将 <code>ARREADY</code> 信号置高。</li><li>一旦地址被接受，将状态切换到 <code>ReadData</code> 并准备输出数据。</li></ul></li><li><strong>实现读写逻辑</strong>：<ul><li>在 <code>ReadData</code> 状态中，等待 <code>RREADY</code> 信号，输出 <code>RDATA</code> 和 <code>RRESP</code>。</li><li>在 <code>WriteAddr</code> 状态中，等待 <code>AWVALID</code> 信号，并将 <code>AWREADY</code> 信号置高。</li><li>在 <code>WriteData</code> 状态中，等待 <code>WVALID</code> 信号，并将写数据和写掩码存储到寄存器中。</li></ul></li><li><strong>实现响应逻辑</strong>：<ul><li>在 <code>WriteResp</code> 状态中，输出写响应信号 <code>BVALID</code> 和 <code>BRESP</code>。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/905731eb-29ea-45e5-a7ae-55ea468b63e8/image.png" alt="image.png"></p><p>实现 AXI4Lite 主设备模块</p><ol><li><strong>实现状态机</strong>：<ul><li>在每个状态中，根据相应的输出信号更新状态和输入信号。</li><li>例如，在 <code>ReadAddr</code> 状态中，输出 <code>ARVALID</code> 信号，并等待 <code>ARREADY</code> 信号变高。</li><li>一旦地址被接受，将状态切换到 <code>ReadData</code> 并准备接收数据。</li></ul></li><li><strong>实现读写逻辑</strong>：<ul><li>在 <code>ReadData</code> 状态中，等待 <code>RVALID</code> 信号，接收 <code>RDATA</code> 和 <code>RRESP</code>。</li><li>在 <code>WriteAddr</code> 状态中，输出 <code>AWVALID</code> 信号，并等待 <code>AWREADY</code> 信号变高。</li><li>在 <code>WriteData</code> 状态中，输出写数据和写掩码信号 <code>WSTRB</code>。</li></ul></li><li><strong>实现响应逻辑</strong>：<ul><li>在 <code>WriteResp</code> 状态中，等待 <code>BVALID</code> 信号，接收写响应信号 <code>BRESP</code>。</li></ul></li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/d9d252c5-393d-457b-abcf-f370d89f2ab8/image.png" alt="image.png"></p><h3 id="ps-一些chisel的知识："><a href="#ps-一些chisel的知识：" class="headerlink" title="ps:一些chisel的知识："></a>ps:一些chisel的知识：</h3><ul><li>Bundle：用于将不同类型的信号划分为一组</li><li>Vec用于表示一个<strong>可索引的、相同类型的</strong>信号的集合</li><li><strong>&lt;&gt; 运算符</strong>：用于连接两个信号，类似于 Verilog 中的 <code>assign</code> 语句。</li></ul><h2 id="实验报告¶"><a href="#实验报告¶" class="headerlink" title="实验报告¶"></a>实验报告<a href="https://yatcpu.sysu.tech/labs/lab2-interrupt/#%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A">¶</a></h2><ol><li>简要概括不同测试用例的功能，描述它们分别从什么层面测试 CPU，以及使用了什么方法加载测试程序指令，以及测试用例的执行结果。</li><li>对于填空涉及到的信号，使用测试框架输出波形图，描述在执行不同指令时候对应的部件的关键信号的变化情况。</li><li>使用实验板上的 LED 或者数码管等外设，体现你的 CPU 可以响应定时器中断或者其他外部中断。</li><li>在完成实验的过程中，遇到的关于实验指导不明确或者其他问题，或者改进的建议。</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/31d55b13-b66a-44e0-a61a-e7ef62f59b8d/image.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_macro</title>
    <link href="/2025/02/19/Rust-macro/"/>
    <url>/2025/02/19/Rust-macro/</url>
    
    <content type="html"><![CDATA[<p>Rust 的宏系统分为两大类： <strong>声明宏</strong> （Declarative Macros）和 <strong>过程宏</strong> （Procedural Macros）。</p><hr><h2 id="1-宏的基本概念"><a href="#1-宏的基本概念" class="headerlink" title="1. 宏的基本概念"></a>1. 宏的基本概念</h2><h3 id="1-1-宏的作用"><a href="#1-1-宏的作用" class="headerlink" title="1.1 宏的作用"></a>1.1 宏的作用</h3><ul><li><strong>代码复用</strong> ：通过宏减少重复代码。</li><li><strong>代码生成</strong> ：在编译时生成代码，减少运行时开销。</li><li><strong>领域特定语言（DSL）</strong> ：通过宏创建自定义语法。</li></ul><h3 id="1-2-宏的分类"><a href="#1-2-宏的分类" class="headerlink" title="1.2 宏的分类"></a>1.2 宏的分类</h3><ul><li><strong>声明宏</strong> ：通过模式匹配生成代码，使用 <code>macro_rules!</code> 定义。</li><li><strong>过程宏</strong> ：更灵活，允许在编译时运行 Rust 代码生成代码，分为三类：</li><li><strong>自定义派生宏</strong> （Custom Derive Macros）：为结构体或枚举自动实现 trait。</li><li><strong>类属性宏</strong> （Attribute-like Macros）：为代码块添加自定义属性。</li><li><strong>类函数宏</strong> （Function-like Macros）：像函数一样调用的宏。</li></ul><hr><h2 id="2-声明宏（Declarative-Macros）"><a href="#2-声明宏（Declarative-Macros）" class="headerlink" title="2. 声明宏（Declarative Macros）"></a>2. 声明宏（Declarative Macros）</h2><h3 id="2-1-声明宏的定义"><a href="#2-1-声明宏的定义" class="headerlink" title="2.1 声明宏的定义"></a>2.1 声明宏的定义</h3><p>使用 <code>macro_rules!</code> 定义声明宏，语法如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> macro_name &#123;<br>    (pattern1) =&gt; &#123; generated_code1 &#125;;<br>    (pattern2) =&gt; &#123; generated_code2 &#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>pattern</code>：匹配输入的语法模式。</li><li><code>generated_code</code>：生成的代码。</li></ul><h3 id="2-2-示例：简单的声明宏"><a href="#2-2-示例：简单的声明宏" class="headerlink" title="2.2 示例：简单的声明宏"></a>2.2 示例：简单的声明宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> say_hello &#123;<br>    () =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    say_hello!(); <span class="hljs-comment">// 输出：Hello, world!</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-模式匹配与捕获"><a href="#2-3-模式匹配与捕获" class="headerlink" title="2.3 模式匹配与捕获"></a>2.3 模式匹配与捕获</h3><p>声明宏支持多种模式匹配和捕获：</p><ul><li><strong>捕获变量</strong> ：<code>$var:type</code>，例如 <code>$x:expr</code> 捕获表达式。</li><li><strong>重复模式</strong> ：<code>$(...)*</code> 或 <code>$(...)+</code>，用于匹配重复的输入。</li></ul><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> create_vector &#123;<br>    ($($x:expr),*) =&gt; &#123;<br>        &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>            $(v.<span class="hljs-title function_ invoke__">push</span>($x);)*<br>            v<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = create_vector!(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, v); <span class="hljs-comment">// 输出：[1, 2, 3]</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-过程宏（Procedural-Macros）"><a href="#3-过程宏（Procedural-Macros）" class="headerlink" title="3. 过程宏（Procedural Macros）"></a>3. 过程宏（Procedural Macros）</h2><p>过程宏更强大，允许在编译时运行 Rust 代码生成代码。过程宏需要单独放在一个 crate 中。</p><h3 id="3-1-自定义派生宏（Custom-Derive-Macros）"><a href="#3-1-自定义派生宏（Custom-Derive-Macros）" class="headerlink" title="3.1 自定义派生宏（Custom Derive Macros）"></a>3.1 自定义派生宏（Custom Derive Macros）</h3><p>派生宏用于为结构体或枚举自动实现 trait。</p><h3 id="3-1-1-定义派生宏"><a href="#3-1-1-定义派生宏" class="headerlink" title="3.1.1 定义派生宏"></a>3.1.1 定义派生宏</h3><p>使用 <code>#[proc_macro_derive]</code> 定义派生宏。</p><p>示例：实现一个简单的 <code>Hello</code> trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><span class="hljs-keyword">use</span> syn::&#123;parse_macro_input, DeriveInput&#125;;<br><br><span class="hljs-meta">#[proc_macro_derive(Hello)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_derive</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ast</span> = parse_macro_input!(input <span class="hljs-keyword">as</span> DeriveInput);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = &amp;ast.ident;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gen</span> = quote! &#123;<br>        <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">for</span> #name &#123;<br>            <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello</span>() &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, I am &#123;&#125;&quot;</span>, <span class="hljs-built_in">stringify!</span>(#name));<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    gen.<span class="hljs-title function_ invoke__">into</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-2-使用派生宏"><a href="#3-1-2-使用派生宏" class="headerlink" title="3.1.2 使用派生宏"></a>3.1.2 使用派生宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> hello_macro::Hello;<br><br><span class="hljs-meta">#[derive(Hello)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    Person::<span class="hljs-title function_ invoke__">hello</span>(); <span class="hljs-comment">// 输出：Hello, I am Person</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-类属性宏（Attribute-like-Macros）"><a href="#3-2-类属性宏（Attribute-like-Macros）" class="headerlink" title="3.2 类属性宏（Attribute-like Macros）"></a>3.2 类属性宏（Attribute-like Macros）</h3><p>类属性宏允许为代码块添加自定义属性。</p><h3 id="3-2-1-定义类属性宏"><a href="#3-2-1-定义类属性宏" class="headerlink" title="3.2.1 定义类属性宏"></a>3.2.1 定义类属性宏</h3><p>使用 <code>#[proc_macro_attribute]</code> 定义类属性宏。</p><p>示例：定义一个属性宏，打印函数名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><span class="hljs-keyword">use</span> syn::&#123;parse_macro_input, ItemFn&#125;;<br><br><span class="hljs-meta">#[proc_macro_attribute]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">log_function</span>(_attr: TokenStream, item: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">input</span> = parse_macro_input!(item <span class="hljs-keyword">as</span> ItemFn);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fn_name</span> = &amp;input.sig.ident;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gen</span> = quote! &#123;<br>        #input<br><br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Function &#x27;&#123;&#125;&#x27; was called.&quot;</span>, <span class="hljs-built_in">stringify!</span>(#fn_name));<br>    &#125;;<br><br>    gen.<span class="hljs-title function_ invoke__">into</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-2-使用类属性宏"><a href="#3-2-2-使用类属性宏" class="headerlink" title="3.2.2 使用类属性宏"></a>3.2.2 使用类属性宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> log_macro::log_function;<br><br><span class="hljs-meta">#[log_function]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">my_function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Doing something...&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">my_function</span>(); <span class="hljs-comment">// 输出：Function &#x27;my_function&#x27; was called.</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-类函数宏（Function-like-Macros）"><a href="#3-3-类函数宏（Function-like-Macros）" class="headerlink" title="3.3 类函数宏（Function-like Macros）"></a>3.3 类函数宏（Function-like Macros）</h3><p>类函数宏像函数一样调用，但可以接受任意输入。</p><h3 id="3-3-1-定义类函数宏"><a href="#3-3-1-定义类函数宏" class="headerlink" title="3.3.1 定义类函数宏"></a>3.3.1 定义类函数宏</h3><p>使用 <code>#[proc_macro]</code> 定义类函数宏。</p><p>示例：定义一个类函数宏，生成一个简单的函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><br><span class="hljs-meta">#[proc_macro]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">make_function</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gen</span> = quote! &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">generated_function</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This is a generated function!&quot;</span>);<br>        &#125;<br>    &#125;;<br><br>    gen.<span class="hljs-title function_ invoke__">into</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3-2-使用类函数宏"><a href="#3-3-2-使用类函数宏" class="headerlink" title="3.3.2 使用类函数宏"></a>3.3.2 使用类函数宏</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> make_function::make_function;<br><br>make_function!();<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">generated_function</span>(); <span class="hljs-comment">// 输出：This is a generated function!</span><br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>ai总结</li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_smart_pointer</title>
    <link href="/2025/02/19/Rust-smart-pointer/"/>
    <url>/2025/02/19/Rust-smart-pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针是一类数据结构，它们表现类似指针，但是也拥有额外的元数据和功能。</p><ul><li><strong>引用计数</strong> （ <em>reference counting</em> ）智能指针类型。这种指针允许数据有多个所有者，它会记录所有者的数量，当没有所有者时清理数据。</li><li>在 Rust 中因为引用和借用，普通引用和智能指针的一个额外的区别是引用是一类 <strong>只借用数据的指针</strong> ；相反，在大部分情况下，智能指针 <strong>拥有</strong> 它们指向的数据。</li></ul><p>常用的智能指针：</p><ul><li><code>Box&lt;T&gt;</code>，用于在堆上分配值</li><li><code>Rc&lt;T&gt;</code>，一个引用计数类型，其数据可以有多个所有者</li><li><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，通过 <code>RefCell&lt;T&gt;</code> 访问。（ <code>RefCell&lt;T&gt;</code> 是一个在运行时而不是在编译时执行借用规则的类型）。</li></ul><h2 id="使用Box-指向堆上的数据"><a href="#使用Box-指向堆上的数据" class="headerlink" title="使用Box &lt;T&gt;指向堆上的数据"></a>使用Box <code>&lt;T&gt;</code>指向堆上的数据</h2><p>box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。</p><h3 id="使用Box-在堆上储存数据"><a href="#使用Box-在堆上储存数据" class="headerlink" title="使用Box &lt;T&gt;在堆上储存数据"></a>使用Box <code>&lt;T&gt;</code>在堆上储存数据</h3><ul><li><code>let b = Box::new(5);</code></li></ul><h3 id="Box允许创建递归类型"><a href="#Box允许创建递归类型" class="headerlink" title="Box允许创建递归类型"></a>Box允许创建递归类型</h3><p> <strong>递归类型</strong> （ <em>recursive type</em> ）的值可以拥有另一个同类型的值作为其自身的一部分。</p><ul><li>cons list：<ul><li><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构，它由嵌套的列表组成。（类似于c++的广义表）</li><li>Box是指针，是可以知道大小的。</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">list</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Nil))))));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="通过Deref-trait将智能指针当作常规引用处理"><a href="#通过Deref-trait将智能指针当作常规引用处理" class="headerlink" title="通过Deref trait将智能指针当作常规引用处理"></a>通过Deref trait将智能指针当作常规引用处理</h2><ul><li>实现 <code>Deref</code> trait 允许我们重载 <strong>解引用运算符</strong></li><li>解引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x;<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>像引用一样使用Box <code>&lt;T&gt;</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(x);<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将 <code>y</code> 设置为一个指向 <code>x</code> 值拷贝的 <code>Box&lt;T&gt;</code> 实例，而不是指向 <code>x</code> 值的引用。</li></ul><h2 id="Rc-引用计数智能指针"><a href="#Rc-引用计数智能指针" class="headerlink" title="Rc &lt;T&gt;引用计数智能指针"></a>Rc <code>&lt;T&gt;</code>引用计数智能指针</h2><p>如果某个值有零个引用，就代表没有任何有效引用并可以被清理。</p><ul><li>使用Rc <code>&lt;T&gt;</code>共享数据</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, Rc&lt;List&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br>**<span class="hljs-keyword">use</span> std::rc::Rc;**<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">5</span>, Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">10</span>, Rc::<span class="hljs-title function_ invoke__">new</span>(Nil)))));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">4</span>, Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a));<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以调用 <code>a.clone()</code> 而不是 <code>Rc::clone(&amp;a)</code>，不过在这里 Rust 的习惯是使用 <code>Rc::clone</code>。</p><ul><li>克隆Rc <code>&lt;T&gt;</code>会增加引用计数</li></ul><ol><li><strong><code>Rc::clone</code></strong> ：</li></ol><ul><li><code>Rc::clone(&amp;sun)</code> 不会复制 <code>Sun</code> 实例，而是增加 <code>Rc</code> 的引用计数。</li><li>所有行星共享同一个 <code>Sun</code> 实例。</li></ul><ol><li><strong>引用计数</strong> ：</li></ol><ul><li>每次调用 <code>Rc::clone(&amp;sun)</code>，引用计数加 1。</li><li>每次调用 <code>drop</code>，引用计数减 1。</li></ul><ol><li><strong><code>drop</code> 的作用</strong> ：</li></ol><ul><li><code>drop</code> 用于手动释放所有权，减少引用计数。</li><li>当引用计数为 0 时，<code>Rc</code> 会自动释放内存。</li></ul><h2 id="cow"><a href="#cow" class="headerlink" title="cow:"></a>cow:</h2><h3 id="Cow-的核心思想是："><a href="#Cow-的核心思想是：" class="headerlink" title="Cow 的核心思想是："></a><code>Cow</code> 的核心思想是：</h3><ul><li>如果数据是 <strong>只读的</strong> ，直接 <strong>使用借用</strong> （<code>Borrowed</code>），避免复制。</li><li>如果数据 <strong>需要修改</strong> ，则 <strong>复制数据并拥有所有权</strong> （<code>Owned</code>）。</li></ul><h2 id="Cow-的常用方法"><a href="#Cow-的常用方法" class="headerlink" title="Cow 的常用方法"></a><code>Cow</code> 的常用方法</h2><h3 id="1-to-mut：获取可变引用"><a href="#1-to-mut：获取可变引用" class="headerlink" title="(1) to_mut：获取可变引用"></a>(1) <code>to_mut</code>：获取可变引用</h3><p>如果 <code>Cow</code> 是 <code>Borrowed</code>，则复制数据并转换为 <code>Owned</code>；如果已经是 <code>Owned</code>，则直接返回可变引用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cow</span> = Cow::<span class="hljs-title function_ invoke__">Borrowed</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = cow.<span class="hljs-title function_ invoke__">to_mut</span>(); <span class="hljs-comment">// 复制数据并转换为 Owned</span><br>s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; world&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s); <span class="hljs-comment">// 输出 &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-into-owned：获取所有权"><a href="#2-into-owned：获取所有权" class="headerlink" title="(2) into_owned：获取所有权"></a>(2) <code>into_owned</code>：获取所有权</h3><p>将 <code>Cow</code> 转换为拥有所有权的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">cow</span> = Cow::<span class="hljs-title function_ invoke__">Borrowed</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: <span class="hljs-type">String</span> = cow.<span class="hljs-title function_ invoke__">into_owned</span>(); <span class="hljs-comment">// 转换为 String</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s); <span class="hljs-comment">// 输出 &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-is-borrowed-和-is-owned：检查状态"><a href="#3-is-borrowed-和-is-owned：检查状态" class="headerlink" title="(3) is_borrowed 和 is_owned：检查状态"></a>(3) <code>is_borrowed</code> 和 <code>is_owned</code>：检查状态</h3><ul><li><code>is_borrowed</code>：检查是否是 <code>Borrowed</code>。</li><li><code>is_owned</code>：检查是否是 <code>Owned</code>。</li></ul><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> cow = Cow::Borrowed(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">assert</span>!(cow.<span class="hljs-keyword">is</span><span class="hljs-number">_</span>borrowed());<br><span class="hljs-keyword">assert</span>!(!cow.<span class="hljs-keyword">is</span><span class="hljs-number">_</span>owned());<br></code></pre></td></tr></table></figure><h2 id="使用Drop-Trait运行清理代码"><a href="#使用Drop-Trait运行清理代码" class="headerlink" title="使用Drop Trait运行清理代码"></a>使用Drop Trait运行清理代码</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Drop</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>drop方法在值离开作用域时<strong>自动调用</strong></p><p>也可以手动调用drop()来清理代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = MyStruct &#123; name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;x&quot;</span>) &#125;;<br>    <span class="hljs-title function_ invoke__">drop</span>(x); <span class="hljs-comment">// 手动调用 drop</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x has been dropped&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Drop与所有权"><a href="#Drop与所有权" class="headerlink" title="Drop与所有权"></a>Drop与所有权</h3><ul><li>当一个值的所有权转移时，drop不会立即调用，只有在<strong>值离开作用域时</strong>才会调用</li><li>如果值被移动（如传递给函数），drop会在新作用域结束时调用</li></ul><h2 id="Drop与Copy"><a href="#Drop与Copy" class="headerlink" title="Drop与Copy"></a>Drop与Copy</h2><p>二者不能同时实现</p><ul><li><code>Copy</code> trait 表示类型可以通过位复制来复制值，而 <code>Drop</code> 表示类型需要清理操作。</li><li>如果类型实现了 <code>Drop</code>，Rust 会阻止你实现 <code>Copy</code>，因为复制可能会<strong>导致资源被多次释放。</strong></li></ul><h2 id="RefCell-和内部可变模式"><a href="#RefCell-和内部可变模式" class="headerlink" title="RefCell &lt;T&gt;和内部可变模式"></a>RefCell <code>&lt;T&gt;</code>和内部可变模式</h2><ul><li><strong>内部可变性</strong>是rust中的一个设计模式，它允许你 <strong>即使在有不可变引用时也可以改变数据</strong> 。</li><li>该模式在数据结构中使用 <code>unsafe</code> 代码来模糊rust通常的可变性和借用规则。不安全代码表明我们在<strong>手动检查</strong>这些规则而不是让编译器替我们检查。</li></ul><h3 id="通过-RefCell在运行时检查借用规则"><a href="#通过-RefCell在运行时检查借用规则" class="headerlink" title="通过 RefCell&lt;T&gt;在运行时检查借用规则"></a>通过 <code>RefCell&lt;T&gt;</code>在运行时检查借用规则</h3><ul><li>不同于 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 代表其数据的唯一的所有权。</li></ul><p>如下为选择 <code>Box&lt;T&gt;</code>，<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由：</p><ul><li><code>Rc&lt;T&gt;</code> 允许相同数据 <strong>有多个所有者</strong> ；<code>Box&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 有单一所有者。</li><li><code>Box&lt;T&gt;</code> 允许在编译时执行不可变或可变借用检查；<code>Rc&lt;T&gt;</code>仅允许在编译时执行不可变借用检查；<code>RefCell&lt;T&gt;</code> 允许在运行时执行不可变或可变借用检查。</li><li>因为 <code>RefCell&lt;T&gt;</code> 允许在运行时执行可变借用检查，所以我们可以在即便 <code>RefCell&lt;T&gt;</code> 自身是不可变的情况下修改其内部的值。</li></ul><h3 id="内部可变性：不可变值的可变借用"><a href="#内部可变性：不可变值的可变借用" class="headerlink" title="内部可变性：不可变值的可变借用"></a>内部可变性：不可变值的可变借用</h3><p>借用规则的一个推论是当有一个不可变值时，不能可变地借用它。</p><ul><li><strong>mock对象</strong><ul><li><strong>mock 对象</strong> 是特定类型的 <strong>测试替身</strong> ，它们记录测试过程中发生了什么以便可以断言操作是正确的。</li></ul></li></ul><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><code>borrow()</code>：获取一个不可变引用（<code>Ref&lt;T&gt;</code>）。如果已经有可变引用，会 panic。</li><li><code>borrow_mut()</code>：获取一个可变引用（<code>RefMut&lt;T&gt;</code>）。如果已经有其他引用（可变或不可变），会 panic。</li><li><code>try_borrow()</code> 和 <code>try_borrow_mut()</code>：与 <code>borrow()</code> 和 <code>borrow_mut()</code> 类似，但不会 panic，而是返回 <code>Result</code>。</li></ul><h2 id="Arc-：-Atomic-Reference-Counting-（原子引用计数）"><a href="#Arc-：-Atomic-Reference-Counting-（原子引用计数）" class="headerlink" title="Arc &lt;T&gt;： Atomic Reference Counting （原子引用计数）"></a>Arc <code>&lt;T&gt;</code>： <strong>Atomic Reference Counting</strong> （原子引用计数）</h2><ol><li><strong>引用计数</strong> ：<code>Arc&lt;T&gt;</code> 会跟踪指向同一数据的引用数量。每次克隆 <code>Arc&lt;T&gt;</code> 时，引用计数会增加；当 <code>Arc&lt;T&gt;</code> 被丢弃时，引用计数会减少。当引用计数为 0 时，数据会被释放。</li><li><strong>线程安全</strong> ：<code>Arc&lt;T&gt;</code> 是线程安全的，因为它的引用计数操作是原子的（atomic），这意味着多个线程可以安全地共享同一个 <code>Arc&lt;T&gt;</code>。</li><li><strong>不可变性</strong> ：<code>Arc&lt;T&gt;</code> 本身是不可变的。如果需要修改内部数据，通常需要与 <code>Mutex&lt;T&gt;</code> 或 <code>RwLock&lt;T&gt;</code> 结合使用。</li></ol><h3 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><code>new(value: T) -&gt; Arc&lt;T&gt;</code>：创建一个新的 <code>Arc&lt;T&gt;</code>。</li><li><code>clone(&amp;self) -&gt; Arc&lt;T&gt;</code>：<strong>克隆</strong> <code>Arc&lt;T&gt;</code>，增加引用计数。</li><li><code>strong_count(&amp;self) -&gt; usize</code>：返回当前 <strong>强引用计数</strong> 。</li><li><code>downgrade(&amp;self) -&gt; Weak&lt;T&gt;</code>：创建一个 <strong>弱引用</strong> （<code>Weak&lt;T&gt;</code>），<strong>不会增加引用计数。</strong></li><li><code>try_unwrap(this: Arc&lt;T&gt;) -&gt; Result&lt;T, Arc&lt;T&gt;&gt;</code>：如果引用计数为 1，则返回内部数据；否则返回 <code>Arc&lt;T&gt;</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_iter</title>
    <link href="/2025/02/19/Rust-iter/"/>
    <url>/2025/02/19/Rust-iter/</url>
    
    <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h2><ul><li>迭代器是rust用于遍历集合的一种抽象，提供了一种统一的方式来访问集合中的元素，而不需要关心集合的具体实现</li><li>rust的迭代器是<strong>惰性</strong>的，只会在真正需要时才回进行计算</li></ul><h2 id="迭代器的核心trait：Iterator"><a href="#迭代器的核心trait：Iterator" class="headerlink" title="迭代器的核心trait：Iterator"></a>迭代器的核心trait：Iterator</h2><h3 id="Iterator-trait的定义："><a href="#Iterator-trait的定义：" class="headerlink" title="Iterator trait的定义："></a><code>Iterator</code> trait的定义：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&#123;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<span class="hljs-comment">//迭代器产生的值的类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)<span class="hljs-punctuation">-&gt;</span><span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<span class="hljs-comment">//获取下一个元素 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建迭代器："><a href="#创建迭代器：" class="headerlink" title="创建迭代器："></a>创建迭代器：</h2><ul><li><code>iter()</code>：生成一个<strong>不可变引用</strong>的迭代器。</li><li><code>iter_mut()</code>：生成一个<strong>可变引用</strong>的迭代器。</li><li><code>into_iter()</code>：生成一个<strong>获取所有权</strong>的迭代器。</li></ul><h2 id="使用迭代器："><a href="#使用迭代器：" class="headerlink" title="使用迭代器："></a>使用迭代器：</h2><p>常用的方法：</p><ol><li><code>map</code> ：对每个元素进行<strong>转换</strong></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">map</span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, f: F) <span class="hljs-punctuation">-&gt;</span> Map&lt;<span class="hljs-keyword">Self</span>, F&gt;<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnMut</span>(<span class="hljs-keyword">Self</span>::Item) <span class="hljs-punctuation">-&gt;</span> B,<br></code></pre></td></tr></table></figure><p>map方法接受一个闭包f，该闭包会对迭代器中的每个元素进行转换， <strong>返回一个新的迭代器</strong> ，产生转换后的值</p><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>=<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">doubled</span>:<span class="hljs-type">Vec</span>&lt;_&gt;=v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x*<span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;,doubled);</span><br></code></pre></td></tr></table></figure><ul><li>由于返回的是一个迭代器，需要使用 <code>collect()</code> 方法来将迭代器转换成集合</li><li><code>Vec&lt;_&gt;</code>：<code>_</code> 是一个占位符，表示让 Rust 编译器推断集合的类型。</li></ul><ol><li><p><code>filter</code> ：过滤元素</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">filter</span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) <span class="hljs-punctuation">-&gt;</span> Filter&lt;<span class="hljs-keyword">Self</span>, P&gt;<br><span class="hljs-keyword">where</span><br>    P: <span class="hljs-title function_ invoke__">FnMut</span>(&amp;<span class="hljs-keyword">Self</span>::Item) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>,<br></code></pre></td></tr></table></figure><p>filter方法接受一个闭包，该闭包会对每个元素进行判断，如果闭包返回true，则保留，否则丢弃；</p><p>返回一个新的得带起，只包含满足闭包的元素</p><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">evens</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|&amp;x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, evens); <span class="hljs-comment">// 输出 [2, 4]</span><br></code></pre></td></tr></table></figure></li><li><p><code>fold</code> ：累积计算</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">fold</span>&lt;B, F&gt;(<span class="hljs-keyword">self</span>, init: B, f: F) <span class="hljs-punctuation">-&gt;</span> B<br><span class="hljs-keyword">where</span><br>    F: <span class="hljs-title function_ invoke__">FnMut</span>(B, <span class="hljs-keyword">Self</span>::Item) <span class="hljs-punctuation">-&gt;</span> B,<br></code></pre></td></tr></table></figure><p>fold方法接受一个初始值init和一个闭包f；闭包会对每个元素进行累积计算；返回最终的累积结果</p><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span>: <span class="hljs-type">i32</span> = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">fold</span>(<span class="hljs-number">0</span>, |acc, &amp;x| acc + x);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, sum); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure></li><li><p><code>collect</code> ：将迭代器转换为集合</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">collect</span>&lt;B&gt;(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> B<br><span class="hljs-keyword">where</span><br>    B: FromIterator&lt;<span class="hljs-keyword">Self</span>::Item&gt;,<br></code></pre></td></tr></table></figure><p>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">doubled</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|&amp;x| x * <span class="hljs-number">2</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, doubled); <span class="hljs-comment">// 输出 [2, 4, 6]</span><br></code></pre></td></tr></table></figure></li><li><p><code>enumerate</code> ：获取索引和值<br>【例子】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, index, value);<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 0: a</span><br><span class="hljs-comment">// 1: b</span><br><span class="hljs-comment">// 2: c</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_包/Crate</title>
    <link href="/2025/02/19/Rust-%E5%8C%85-Crate/"/>
    <url>/2025/02/19/Rust-%E5%8C%85-Crate/</url>
    
    <content type="html"><![CDATA[<h1 id="使用包、Crate和模块管理不断增长的项目"><a href="#使用包、Crate和模块管理不断增长的项目" class="headerlink" title="使用包、Crate和模块管理不断增长的项目"></a>使用包、Crate和模块管理不断增长的项目</h1><ul><li><strong>包</strong> （ <em>Packages</em> ）：Cargo 的一个功能，它允许你构建、测试和分享 crate。</li><li><strong>Crates</strong> ：一个模块的树形结构，它形成了库或二进制项目。</li><li><strong>模块</strong> （ <em>Modules</em> ）和  <strong>use</strong> ：允许你控制作用域和路径的私有性。</li><li><strong>路径</strong> （ <em>path</em> ）：一个命名例如结构体、函数或模块等项的方式。</li><li>crate是rust在编译时的最小代码单位。如果使用rustc来编译，编译器依然会将这个文件认作一个crate。</li><li>crate的两种形式：二进制项和库</li><li><em>包</em> （ <em>package</em> ）是提供一系列功能的一个或者多个 crate。</li></ul><h2 id="定义模块来控制作用域和私有域"><a href="#定义模块来控制作用域和私有域" class="headerlink" title="定义模块来控制作用域和私有域"></a>定义模块来控制作用域和私有域</h2><h3 id="工作方式："><a href="#工作方式：" class="headerlink" title="工作方式："></a>工作方式：</h3><p>从crate根节点开始（寻找需要被编译的代码）→声明模块→声明子模块</p><ul><li><strong>声明模块</strong> : 在 crate 根文件中，你可以声明一个新模块；比如，你用 <code>mod garden;</code>声明了一个叫做 <code>garden</code>的模块。编译器会在下列路径中寻找模块代码：</li><li>内联，在大括号中，当 <code>mod garden</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src&#x2F;garden.rs</em></li><li>在文件 <em>src&#x2F;garden&#x2F;mod.rs</em></li><li><strong>声明子模块</strong> : 在除了 crate 根节点以外的其他文件中，你可以定义子模块。比如，你可能在<em>src&#x2F;garden.rs</em>中定义了 <code>mod vegetables;</code>。编译器会在以父模块命名的目录中寻找子模块代码：</li><li>内联，在大括号中，当 <code>mod vegetables</code>后方不是一个分号而是一个大括号</li><li>在文件 <em>src&#x2F;garden&#x2F;vegetables.rs</em></li><li>在文件 <em>src&#x2F;garden&#x2F;vegetables&#x2F;mod.rs</em></li><li>模块中的 <strong>代码路径</strong> ：举例而言，一个 garden vegetables 模块下的 <code>Asparagus</code>类型可以在 <code>crate::garden::vegetables::Asparagus</code>被找到。</li><li>公有（要加pub）和私有</li><li><strong>使用use关键字引入</strong> <code>use crate::garden::vegetables::Asparagus;</code></li></ul><h2 id="引用模块项目的路径"><a href="#引用模块项目的路径" class="headerlink" title="引用模块项目的路径"></a>引用模块项目的路径</h2><ul><li>绝对路径：从crate根开始</li><li>相对路径：从当前模块开始，以 <code>self</code>、<code>super</code> 或定义在当前模块中的标识符开头。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    <span class="hljs-comment">// 绝对路径</span><br>    crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br><br>    <span class="hljs-comment">// 相对路径</span><br>    front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="super开始的相对路径"><a href="#super开始的相对路径" class="headerlink" title="super开始的相对路径"></a>super开始的相对路径</h3><p>通过在路径的开头使用 <code>super</code> ，从父模块开始构建相对路径，而不是从当前模块或者 crate 根开始。</p><h3 id="使用as关键字提供新的名称"><a href="#使用as关键字提供新的名称" class="headerlink" title="使用as关键字提供新的名称"></a>使用as关键字提供新的名称</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> **<span class="hljs-keyword">as</span>** IoResult;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function1</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function2</span>() <span class="hljs-punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用pub-use重导出名称"><a href="#使用pub-use重导出名称" class="headerlink" title="使用pub use重导出名称"></a>使用pub use重导出名称</h3><ul><li>使用 <code>use</code> 关键字，将某个名称导入当前作用域后，这个名称在此作用域中就可以使用了，但它对此作用域之外还是私有的。</li><li>将 <code>pub</code> 和 <code>use</code> 合起来使用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="嵌套路径来消除大量的use行"><a href="#嵌套路径来消除大量的use行" class="headerlink" title="嵌套路径来消除大量的use行"></a>嵌套路径来消除大量的use行</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// --snip--</span><br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-comment">// --snip--</span><br><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// --snip--</span><br><span class="hljs-keyword">use</span> std::&#123;cmp::Ordering, io&#125;;<br><span class="hljs-comment">// --snip--</span><br><br></code></pre></td></tr></table></figure><h3 id="通过glob运算符将所有的公有定义引入作用域"><a href="#通过glob运算符将所有的公有定义引入作用域" class="headerlink" title="通过glob运算符将所有的公有定义引入作用域"></a>通过glob运算符将所有的公有定义引入作用域</h3><p><code>use std::collections::*;</code></p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_String</title>
    <link href="/2025/02/19/Rust-String/"/>
    <url>/2025/02/19/Rust-String/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h1><ul><li>string和&amp;str是两种不同的字符串类型，主要区别在于所有权和可变性</li><li>String<ul><li>拥有所有权</li><li>是可变的，在堆上分配内存</li></ul></li><li>&amp;str<ul><li>字符串切片—slice，通常是对string或字符串字面量的引用。不具有所有权</li><li>不可变的</li></ul></li></ul><h2 id="新建字符串"><a href="#新建字符串" class="headerlink" title="新建字符串"></a>新建字符串</h2><ul><li>和cpp等类似，string被实现为一个带有一些额外保证、限制和功能的字节vector封装</li></ul><p>新建：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//1</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s0</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<span class="hljs-comment">//由于string是可变的，前面要有mut关键字</span><br><span class="hljs-comment">//2</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">data</span>=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span>=data.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-comment">//3</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-comment">//4</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a>更新字符串</h2><ul><li>使用push_str()或push()来附加</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot; world&quot;</span>);<br></code></pre></td></tr></table></figure><ol><li><code>push_str()</code>采用 <strong>字符串slice</strong> ，不需要获得参数的所有权。例如：</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-string">&quot;world&quot;</span>;<br>s1.<span class="hljs-title function_ invoke__">push_str</span>(s2);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;s2&#125;&quot;</span>);<span class="hljs-comment">//可以通过编译！s2并没有失效</span><br></code></pre></td></tr></table></figure><ol><li><code>push()</code> 获取<strong>单个字符</strong>作为参数附加到String中。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;h&quot;</span>);<br>s.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;i&#x27;</span>);<br></code></pre></td></tr></table></figure><ol><li>使用 <code>+</code> 或 <code>format!</code> 宏 拼接字符串</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;wow&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>=s1 + **&amp;s2**;**<span class="hljs-comment">//此处s1被“移动”了，不能再使用了；s2仍然可以使用**</span><br></code></pre></td></tr></table></figure><ul><li>&amp;String可以强制转换成&amp;str</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;You&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;are&quot;</span>)l<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span>=<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;right&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>=<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;s1&#125; &#123;s2&#125; &#123;s3&#125;&quot;</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;s&#125;&quot;</span>);<br></code></pre></td></tr></table></figure><p>可以用于连接多个复杂字符串并返回；有点类似于println!</p><ul><li>rust的字符串不支持索引</li><li>每个 Unicode 标量值需要两个字节存储</li></ul><h2 id="字符串slice"><a href="#字符串slice" class="headerlink" title="字符串slice"></a>字符串slice</h2><p>可以创建slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span>=&amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><p>在 Rust 中，字符串是以 UTF-8 编码的，因此遍历字符串时需要注意字符和字节的区别。Rust 提供了多种方法来遍历字符串的不同部分，具体取决于你需要操作的是字符、字节还是更复杂的字形簇（grapheme clusters）。</p><hr><h3 id="1-遍历-Unicode-标量值（字符）"><a href="#1-遍历-Unicode-标量值（字符）" class="headerlink" title="1. 遍历 Unicode 标量值（字符）"></a>1. <strong>遍历 Unicode 标量值（字符）</strong></h3><p>使用 <code>chars()</code> 方法可以将字符串按 Unicode 标量值（即 Rust 中的 <code>char</code> 类型）分割，并逐个遍历。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Зд&quot;</span>.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;c&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">З<br>д<br><br></code></pre></td></tr></table></figure><ul><li><strong>适用场景</strong> ：当你需要处理单个 Unicode 字符时。</li><li><strong>注意</strong> ：<code>chars()</code> 返回的是 Unicode 标量值，而不是字形簇（例如，某些字符可能由多个 Unicode 标量值组成，如 <code>é</code> 可以是 <code>e</code> 和 <code>´</code> 的组合）。</li></ul><hr><h3 id="2-遍历原始字节"><a href="#2-遍历原始字节" class="headerlink" title="2. 遍历原始字节"></a>2. <strong>遍历原始字节</strong></h3><p>使用 <code>bytes()</code> 方法可以遍历字符串的原始字节（UTF-8 编码的字节序列）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">b</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Зд&quot;</span>.<span class="hljs-title function_ invoke__">bytes</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;b&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">208<br>151<br>208<br>180<br><br></code></pre></td></tr></table></figure><ul><li><strong>适用场景</strong> ：当你需要处理字符串的底层字节表示时。</li><li><strong>注意</strong> ：UTF-8 编码中，一个 Unicode 标量值可能由多个字节组成（例如，<code>З</code> 由两个字节 <code>208</code> 和 <code>151</code> 组成）。</li></ul><hr><h3 id="3-遍历字形簇（Grapheme-Clusters）"><a href="#3-遍历字形簇（Grapheme-Clusters）" class="headerlink" title="3. 遍历字形簇（Grapheme Clusters）"></a>3. <strong>遍历字形簇（Grapheme Clusters）</strong></h3><p>字形簇是用户感知的“字符”，可能由多个 Unicode 标量值组成。例如，<code>é</code> 可以是一个字形簇，但它可能由 <code>e</code> 和 <code>´</code> 两个 Unicode 标量值组成。</p><p>Rust 标准库没有直接支持字形簇的操作，但可以通过第三方库（如 <code>unicode-segmentation</code>）来实现。</p><h3 id="使用-unicode-segmentation-库"><a href="#使用-unicode-segmentation-库" class="headerlink" title="使用 unicode-segmentation 库"></a>使用 <code>unicode-segmentation</code> 库</h3><p>首先，在 <code>Cargo.toml</code> 中添加依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">unicode-segmentation</span> = <span class="hljs-string">&quot;1.10&quot;</span><br><br></code></pre></td></tr></table></figure><p>然后，使用 <code>graphemes()</code> 方法遍历字形簇：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> unicode_segmentation::UnicodeSegmentation;<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">g</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;नमस्ते&quot;</span>.<span class="hljs-title function_ invoke__">graphemes</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;g&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">न<br>म<br>स्<br>ते<br><br></code></pre></td></tr></table></figure><ul><li><strong>适用场景</strong> ：当你需要处理用户感知的“字符”时（例如，文本渲染或输入处理）。</li><li><strong>注意</strong> ：字形簇的处理比字符和字节更复杂，因此需要依赖第三方库。</li></ul><hr><h3 id="4-遍历字符串的其他方法"><a href="#4-遍历字符串的其他方法" class="headerlink" title="4. 遍历字符串的其他方法"></a>4. <strong>遍历字符串的其他方法</strong></h3><ul><li><strong>按行遍历</strong> ：使用 <code>lines()</code> 方法可以将字符串按行分割。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;hello\\\\nworld&quot;</span>.<span class="hljs-title function_ invoke__">lines</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;line&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>按单词遍历</strong> ：使用 <code>split_whitespace()</code> 方法可以将字符串按空白字符分割。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;hello world&quot;</span>.<span class="hljs-title function_ invoke__">split_whitespace</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;word&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>方法</th><th>返回类型</th><th>适用场景</th><th>注意事项</th></tr></thead><tbody><tr><td><code>chars()</code></td><td><code>char</code></td><td>处理单个 Unicode 标量值</td><td>不适用于字形簇</td></tr><tr><td><code>bytes()</code></td><td><code>u8</code></td><td>处理字符串的原始字节</td><td>一个字符可能由多个字节组成</td></tr><tr><td><code>graphemes()</code>（第三方）</td><td>字形簇</td><td>处理用户感知的“字符”</td><td>需要 <code>unicode-segmentation</code>库</td></tr><tr><td><code>lines()</code></td><td>字符串切片</td><td>按行分割字符串</td><td>适用于多行文本</td></tr><tr><td><code>split_whitespace()</code></td><td>字符串切片</td><td>按空白字符分割字符串</td><td>适用于单词分割</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust_Notes</title>
    <link href="/2025/02/10/Rust-Notes/"/>
    <url>/2025/02/10/Rust-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="Resources："><a href="#Resources：" class="headerlink" title="Resources："></a>Resources：</h1><p><a href="https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html">https://kaisery.github.io/trpl-zh-cn/ch01-02-hello-world.html</a></p><h1 id="导学阶段："><a href="#导学阶段：" class="headerlink" title="导学阶段："></a>导学阶段：</h1><ul><li>rust的更新和卸载：<ul><li>更新：<code>rustup update</code></li><li>卸载：<code>rustup self uninstall</code></li></ul></li></ul><h2 id="Hello-World！第一个rust程序："><a href="#Hello-World！第一个rust程序：" class="headerlink" title="Hello World！第一个rust程序："></a>Hello World！第一个rust程序：</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="一些基础知识："><a href="#一些基础知识：" class="headerlink" title="一些基础知识："></a>一些基础知识：</h2><ul><li><p>函数的定义：</p><ul><li>如main函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要有fn作为函数的基本标志，其余类似于c++</p><p>ps：语句也需要有分号</p></li><li><p>调用Rust宏：如果看到了 <code>!</code> 说明调用了宏而不是普通函数。</p></li></ul><h2 id="包管理器Cargo"><a href="#包管理器Cargo" class="headerlink" title="包管理器Cargo"></a>包管理器Cargo</h2><blockquote><p>可以帮助我们构建代码，下载依赖库并编译这些库</p></blockquote><ol><li>使用cargo创建项目：<code>cargo new xxx</code></li></ol><p>会创建一个文件夹，里面包含了一个src文件夹和两个文件</p><ul><li>如果没有使用cargo开始项目，我们可以将其转换成cargo项目；<ul><li>将项目代码移入src目录</li><li>创建一个合适的cargo.toml文件（可以使用 cargo init命令）</li></ul></li></ul><ol><li><p>构建并运行cargo项目</p><ol><li>构建项目：<code>cargo build</code> —可以看到生成的可执行文件落在了debug文件夹下。</li><li>运行：可以使用具体位置来运行，也可以直接输入 <code>cargo run</code> 来运行。推荐后者</li></ol><p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/2e763812-23f7-45b6-8338-e8153720b833/88683d38-8c7e-4b4a-92dd-43c2040fe6ce/image.png" alt="image.png"></p></li><li><p>快速检查代码确保其可以编译：<code>cargo check</code></p></li><li><p>发布构建：可以使用 <code>cargo build --release</code> 来优化编译项目。生成结果在target&#x2F;release下</p></li></ol><h2 id="小例子：猜数游戏"><a href="#小例子：猜数游戏" class="headerlink" title="小例子：猜数游戏"></a>小例子：猜数游戏</h2><ol><li>作用域引入；e.g: <code>use std::io;</code></li><li><strong>变量</strong>存储用户输入：可变的变量和不可变的变量<ol><li>使用let来创建变量：<ol><li>可变：<code>let mut var = String::new();</code></li><li>不可变：<code>let var = 5;</code></li></ol></li></ol></li><li>println!(”You guess:{}”,guess);这里的{}是一个占位符，用于打印变量的值，逗号后面是打印的表达式列表；</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;x&#125; and y + 2 = &#123;&#125;&quot;</span>, y + <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>会打印出 <code>x = 5 and y + 2 = 12</code></p><ol><li>使用<strong>crate</strong>来增加更多功能<ol><li>crate 是一组 Rust 源代码文件。</li><li><code>rand</code> crate 是一个 <em>库 crate</em>，库 crate 可以包含任意能被其他程序使用的代码，但是无法独立执行。</li><li>在我们使用 <code>rand</code> 编写代码之前，需要修改 <em>Cargo.toml</em> 文件，引入一个 <code>rand</code> 依赖。</li></ol></li><li>cargo.lock<ol><li>当第一次构建项目时，Cargo 计算出所有符合要求的依赖版本并写入 <em>Cargo.lock</em> 文件。当将来构建项目时，Cargo 会发现 <em>Cargo.lock</em> 已存在并使用其中指定的版本，而不是再次计算所有的版本。这使得你拥有了一个自动化的可重现的构建。换句话说，项目会持续使用 <code>0.8.5</code> 直到你显式升级，多亏有了 <em>Cargo.lock</em> 文件。由于 <em>Cargo.lock</em> 文件对于“可重复构建”非常重要，因此它通常会和项目中的其余代码一样纳入到版本控制系统中。</li></ol></li><li>更新crate到新版本：使用 <code>cargo update</code><br>，会忽略cargo.lock文件，并计算出所有符合cargo.toml声明的最新版本。接下来把这些版本写入cargo.lock中。</li><li>Cargo 有一个很棒的功能是：运行 <code>cargo doc --open</code> 命令来构建所有本地依赖提供的文档，并在浏览器中打开。</li></ol><h2 id="常见编程概念"><a href="#常见编程概念" class="headerlink" title="常见编程概念"></a>常见编程概念</h2><h3 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h3><ol><li>变量<strong>默认</strong>是<strong>不可改变的</strong>。当变量不可变时，一旦值被绑定一个名称上，就不能改变这个值。</li></ol><p><img src="attachment:d36497e2-b2c3-4196-ac77-eac508ff047c:image.png" alt="image.png"></p><p>如果我们对同一个不可变的变量赋值两次，会出现报错。</p><p>但如果我们修改一下，改成let mut x&#x3D;5；这样子是可变的变量，就可以赋值多次。</p><p><img src="attachment:9a16ddaf-d30a-44c3-b87c-f696a04a71b4:image.png" alt="image.png"></p><p><img src="attachment:e53bd69f-3268-4fe3-8087-a3ed10f1f452:image.png" alt="image.png"></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>常量也是绑定到一个名称的不允许改变的值。（q：常量和不可变量的区别？<ul><li>不允许对常量使用mut。常量总是不可变的。</li><li>声明常量使用const，而不是let，并且 <em>必须</em> 注明<strong>值的类型</strong>。</li><li>常量可以在任何作用域中声明，包括全局作用域</li><li>常量只能被设置为<strong>常量表达式</strong>，而不可以是其他任何只能在运行时计算出的值</li></ul></li></ul><p>下面是一个声明常量的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="hljs-type">u32</span> = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>定义一个与之前变量同名的新变量。就会把前面的变量隐藏。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>标量和复合</p><p><strong>标量类型：</strong></p><ul><li><p>整数类型：i8, i16, i32, i64, i128 和 u8, u16, u32, u64, u128（i表示有符号，u表示无符号）</p><ul><li>可以使用_来分隔数字，方便读数</li></ul><table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr><tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr><tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr><tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr><tr><td>Byte (单字节字符)(仅限于 <code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><ul><li><p>溢出处理：</p><ul><li>所有模式下都可以使用 <code>wrapping_*</code> 方法进行 wrapping，如 <code>wrapping_add</code></li><li>如果 <code>checked_*</code> 方法出现溢出，则返回 <code>None</code>值</li><li>用 <code>overflowing_*</code> 方法返回值和一个布尔值，表示是否出现溢出</li><li>用 <code>saturating_*</code> 方法在值的最小值或最大值处进行饱和处理</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">wrapping_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 0</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">checked_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 None</span><br><span class="hljs-keyword">let</span> (result, overflowed) = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">overflowing_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 (0, true)</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">255u8</span>.<span class="hljs-title function_ invoke__">saturating_add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为 255</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>浮点数类型：f32, f64。</p><ul><li>默认类型是 <code>f64</code></li></ul></li><li><p>布尔类型：bool，值只能是true或false（可以显示或者隐式表示）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// with explicit type annotation</span><br></code></pre></td></tr></table></figure></li><li><p>字符类型：char，表示单个Unicode标量值</p></li></ul><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><blockquote><p>将多个值组合成一个类型。元组和数组</p></blockquote><p>元组：多个其他类型的值组合进一个符合类型的主要方式。长度固定：一旦声明，长度不会增大或缩小。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>tup变量绑定到整个元组上，使用<strong>模式匹配</strong>来解构元组值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    **<span class="hljs-keyword">let</span> (x, y, z) = tup;**<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;y&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将一个元组拆成x,y,z就叫做解构。</p><p>也可以使用 <code>.</code> 后跟值的索引来直接访问他们。</p><p>如：tup.0;tup.1这样子。（索引从0开始）</p><p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。</p><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><blockquote><p>每个元素类型必须相同。数组长度也是固定的。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-comment">//数据类型;数量</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<span class="hljs-comment">//初始值;元素个数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>索引访问</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><p>在fn后面输入函数名和一对圆括号来定义函数。大括号告诉编译器函数体的开始和结尾。</p></li><li><p>rust<strong>不关心函数定义所在的位置</strong>；可以在main之前也可以在之后。</p></li><li><p>参数：</p><ol><li>在函数签名中必须<strong>声明每个参数的类型</strong>。</li></ol></li><li><p>语句和表达式</p><ol><li>语句：执行一些操作但不返回值的指令</li><li>表达式：计算并产生一个值。</li><li>表达式的结尾没有分号，如果加上分号就会变成语句。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">3</span>;<br>    x + <span class="hljs-number">1</span>     <span class="hljs-comment">//这里没有分号。</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>具有返回值的函数：不对返回值命名，但在箭头后声明他的类型。 可以使用return和指定值提前返回。否则函数会隐式地<strong>返回最后的表达式（保证最后是一个表达式，而不是语句）</strong></p></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">five</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p><strong>if表达式：</strong></p><ul><li>if后面直接跟一个表达式，不需要加括号，表达式之后再加大括号</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> number &lt; <span class="hljs-number">5</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was true&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;condition was false&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>rust不会在比较的时候将整数转换为布尔值</p><ul><li>在let语句中使用if：<code>let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;</code></li></ul><p><strong>使用循环重复执行：</strong></p><ul><li>loop循环：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;again!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从循环返回值：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>    counter += <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>        **<span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<span class="hljs-comment">//在break后面输入返回值**</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>循环标签：在多个循环之间消除歧义</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-symbol">&#x27;counting_up</span>: <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;count = &#123;count&#125;&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">remaining</span> = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;remaining = &#123;remaining&#125;&quot;</span>);<br>            <span class="hljs-keyword">if</span> remaining == <span class="hljs-number">9</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> count == <span class="hljs-number">2</span> &#123;<br>                <span class="hljs-keyword">break</span> <span class="hljs-symbol">&#x27;counting_up</span>;<br>            &#125;<br>            remaining -= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        count += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;End count = &#123;count&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>while条件循环</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> number != <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;number&#125;!&quot;</span>);<br><br>    number -= <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>for遍历集合</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> a &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the value is: &#123;element&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">number</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>..<span class="hljs-number">4</span>).<span class="hljs-title function_ invoke__">rev</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;number&#125;!&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;LIFTOFF!!!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>翻转range</p><h1 id="阶段一："><a href="#阶段一：" class="headerlink" title="阶段一："></a>阶段一：</h1><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><blockquote><p>让 Rust 无需垃圾回收（garbage collector）即可保障内存安全</p></blockquote><ol><li>所有权是rust用于管理内存的一组规则。区别于其他语言的管理方式（垃圾回收机制or程序员亲自分配和释放内存），rust采用<strong>通过所有权系统管理内存</strong>，编译器在编译时会根据一系列的规则进行检查，如果违反了这些规则，程序就不能编译。</li><li>栈中的所有数据都必须占用已知且固定的大小，在编译时大小位置或大小可能变化的数据，要改为存储在堆上。向堆中放入数据时，你要请求一定大小的空间。内存分配器在堆上找到合适空位后，标记并返回表示该地址的指针，这个指针可以存储在栈上。</li><li>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的</li><li>所有权规则：<ol><li>Rust 中的每一个值都有一个 <strong>所有者</strong>（<em>owner</em>）。</li><li>值在任一时刻<strong>有且只有一个所有者</strong>。</li><li>当<strong>所有者（变量）离开作用域</strong>，这个<strong>值将被丢弃</strong>。</li></ol></li></ol><p>ps: String类型</p><ol><li>获取：let s&#x3D;String::from(”hello”);</li><li>在字符串后追加字面值：s.push_str(”,world!”);</li></ol><p>string类型可变，但是值不可变；string类型向堆申请内存。</p><h3 id="变量与数据交互的方式（一）：移动"><a href="#变量与数据交互的方式（一）：移动" class="headerlink" title="变量与数据交互的方式（一）：移动"></a><strong>变量与数据交互的方式（一）：移动</strong></h3><ul><li>多个变量可以采取不同的方式与同一数据进行交互</li><li>当s1赋值给s2后，s1就会失效。也就是s1被移动到了s2。（避免了二次释放）</li></ul><h3 id="变量与数据交互的方式（二）：克隆"><a href="#变量与数据交互的方式（二）：克隆" class="headerlink" title="变量与数据交互的方式（二）：克隆"></a>变量与数据交互的方式（二）：克隆</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>**copy trait：**如果一个类型实现了copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用</p><p>任何一组<strong>简单标量值</strong>的组合都可以实现 <code>Copy</code> ：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都实现 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 实现了 <code>Copy</code>，但 <code>(i32, String)</code> 就没有。</li></ul><h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><ul><li>将值传递给函数与变量赋值的原理相似，向函数传递值可能会移动或者复制。如果是可copy的，就是复制进去，原变量仍有效。但如果是移动进去，原变量无效了。</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);             <span class="hljs-comment">// s 的值移动到函数里 ...</span><br>                                    <span class="hljs-comment">// ... 所以到这里不再有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);                  <span class="hljs-comment">// x 应该移动函数里，</span><br>                                    <span class="hljs-comment">// 但 i32 是 Copy 的，</span><br>                                    <span class="hljs-comment">// 所以在后面可继续使用 x</span><br><br>&#125; <span class="hljs-comment">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br>  <span class="hljs-comment">// 没有特殊之处</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <span class="hljs-comment">// some_string 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;some_string&#125;&quot;</span>);<br>&#125; <span class="hljs-comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span><br>  <span class="hljs-comment">// 占用的内存被释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <span class="hljs-comment">// some_integer 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;some_integer&#125;&quot;</span>);<br>&#125; <span class="hljs-comment">// 这里，some_integer 移出作用域。没有特殊之处</span><br></code></pre></td></tr></table></figure><h2 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h2><ul><li>返回值也可以转移所有权</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();         <span class="hljs-comment">// gives_ownership 将返回值</span><br>                                        <span class="hljs-comment">// 转移给 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 进入作用域</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="hljs-comment">// s2 被移动到</span><br>                                        <span class="hljs-comment">// takes_and_gives_back 中，</span><br>                                        <span class="hljs-comment">// 它也将返回值移给 s3</span><br>&#125; <span class="hljs-comment">// 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br>  <span class="hljs-comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;             <span class="hljs-comment">// gives_ownership 会将</span><br>                                             <span class="hljs-comment">// 返回值移动给</span><br>                                             <span class="hljs-comment">// 调用它的函数</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;yours&quot;</span>); <span class="hljs-comment">// some_string 进入作用域。</span><br><br>    some_string                              <span class="hljs-comment">// 返回 some_string </span><br>                                             <span class="hljs-comment">// 并移出给调用的函数</span><br>                                             <span class="hljs-comment">// </span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <span class="hljs-comment">// a_string 进入作用域</span><br>                                                      <span class="hljs-comment">// </span><br><br>    a_string  <span class="hljs-comment">// 返回 a_string 并移出给调用的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><blockquote><p><strong>不获取所有权</strong>就可以使用值的功能。</p></blockquote><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(**&amp;s1**);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: **&amp;<span class="hljs-type">String</span>**) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在传参的时候也要显式地表明是引用传参</li></ul><p>解引用：<code>*</code></p><p><strong>创建一个引用的行为，称为借用</strong></p><ul><li>（默认）不允许修改引用的值。</li></ul><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><ul><li>类似的，我们通过添加 <code>mut</code> 来声明是可变的。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">change</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change</span>(some_string: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    some_string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。</li><li>不能在同一时间多次将 <code>s</code> 作为可变变量借用。</li><li>我们 <strong>也</strong> 不能在拥有不可变引用的同时拥有可变引用。</li><li>可以避免数据竞争。</li></ul><p><strong>总的来说，就是我们可以同时拥有多个不可变引用，但是不可以在拥有不可变引用时拥有可变引用（不能同时使用）；也不可以同时拥有多个可变引用。</strong></p><h3 id="悬垂引用"><a href="#悬垂引用" class="headerlink" title="悬垂引用"></a>悬垂引用</h3><p>在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器<strong>确保数据不会在其引用之前离开作用域。</strong></p><h2 id="Slice类型"><a href="#Slice类型" class="headerlink" title="Slice类型"></a>Slice类型</h2><p><em>slice</em> 允许你引用集合中<strong>一段连续的元素序列</strong>，而不用引用整个集合。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..];<br></code></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="vector："><a href="#vector：" class="headerlink" title="vector："></a>vector：</h2><blockquote><p>类似于array，但长度可以改变，存储在heap中。存储的数据类型要相同</p></blockquote><h3 id="创建vector"><a href="#创建vector" class="headerlink" title="创建vector"></a>创建vector</h3><ul><li>调用 <code>Vec::new()</code> 函数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> : <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure><p>C++：<code>vector&lt;int&gt; v;</code></p><p>在没有显式的给定初始值的时候，我们需要显式地指出vector要存储的数据类型。可以使用 <code>vec!</code> 宏，会根据我们提供的值来创建一个新的vector</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>=<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="更新vector"><a href="#更新vector" class="headerlink" title="更新vector"></a>更新vector</h2><p>向vector中添加新元素，可以使用 <code>push()</code> 方法；</p><p>比如：<code>v.push(4);</code></p><p>**但是！**需要注意的是，同之前讨论的任何变量一样，如果想要改变他的值，必须要使用 <code>mut</code> 关键字使其可变！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span>=<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//这样子才是可以通过编译的</span><br></code></pre></td></tr></table></figure><h2 id="读取vector的元素"><a href="#读取vector的元素" class="headerlink" title="读取vector的元素"></a>读取vector的元素</h2><ul><li>通过索引读取</li><li>使用 <code>get()</code> 方法</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>= <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">third</span>:&amp;<span class="hljs-type">i32</span>=&amp;v[<span class="hljs-number">2</span>];<span class="hljs-comment">//这里相当于索引引用？</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;third&#125;&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">third</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt;=v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">match</span> third&#123;<br><span class="hljs-title function_ invoke__">Some</span>(third)=&gt;<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The third element is &#123;third&#125;&quot;</span>)，<br><span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no third element.&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是索引引用，程序员需要保证一定不会越界，否则程序会崩溃且报错；</p><p>但是如果是get方法，则可以产生一个无法获取的打印信息；</p><ul><li>不可以在拥有vector中项的引用的同时向其增加一个元素</li></ul><p>在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p><h2 id="遍历vector中的元素"><a href="#遍历vector中的元素" class="headerlink" title="遍历vector中的元素"></a>遍历vector中的元素</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;i&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>    *i += <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举：存储多种类型"><a href="#枚举：存储多种类型" class="headerlink" title="枚举：存储多种类型"></a>枚举：存储多种类型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SpreadsheetCell</span> &#123;<br>    <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">row</span> = <span class="hljs-built_in">vec!</span>[<br>    SpreadsheetCell::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">3</span>),<br>    SpreadsheetCell::<span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;blue&quot;</span>)),<br>    SpreadsheetCell::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">10.12</span>),<br>];<br><br></code></pre></td></tr></table></figure><h2 id="丢弃vector时也会丢弃所有元素"><a href="#丢弃vector时也会丢弃所有元素" class="headerlink" title="丢弃vector时也会丢弃所有元素"></a>丢弃vector时也会丢弃所有元素</h2><h2 id="一些函数："><a href="#一些函数：" class="headerlink" title="一些函数："></a>一些函数：</h2><ol><li><strong>可变引用</strong>：<code>iter_mut()</code> 生成的引用是可变的，允许你修改集合中的元素。</li><li><strong><code>v.iter()</code></strong>:<ul><li>返回一个<strong>不可变引用</strong>的迭代器（<code>Iterator&lt;Item = &amp;T&gt;</code>）。</li><li>这意味着你可以遍历集合中的每个元素，但不能修改它们。</li></ul></li><li><strong><code>map(|element| &#123; ... &#125;)</code></strong>:<ul><li><code>map</code> 是一个<strong>高阶函数</strong>，接受一个<strong>闭包</strong>（<code>|element| &#123; ... &#125;</code>）作为参数。</li><li>闭包会对迭代器中的每个元素（<code>element</code>）进行处理，并返回一个新的值。</li><li>这里的 <code>element</code> 是集合中元素的不可变引用（<code>&amp;T</code>）。</li></ul></li><li><strong><code>collect()</code></strong>:<ul><li>将 <code>map</code> 处理后的结果收集到一个新的集合中（如 <code>Vec&lt;T&gt;</code>）。</li><li><code>collect()</code> 的返回类型取决于上下文，通常需要显式指定类型或通过类型推断确定。</li></ul></li></ol><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="定义与实例化"><a href="#定义与实例化" class="headerlink" title="定义与实例化"></a>定义与实例化</h2><ul><li>结构体的每一部分可以是不同类型；</li><li>结构体比元组更加灵活，<strong>不需要依赖顺序</strong>来指定或访问实例中的值</li></ul><p>定义方式与c++类似；</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Name</span>&#123;<br>var1:type1,<br>var2:type2,<br>var3:type3,<br>&#125;<br></code></pre></td></tr></table></figure><p>在大括号中，定义每一部分数据结构的名字和类型，我们称为<strong>字段</strong></p><ul><li>实例化：</li></ul><p>创建一个实例，需要以结构体的名字开头，接着在大括号中使用 <code>key:value</code> 键-值对的形式提供字段。实例中字段顺序不需要和他们在结构体声明中的顺序一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;;<br>     <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user2</span> = User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;;<br>    user2.email = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;anotheremail@example.com&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>.</code> 来获取对应的值或者修改对应的值</li><li><strong>注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。</strong></li></ul><h3 id="字段初始化简写语法"><a href="#字段初始化简写语法" class="headerlink" title="字段初始化简写语法"></a><strong>字段初始化简写语法</strong></h3><ul><li>如果在创建一个新实例的时候，我们哟啊将email字段的值设置为传入参数email的值，不需要显式地说明，他们可以直接对应</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        username: username,<br>        email: email,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//简化后：</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        active: <span class="hljs-literal">true</span>,<br>        **username,<br>        email,**<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a><strong>结构体更新语法</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//原版：</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// --snip--</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>        active: user1.active,<br>        username: user1.username,<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>        sign_in_count: user1.sign_in_count,<br>    &#125;;<br>&#125;<br><span class="hljs-comment">//简化后：</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// --snip--</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>        email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>        **..user1**<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是利用了<strong>移动</strong>。所以后续不能再使用user1了</p><p>但是如果我们丢username和email这种不是很轻松复制的变量都进行修改，那么就可以利用<strong>克隆</strong>，这样子user1仍然可用</p><h3 id="使用没有命名字段的元组结构来创建不同的类型"><a href="#使用没有命名字段的元组结构来创建不同的类型" class="headerlink" title="使用没有命名字段的元组结构来创建不同的类型"></a>使用没有命名字段的元组结构来创建不同的类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = <span class="hljs-title function_ invoke__">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="没有任何字段的类单元结构体"><a href="#没有任何字段的类单元结构体" class="headerlink" title="没有任何字段的类单元结构体"></a>没有任何字段的类单元结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlwaysEqual</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">subject</span> = AlwaysEqual;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a>方法语法</h1><p><strong>方法</strong>（method）与函数类似：它们使用 <code>fn</code> 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们<strong>在结构体的上下文中被定义</strong>（或者是枚举或 trait 对象的上下文，将分别在<a href="https://kaisery.github.io/trpl-zh-cn/ch06-00-enums.html">第六章</a>和<a href="https://kaisery.github.io/trpl-zh-cn/ch18-02-trait-objects.html">第十八章</a>讲解），并且它们<strong>第一个参数总是 <code>self</code></strong>，它代表调用该方法的结构体实例。</p><h2 id="定义方法："><a href="#定义方法：" class="headerlink" title="定义方法："></a>定义方法：</h2><p>impl代表实例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关联函数：</p><p>所有在 <code>impl</code> 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>），因为它们与 <code>impl</code> 后面命名的类型相关。</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_learning</title>
    <link href="/2025/02/08/OS-learning/"/>
    <url>/2025/02/08/OS-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter1：操作系统接口"><a href="#chapter1：操作系统接口" class="headerlink" title="chapter1：操作系统接口"></a>chapter1：操作系统接口</h1><p><strong>操作系统的工作是：</strong></p><ul><li>将<strong>计算机资源在多个程序之间共享</strong>，并给程序提供一系列比硬件本身更有用的服务</li><li><strong>管理并抽象</strong>底层硬件。（如word不用关心自己使用的是哪种硬盘）</li><li>多路复用硬件，让多个程序“看起来”是同时运行的。</li><li>给程序间提供一种受控的交互方式，使得程序之间可以共享数据、共同工作</li></ul><p>操作系统通过<strong>接口</strong>向用户程序提供服务。接口设计依赖于少量的机制，通过这些机制的组合提供强大、通用的功能。</p><ul><li><em>kernel</em>(内核)：为运行的程序提供服务的一种特殊程序。每个运行着的程序叫做进程，<strong>每个进程的内存中存储指令、数据和堆栈</strong>。一个计算机可以<strong>拥有多个进程</strong>，但是只能有一个内核。</li><li>每当进程需要调用内核时，它会触发一个<em>system call</em>（系统调用），system call进入内核执行相应的服务然后返回。</li><li>shell 是一个普通的程序，它接受用户输入的命令并且执行它们。不是内核的一部分。</li><li>xv6内核提供了Unix传统系统调用的一部分。</li></ul><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>fork()</strong></td><td><strong>创建进程</strong></td></tr><tr><td>exit()</td><td>结束当前进程；0代表以正常状态退出，1代表以非正常状态退出</td></tr><tr><td>wait()</td><td>等待子进程结束;等待子进程退出，返回子进程PID;没有子程序则返回-1</td></tr><tr><td>kill(pid)</td><td>结束 pid 所指进程</td></tr><tr><td>getpid()</td><td>获得当前进程 pid</td></tr><tr><td><strong>sleep(n)</strong></td><td><strong>睡眠 n 秒</strong></td></tr><tr><td>exec(filename, *argv)</td><td>加载并执行一个文件</td></tr><tr><td>sbrk(n)</td><td>为进程内存空间增加 n 字节</td></tr><tr><td>open(filename, flags)</td><td>打开文件，flags 指定读&#x2F;写模式</td></tr><tr><td>read(fd, buf, n)</td><td>从文件中读 n 个字节到 buf</td></tr><tr><td>write(fd, buf, n)</td><td>从 buf 中写 n 个字节到文件</td></tr><tr><td>close(fd)</td><td>关闭打开的 fd</td></tr><tr><td>dup(fd)</td><td>复制 fd</td></tr><tr><td>pipe( p)</td><td>创建管道， 并把读和写的 fd 返回到p</td></tr><tr><td>chdir(dirname)</td><td>改变当前目录</td></tr><tr><td>mkdir(dirname)</td><td>创建新的目录</td></tr><tr><td>mknod(name, major, minor)</td><td>创建设备文件</td></tr><tr><td>fstat(fd)</td><td>返回文件信息</td></tr><tr><td>link(f1, f2)</td><td>给 f1 创建一个新名字(f2)</td></tr><tr><td>unlink(filename)</td><td>删除文件</td></tr></tbody></table><h2 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h2><ol><li>xv6进程由两部分组成：<strong>用户内存空间</strong>（指令，数据，堆栈）+ <strong>仅对内核可见</strong>的进程状态</li><li>分时特性：在可用CPU之间不断切换。当一个进程不在执行时，xv6保存它的CPU寄存器，当他们再次被执行时恢复这些寄存器的值。</li><li>内核将每个<strong>进程</strong>和一个<strong>PID</strong>（process identifier）关联起来</li><li>一个进程可以通过调用fork()来创建新进程；创建生成的是<strong>子进程</strong>，其内容同创建它的进程（父进程）一样。</li></ol><ul><li><code>fork</code> 函数在父进程、子进程中都返回（一次调用两次返回）。对于父进程它返回子进程的 pid，对于子进程它返回 0。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">int pid;<br>pid = fork();<br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>    pid = <span class="hljs-title function_ invoke__">wait</span>();<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br>    <span class="hljs-title function_ invoke__">exit</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O和文件描述符"><a href="#I-O和文件描述符" class="headerlink" title="I&#x2F;O和文件描述符"></a>I&#x2F;O和文件描述符</h2><ul><li><strong>文件描述符</strong>是一个整数，它代表了一个进程<strong>可以读写的被内核管理的对象</strong>。</li><li>获取方式：打开文件、目录、设备或创建一个管道pipe或复制已经存在的文件描述符。</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是一个小的内核缓冲区，它以<strong>文件描述符对</strong>的形式提供给进程，一个用于<strong>写操作</strong>，一个用于<strong>读操作</strong>。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式。</p><ul><li>管道会进行自我清扫</li><li>管道可以传输任意长度的数据</li><li>管道允许同步</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>xv6 文件系统提供文件和目录，文件就是一个简单的字节数组，而目录包含指向文件和其他目录的引用。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>read接受三个参数</p><ul><li>第一个参数：文件描述符，指向一个之前打开的文件。<ul><li>shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到console的输出。</li></ul></li><li>第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据。</li><li>第三个参数是代码想读取的最大长度。</li></ul><h1 id="Lab0-实验搭建"><a href="#Lab0-实验搭建" class="headerlink" title="Lab0 实验搭建"></a>Lab0 实验搭建</h1><ul><li>使用wsl2。（在debian12中进行）</li></ul><ol><li>安装编译器（突然意识到，之前计组实验好像安装过了，所以直接使用）</li><li>安装QEMU</li><li>下载xv6并编译</li></ol><p>遇到的问题：在 <code>make qemu</code>时出现了死循环错误。解决办法：修改makefile，将 <code>CFLAGS := -Wall -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie</code> 注释掉。</p><p>其余的直接安装官方步骤进行就可以了。</p><h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="sleep的实现"><a href="#sleep的实现" class="headerlink" title="sleep的实现"></a>sleep的实现</h2><ol><li>在user文件夹下新建sleep.c文件</li><li>研究一下其他函数文件是怎么实现的</li></ol><ul><li>如何传递命令行参数</li><li>头文件需要引用哪一些</li></ul><p>例子：echo.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> i;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, argv[i], <span class="hljs-built_in">strlen</span>(argv[i]));<br>    <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt; argc)&#123;<br>      <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>直接使用同款头文件就行了</p><ul><li>#include “user&#x2F;user.h”这里涵盖了sleep()等系统调用函数</li><li>#include “kernel&#x2F;types.h” 是一些数据类型</li><li>获取参数：int main(int argc, char *argv[])<ul><li>argc是参数个数</li><li>argv是输入的字符串</li></ul></li><li>将字符串转为int–atoi函数</li></ul><ol start="3"><li>写完sleep.c之后，要将它添加到makefile文件，一同编译出来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">UPROGS=\<br><span class="hljs-variable">$U</span>/_cat\<br><span class="hljs-variable">$U</span>/_echo\<br><span class="hljs-variable">$U</span>/_forktest\<br><span class="hljs-variable">$U</span>/_grep\<br><span class="hljs-variable">$U</span>/_init\<br><span class="hljs-variable">$U</span>/_kill\<br><span class="hljs-variable">$U</span>/_ln\<br><span class="hljs-variable">$U</span>/_ls\<br><span class="hljs-variable">$U</span>/_mkdir\<br><span class="hljs-variable">$U</span>/_rm\<br><span class="hljs-variable">$U</span>/_sh\<br><span class="hljs-variable">$U</span>/_stressfs\<br><span class="hljs-variable">$U</span>/_usertests\<br><span class="hljs-variable">$U</span>/_grind\<br><span class="hljs-variable">$U</span>/_wc\<br><span class="hljs-variable">$U</span>/_zombie\<br><span class="hljs-variable">$U</span>/_sleep\<br></code></pre></td></tr></table></figure></li><li>然后再编译 <code>make qemu</code>，成功后，调用sleep函数就可以了</li></ol><h2 id="pingpong的实现"><a href="#pingpong的实现" class="headerlink" title="pingpong的实现"></a>pingpong的实现</h2><ol><li>理解管道（pipe）<ul><li>管道是一种半双工的通信机制，允许两个进程进行通信。管道有两个文件描述符：<ul><li>p[0]：用于读取数据</li><li>p[1]：用于写入数据</li></ul></li></ul></li><li>使用pipe()创建管道；此处需要创建<strong>两个管道</strong>，一个用于<strong>父级向子级发送一个字节</strong>；一个用于<strong>父级从子级读取字节</strong></li><li>read(fd, buf, n)：从文件中读 n 个字节到 buf</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>    pipe(p1);<br>    pipe(p2);<br>    <span class="hljs-type">int</span> pid;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR:fork failed!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<span class="hljs-comment">//子进程： 父进程从子进程读取数据--开启父进程的写，关闭读；开启子进程的读，关闭写</span><br>        close(p1[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭子进程的写</span><br>        close(p2[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭父进程的读</span><br>        read(p1[<span class="hljs-number">0</span>],buf, <span class="hljs-number">1</span>);<span class="hljs-comment">//从子进程的读口读出1个字节到buf</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:received ping\n&quot;</span>, getpid());<br>        write(p2[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//向父进程的写口，写入一个字节</span><br>        close(p1[<span class="hljs-number">0</span>]);<span class="hljs-comment">//关闭子进程的读口</span><br>        close(p2[<span class="hljs-number">1</span>]);<span class="hljs-comment">//关闭父进程的写口</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//正常退出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<span class="hljs-comment">//父进程：父进程写入子进程--开启父进程读口和子进程写口；关闭父进程写口和子进程读口</span><br>        close(p1[<span class="hljs-number">0</span>]);<br>        close(p2[<span class="hljs-number">1</span>]);<br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>        read(p2[<span class="hljs-number">0</span>], buf, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:received pong\n&quot;</span>,getpid());<br>        close(p1[<span class="hljs-number">1</span>]);<br>        close(p2[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p><strong>&#x3D;&gt;素数筛法</strong><br>素数筛法是一种经典的算法，用于找出一定范围内的所有素数。它的基本思想是：</p><ul><li>从 2 开始，将当前数标记为素数。</li><li>将该数的所有倍数标记为非素数。</li><li>移动到下一个未被标记的数，重复上述过程。<br>在并发版本中，每个素数会由一个独立的进程处理，并通过管道将筛选后的数字传递给下一个进程。</li></ul><p><strong>&#x3D;&gt;并发版本的思路</strong><br>在并发版本中，每个素数对应一个进程，进程之间通过管道通信：</p><ol><li>第一个进程：生成数字 2 到 35，并将它们写入管道。</li><li>后续进程：</li></ol><ul><li>从管道中读取第一个数字，这个数字就是当前进程负责的素数。</li><li>打印这个素数。</li><li>继续读取后续的数字，筛选掉当前素数的倍数，将剩余的数字写入下一个管道。</li><li>创建一个新的子进程来处理下一个素数。</li></ul><ol start="3"><li>终止条件：</li></ol><ul><li>当没有更多数字需要处理时，进程退出。</li></ul><p>&#x3D;&gt;需要两个管道，一个用于筛选得到新的一组数据，另一个用于接收新一组的数据，进一步进行筛选；<br>直到达到限制</p><p>&#x3D;&gt;文件描述符的管理：<br>每个进程需要关闭不需要的文件描述符，以避免资源耗尽。<br>父进程在创建子进程后，需要关闭子进程使用的管道端。</p><p>&#x3D;&gt;进程的递归创建：<br>每个素数对应一个进程，进程之间通过管道连接，形成一条链。</p><p>&#x3D;&gt;终止条件：<br>当管道中没有更多数字时，进程退出。<br>主进程需要等待所有子进程退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>&#123;<br>    <span class="hljs-type">int</span> num;<br>   <span class="hljs-comment">//read(fd, &amp;num, sizeof(num));//读取第一个数，作为素数</span><br>    <span class="hljs-keyword">if</span> (read(fd, &amp;num, <span class="hljs-keyword">sizeof</span>(num)) == <span class="hljs-number">0</span>) &#123;<br>        close(fd);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 读取失败，退出</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, num);<span class="hljs-comment">//打印目标语句</span><br>    <span class="hljs-comment">//筛选掉当前素数的倍数</span><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//递归</span><br>        close(p[<span class="hljs-number">1</span>]);<br>        sieve(p[<span class="hljs-number">0</span>]);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">//筛选</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span>(read(fd,&amp;n,<span class="hljs-keyword">sizeof</span>(n))&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(n%num!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//不是当前素数的倍数，保留</span><br>                <span class="hljs-comment">//传入到下一个</span><br>                write(p[<span class="hljs-number">1</span>], &amp;n, <span class="hljs-keyword">sizeof</span>(n));<br>            &#125;<br>        &#125;<br>        close(fd);<br>        close(p[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<span class="hljs-comment">//等待子进程退出</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//child process</span><br>        close(p[<span class="hljs-number">1</span>]);<br>        sieve(p[<span class="hljs-number">0</span>]);<span class="hljs-comment">//从子进程读口获取新一组数据</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//parent process</span><br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>;i++)&#123;<br>            write(p[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(i));<span class="hljs-comment">//2-35</span><br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">while</span> (wait(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="find的实现"><a href="#find的实现" class="headerlink" title="find的实现"></a>find的实现</h2><ol><li><p>阅读ls.c文件，了解如何获取目录信息</p><ul><li>dirent：读取目录项<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> dirent &#123;<br>    <span class="hljs-built_in">ushort</span> inum;    <span class="hljs-comment">// i-node 号，指向文件系统中的 i-node</span><br>    <span class="hljs-built_in">char</span> name[DIRSIZ];  <span class="hljs-comment">// 文件/目录名（不含路径）</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li>stat：获取文件属性<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> stat &#123;<br>    <span class="hljs-built_in">int</span> dev;     <span class="hljs-comment">// 设备号</span><br>    <span class="hljs-built_in">uint</span> ino;    <span class="hljs-comment">// i-node 号</span><br>    <span class="hljs-built_in">short</span> type;  <span class="hljs-comment">// 文件类型 (T_DIR=目录, T_FILE=普通文件)</span><br>    <span class="hljs-built_in">short</span> nlink; <span class="hljs-comment">// 硬链接数</span><br>    <span class="hljs-built_in">uint</span> size;   <span class="hljs-comment">// 文件大小</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><strong><code>dirent</code> 结构本身不会告诉你文件是目录还是普通文件</strong> ，要用 <code>stat()</code> 查询。</li></ul></li><li><p>读取目录：</p><ul><li>用read()读取目录项<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;.&quot;</span>,O_RDONLY);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><span class="hljs-keyword">while</span>(read(fd,&amp;de,<span class="hljs-keyword">sizeof</span>(de))==<span class="hljs-keyword">sizeof</span>(de))&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;File:%s\n&quot;</span>,de.name);<br>&#125;<br>close(fd);<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>获取文件属性</li></ol></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">struct <span class="hljs-keyword">stat</span> st;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">stat</span>(<span class="hljs-string">&quot;filename&quot;</span>, &amp;st) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Size: <span class="hljs-variable">%d</span>, Type: <span class="hljs-variable">%d</span>\n&quot;</span>, st.size, st.type);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="xargs的实现"><a href="#xargs的实现" class="headerlink" title="xargs的实现"></a>xargs的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-comment">// 读取一行输入，存储到 buffer</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">read_line</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> max_size)</span> &#123;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <br>    <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, &amp;c, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 从标准输入读取一个字符</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123; <span class="hljs-comment">// 行结束</span><br>            buffer[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 以 NULL 结尾</span><br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; max_size - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 防止溢出</span><br>            buffer[i++] = c;<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-keyword">return</span> i &gt; <span class="hljs-number">0</span> ? i : <span class="hljs-number">-1</span>; <span class="hljs-comment">// 返回读取的字节数，如果是 EOF 则返回 -1</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: xargs &lt;command&gt; [args ...]\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">512</span>]; <span class="hljs-comment">// 存储输入行</span><br>    <span class="hljs-type">char</span> *exec_argv[MAXARG]; <span class="hljs-comment">// exec() 参数数组</span><br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-comment">// 复制原始命令参数（跳过 xargs 本身）</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc - <span class="hljs-number">1</span> &amp;&amp; i &lt; MAXARG - <span class="hljs-number">1</span>; i++) &#123;<br>        exec_argv[i] = argv[i + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (read_line(buffer, <span class="hljs-keyword">sizeof</span>(buffer)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= MAXARG - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xargs: too many arguments\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        exec_argv[i] = buffer;  <span class="hljs-comment">// 把读取到的行作为新参数</span><br>        exec_argv[i + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;   <span class="hljs-comment">// exec 需要 NULL 终止</span><br><br>        <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>            exec(exec_argv[<span class="hljs-number">0</span>], exec_argv);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xargs: exec failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            wait(<span class="hljs-number">0</span>); <span class="hljs-comment">// 等待子进程完成</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
